var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _nodeTree, _node, _name, _attrs, _string, _strings, _values;
import * as React from "https://esm.sh/react";
import React__default, { useState, useCallback, useMemo, useRef, useSyncExternalStore, useLayoutEffect, useEffect, useDebugValue, forwardRef, useImperativeHandle, useContext, isValidElement, cloneElement, Children, createContext, createElement, memo, Fragment, Suspense, createRef, Component as Component$1, useReducer } from "https://esm.sh/react";
import * as ReactDOM from "https://esm.sh/react-dom";
import ReactDOM__default from "https://esm.sh/react-dom";
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production = {};
/**
 * @license React
 * https://esm.sh/react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production;
function requireReactJsxRuntime_production() {
  if (hasRequiredReactJsxRuntime_production) return reactJsxRuntime_production;
  hasRequiredReactJsxRuntime_production = 1;
  var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
  function jsxProd(type, config2, maybeKey) {
    var key = null;
    void 0 !== maybeKey && (key = "" + maybeKey);
    void 0 !== config2.key && (key = "" + config2.key);
    if ("key" in config2) {
      maybeKey = {};
      for (var propName in config2)
        "key" !== propName && (maybeKey[propName] = config2[propName]);
    } else maybeKey = config2;
    config2 = maybeKey.ref;
    return {
      $$typeof: REACT_ELEMENT_TYPE,
      type,
      key,
      ref: void 0 !== config2 ? config2 : null,
      props: maybeKey
    };
  }
  reactJsxRuntime_production.Fragment = REACT_FRAGMENT_TYPE;
  reactJsxRuntime_production.jsx = jsxProd;
  reactJsxRuntime_production.jsxs = jsxProd;
  return reactJsxRuntime_production;
}
jsxRuntime.exports;
var hasRequiredJsxRuntime;
function requireJsxRuntime() {
  if (hasRequiredJsxRuntime) return jsxRuntime.exports;
  hasRequiredJsxRuntime = 1;
  {
    jsxRuntime.exports = requireReactJsxRuntime_production();
  }
  return jsxRuntime.exports;
}
var jsxRuntimeExports = requireJsxRuntime();
const MESSAGE_SENDER = {
  CLIENT: "client",
  RESPONSE: "response",
  SYSTEM: "system"
};
const USER_TYPE = {
  AGENT: "agent",
  GUEST: "customer",
  BOT: "Bot"
};
const MESSAGES_TYPES = {
  TEXT: "text",
  FILES: "files",
  SNIPPET: {
    LINK: "snippet"
  },
  CUSTOM_COMPONENT: "component",
  CAROUSEL: "carousel"
};
const CHAT_TYPES = {
  GROUPCHAT: "groupchat",
  CHAT: "chat",
  ERROR: "error",
  CONNECT_TO_AGENT: "cta"
};
const LOCAL_STORAGE = {
  CHAT_HISTORY: "chatHistory",
  SENT: "sent",
  RECEIVED: "received"
};
const MESSAGE_BOX_SCROLL_DURATION = 400;
const TIMESTAMP_STORAGE_KEY = "timestamp";
const ROOM_STORAGE_KEY = "room_jid";
const GUEST_STORAGE_KEY = "guest_jid";
const USER_TYPE_KEY = "type";
function useChatStorage() {
  const [roomJID, setRoomJID] = useState(() => localStorage.getItem(ROOM_STORAGE_KEY));
  const [guestJID, setGuestJID] = useState(() => localStorage.getItem(GUEST_STORAGE_KEY));
  const [userType, setUserType] = useState(() => localStorage.getItem(USER_TYPE_KEY));
  const [timeStamp, setTimestamp] = useState(() => localStorage.getItem(TIMESTAMP_STORAGE_KEY));
  const saveRoomJID = useCallback((jid) => {
    localStorage.setItem(ROOM_STORAGE_KEY, jid);
    setRoomJID(jid);
  }, []);
  const saveGuestJID = useCallback((jid) => {
    localStorage.setItem(GUEST_STORAGE_KEY, jid);
    setGuestJID(jid);
  }, []);
  const saveUserType = useCallback((type) => {
    localStorage.setItem(USER_TYPE_KEY, type);
    setUserType(type);
  }, []);
  const saveTimestamp = useCallback(() => {
    const timeStamp2 = (/* @__PURE__ */ new Date()).getTime().toString();
    localStorage.setItem(TIMESTAMP_STORAGE_KEY, timeStamp2);
    setTimestamp(timeStamp2);
  }, []);
  const clearStorage = useCallback(() => {
    localStorage.clear();
  }, []);
  const getRoomJID = useCallback(() => roomJID, [roomJID]);
  const getGuestJID = useCallback(() => guestJID, [guestJID]);
  const getTimestamp = useCallback(() => timeStamp, [timeStamp]);
  const getUserType = useCallback(() => userType, [userType]);
  return {
    roomJID,
    saveRoomJID,
    getRoomJID,
    guestJID,
    saveGuestJID,
    getGuestJID,
    getTimestamp,
    saveTimestamp,
    clearStorage,
    getUserType,
    saveUserType
  };
}
const TRACK_MEMO_SYMBOL = Symbol();
const GET_ORIGINAL_SYMBOL = Symbol();
const AFFECTED_PROPERTY = "a";
const IS_TARGET_COPIED_PROPERTY = "f";
const PROXY_PROPERTY = "p";
const PROXY_CACHE_PROPERTY = "c";
const TARGET_CACHE_PROPERTY = "t";
const HAS_KEY_PROPERTY = "h";
const ALL_OWN_KEYS_PROPERTY = "w";
const HAS_OWN_KEY_PROPERTY = "o";
const KEYS_PROPERTY = "k";
let newProxy$1 = (target, handler) => new Proxy(target, handler);
const getProto = Object.getPrototypeOf;
const objectsToTrack = /* @__PURE__ */ new WeakMap();
const isObjectToTrack = (obj) => obj && (objectsToTrack.has(obj) ? objectsToTrack.get(obj) : getProto(obj) === Object.prototype || getProto(obj) === Array.prototype);
const isObject$2 = (x2) => typeof x2 === "object" && x2 !== null;
const needsToCopyTargetObject = (obj) => Object.values(Object.getOwnPropertyDescriptors(obj)).some((descriptor) => !descriptor.configurable && !descriptor.writable);
const copyTargetObject = (obj) => {
  if (Array.isArray(obj)) {
    return Array.from(obj);
  }
  const descriptors = Object.getOwnPropertyDescriptors(obj);
  Object.values(descriptors).forEach((desc) => {
    desc.configurable = true;
  });
  return Object.create(getProto(obj), descriptors);
};
const createProxyHandler = (origObj, isTargetCopied) => {
  const state2 = {
    [IS_TARGET_COPIED_PROPERTY]: isTargetCopied
  };
  let trackObject = false;
  const recordUsage = (type, key) => {
    if (!trackObject) {
      let used = state2[AFFECTED_PROPERTY].get(origObj);
      if (!used) {
        used = {};
        state2[AFFECTED_PROPERTY].set(origObj, used);
      }
      if (type === ALL_OWN_KEYS_PROPERTY) {
        used[ALL_OWN_KEYS_PROPERTY] = true;
      } else {
        let set2 = used[type];
        if (!set2) {
          set2 = /* @__PURE__ */ new Set();
          used[type] = set2;
        }
        set2.add(key);
      }
    }
  };
  const recordObjectAsUsed = () => {
    trackObject = true;
    state2[AFFECTED_PROPERTY].delete(origObj);
  };
  const handler = {
    get(target, key) {
      if (key === GET_ORIGINAL_SYMBOL) {
        return origObj;
      }
      recordUsage(KEYS_PROPERTY, key);
      return createProxy(Reflect.get(target, key), state2[AFFECTED_PROPERTY], state2[PROXY_CACHE_PROPERTY], state2[TARGET_CACHE_PROPERTY]);
    },
    has(target, key) {
      if (key === TRACK_MEMO_SYMBOL) {
        recordObjectAsUsed();
        return true;
      }
      recordUsage(HAS_KEY_PROPERTY, key);
      return Reflect.has(target, key);
    },
    getOwnPropertyDescriptor(target, key) {
      recordUsage(HAS_OWN_KEY_PROPERTY, key);
      return Reflect.getOwnPropertyDescriptor(target, key);
    },
    ownKeys(target) {
      recordUsage(ALL_OWN_KEYS_PROPERTY);
      return Reflect.ownKeys(target);
    }
  };
  if (isTargetCopied) {
    handler.set = handler.deleteProperty = () => false;
  }
  return [handler, state2];
};
const getOriginalObject = (obj) => (
  // unwrap proxy
  obj[GET_ORIGINAL_SYMBOL] || // otherwise
  obj
);
const createProxy = (obj, affected, proxyCache2, targetCache2) => {
  if (!isObjectToTrack(obj))
    return obj;
  let targetAndCopied = targetCache2 && targetCache2.get(obj);
  if (!targetAndCopied) {
    const target2 = getOriginalObject(obj);
    if (needsToCopyTargetObject(target2)) {
      targetAndCopied = [target2, copyTargetObject(target2)];
    } else {
      targetAndCopied = [target2];
    }
    targetCache2 === null || targetCache2 === void 0 ? void 0 : targetCache2.set(obj, targetAndCopied);
  }
  const [target, copiedTarget] = targetAndCopied;
  let handlerAndState = proxyCache2 && proxyCache2.get(target);
  if (!handlerAndState || handlerAndState[1][IS_TARGET_COPIED_PROPERTY] !== !!copiedTarget) {
    handlerAndState = createProxyHandler(target, !!copiedTarget);
    handlerAndState[1][PROXY_PROPERTY] = newProxy$1(copiedTarget || target, handlerAndState[0]);
    if (proxyCache2) {
      proxyCache2.set(target, handlerAndState);
    }
  }
  handlerAndState[1][AFFECTED_PROPERTY] = affected;
  handlerAndState[1][PROXY_CACHE_PROPERTY] = proxyCache2;
  handlerAndState[1][TARGET_CACHE_PROPERTY] = targetCache2;
  return handlerAndState[1][PROXY_PROPERTY];
};
const isAllOwnKeysChanged = (prevObj, nextObj) => {
  const prevKeys = Reflect.ownKeys(prevObj);
  const nextKeys = Reflect.ownKeys(nextObj);
  return prevKeys.length !== nextKeys.length || prevKeys.some((k2, i) => k2 !== nextKeys[i]);
};
const isChanged = (prevObj, nextObj, affected, cache, isEqual = Object.is) => {
  if (isEqual(prevObj, nextObj)) {
    return false;
  }
  if (!isObject$2(prevObj) || !isObject$2(nextObj))
    return true;
  const used = affected.get(getOriginalObject(prevObj));
  if (!used)
    return true;
  if (cache) {
    const hit = cache.get(prevObj);
    if (hit === nextObj) {
      return false;
    }
    cache.set(prevObj, nextObj);
  }
  let changed = null;
  for (const key of used[HAS_KEY_PROPERTY] || []) {
    changed = Reflect.has(prevObj, key) !== Reflect.has(nextObj, key);
    if (changed)
      return changed;
  }
  if (used[ALL_OWN_KEYS_PROPERTY] === true) {
    changed = isAllOwnKeysChanged(prevObj, nextObj);
    if (changed)
      return changed;
  } else {
    for (const key of used[HAS_OWN_KEY_PROPERTY] || []) {
      const hasPrev = !!Reflect.getOwnPropertyDescriptor(prevObj, key);
      const hasNext = !!Reflect.getOwnPropertyDescriptor(nextObj, key);
      changed = hasPrev !== hasNext;
      if (changed)
        return changed;
    }
  }
  for (const key of used[KEYS_PROPERTY] || []) {
    changed = isChanged(prevObj[key], nextObj[key], affected, cache, isEqual);
    if (changed)
      return changed;
  }
  if (changed === null)
    throw new Error("invalid used");
  return changed;
};
const getUntracked = (obj) => {
  if (isObjectToTrack(obj)) {
    return obj[GET_ORIGINAL_SYMBOL] || null;
  }
  return null;
};
const markToTrack = (obj, mark = true) => {
  objectsToTrack.set(obj, mark);
};
const affectedToPathList = (obj, affected, onlyWithValues) => {
  const list2 = [];
  const seen = /* @__PURE__ */ new WeakSet();
  const walk = (x2, path) => {
    var _a2, _b, _c;
    if (seen.has(x2)) {
      return;
    }
    if (isObject$2(x2)) {
      seen.add(x2);
    }
    const used = isObject$2(x2) && affected.get(getOriginalObject(x2));
    if (used) {
      (_a2 = used[HAS_KEY_PROPERTY]) === null || _a2 === void 0 ? void 0 : _a2.forEach((key) => {
        const segment = `:has(${String(key)})`;
        list2.push(path ? [...path, segment] : [segment]);
      });
      if (used[ALL_OWN_KEYS_PROPERTY] === true) {
        const segment = ":ownKeys";
        list2.push(path ? [...path, segment] : [segment]);
      } else {
        (_b = used[HAS_OWN_KEY_PROPERTY]) === null || _b === void 0 ? void 0 : _b.forEach((key) => {
          const segment = `:hasOwn(${String(key)})`;
          list2.push(path ? [...path, segment] : [segment]);
        });
      }
      (_c = used[KEYS_PROPERTY]) === null || _c === void 0 ? void 0 : _c.forEach((key) => {
        if ("value" in (Object.getOwnPropertyDescriptor(x2, key) || {})) {
          walk(x2[key], path ? [...path, key] : [key]);
        }
      });
    } else if (path) {
      list2.push(path);
    }
  };
  walk(obj);
  return list2;
};
const __vite_import_meta_env__$1 = {};
const isObject$1 = (x2) => typeof x2 === "object" && x2 !== null;
const canProxyDefault = (x2) => isObject$1(x2) && !refSet.has(x2) && (Array.isArray(x2) || !(Symbol.iterator in x2)) && !(x2 instanceof WeakMap) && !(x2 instanceof WeakSet) && !(x2 instanceof Error) && !(x2 instanceof Number) && !(x2 instanceof Date) && !(x2 instanceof String) && !(x2 instanceof RegExp) && !(x2 instanceof ArrayBuffer) && !(x2 instanceof Promise);
const createSnapshotDefault = (target, version) => {
  const cache = snapCache.get(target);
  if ((cache == null ? void 0 : cache[0]) === version) {
    return cache[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  markToTrack(snap, true);
  snapCache.set(target, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    if (Object.getOwnPropertyDescriptor(snap, key)) {
      return;
    }
    const value = Reflect.get(target, key);
    const { enumerable } = Reflect.getOwnPropertyDescriptor(
      target,
      key
    );
    const desc = {
      value,
      enumerable,
      // This is intentional to avoid copying with proxy-compare.
      // It's still non-writable, so it avoids assigning a value.
      configurable: true
    };
    if (refSet.has(value)) {
      markToTrack(value, false);
    } else if (proxyStateMap.has(value)) {
      const [target2, ensureVersion] = proxyStateMap.get(
        value
      );
      desc.value = createSnapshotDefault(target2, ensureVersion());
    }
    Object.defineProperty(snap, key, desc);
  });
  return Object.preventExtensions(snap);
};
const createHandlerDefault = (isInitializing, addPropListener, removePropListener, notifyUpdate) => ({
  deleteProperty(target, prop) {
    const prevValue = Reflect.get(target, prop);
    removePropListener(prop);
    const deleted = Reflect.deleteProperty(target, prop);
    if (deleted) {
      notifyUpdate(["delete", [prop], prevValue]);
    }
    return deleted;
  },
  set(target, prop, value, receiver) {
    const hasPrevValue = !isInitializing() && Reflect.has(target, prop);
    const prevValue = Reflect.get(target, prop, receiver);
    if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
      return true;
    }
    removePropListener(prop);
    if (isObject$1(value)) {
      value = getUntracked(value) || value;
    }
    const nextValue = !proxyStateMap.has(value) && canProxy(value) ? proxy(value) : value;
    addPropListener(prop, nextValue);
    Reflect.set(target, prop, nextValue, receiver);
    notifyUpdate(["set", [prop], value, prevValue]);
    return true;
  }
});
const proxyStateMap = /* @__PURE__ */ new WeakMap();
const refSet = /* @__PURE__ */ new WeakSet();
const snapCache = /* @__PURE__ */ new WeakMap();
const versionHolder = [1, 1];
const proxyCache = /* @__PURE__ */ new WeakMap();
let objectIs = Object.is;
let newProxy = (target, handler) => new Proxy(target, handler);
let canProxy = canProxyDefault;
let createSnapshot = createSnapshotDefault;
let createHandler = createHandlerDefault;
function proxy(baseObject = {}) {
  if (!isObject$1(baseObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(baseObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version) {
          version = propVersion;
        }
      });
    }
    return version;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propValue) => {
    const propProxyState = !refSet.has(propValue) && proxyStateMap.get(propValue);
    if (propProxyState) {
      if ((__vite_import_meta_env__$1 ? "production" : void 0) !== "production" && propProxyStates.has(prop)) {
        throw new Error("prop listener already exists");
      }
      if (listeners.size) {
        const remove = propProxyState[2](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove]);
      } else {
        propProxyStates.set(prop, [propProxyState]);
      }
    }
  };
  const removePropListener = (prop) => {
    var _a2;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a2 = entry[1]) == null ? void 0 : _a2.call(entry);
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if ((__vite_import_meta_env__$1 ? "production" : void 0) !== "production" && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove = propProxyState[2](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove], prop) => {
          if (remove) {
            remove();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  let initializing = true;
  const handler = createHandler(
    () => initializing,
    addPropListener,
    removePropListener,
    notifyUpdate
  );
  const proxyObject = newProxy(baseObject, handler);
  proxyCache.set(baseObject, proxyObject);
  const proxyState = [baseObject, ensureVersion, addListener];
  proxyStateMap.set(proxyObject, proxyState);
  Reflect.ownKeys(baseObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(
      baseObject,
      key
    );
    if ("value" in desc && desc.writable) {
      proxyObject[key] = baseObject[key];
    }
  });
  initializing = false;
  return proxyObject;
}
function subscribe(proxyObject, callback, notifyInSync) {
  const proxyState = proxyStateMap.get(proxyObject);
  if ((__vite_import_meta_env__$1 ? "production" : void 0) !== "production" && !proxyState) {
  }
  let promise;
  const ops = [];
  const addListener = proxyState[2];
  let isListenerActive = false;
  const listener = (op) => {
    ops.push(op);
    if (!promise) {
      promise = Promise.resolve().then(() => {
        promise = void 0;
        if (isListenerActive) {
          callback(ops.splice(0));
        }
      });
    }
  };
  const removeListener = addListener(listener);
  isListenerActive = true;
  return () => {
    isListenerActive = false;
    removeListener();
  };
}
function snapshot(proxyObject) {
  const proxyState = proxyStateMap.get(proxyObject);
  if ((__vite_import_meta_env__$1 ? "production" : void 0) !== "production" && !proxyState) {
  }
  const [target, ensureVersion] = proxyState;
  return createSnapshot(target, ensureVersion());
}
function ref$1(obj) {
  refSet.add(obj);
  return obj;
}
const __vite_import_meta_env__ = {};
const useAffectedDebugValue = (state2, affected) => {
  const pathList = useRef(void 0);
  useEffect(() => {
    pathList.current = affectedToPathList(state2, affected);
  });
  useDebugValue(pathList.current);
};
const condUseAffectedDebugValue = useAffectedDebugValue;
const targetCache = /* @__PURE__ */ new WeakMap();
function useSnapshot(proxyObject, options) {
  const notifyInSync = void 0;
  const affected = useMemo(
    () => proxyObject && /* @__PURE__ */ new WeakMap(),
    [proxyObject]
  );
  const lastSnapshot = useRef(void 0);
  let inRender = true;
  const currSnapshot = useSyncExternalStore(
    useCallback(
      (callback) => {
        const unsub = subscribe(proxyObject, callback);
        callback();
        return unsub;
      },
      [proxyObject, notifyInSync]
    ),
    () => {
      const nextSnapshot = snapshot(proxyObject);
      try {
        if (!inRender && lastSnapshot.current && !isChanged(
          lastSnapshot.current,
          nextSnapshot,
          affected,
          /* @__PURE__ */ new WeakMap()
        )) {
          return lastSnapshot.current;
        }
      } catch (e) {
      }
      return nextSnapshot;
    },
    () => snapshot(proxyObject)
  );
  inRender = false;
  useLayoutEffect(() => {
    lastSnapshot.current = currSnapshot;
  });
  if ((__vite_import_meta_env__ ? "production" : void 0) !== "production") {
    condUseAffectedDebugValue(currSnapshot, affected);
  }
  const proxyCache2 = useMemo(() => /* @__PURE__ */ new WeakMap(), []);
  return createProxy(currSnapshot, affected, proxyCache2, targetCache);
}
const initialState$6 = {
  src: "",
  alt: "",
  width: 0,
  height: 0,
  visible: false
};
const state$7 = proxy(initialState$6);
function openFullscreenPreview(payload) {
  const { src, width: width2, height: height2 } = payload;
  Object.assign(state$7, { src, width: width2, height: height2, visible: true });
}
function closeFullscreenPreview() {
  Object.assign(state$7, initialState$6);
}
const initialState$5 = {
  responseUser: null,
  messages: [],
  badgeCount: 0,
  popupMessage: null,
  replyMessage: null,
  contextMenu: null
};
const state$6 = proxy(initialState$5);
function dropMessages() {
  state$6.messages = [];
}
function hideAvatar(index) {
  state$6.messages[index].showAvatar = false;
}
function deleteMessages(count, id) {
  state$6.messages = id ? state$6.messages.filter((_2, index) => {
    const targetMsg = state$6.messages.findIndex((tMsg) => tMsg.customId === id);
    return index < targetMsg - count + 1 || index > targetMsg;
  }) : state$6.messages.slice(0, state$6.messages.length - count);
}
function setBadgeCount(count) {
  state$6.badgeCount = count;
}
function markAllMessagesRead() {
  state$6.messages = state$6.messages.map((message2) => ({ ...message2, unread: false }));
  state$6.badgeCount = 0;
}
function setMessages(messages) {
  state$6.messages = messages;
  state$6.badgeCount = 0;
}
function findMessageByCustomId(id) {
  return state$6.messages.find((item) => item.customId == id) ?? null;
}
function setMessageStatus(id, status, props = null) {
  const m2 = findMessageByCustomId(id);
  if (m2) {
    m2.status = status;
    if (props) {
      Object.assign(m2, props);
    }
    return true;
  }
  return false;
}
function setResponseUser(user) {
  state$6.responseUser = user;
}
function setPopupMessage(message2) {
  state$6.popupMessage = message2;
}
function setStatusLocale(locale) {
  state$6.statusLocale = locale;
}
function setVoiceLocale(locale) {
  state$6.voiceLocale = locale;
}
function setReplyMessage(message2) {
  state$6.replyMessage = message2;
}
function setContextMenu(id, pos, data) {
  const position2 = ref$1(pos ?? { x: 0, y: 0 });
  state$6.contextMenu = id ? { id, position: position2, data } : null;
}
var __defProp2 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp2(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp2(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var CarouselContext = React__default.createContext(
  {}
);
var CarouselProvider = CarouselContext.Provider;
var useCarousel = () => {
  const context = useContext(CarouselContext);
  return context;
};
function useInterval(callback, delay, enabled = true) {
  const _callback = useRef();
  useEffect(() => {
    _callback.current = callback;
  }, [callback]);
  useEffect(() => {
    if (enabled && delay !== null) {
      const id = setInterval(() => {
        if (_callback.current) _callback.current();
      }, delay);
      return () => clearInterval(id);
    }
  }, [delay, enabled]);
}
function usePaging({
  totalPages,
  wrapMode,
  initialPage
}) {
  const [currentPage, setCurrentPage] = useState(0);
  useEffect(() => {
    if (initialPage) {
      setCurrentPage(Math.max(0, Math.min(initialPage, totalPages)));
    }
  }, [initialPage, totalPages]);
  const goToPage = (idx) => {
    if (idx < 0 || idx >= totalPages) return;
    setCurrentPage(idx);
  };
  const goForward = () => {
    if (wrapMode === "wrap") {
      setCurrentPage((prev2) => (prev2 + 1) % totalPages);
    } else {
      setCurrentPage((prev2) => Math.min(prev2 + 1, totalPages - 1));
    }
  };
  const goBack = () => {
    if (wrapMode === "wrap") {
      setCurrentPage((prev2) => (prev2 - 1 + totalPages) % totalPages);
    } else {
      setCurrentPage((prev2) => Math.max(prev2 - 1, 0));
    }
  };
  return { currentPage, goToPage, goForward, goBack };
}
function arraySeq(length2, initialValue) {
  return new Array(length2).fill(0).map((_2, i) => i * initialValue);
}
function arraySum(values2) {
  let sum = 0;
  return values2.map((value) => sum += value);
}
var isBrowser$1 = () => typeof window !== "undefined";
function cls(...classes) {
  return classes.filter(Boolean).join(" ");
}
function isMouseEvent(e) {
  return "clientY" in e;
}
function useResizeObserver(element) {
  const [dimensions, setDimensions] = useState();
  useEffect(() => {
    if (!element.current) return;
    const target = element.current;
    const observer = new ResizeObserver(
      () => setDimensions(target.getBoundingClientRect())
    );
    observer.observe(target);
    return () => {
      observer.unobserve(target);
    };
  }, [element]);
  return dimensions;
}
function useMeasurement({ element, scrollDistance }) {
  const [totalPages, setTotalPages] = useState(0);
  const [scrollOffset, setScrollOffset] = useState(arraySeq(totalPages, 0));
  const dimensions = useResizeObserver(element);
  useEffect(() => {
    var _a2;
    const container = element.current;
    if (!(container && dimensions)) return;
    const scrollWidth = container.scrollWidth;
    const visibleWidth = container.offsetWidth;
    const remainder = scrollWidth - visibleWidth;
    if (visibleWidth === 0) return;
    switch (scrollDistance) {
      case "screen": {
        const pageCount = Math.round(scrollWidth / visibleWidth);
        setTotalPages(pageCount);
        setScrollOffset(arraySeq(pageCount, visibleWidth));
        break;
      }
      case "slide": {
        const children = ((_a2 = container.querySelector("#nuka-wrapper")) == null ? void 0 : _a2.children) || [];
        const offsets = Array.from(children).map(
          (child) => child.offsetWidth
        );
        const scrollOffsets = arraySum([0, ...offsets.slice(0, -1)]);
        const pageCount = scrollOffsets.findIndex((offset) => offset >= remainder) + 1;
        setTotalPages(pageCount);
        setScrollOffset(scrollOffsets);
        break;
      }
      default: {
        if (typeof scrollDistance === "number" && scrollDistance > 0) {
          const pageCount = Math.ceil(remainder / scrollDistance) + 1;
          setTotalPages(pageCount);
          setScrollOffset(arraySeq(pageCount, scrollDistance));
        }
      }
    }
  }, [element, scrollDistance, dimensions]);
  return { totalPages, scrollOffset };
}
function useHover({
  element,
  enabled
}) {
  const [hovered, setHovered] = useState(false);
  const target = element == null ? void 0 : element.current;
  useEffect(() => {
    if (!(target && target.addEventListener)) return;
    if (enabled) {
      const onMouseOver = () => setHovered(true);
      const onMouseOut = () => setHovered(false);
      target.addEventListener("mouseover", onMouseOver);
      target.addEventListener("mouseout", onMouseOut);
      return () => {
        target.removeEventListener("mouseover", onMouseOver);
        target.removeEventListener("mouseout", onMouseOut);
      };
    }
  }, [target, enabled]);
  return hovered;
}
function useKeyboard({
  element,
  enabled,
  goForward,
  goBack
}) {
  const target = element == null ? void 0 : element.current;
  useEffect(() => {
    if (target && enabled) {
      const onKeyDown = (e) => {
        if (e.key === "ArrowLeft") {
          goBack();
        } else if (e.key === "ArrowRight") {
          goForward();
        }
      };
      target.addEventListener("keydown", onKeyDown);
      return () => target.removeEventListener("keydown", onKeyDown);
    }
  }, [enabled, goBack, goForward, target]);
}
var QUERY = "(prefers-reduced-motion: no-preference)";
var getInitialState = () => isBrowser$1() ? !window.matchMedia(QUERY).matches : true;
function useReducedMotion({ enabled }) {
  const [reduceMotion, setReducedMotion] = useState(getInitialState);
  useEffect(() => {
    if (!(isBrowser$1() && enabled)) return;
    const mediaQueryList = window.matchMedia(QUERY);
    const listener = (event) => {
      setReducedMotion(!event.matches);
    };
    mediaQueryList.addEventListener("change", listener);
    return () => {
      mediaQueryList.removeEventListener("change", listener);
    };
  }, [enabled]);
  return reduceMotion;
}
function NavButtons() {
  const { currentPage, totalPages, wrapMode, goBack, goForward } = useCarousel();
  const allowWrap = wrapMode !== "nowrap";
  const enablePrevNavButton = allowWrap || currentPage > 0;
  const enableNextNavButton = allowWrap || currentPage < totalPages - 1;
  const prevNavClassName = cls(
    "nuka-nav-button",
    "nuka-nav-button-prev",
    enablePrevNavButton && "nuka-nav-button-enabled"
  );
  const nextNavClassName = cls(
    "nuka-nav-button",
    "nuka-nav-button-next",
    enableNextNavButton && "nuka-nav-button-enabled"
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: prevNavClassName, onClick: goBack, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 20 20",
        fill: "currentcolor",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            fillRule: "evenodd",
            d: "M11.78 5.22a.75.75 0 0 1 0 1.06L8.06 10l3.72 3.72a.75.75 0 1 1-1.06 1.06l-4.25-4.25a.75.75 0 0 1 0-1.06l4.25-4.25a.75.75 0 0 1 1.06 0Z",
            clipRule: "evenodd"
          }
        )
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: nextNavClassName, onClick: goForward, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 20 20",
        fill: "currentcolor",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            fillRule: "evenodd",
            d: "M8.22 5.22a.75.75 0 0 1 1.06 0l4.25 4.25a.75.75 0 0 1 0 1.06l-4.25 4.25a.75.75 0 0 1-1.06-1.06L11.94 10 8.22 6.28a.75.75 0 0 1 0-1.06Z",
            clipRule: "evenodd"
          }
        )
      }
    ) })
  ] });
}
var PageIndicators = () => {
  const { totalPages, currentPage, goToPage } = useCarousel();
  const className = (index) => cls(
    "nuka-page-indicator",
    currentPage === index ? "nuka-page-indicator-active" : ""
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "nuka-page-container", "data-testid": "pageIndicatorContainer", children: [...Array(totalPages)].map((_2, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    "button",
    {
      onClick: () => goToPage(index),
      className: className(index),
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "nuka-hidden", children: index + 1 })
    },
    index
  )) });
};
function styleInject(css2, { insertAt } = {}) {
  if (typeof document === "undefined") return;
  const head = document.head || document.getElementsByTagName("head")[0];
  const style2 = document.createElement("style");
  style2.type = "text/css";
  if (insertAt === "top") {
    if (head.firstChild) {
      head.insertBefore(style2, head.firstChild);
    } else {
      head.appendChild(style2);
    }
  } else {
    head.appendChild(style2);
  }
  if (style2.styleSheet) {
    style2.styleSheet.cssText = css2;
  } else {
    style2.appendChild(document.createTextNode(css2));
  }
}
styleInject(".nuka-hidden {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  padding: 0;\n  margin: -1px;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0);\n  white-space: nowrap;\n  border-width: 0;\n}\n.nuka-container {\n  position: relative;\n}\n.nuka-slide-container {\n  position: relative;\n}\n.nuka-overflow {\n  overflow: scroll;\n  -ms-overflow-style: none;\n  scrollbar-width: none;\n}\n.nuka-overflow.scroll-smooth {\n  scroll-behavior: smooth;\n}\n.nuka-overflow.scroll-auto {\n  scroll-behavior: auto;\n}\n.nuka-overflow::-webkit-scrollbar {\n  display: none;\n}\n.nuka-wrapper {\n  display: flex;\n}\n.nuka-nav-button {\n  position: absolute;\n  top: calc(50% - 2rem);\n  margin: 1rem;\n  display: none;\n  height: 2rem;\n  width: 2rem;\n  cursor: pointer;\n  background-color: rgba(146, 148, 151, 0.5);\n  color: white;\n  border-radius: 9999px;\n  font-size: 1rem;\n  user-select: none;\n}\n.nuka-nav-button.nuka-nav-button-prev {\n  left: 0;\n  margin-right: 1rem;\n}\n.nuka-nav-button.nuka-nav-button-next {\n  right: 0;\n  margin-left: 1rem;\n}\n.nuka-nav-button:hover {\n  background-color: rgba(146, 148, 151, 0.65);\n}\n.nuka-nav-button-enabled {\n  display: block;\n}\n.nuka-container-auto-hide .nuka-nav-button {\n  display: none;\n}\n.nuka-container-auto-hide:hover .nuka-nav-button-enabled {\n  display: block;\n}\n.nuka-page-container {\n  padding-top: 1rem;\n  padding-bottom: 1rem;\n  display: flex;\n  gap: 0.5rem;\n  justify-content: center;\n  align-items: center;\n}\n.nuka-page-indicator {\n  width: 0.75rem;\n  height: 0.75rem;\n  cursor: pointer;\n  border-radius: 9999px;\n  border-style: none;\n  background-color: rgba(146, 148, 151, 0.65);\n}\n.nuka-page-indicator.nuka-page-indicator-active,\n.nuka-page-indicator.nuka-page-indicator-active:hover {\n  background-color: rgb(229 231 235 / 1);\n}\n.nuka-page-indicator:hover {\n  background-color: rgb(229 231 235 / 1);\n}\n");
var defaults = {
  arrows: /* @__PURE__ */ jsxRuntimeExports.jsx(NavButtons, {}),
  autoplay: false,
  autoplayInterval: 3e3,
  dots: /* @__PURE__ */ jsxRuntimeExports.jsx(PageIndicators, {}),
  id: "nuka-carousel",
  keyboard: true,
  minSwipeDistance: 50,
  scrollDistance: "screen",
  showArrows: false,
  showDots: false,
  swiping: true,
  wrapMode: "nowrap"
};
var Carousel = forwardRef(
  (props, ref2) => {
    const options = __spreadValues(__spreadValues({}, defaults), props);
    const {
      afterSlide,
      arrows,
      autoplay,
      autoplayInterval,
      beforeSlide,
      children,
      className,
      dots,
      id,
      keyboard,
      minSwipeDistance,
      scrollDistance,
      showArrows,
      showDots,
      swiping,
      title,
      wrapMode,
      initialPage
    } = options;
    const carouselRef = useRef(null);
    const containerRef = useRef(null);
    const previousPageRef = useRef(-1);
    const arrowsContainerRef = useRef(null);
    const { totalPages, scrollOffset } = useMeasurement({
      element: containerRef,
      scrollDistance
    });
    const { currentPage, goBack, goForward, goToPage } = usePaging({
      totalPages,
      wrapMode,
      initialPage
    });
    const [touchStart, setTouchStart] = useState(null);
    const [touchEnd, setTouchEnd] = useState(null);
    const onTouchStart = (e) => {
      if (!swiping) return;
      setTouchEnd(null);
      setTouchStart(isMouseEvent(e) ? e.clientX : e.targetTouches[0].clientX);
    };
    const onTouchMove = (e) => {
      if (!swiping) return;
      setTouchEnd(isMouseEvent(e) ? e.clientX : e.targetTouches[0].clientX);
    };
    const onTouchEnd = () => {
      if (!swiping) return;
      if (!containerRef.current) return;
      if (!touchStart || !touchEnd) return;
      const distance = touchStart - touchEnd;
      const isLeftSwipe = distance > minSwipeDistance;
      const isRightSwipe = distance < -minSwipeDistance;
      if (isLeftSwipe || isRightSwipe) {
        if (isLeftSwipe) {
          goForward();
        } else {
          goBack();
        }
      }
    };
    useKeyboard({
      element: carouselRef,
      enabled: keyboard,
      goForward,
      goBack
    });
    useImperativeHandle(ref2, () => ({ goForward, goBack, goToPage }), [
      goForward,
      goBack,
      goToPage
    ]);
    const isHovered = useHover({ element: containerRef, enabled: autoplay });
    const isArrowHovered = useHover({
      element: arrowsContainerRef,
      enabled: autoplay && showArrows === true
    });
    const prefersReducedMotion = useReducedMotion({ enabled: autoplay });
    const autoplayEnabled = autoplay && !(isHovered || prefersReducedMotion || isArrowHovered);
    useInterval(goForward, autoplayInterval, autoplayEnabled);
    useEffect(() => {
      if (containerRef.current) {
        const currentSlideIndex = previousPageRef.current;
        const endSlideIndex = currentPage;
        beforeSlide && beforeSlide(currentSlideIndex, endSlideIndex);
        containerRef.current.scrollLeft = scrollOffset[currentPage];
        afterSlide && setTimeout(() => afterSlide(endSlideIndex), 0);
        previousPageRef.current = currentPage;
        if (initialPage === void 0 || currentPage === initialPage) {
          containerRef.current.classList.remove("scroll-auto");
          containerRef.current.classList.add("scroll-smooth");
        }
      }
    }, [currentPage, scrollOffset, beforeSlide, afterSlide, initialPage]);
    const containerClassName = cls(
      "nuka-container",
      showArrows === "hover" && "nuka-container-auto-hide",
      className
    );
    const providerValues = __spreadProps(__spreadValues({}, options), {
      totalPages,
      currentPage,
      scrollOffset,
      goBack,
      goForward,
      goToPage
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(CarouselProvider, { value: providerValues, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: containerClassName,
          "aria-labelledby": "nuka-carousel-heading",
          tabIndex: keyboard ? 0 : void 0,
          ref: carouselRef,
          id,
          children: [
            title && /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { id: "nuka-carousel-heading", className: "nuka-hidden", children: title }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nuka-slide-container", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  className: "nuka-overflow",
                  ref: containerRef,
                  onTouchEnd,
                  onTouchMove,
                  onTouchStart,
                  id: "nuka-overflow",
                  "data-testid": "nuka-overflow",
                  style: { touchAction: "pan-y" },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      className: "nuka-wrapper",
                      id: "nuka-wrapper",
                      "data-testid": "nuka-wrapper",
                      children
                    }
                  )
                }
              ),
              showArrows && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: arrowsContainerRef, children: arrows })
            ] })
          ]
        }
      ),
      showDots && dots
    ] });
  }
);
Carousel.displayName = "Carousel";
function CarouselMessage(props) {
  const actualProps = props && props.value ? props.value : props;
  const { message: message2 } = actualProps;
  const items = message2 && message2.items ? message2.items : [];
  message2.summary;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: (items == null ? void 0 : items.length) > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "carousel-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Carousel, { autoplay: true, autoplayInterval: 3e3, showArrows: true, children: items.map((item, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "carousel-slide", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "absolute", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "carousel-price", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "₹" }),
        item.price
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: item.image, alt: `Carousel Item ${index}` })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "carousel-content", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "carousel-title", children: item.category }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "carousel-description", children: item.title }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: item.link, className: "carousel-button", target: "_blank", rel: "noreferrer", children: "Buy Now" })
    ] })
  ] }, index)) }) }) });
}
const decodeCache = {};
function getDecodeCache(exclude) {
  let cache = decodeCache[exclude];
  if (cache) {
    return cache;
  }
  cache = decodeCache[exclude] = [];
  for (let i = 0; i < 128; i++) {
    const ch = String.fromCharCode(i);
    cache.push(ch);
  }
  for (let i = 0; i < exclude.length; i++) {
    const ch = exclude.charCodeAt(i);
    cache[ch] = "%" + ("0" + ch.toString(16).toUpperCase()).slice(-2);
  }
  return cache;
}
function decode$1(string, exclude) {
  if (typeof exclude !== "string") {
    exclude = decode$1.defaultChars;
  }
  const cache = getDecodeCache(exclude);
  return string.replace(/(%[a-f0-9]{2})+/gi, function(seq) {
    let result = "";
    for (let i = 0, l = seq.length; i < l; i += 3) {
      const b1 = parseInt(seq.slice(i + 1, i + 3), 16);
      if (b1 < 128) {
        result += cache[b1];
        continue;
      }
      if ((b1 & 224) === 192 && i + 3 < l) {
        const b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        if ((b2 & 192) === 128) {
          const chr = b1 << 6 & 1984 | b2 & 63;
          if (chr < 128) {
            result += "��";
          } else {
            result += String.fromCharCode(chr);
          }
          i += 3;
          continue;
        }
      }
      if ((b1 & 240) === 224 && i + 6 < l) {
        const b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        const b3 = parseInt(seq.slice(i + 7, i + 9), 16);
        if ((b2 & 192) === 128 && (b3 & 192) === 128) {
          const chr = b1 << 12 & 61440 | b2 << 6 & 4032 | b3 & 63;
          if (chr < 2048 || chr >= 55296 && chr <= 57343) {
            result += "���";
          } else {
            result += String.fromCharCode(chr);
          }
          i += 6;
          continue;
        }
      }
      if ((b1 & 248) === 240 && i + 9 < l) {
        const b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        const b3 = parseInt(seq.slice(i + 7, i + 9), 16);
        const b4 = parseInt(seq.slice(i + 10, i + 12), 16);
        if ((b2 & 192) === 128 && (b3 & 192) === 128 && (b4 & 192) === 128) {
          let chr = b1 << 18 & 1835008 | b2 << 12 & 258048 | b3 << 6 & 4032 | b4 & 63;
          if (chr < 65536 || chr > 1114111) {
            result += "����";
          } else {
            chr -= 65536;
            result += String.fromCharCode(55296 + (chr >> 10), 56320 + (chr & 1023));
          }
          i += 9;
          continue;
        }
      }
      result += "�";
    }
    return result;
  });
}
decode$1.defaultChars = ";/?:@&=+$,#";
decode$1.componentChars = "";
const encodeCache = {};
function getEncodeCache(exclude) {
  let cache = encodeCache[exclude];
  if (cache) {
    return cache;
  }
  cache = encodeCache[exclude] = [];
  for (let i = 0; i < 128; i++) {
    const ch = String.fromCharCode(i);
    if (/^[0-9a-z]$/i.test(ch)) {
      cache.push(ch);
    } else {
      cache.push("%" + ("0" + i.toString(16).toUpperCase()).slice(-2));
    }
  }
  for (let i = 0; i < exclude.length; i++) {
    cache[exclude.charCodeAt(i)] = exclude[i];
  }
  return cache;
}
function encode$1(string, exclude, keepEscaped) {
  if (typeof exclude !== "string") {
    keepEscaped = exclude;
    exclude = encode$1.defaultChars;
  }
  if (typeof keepEscaped === "undefined") {
    keepEscaped = true;
  }
  const cache = getEncodeCache(exclude);
  let result = "";
  for (let i = 0, l = string.length; i < l; i++) {
    const code2 = string.charCodeAt(i);
    if (keepEscaped && code2 === 37 && i + 2 < l) {
      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
        result += string.slice(i, i + 3);
        i += 2;
        continue;
      }
    }
    if (code2 < 128) {
      result += cache[code2];
      continue;
    }
    if (code2 >= 55296 && code2 <= 57343) {
      if (code2 >= 55296 && code2 <= 56319 && i + 1 < l) {
        const nextCode = string.charCodeAt(i + 1);
        if (nextCode >= 56320 && nextCode <= 57343) {
          result += encodeURIComponent(string[i] + string[i + 1]);
          i++;
          continue;
        }
      }
      result += "%EF%BF%BD";
      continue;
    }
    result += encodeURIComponent(string[i]);
  }
  return result;
}
encode$1.defaultChars = ";/?:@&=+$,-_.!~*'()#";
encode$1.componentChars = "-_.!~*'()";
function format$1(url) {
  let result = "";
  result += url.protocol || "";
  result += url.slashes ? "//" : "";
  result += url.auth ? url.auth + "@" : "";
  if (url.hostname && url.hostname.indexOf(":") !== -1) {
    result += "[" + url.hostname + "]";
  } else {
    result += url.hostname || "";
  }
  result += url.port ? ":" + url.port : "";
  result += url.pathname || "";
  result += url.search || "";
  result += url.hash || "";
  return result;
}
function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.pathname = null;
}
const protocolPattern = /^([a-z0-9.+-]+:)/i;
const portPattern = /:[0-9]*$/;
const simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
const delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"];
const unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims);
const autoEscape = ["'"].concat(unwise);
const nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape);
const hostEndingChars = ["/", "?", "#"];
const hostnameMaxLen = 255;
const hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
const hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
const hostlessProtocol = {
  javascript: true,
  "javascript:": true
};
const slashedProtocol = {
  http: true,
  https: true,
  ftp: true,
  gopher: true,
  file: true,
  "http:": true,
  "https:": true,
  "ftp:": true,
  "gopher:": true,
  "file:": true
};
function urlParse(url, slashesDenoteHost) {
  if (url && url instanceof Url) return url;
  const u2 = new Url();
  u2.parse(url, slashesDenoteHost);
  return u2;
}
Url.prototype.parse = function(url, slashesDenoteHost) {
  let lowerProto, hec, slashes;
  let rest = url;
  rest = rest.trim();
  if (!slashesDenoteHost && url.split("#").length === 1) {
    const simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
      }
      return this;
    }
  }
  let proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    lowerProto = proto.toLowerCase();
    this.protocol = proto;
    rest = rest.substr(proto.length);
  }
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    slashes = rest.substr(0, 2) === "//";
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }
  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
    let hostEnd = -1;
    for (let i = 0; i < hostEndingChars.length; i++) {
      hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    let auth, atSign;
    if (hostEnd === -1) {
      atSign = rest.lastIndexOf("@");
    } else {
      atSign = rest.lastIndexOf("@", hostEnd);
    }
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = auth;
    }
    hostEnd = -1;
    for (let i = 0; i < nonHostChars.length; i++) {
      hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    if (hostEnd === -1) {
      hostEnd = rest.length;
    }
    if (rest[hostEnd - 1] === ":") {
      hostEnd--;
    }
    const host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);
    this.parseHost(host);
    this.hostname = this.hostname || "";
    const ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!ipv6Hostname) {
      const hostparts = this.hostname.split(/\./);
      for (let i = 0, l = hostparts.length; i < l; i++) {
        const part = hostparts[i];
        if (!part) {
          continue;
        }
        if (!part.match(hostnamePartPattern)) {
          let newpart = "";
          for (let j2 = 0, k2 = part.length; j2 < k2; j2++) {
            if (part.charCodeAt(j2) > 127) {
              newpart += "x";
            } else {
              newpart += part[j2];
            }
          }
          if (!newpart.match(hostnamePartPattern)) {
            const validParts = hostparts.slice(0, i);
            const notHost = hostparts.slice(i + 1);
            const bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = notHost.join(".") + rest;
            }
            this.hostname = validParts.join(".");
            break;
          }
        }
      }
    }
    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = "";
    }
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
    }
  }
  const hash2 = rest.indexOf("#");
  if (hash2 !== -1) {
    this.hash = rest.substr(hash2);
    rest = rest.slice(0, hash2);
  }
  const qm = rest.indexOf("?");
  if (qm !== -1) {
    this.search = rest.substr(qm);
    rest = rest.slice(0, qm);
  }
  if (rest) {
    this.pathname = rest;
  }
  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = "";
  }
  return this;
};
Url.prototype.parseHost = function(host) {
  let port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ":") {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) {
    this.hostname = host;
  }
};
const mdurl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: decode$1,
  encode: encode$1,
  format: format$1,
  parse: urlParse
}, Symbol.toStringTag, { value: "Module" }));
const Any = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
const Cc = /[\0-\x1F\x7F-\x9F]/;
const regex$1 = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u0890\u0891\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD80D[\uDC30-\uDC3F]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;
const P$1 = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52-\u2E5D\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDEAD\uDF55-\uDF59\uDF86-\uDF89]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5A\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDEB9\uDF3C-\uDF3E]|\uD806[\uDC3B\uDD44-\uDD46\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2\uDF00-\uDF09]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDF43-\uDF4F\uDFFF]|\uD809[\uDC70-\uDC74]|\uD80B[\uDFF1\uDFF2]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;
const regex = /[\$\+<->\^`\|~\xA2-\xA6\xA8\xA9\xAC\xAE-\xB1\xB4\xB8\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u03F6\u0482\u058D-\u058F\u0606-\u0608\u060B\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u07FE\u07FF\u0888\u09F2\u09F3\u09FA\u09FB\u0AF1\u0B70\u0BF3-\u0BFA\u0C7F\u0D4F\u0D79\u0E3F\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u166D\u17DB\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u2044\u2052\u207A-\u207C\u208A-\u208C\u20A0-\u20C0\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F\u218A\u218B\u2190-\u2307\u230C-\u2328\u232B-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u2767\u2794-\u27C4\u27C7-\u27E5\u27F0-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2B73\u2B76-\u2B95\u2B97-\u2BFF\u2CE5-\u2CEA\u2E50\u2E51\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFF\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u309B\u309C\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u31EF\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA700-\uA716\uA720\uA721\uA789\uA78A\uA828-\uA82B\uA836-\uA839\uAA77-\uAA79\uAB5B\uAB6A\uAB6B\uFB29\uFBB2-\uFBC2\uFD40-\uFD4F\uFDCF\uFDFC-\uFDFF\uFE62\uFE64-\uFE66\uFE69\uFF04\uFF0B\uFF1C-\uFF1E\uFF3E\uFF40\uFF5C\uFF5E\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFFC\uFFFD]|\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9C\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|\uD805\uDF3F|\uD807[\uDFD5-\uDFF1]|\uD81A[\uDF3C-\uDF3F\uDF45]|\uD82F\uDC9C|\uD833[\uDF50-\uDFC3]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDEA\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD838[\uDD4F\uDEFF]|\uD83B[\uDCAC\uDCB0\uDD2E\uDEF0\uDEF1]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD0D-\uDDAD\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED7\uDEDC-\uDEEC\uDEF0-\uDEFC\uDF00-\uDF76\uDF7B-\uDFD9\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDCB0\uDCB1\uDD00-\uDE53\uDE60-\uDE6D\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC5\uDECE-\uDEDB\uDEE0-\uDEE8\uDEF0-\uDEF8\uDF00-\uDF92\uDF94-\uDFCA]/;
const Z = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
const ucmicro = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Any,
  Cc,
  Cf: regex$1,
  P: P$1,
  S: regex,
  Z
}, Symbol.toStringTag, { value: "Module" }));
const htmlDecodeTree = new Uint16Array(
  // prettier-ignore
  'ᵁ<Õıʊҝջאٵ۞ޢߖࠏ੊ઑඡ๭༉༦჊ረዡᐕᒝᓃᓟᔥ\0\0\0\0\0\0ᕫᛍᦍᰒᷝ὾⁠↰⊍⏀⏻⑂⠤⤒ⴈ⹈⿎〖㊺㘹㞬㣾㨨㩱㫠㬮ࠀEMabcfglmnoprstu\\bfms¦³¹ÈÏlig耻Æ䃆P耻&䀦cute耻Á䃁reve;䄂Āiyx}rc耻Â䃂;䐐r;쀀𝔄rave耻À䃀pha;䎑acr;䄀d;橓Āgp¡on;䄄f;쀀𝔸plyFunction;恡ing耻Å䃅Ācs¾Ãr;쀀𝒜ign;扔ilde耻Ã䃃ml耻Ä䃄ЀaceforsuåûþėĜĢħĪĀcrêòkslash;或Ŷöø;櫧ed;挆y;䐑ƀcrtąċĔause;戵noullis;愬a;䎒r;쀀𝔅pf;쀀𝔹eve;䋘còēmpeq;扎܀HOacdefhilorsuōőŖƀƞƢƵƷƺǜȕɳɸɾcy;䐧PY耻©䂩ƀcpyŝŢźute;䄆Ā;iŧŨ拒talDifferentialD;慅leys;愭ȀaeioƉƎƔƘron;䄌dil耻Ç䃇rc;䄈nint;戰ot;䄊ĀdnƧƭilla;䂸terDot;䂷òſi;䎧rcleȀDMPTǇǋǑǖot;抙inus;抖lus;投imes;抗oĀcsǢǸkwiseContourIntegral;戲eCurlyĀDQȃȏoubleQuote;思uote;怙ȀlnpuȞȨɇɕonĀ;eȥȦ户;橴ƀgitȯȶȺruent;扡nt;戯ourIntegral;戮ĀfrɌɎ;愂oduct;成nterClockwiseContourIntegral;戳oss;樯cr;쀀𝒞pĀ;Cʄʅ拓ap;才րDJSZacefiosʠʬʰʴʸˋ˗ˡ˦̳ҍĀ;oŹʥtrahd;椑cy;䐂cy;䐅cy;䐏ƀgrsʿ˄ˇger;怡r;憡hv;櫤Āayː˕ron;䄎;䐔lĀ;t˝˞戇a;䎔r;쀀𝔇Āaf˫̧Ācm˰̢riticalȀADGT̖̜̀̆cute;䂴oŴ̋̍;䋙bleAcute;䋝rave;䁠ilde;䋜ond;拄ferentialD;慆Ѱ̽\0\0\0͔͂\0Ѕf;쀀𝔻ƀ;DE͈͉͍䂨ot;惜qual;扐blèCDLRUVͣͲ΂ϏϢϸontourIntegraìȹoɴ͹\0\0ͻ»͉nArrow;懓Āeo·ΤftƀARTΐΖΡrrow;懐ightArrow;懔eåˊngĀLRΫτeftĀARγιrrow;柸ightArrow;柺ightArrow;柹ightĀATϘϞrrow;懒ee;抨pɁϩ\0\0ϯrrow;懑ownArrow;懕erticalBar;戥ǹABLRTaВЪаўѿͼrrowƀ;BUНОТ憓ar;椓pArrow;懵reve;䌑eft˒к\0ц\0ѐightVector;楐eeVector;楞ectorĀ;Bљњ憽ar;楖ightǔѧ\0ѱeeVector;楟ectorĀ;BѺѻ懁ar;楗eeĀ;A҆҇护rrow;憧ĀctҒҗr;쀀𝒟rok;䄐ࠀNTacdfglmopqstuxҽӀӄӋӞӢӧӮӵԡԯԶՒ՝ՠեG;䅊H耻Ð䃐cute耻É䃉ƀaiyӒӗӜron;䄚rc耻Ê䃊;䐭ot;䄖r;쀀𝔈rave耻È䃈ement;戈ĀapӺӾcr;䄒tyɓԆ\0\0ԒmallSquare;旻erySmallSquare;斫ĀgpԦԪon;䄘f;쀀𝔼silon;䎕uĀaiԼՉlĀ;TՂՃ橵ilde;扂librium;懌Āci՗՚r;愰m;橳a;䎗ml耻Ë䃋Āipժկsts;戃onentialE;慇ʀcfiosօֈ֍ֲ׌y;䐤r;쀀𝔉lledɓ֗\0\0֣mallSquare;旼erySmallSquare;斪Ͱֺ\0ֿ\0\0ׄf;쀀𝔽All;戀riertrf;愱cò׋؀JTabcdfgorstר׬ׯ׺؀ؒؖ؛؝أ٬ٲcy;䐃耻>䀾mmaĀ;d׷׸䎓;䏜reve;䄞ƀeiy؇،ؐdil;䄢rc;䄜;䐓ot;䄠r;쀀𝔊;拙pf;쀀𝔾eater̀EFGLSTصلَٖٛ٦qualĀ;Lؾؿ扥ess;招ullEqual;执reater;檢ess;扷lantEqual;橾ilde;扳cr;쀀𝒢;扫ЀAacfiosuڅڋږڛڞڪھۊRDcy;䐪Āctڐڔek;䋇;䁞irc;䄤r;愌lbertSpace;愋ǰگ\0ڲf;愍izontalLine;攀Āctۃۅòکrok;䄦mpńېۘownHumðįqual;扏܀EJOacdfgmnostuۺ۾܃܇܎ܚܞܡܨ݄ݸދޏޕcy;䐕lig;䄲cy;䐁cute耻Í䃍Āiyܓܘrc耻Î䃎;䐘ot;䄰r;愑rave耻Ì䃌ƀ;apܠܯܿĀcgܴܷr;䄪inaryI;慈lieóϝǴ݉\0ݢĀ;eݍݎ戬Āgrݓݘral;戫section;拂isibleĀCTݬݲomma;恣imes;恢ƀgptݿރވon;䄮f;쀀𝕀a;䎙cr;愐ilde;䄨ǫޚ\0ޞcy;䐆l耻Ï䃏ʀcfosuެ޷޼߂ߐĀiyޱ޵rc;䄴;䐙r;쀀𝔍pf;쀀𝕁ǣ߇\0ߌr;쀀𝒥rcy;䐈kcy;䐄΀HJacfosߤߨ߽߬߱ࠂࠈcy;䐥cy;䐌ppa;䎚Āey߶߻dil;䄶;䐚r;쀀𝔎pf;쀀𝕂cr;쀀𝒦րJTaceflmostࠥࠩࠬࡐࡣ঳সে্਷ੇcy;䐉耻<䀼ʀcmnpr࠷࠼ࡁࡄࡍute;䄹bda;䎛g;柪lacetrf;愒r;憞ƀaeyࡗ࡜ࡡron;䄽dil;䄻;䐛Āfsࡨ॰tԀACDFRTUVarࡾࢩࢱࣦ࣠ࣼयज़ΐ४Ānrࢃ࢏gleBracket;柨rowƀ;BR࢙࢚࢞憐ar;懤ightArrow;懆eiling;挈oǵࢷ\0ࣃbleBracket;柦nǔࣈ\0࣒eeVector;楡ectorĀ;Bࣛࣜ懃ar;楙loor;挊ightĀAV࣯ࣵrrow;憔ector;楎Āerँगeƀ;AVउऊऐ抣rrow;憤ector;楚iangleƀ;BEतथऩ抲ar;槏qual;抴pƀDTVषूौownVector;楑eeVector;楠ectorĀ;Bॖॗ憿ar;楘ectorĀ;B॥०憼ar;楒ightáΜs̀EFGLSTॾঋকঝঢভqualGreater;拚ullEqual;扦reater;扶ess;檡lantEqual;橽ilde;扲r;쀀𝔏Ā;eঽা拘ftarrow;懚idot;䄿ƀnpw৔ਖਛgȀLRlr৞৷ਂਐeftĀAR০৬rrow;柵ightArrow;柷ightArrow;柶eftĀarγਊightáοightáϊf;쀀𝕃erĀLRਢਬeftArrow;憙ightArrow;憘ƀchtਾੀੂòࡌ;憰rok;䅁;扪Ѐacefiosuਗ਼੝੠੷੼અઋ઎p;椅y;䐜Ādl੥੯iumSpace;恟lintrf;愳r;쀀𝔐nusPlus;戓pf;쀀𝕄cò੶;䎜ҀJacefostuણધભીଔଙඑ඗ඞcy;䐊cute;䅃ƀaey઴હાron;䅇dil;䅅;䐝ƀgswે૰଎ativeƀMTV૓૟૨ediumSpace;怋hiĀcn૦૘ë૙eryThiî૙tedĀGL૸ଆreaterGreateòٳessLesóੈLine;䀊r;쀀𝔑ȀBnptଢନଷ଺reak;恠BreakingSpace;䂠f;愕ڀ;CDEGHLNPRSTV୕ୖ୪୼஡௫ఄ౞಄ದ೘ൡඅ櫬Āou୛୤ngruent;扢pCap;扭oubleVerticalBar;戦ƀlqxஃஊ஛ement;戉ualĀ;Tஒஓ扠ilde;쀀≂̸ists;戄reater΀;EFGLSTஶஷ஽௉௓௘௥扯qual;扱ullEqual;쀀≧̸reater;쀀≫̸ess;批lantEqual;쀀⩾̸ilde;扵umpń௲௽ownHump;쀀≎̸qual;쀀≏̸eĀfsఊధtTriangleƀ;BEచఛడ拪ar;쀀⧏̸qual;括s̀;EGLSTవశ఼ౄోౘ扮qual;扰reater;扸ess;쀀≪̸lantEqual;쀀⩽̸ilde;扴estedĀGL౨౹reaterGreater;쀀⪢̸essLess;쀀⪡̸recedesƀ;ESಒಓಛ技qual;쀀⪯̸lantEqual;拠ĀeiಫಹverseElement;戌ghtTriangleƀ;BEೋೌ೒拫ar;쀀⧐̸qual;拭ĀquೝഌuareSuĀbp೨೹setĀ;E೰ೳ쀀⊏̸qual;拢ersetĀ;Eഃആ쀀⊐̸qual;拣ƀbcpഓതൎsetĀ;Eഛഞ쀀⊂⃒qual;抈ceedsȀ;ESTലള഻െ抁qual;쀀⪰̸lantEqual;拡ilde;쀀≿̸ersetĀ;E൘൛쀀⊃⃒qual;抉ildeȀ;EFT൮൯൵ൿ扁qual;扄ullEqual;扇ilde;扉erticalBar;戤cr;쀀𝒩ilde耻Ñ䃑;䎝܀Eacdfgmoprstuvලෂ෉෕ෛ෠෧෼ขภยา฿ไlig;䅒cute耻Ó䃓Āiy෎ීrc耻Ô䃔;䐞blac;䅐r;쀀𝔒rave耻Ò䃒ƀaei෮ෲ෶cr;䅌ga;䎩cron;䎟pf;쀀𝕆enCurlyĀDQฎบoubleQuote;怜uote;怘;橔Āclวฬr;쀀𝒪ash耻Ø䃘iŬื฼de耻Õ䃕es;樷ml耻Ö䃖erĀBP๋๠Āar๐๓r;怾acĀek๚๜;揞et;掴arenthesis;揜Ҁacfhilors๿ງຊຏຒດຝະ໼rtialD;戂y;䐟r;쀀𝔓i;䎦;䎠usMinus;䂱Āipຢອncareplanåڝf;愙Ȁ;eio຺ູ໠໤檻cedesȀ;EST່້໏໚扺qual;檯lantEqual;扼ilde;找me;怳Ādp໩໮uct;戏ortionĀ;aȥ໹l;戝Āci༁༆r;쀀𝒫;䎨ȀUfos༑༖༛༟OT耻"䀢r;쀀𝔔pf;愚cr;쀀𝒬؀BEacefhiorsu༾གྷཇའཱིྦྷྪྭ႖ႩႴႾarr;椐G耻®䂮ƀcnrཎནབute;䅔g;柫rĀ;tཛྷཝ憠l;椖ƀaeyཧཬཱron;䅘dil;䅖;䐠Ā;vླྀཹ愜erseĀEUྂྙĀlq྇ྎement;戋uilibrium;懋pEquilibrium;楯r»ཹo;䎡ghtЀACDFTUVa࿁࿫࿳ဢဨၛႇϘĀnr࿆࿒gleBracket;柩rowƀ;BL࿜࿝࿡憒ar;懥eftArrow;懄eiling;按oǵ࿹\0စbleBracket;柧nǔည\0နeeVector;楝ectorĀ;Bဝသ懂ar;楕loor;挋Āerိ၃eƀ;AVဵံြ抢rrow;憦ector;楛iangleƀ;BEၐၑၕ抳ar;槐qual;抵pƀDTVၣၮၸownVector;楏eeVector;楜ectorĀ;Bႂႃ憾ar;楔ectorĀ;B႑႒懀ar;楓Āpuႛ႞f;愝ndImplies;楰ightarrow;懛ĀchႹႼr;愛;憱leDelayed;槴ڀHOacfhimoqstuფჱჷჽᄙᄞᅑᅖᅡᅧᆵᆻᆿĀCcჩხHcy;䐩y;䐨FTcy;䐬cute;䅚ʀ;aeiyᄈᄉᄎᄓᄗ檼ron;䅠dil;䅞rc;䅜;䐡r;쀀𝔖ortȀDLRUᄪᄴᄾᅉownArrow»ОeftArrow»࢚ightArrow»࿝pArrow;憑gma;䎣allCircle;战pf;쀀𝕊ɲᅭ\0\0ᅰt;戚areȀ;ISUᅻᅼᆉᆯ斡ntersection;抓uĀbpᆏᆞsetĀ;Eᆗᆘ抏qual;抑ersetĀ;Eᆨᆩ抐qual;抒nion;抔cr;쀀𝒮ar;拆ȀbcmpᇈᇛሉላĀ;sᇍᇎ拐etĀ;Eᇍᇕqual;抆ĀchᇠህeedsȀ;ESTᇭᇮᇴᇿ扻qual;檰lantEqual;扽ilde;承Tháྌ;我ƀ;esሒሓሣ拑rsetĀ;Eሜም抃qual;抇et»ሓրHRSacfhiorsሾቄ቉ቕ቞ቱቶኟዂወዑORN耻Þ䃞ADE;愢ĀHc቎ቒcy;䐋y;䐦Ābuቚቜ;䀉;䎤ƀaeyብቪቯron;䅤dil;䅢;䐢r;쀀𝔗Āeiቻ኉ǲኀ\0ኇefore;戴a;䎘Ācn኎ኘkSpace;쀀  Space;怉ldeȀ;EFTካኬኲኼ戼qual;扃ullEqual;扅ilde;扈pf;쀀𝕋ipleDot;惛Āctዖዛr;쀀𝒯rok;䅦ૡዷጎጚጦ\0ጬጱ\0\0\0\0\0ጸጽ፷ᎅ\0᏿ᐄᐊᐐĀcrዻጁute耻Ú䃚rĀ;oጇገ憟cir;楉rǣጓ\0጖y;䐎ve;䅬Āiyጞጣrc耻Û䃛;䐣blac;䅰r;쀀𝔘rave耻Ù䃙acr;䅪Ādiፁ፩erĀBPፈ፝Āarፍፐr;䁟acĀekፗፙ;揟et;掵arenthesis;揝onĀ;P፰፱拃lus;抎Āgp፻፿on;䅲f;쀀𝕌ЀADETadps᎕ᎮᎸᏄϨᏒᏗᏳrrowƀ;BDᅐᎠᎤar;椒ownArrow;懅ownArrow;憕quilibrium;楮eeĀ;AᏋᏌ报rrow;憥ownáϳerĀLRᏞᏨeftArrow;憖ightArrow;憗iĀ;lᏹᏺ䏒on;䎥ing;䅮cr;쀀𝒰ilde;䅨ml耻Ü䃜ҀDbcdefosvᐧᐬᐰᐳᐾᒅᒊᒐᒖash;披ar;櫫y;䐒ashĀ;lᐻᐼ抩;櫦Āerᑃᑅ;拁ƀbtyᑌᑐᑺar;怖Ā;iᑏᑕcalȀBLSTᑡᑥᑪᑴar;戣ine;䁼eparator;杘ilde;所ThinSpace;怊r;쀀𝔙pf;쀀𝕍cr;쀀𝒱dash;抪ʀcefosᒧᒬᒱᒶᒼirc;䅴dge;拀r;쀀𝔚pf;쀀𝕎cr;쀀𝒲Ȁfiosᓋᓐᓒᓘr;쀀𝔛;䎞pf;쀀𝕏cr;쀀𝒳ҀAIUacfosuᓱᓵᓹᓽᔄᔏᔔᔚᔠcy;䐯cy;䐇cy;䐮cute耻Ý䃝Āiyᔉᔍrc;䅶;䐫r;쀀𝔜pf;쀀𝕐cr;쀀𝒴ml;䅸ЀHacdefosᔵᔹᔿᕋᕏᕝᕠᕤcy;䐖cute;䅹Āayᕄᕉron;䅽;䐗ot;䅻ǲᕔ\0ᕛoWidtè૙a;䎖r;愨pf;愤cr;쀀𝒵௡ᖃᖊᖐ\0ᖰᖶᖿ\0\0\0\0ᗆᗛᗫᙟ᙭\0ᚕ᚛ᚲᚹ\0ᚾcute耻á䃡reve;䄃̀;Ediuyᖜᖝᖡᖣᖨᖭ戾;쀀∾̳;房rc耻â䃢te肻´̆;䐰lig耻æ䃦Ā;r²ᖺ;쀀𝔞rave耻à䃠ĀepᗊᗖĀfpᗏᗔsym;愵èᗓha;䎱ĀapᗟcĀclᗤᗧr;䄁g;樿ɤᗰ\0\0ᘊʀ;adsvᗺᗻᗿᘁᘇ戧nd;橕;橜lope;橘;橚΀;elmrszᘘᘙᘛᘞᘿᙏᙙ戠;榤e»ᘙsdĀ;aᘥᘦ戡ѡᘰᘲᘴᘶᘸᘺᘼᘾ;榨;榩;榪;榫;榬;榭;榮;榯tĀ;vᙅᙆ戟bĀ;dᙌᙍ抾;榝Āptᙔᙗh;戢»¹arr;捼Āgpᙣᙧon;䄅f;쀀𝕒΀;Eaeiop዁ᙻᙽᚂᚄᚇᚊ;橰cir;橯;扊d;手s;䀧roxĀ;e዁ᚒñᚃing耻å䃥ƀctyᚡᚦᚨr;쀀𝒶;䀪mpĀ;e዁ᚯñʈilde耻ã䃣ml耻ä䃤Āciᛂᛈoninôɲnt;樑ࠀNabcdefiklnoprsu᛭ᛱᜰ᜼ᝃᝈ᝸᝽០៦ᠹᡐᜍ᤽᥈ᥰot;櫭Ācrᛶ᜞kȀcepsᜀᜅᜍᜓong;扌psilon;䏶rime;怵imĀ;e᜚᜛戽q;拍Ŷᜢᜦee;抽edĀ;gᜬᜭ挅e»ᜭrkĀ;t፜᜷brk;掶Āoyᜁᝁ;䐱quo;怞ʀcmprtᝓ᝛ᝡᝤᝨausĀ;eĊĉptyv;榰séᜌnoõēƀahwᝯ᝱ᝳ;䎲;愶een;扬r;쀀𝔟g΀costuvwឍឝឳេ៕៛៞ƀaiuបពរðݠrc;旯p»፱ƀdptឤឨឭot;樀lus;樁imes;樂ɱឹ\0\0ើcup;樆ar;昅riangleĀdu៍្own;施p;斳plus;樄eåᑄåᒭarow;植ƀako៭ᠦᠵĀcn៲ᠣkƀlst៺֫᠂ozenge;槫riangleȀ;dlr᠒᠓᠘᠝斴own;斾eft;旂ight;斸k;搣Ʊᠫ\0ᠳƲᠯ\0ᠱ;斒;斑4;斓ck;斈ĀeoᠾᡍĀ;qᡃᡆ쀀=⃥uiv;쀀≡⃥t;挐Ȁptwxᡙᡞᡧᡬf;쀀𝕓Ā;tᏋᡣom»Ꮜtie;拈؀DHUVbdhmptuvᢅᢖᢪᢻᣗᣛᣬ᣿ᤅᤊᤐᤡȀLRlrᢎᢐᢒᢔ;敗;敔;敖;敓ʀ;DUduᢡᢢᢤᢦᢨ敐;敦;敩;敤;敧ȀLRlrᢳᢵᢷᢹ;敝;敚;敜;教΀;HLRhlrᣊᣋᣍᣏᣑᣓᣕ救;敬;散;敠;敫;敢;敟ox;槉ȀLRlrᣤᣦᣨᣪ;敕;敒;攐;攌ʀ;DUduڽ᣷᣹᣻᣽;敥;敨;攬;攴inus;抟lus;択imes;抠ȀLRlrᤙᤛᤝ᤟;敛;敘;攘;攔΀;HLRhlrᤰᤱᤳᤵᤷ᤻᤹攂;敪;敡;敞;攼;攤;攜Āevģ᥂bar耻¦䂦Ȁceioᥑᥖᥚᥠr;쀀𝒷mi;恏mĀ;e᜚᜜lƀ;bhᥨᥩᥫ䁜;槅sub;柈Ŭᥴ᥾lĀ;e᥹᥺怢t»᥺pƀ;Eeįᦅᦇ;檮Ā;qۜۛೡᦧ\0᧨ᨑᨕᨲ\0ᨷᩐ\0\0᪴\0\0᫁\0\0ᬡᬮ᭍᭒\0᯽\0ᰌƀcpr᦭ᦲ᧝ute;䄇̀;abcdsᦿᧀᧄ᧊᧕᧙戩nd;橄rcup;橉Āau᧏᧒p;橋p;橇ot;橀;쀀∩︀Āeo᧢᧥t;恁îړȀaeiu᧰᧻ᨁᨅǰ᧵\0᧸s;橍on;䄍dil耻ç䃧rc;䄉psĀ;sᨌᨍ橌m;橐ot;䄋ƀdmnᨛᨠᨦil肻¸ƭptyv;榲t脀¢;eᨭᨮ䂢räƲr;쀀𝔠ƀceiᨽᩀᩍy;䑇ckĀ;mᩇᩈ朓ark»ᩈ;䏇r΀;Ecefms᩟᩠ᩢᩫ᪤᪪᪮旋;槃ƀ;elᩩᩪᩭ䋆q;扗eɡᩴ\0\0᪈rrowĀlr᩼᪁eft;憺ight;憻ʀRSacd᪒᪔᪖᪚᪟»ཇ;擈st;抛irc;抚ash;抝nint;樐id;櫯cir;槂ubsĀ;u᪻᪼晣it»᪼ˬ᫇᫔᫺\0ᬊonĀ;eᫍᫎ䀺Ā;qÇÆɭ᫙\0\0᫢aĀ;t᫞᫟䀬;䁀ƀ;fl᫨᫩᫫戁îᅠeĀmx᫱᫶ent»᫩eóɍǧ᫾\0ᬇĀ;dኻᬂot;橭nôɆƀfryᬐᬔᬗ;쀀𝕔oäɔ脀©;sŕᬝr;愗Āaoᬥᬩrr;憵ss;朗Ācuᬲᬷr;쀀𝒸Ābpᬼ᭄Ā;eᭁᭂ櫏;櫑Ā;eᭉᭊ櫐;櫒dot;拯΀delprvw᭠᭬᭷ᮂᮬᯔ᯹arrĀlr᭨᭪;椸;椵ɰ᭲\0\0᭵r;拞c;拟arrĀ;p᭿ᮀ憶;椽̀;bcdosᮏᮐᮖᮡᮥᮨ截rcap;橈Āauᮛᮞp;橆p;橊ot;抍r;橅;쀀∪︀Ȁalrv᮵ᮿᯞᯣrrĀ;mᮼᮽ憷;椼yƀevwᯇᯔᯘqɰᯎ\0\0ᯒreã᭳uã᭵ee;拎edge;拏en耻¤䂤earrowĀlrᯮ᯳eft»ᮀight»ᮽeäᯝĀciᰁᰇoninôǷnt;戱lcty;挭ঀAHabcdefhijlorstuwz᰸᰻᰿ᱝᱩᱵᲊᲞᲬᲷ᳻᳿ᴍᵻᶑᶫᶻ᷆᷍rò΁ar;楥Ȁglrs᱈ᱍ᱒᱔ger;怠eth;愸òᄳhĀ;vᱚᱛ怐»ऊūᱡᱧarow;椏aã̕Āayᱮᱳron;䄏;䐴ƀ;ao̲ᱼᲄĀgrʿᲁr;懊tseq;橷ƀglmᲑᲔᲘ耻°䂰ta;䎴ptyv;榱ĀirᲣᲨsht;楿;쀀𝔡arĀlrᲳᲵ»ࣜ»သʀaegsv᳂͸᳖᳜᳠mƀ;oș᳊᳔ndĀ;ș᳑uit;晦amma;䏝in;拲ƀ;io᳧᳨᳸䃷de脀÷;o᳧ᳰntimes;拇nø᳷cy;䑒cɯᴆ\0\0ᴊrn;挞op;挍ʀlptuwᴘᴝᴢᵉᵕlar;䀤f;쀀𝕕ʀ;emps̋ᴭᴷᴽᵂqĀ;d͒ᴳot;扑inus;戸lus;戔quare;抡blebarwedgåúnƀadhᄮᵝᵧownarrowóᲃarpoonĀlrᵲᵶefôᲴighôᲶŢᵿᶅkaro÷གɯᶊ\0\0ᶎrn;挟op;挌ƀcotᶘᶣᶦĀryᶝᶡ;쀀𝒹;䑕l;槶rok;䄑Ādrᶰᶴot;拱iĀ;fᶺ᠖斿Āah᷀᷃ròЩaòྦangle;榦Āci᷒ᷕy;䑟grarr;柿ऀDacdefglmnopqrstuxḁḉḙḸոḼṉṡṾấắẽỡἪἷὄ὎὚ĀDoḆᴴoôᲉĀcsḎḔute耻é䃩ter;橮ȀaioyḢḧḱḶron;䄛rĀ;cḭḮ扖耻ê䃪lon;払;䑍ot;䄗ĀDrṁṅot;扒;쀀𝔢ƀ;rsṐṑṗ檚ave耻è䃨Ā;dṜṝ檖ot;檘Ȁ;ilsṪṫṲṴ檙nters;揧;愓Ā;dṹṺ檕ot;檗ƀapsẅẉẗcr;䄓tyƀ;svẒẓẕ戅et»ẓpĀ1;ẝẤĳạả;怄;怅怃ĀgsẪẬ;䅋p;怂ĀgpẴẸon;䄙f;쀀𝕖ƀalsỄỎỒrĀ;sỊị拕l;槣us;橱iƀ;lvỚớở䎵on»ớ;䏵ȀcsuvỪỳἋἣĀioữḱrc»Ḯɩỹ\0\0ỻíՈantĀglἂἆtr»ṝess»Ṻƀaeiἒ἖Ἒls;䀽st;扟vĀ;DȵἠD;橸parsl;槥ĀDaἯἳot;打rr;楱ƀcdiἾὁỸr;愯oô͒ĀahὉὋ;䎷耻ð䃰Āmrὓὗl耻ë䃫o;悬ƀcipὡὤὧl;䀡sôծĀeoὬὴctatioîՙnentialåչৡᾒ\0ᾞ\0ᾡᾧ\0\0ῆῌ\0ΐ\0ῦῪ \0 ⁚llingdotseñṄy;䑄male;晀ƀilrᾭᾳ῁lig;耀ﬃɩᾹ\0\0᾽g;耀ﬀig;耀ﬄ;쀀𝔣lig;耀ﬁlig;쀀fjƀaltῙ῜ῡt;晭ig;耀ﬂns;斱of;䆒ǰ΅\0ῳf;쀀𝕗ĀakֿῷĀ;vῼ´拔;櫙artint;樍Āao‌⁕Ācs‑⁒α‚‰‸⁅⁈\0⁐β•‥‧‪‬\0‮耻½䂽;慓耻¼䂼;慕;慙;慛Ƴ‴\0‶;慔;慖ʴ‾⁁\0\0⁃耻¾䂾;慗;慜5;慘ƶ⁌\0⁎;慚;慝8;慞l;恄wn;挢cr;쀀𝒻ࢀEabcdefgijlnorstv₂₉₟₥₰₴⃰⃵⃺⃿℃ℒℸ̗ℾ⅒↞Ā;lٍ₇;檌ƀcmpₐₕ₝ute;䇵maĀ;dₜ᳚䎳;檆reve;䄟Āiy₪₮rc;䄝;䐳ot;䄡Ȁ;lqsؾق₽⃉ƀ;qsؾٌ⃄lanô٥Ȁ;cdl٥⃒⃥⃕c;檩otĀ;o⃜⃝檀Ā;l⃢⃣檂;檄Ā;e⃪⃭쀀⋛︀s;檔r;쀀𝔤Ā;gٳ؛mel;愷cy;䑓Ȁ;Eajٚℌℎℐ;檒;檥;檤ȀEaesℛℝ℩ℴ;扩pĀ;p℣ℤ檊rox»ℤĀ;q℮ℯ檈Ā;q℮ℛim;拧pf;쀀𝕘Āci⅃ⅆr;愊mƀ;el٫ⅎ⅐;檎;檐茀>;cdlqr׮ⅠⅪⅮⅳⅹĀciⅥⅧ;檧r;橺ot;拗Par;榕uest;橼ʀadelsↄⅪ←ٖ↛ǰ↉\0↎proø₞r;楸qĀlqؿ↖lesó₈ií٫Āen↣↭rtneqq;쀀≩︀Å↪ԀAabcefkosy⇄⇇⇱⇵⇺∘∝∯≨≽ròΠȀilmr⇐⇔⇗⇛rsðᒄf»․ilôکĀdr⇠⇤cy;䑊ƀ;cwࣴ⇫⇯ir;楈;憭ar;意irc;䄥ƀalr∁∎∓rtsĀ;u∉∊晥it»∊lip;怦con;抹r;쀀𝔥sĀew∣∩arow;椥arow;椦ʀamopr∺∾≃≞≣rr;懿tht;戻kĀlr≉≓eftarrow;憩ightarrow;憪f;쀀𝕙bar;怕ƀclt≯≴≸r;쀀𝒽asè⇴rok;䄧Ābp⊂⊇ull;恃hen»ᱛૡ⊣\0⊪\0⊸⋅⋎\0⋕⋳\0\0⋸⌢⍧⍢⍿\0⎆⎪⎴cute耻í䃭ƀ;iyݱ⊰⊵rc耻î䃮;䐸Ācx⊼⊿y;䐵cl耻¡䂡ĀfrΟ⋉;쀀𝔦rave耻ì䃬Ȁ;inoܾ⋝⋩⋮Āin⋢⋦nt;樌t;戭fin;槜ta;愩lig;䄳ƀaop⋾⌚⌝ƀcgt⌅⌈⌗r;䄫ƀelpܟ⌏⌓inåގarôܠh;䄱f;抷ed;䆵ʀ;cfotӴ⌬⌱⌽⍁are;愅inĀ;t⌸⌹戞ie;槝doô⌙ʀ;celpݗ⍌⍐⍛⍡al;抺Āgr⍕⍙eróᕣã⍍arhk;樗rod;樼Ȁcgpt⍯⍲⍶⍻y;䑑on;䄯f;쀀𝕚a;䎹uest耻¿䂿Āci⎊⎏r;쀀𝒾nʀ;EdsvӴ⎛⎝⎡ӳ;拹ot;拵Ā;v⎦⎧拴;拳Ā;iݷ⎮lde;䄩ǫ⎸\0⎼cy;䑖l耻ï䃯̀cfmosu⏌⏗⏜⏡⏧⏵Āiy⏑⏕rc;䄵;䐹r;쀀𝔧ath;䈷pf;쀀𝕛ǣ⏬\0⏱r;쀀𝒿rcy;䑘kcy;䑔Ѐacfghjos␋␖␢␧␭␱␵␻ppaĀ;v␓␔䎺;䏰Āey␛␠dil;䄷;䐺r;쀀𝔨reen;䄸cy;䑅cy;䑜pf;쀀𝕜cr;쀀𝓀஀ABEHabcdefghjlmnoprstuv⑰⒁⒆⒍⒑┎┽╚▀♎♞♥♹♽⚚⚲⛘❝❨➋⟀⠁⠒ƀart⑷⑺⑼rò৆òΕail;椛arr;椎Ā;gঔ⒋;檋ar;楢ॣ⒥\0⒪\0⒱\0\0\0\0\0⒵Ⓔ\0ⓆⓈⓍ\0⓹ute;䄺mptyv;榴raîࡌbda;䎻gƀ;dlࢎⓁⓃ;榑åࢎ;檅uo耻«䂫rЀ;bfhlpst࢙ⓞⓦⓩ⓫⓮⓱⓵Ā;f࢝ⓣs;椟s;椝ë≒p;憫l;椹im;楳l;憢ƀ;ae⓿─┄檫il;椙Ā;s┉┊檭;쀀⪭︀ƀabr┕┙┝rr;椌rk;杲Āak┢┬cĀek┨┪;䁻;䁛Āes┱┳;榋lĀdu┹┻;榏;榍Ȁaeuy╆╋╖╘ron;䄾Ādi═╔il;䄼ìࢰâ┩;䐻Ȁcqrs╣╦╭╽a;椶uoĀ;rนᝆĀdu╲╷har;楧shar;楋h;憲ʀ;fgqs▋▌উ◳◿扤tʀahlrt▘▤▷◂◨rrowĀ;t࢙□aé⓶arpoonĀdu▯▴own»њp»०eftarrows;懇ightƀahs◍◖◞rrowĀ;sࣴࢧarpoonó྘quigarro÷⇰hreetimes;拋ƀ;qs▋ও◺lanôবʀ;cdgsব☊☍☝☨c;檨otĀ;o☔☕橿Ā;r☚☛檁;檃Ā;e☢☥쀀⋚︀s;檓ʀadegs☳☹☽♉♋pproøⓆot;拖qĀgq♃♅ôউgtò⒌ôছiíলƀilr♕࣡♚sht;楼;쀀𝔩Ā;Eজ♣;檑š♩♶rĀdu▲♮Ā;l॥♳;楪lk;斄cy;䑙ʀ;achtੈ⚈⚋⚑⚖rò◁orneòᴈard;楫ri;旺Āio⚟⚤dot;䅀ustĀ;a⚬⚭掰che»⚭ȀEaes⚻⚽⛉⛔;扨pĀ;p⛃⛄檉rox»⛄Ā;q⛎⛏檇Ā;q⛎⚻im;拦Ѐabnoptwz⛩⛴⛷✚✯❁❇❐Ānr⛮⛱g;柬r;懽rëࣁgƀlmr⛿✍✔eftĀar০✇ightá৲apsto;柼ightá৽parrowĀlr✥✩efô⓭ight;憬ƀafl✶✹✽r;榅;쀀𝕝us;樭imes;樴š❋❏st;戗áፎƀ;ef❗❘᠀旊nge»❘arĀ;l❤❥䀨t;榓ʀachmt❳❶❼➅➇ròࢨorneòᶌarĀ;d྘➃;業;怎ri;抿̀achiqt➘➝ੀ➢➮➻quo;怹r;쀀𝓁mƀ;egল➪➬;檍;檏Ābu┪➳oĀ;rฟ➹;怚rok;䅂萀<;cdhilqrࠫ⟒☹⟜⟠⟥⟪⟰Āci⟗⟙;檦r;橹reå◲mes;拉arr;楶uest;橻ĀPi⟵⟹ar;榖ƀ;ef⠀भ᠛旃rĀdu⠇⠍shar;楊har;楦Āen⠗⠡rtneqq;쀀≨︀Å⠞܀Dacdefhilnopsu⡀⡅⢂⢎⢓⢠⢥⢨⣚⣢⣤ઃ⣳⤂Dot;戺Ȁclpr⡎⡒⡣⡽r耻¯䂯Āet⡗⡙;時Ā;e⡞⡟朠se»⡟Ā;sျ⡨toȀ;dluျ⡳⡷⡻owîҌefôएðᏑker;斮Āoy⢇⢌mma;権;䐼ash;怔asuredangle»ᘦr;쀀𝔪o;愧ƀcdn⢯⢴⣉ro耻µ䂵Ȁ;acdᑤ⢽⣀⣄sôᚧir;櫰ot肻·Ƶusƀ;bd⣒ᤃ⣓戒Ā;uᴼ⣘;横ţ⣞⣡p;櫛ò−ðઁĀdp⣩⣮els;抧f;쀀𝕞Āct⣸⣽r;쀀𝓂pos»ᖝƀ;lm⤉⤊⤍䎼timap;抸ఀGLRVabcdefghijlmoprstuvw⥂⥓⥾⦉⦘⧚⧩⨕⨚⩘⩝⪃⪕⪤⪨⬄⬇⭄⭿⮮ⰴⱧⱼ⳩Āgt⥇⥋;쀀⋙̸Ā;v⥐௏쀀≫⃒ƀelt⥚⥲⥶ftĀar⥡⥧rrow;懍ightarrow;懎;쀀⋘̸Ā;v⥻ే쀀≪⃒ightarrow;懏ĀDd⦎⦓ash;抯ash;抮ʀbcnpt⦣⦧⦬⦱⧌la»˞ute;䅄g;쀀∠⃒ʀ;Eiop඄⦼⧀⧅⧈;쀀⩰̸d;쀀≋̸s;䅉roø඄urĀ;a⧓⧔普lĀ;s⧓ସǳ⧟\0⧣p肻 ଷmpĀ;e௹ఀʀaeouy⧴⧾⨃⨐⨓ǰ⧹\0⧻;橃on;䅈dil;䅆ngĀ;dൾ⨊ot;쀀⩭̸p;橂;䐽ash;怓΀;Aadqsxஒ⨩⨭⨻⩁⩅⩐rr;懗rĀhr⨳⨶k;椤Ā;oᏲᏰot;쀀≐̸uiöୣĀei⩊⩎ar;椨í஘istĀ;s஠டr;쀀𝔫ȀEest௅⩦⩹⩼ƀ;qs஼⩭௡ƀ;qs஼௅⩴lanô௢ií௪Ā;rஶ⪁»ஷƀAap⪊⪍⪑rò⥱rr;憮ar;櫲ƀ;svྍ⪜ྌĀ;d⪡⪢拼;拺cy;䑚΀AEadest⪷⪺⪾⫂⫅⫶⫹rò⥦;쀀≦̸rr;憚r;急Ȁ;fqs఻⫎⫣⫯tĀar⫔⫙rro÷⫁ightarro÷⪐ƀ;qs఻⪺⫪lanôౕĀ;sౕ⫴»శiíౝĀ;rవ⫾iĀ;eచథiäඐĀpt⬌⬑f;쀀𝕟膀¬;in⬙⬚⬶䂬nȀ;Edvஉ⬤⬨⬮;쀀⋹̸ot;쀀⋵̸ǡஉ⬳⬵;拷;拶iĀ;vಸ⬼ǡಸ⭁⭃;拾;拽ƀaor⭋⭣⭩rȀ;ast୻⭕⭚⭟lleì୻l;쀀⫽⃥;쀀∂̸lint;樔ƀ;ceಒ⭰⭳uåಥĀ;cಘ⭸Ā;eಒ⭽ñಘȀAait⮈⮋⮝⮧rò⦈rrƀ;cw⮔⮕⮙憛;쀀⤳̸;쀀↝̸ghtarrow»⮕riĀ;eೋೖ΀chimpqu⮽⯍⯙⬄୸⯤⯯Ȁ;cerല⯆ഷ⯉uå൅;쀀𝓃ortɭ⬅\0\0⯖ará⭖mĀ;e൮⯟Ā;q൴൳suĀbp⯫⯭å೸åഋƀbcp⯶ⰑⰙȀ;Ees⯿ⰀഢⰄ抄;쀀⫅̸etĀ;eഛⰋqĀ;qണⰀcĀ;eലⰗñസȀ;EesⰢⰣൟⰧ抅;쀀⫆̸etĀ;e൘ⰮqĀ;qൠⰣȀgilrⰽⰿⱅⱇìௗlde耻ñ䃱çృiangleĀlrⱒⱜeftĀ;eచⱚñదightĀ;eೋⱥñ೗Ā;mⱬⱭ䎽ƀ;esⱴⱵⱹ䀣ro;愖p;怇ҀDHadgilrsⲏⲔⲙⲞⲣⲰⲶⳓⳣash;抭arr;椄p;쀀≍⃒ash;抬ĀetⲨⲬ;쀀≥⃒;쀀>⃒nfin;槞ƀAetⲽⳁⳅrr;椂;쀀≤⃒Ā;rⳊⳍ쀀<⃒ie;쀀⊴⃒ĀAtⳘⳜrr;椃rie;쀀⊵⃒im;쀀∼⃒ƀAan⳰⳴ⴂrr;懖rĀhr⳺⳽k;椣Ā;oᏧᏥear;椧ቓ᪕\0\0\0\0\0\0\0\0\0\0\0\0\0ⴭ\0ⴸⵈⵠⵥ⵲ⶄᬇ\0\0ⶍⶫ\0ⷈⷎ\0ⷜ⸙⸫⸾⹃Ācsⴱ᪗ute耻ó䃳ĀiyⴼⵅrĀ;c᪞ⵂ耻ô䃴;䐾ʀabios᪠ⵒⵗǈⵚlac;䅑v;樸old;榼lig;䅓Ācr⵩⵭ir;榿;쀀𝔬ͯ⵹\0\0⵼\0ⶂn;䋛ave耻ò䃲;槁Ābmⶈ෴ar;榵Ȁacitⶕ⶘ⶥⶨrò᪀Āir⶝ⶠr;榾oss;榻nå๒;槀ƀaeiⶱⶵⶹcr;䅍ga;䏉ƀcdnⷀⷅǍron;䎿;榶pf;쀀𝕠ƀaelⷔ⷗ǒr;榷rp;榹΀;adiosvⷪⷫⷮ⸈⸍⸐⸖戨rò᪆Ȁ;efmⷷⷸ⸂⸅橝rĀ;oⷾⷿ愴f»ⷿ耻ª䂪耻º䂺gof;抶r;橖lope;橗;橛ƀclo⸟⸡⸧ò⸁ash耻ø䃸l;折iŬⸯ⸴de耻õ䃵esĀ;aǛ⸺s;樶ml耻ö䃶bar;挽ૡ⹞\0⹽\0⺀⺝\0⺢⺹\0\0⻋ຜ\0⼓\0\0⼫⾼\0⿈rȀ;astЃ⹧⹲຅脀¶;l⹭⹮䂶leìЃɩ⹸\0\0⹻m;櫳;櫽y;䐿rʀcimpt⺋⺏⺓ᡥ⺗nt;䀥od;䀮il;怰enk;怱r;쀀𝔭ƀimo⺨⺰⺴Ā;v⺭⺮䏆;䏕maô੶ne;明ƀ;tv⺿⻀⻈䏀chfork»´;䏖Āau⻏⻟nĀck⻕⻝kĀ;h⇴⻛;愎ö⇴sҀ;abcdemst⻳⻴ᤈ⻹⻽⼄⼆⼊⼎䀫cir;樣ir;樢Āouᵀ⼂;樥;橲n肻±ຝim;樦wo;樧ƀipu⼙⼠⼥ntint;樕f;쀀𝕡nd耻£䂣Ԁ;Eaceinosu່⼿⽁⽄⽇⾁⾉⾒⽾⾶;檳p;檷uå໙Ā;c໎⽌̀;acens່⽙⽟⽦⽨⽾pproø⽃urlyeñ໙ñ໎ƀaes⽯⽶⽺pprox;檹qq;檵im;拨iíໟmeĀ;s⾈ຮ怲ƀEas⽸⾐⽺ð⽵ƀdfp໬⾙⾯ƀals⾠⾥⾪lar;挮ine;挒urf;挓Ā;t໻⾴ï໻rel;抰Āci⿀⿅r;쀀𝓅;䏈ncsp;怈̀fiopsu⿚⋢⿟⿥⿫⿱r;쀀𝔮pf;쀀𝕢rime;恗cr;쀀𝓆ƀaeo⿸〉〓tĀei⿾々rnionóڰnt;樖stĀ;e【】䀿ñἙô༔઀ABHabcdefhilmnoprstux぀けさすムㄎㄫㅇㅢㅲㆎ㈆㈕㈤㈩㉘㉮㉲㊐㊰㊷ƀartぇおがròႳòϝail;検aròᱥar;楤΀cdenqrtとふへみわゔヌĀeuねぱ;쀀∽̱te;䅕iãᅮmptyv;榳gȀ;del࿑らるろ;榒;榥å࿑uo耻»䂻rր;abcfhlpstw࿜ガクシスゼゾダッデナp;極Ā;f࿠ゴs;椠;椳s;椞ë≝ð✮l;楅im;楴l;憣;憝Āaiパフil;椚oĀ;nホボ戶aló༞ƀabrョリヮrò៥rk;杳ĀakンヽcĀekヹ・;䁽;䁝Āes㄂㄄;榌lĀduㄊㄌ;榎;榐Ȁaeuyㄗㄜㄧㄩron;䅙Ādiㄡㄥil;䅗ì࿲âヺ;䑀Ȁclqsㄴㄷㄽㅄa;椷dhar;楩uoĀ;rȎȍh;憳ƀacgㅎㅟངlȀ;ipsླྀㅘㅛႜnåႻarôྩt;断ƀilrㅩဣㅮsht;楽;쀀𝔯ĀaoㅷㆆrĀduㅽㅿ»ѻĀ;l႑ㆄ;楬Ā;vㆋㆌ䏁;䏱ƀgns㆕ㇹㇼht̀ahlrstㆤㆰ㇂㇘㇤㇮rrowĀ;t࿜ㆭaéトarpoonĀduㆻㆿowîㅾp»႒eftĀah㇊㇐rrowó࿪arpoonóՑightarrows;應quigarro÷ニhreetimes;拌g;䋚ingdotseñἲƀahm㈍㈐㈓rò࿪aòՑ;怏oustĀ;a㈞㈟掱che»㈟mid;櫮Ȁabpt㈲㈽㉀㉒Ānr㈷㈺g;柭r;懾rëဃƀafl㉇㉊㉎r;榆;쀀𝕣us;樮imes;樵Āap㉝㉧rĀ;g㉣㉤䀩t;榔olint;樒arò㇣Ȁachq㉻㊀Ⴜ㊅quo;怺r;쀀𝓇Ābu・㊊oĀ;rȔȓƀhir㊗㊛㊠reåㇸmes;拊iȀ;efl㊪ၙᠡ㊫方tri;槎luhar;楨;愞ൡ㋕㋛㋟㌬㌸㍱\0㍺㎤\0\0㏬㏰\0㐨㑈㑚㒭㒱㓊㓱\0㘖\0\0㘳cute;䅛quï➺Ԁ;Eaceinpsyᇭ㋳㋵㋿㌂㌋㌏㌟㌦㌩;檴ǰ㋺\0㋼;檸on;䅡uåᇾĀ;dᇳ㌇il;䅟rc;䅝ƀEas㌖㌘㌛;檶p;檺im;择olint;樓iíሄ;䑁otƀ;be㌴ᵇ㌵担;橦΀Aacmstx㍆㍊㍗㍛㍞㍣㍭rr;懘rĀhr㍐㍒ë∨Ā;oਸ਼਴t耻§䂧i;䀻war;椩mĀin㍩ðnuóñt;朶rĀ;o㍶⁕쀀𝔰Ȁacoy㎂㎆㎑㎠rp;景Āhy㎋㎏cy;䑉;䑈rtɭ㎙\0\0㎜iäᑤaraì⹯耻­䂭Āgm㎨㎴maƀ;fv㎱㎲㎲䏃;䏂Ѐ;deglnprካ㏅㏉㏎㏖㏞㏡㏦ot;橪Ā;q኱ኰĀ;E㏓㏔檞;檠Ā;E㏛㏜檝;檟e;扆lus;樤arr;楲aròᄽȀaeit㏸㐈㐏㐗Āls㏽㐄lsetmé㍪hp;樳parsl;槤Ādlᑣ㐔e;挣Ā;e㐜㐝檪Ā;s㐢㐣檬;쀀⪬︀ƀflp㐮㐳㑂tcy;䑌Ā;b㐸㐹䀯Ā;a㐾㐿槄r;挿f;쀀𝕤aĀdr㑍ЂesĀ;u㑔㑕晠it»㑕ƀcsu㑠㑹㒟Āau㑥㑯pĀ;sᆈ㑫;쀀⊓︀pĀ;sᆴ㑵;쀀⊔︀uĀbp㑿㒏ƀ;esᆗᆜ㒆etĀ;eᆗ㒍ñᆝƀ;esᆨᆭ㒖etĀ;eᆨ㒝ñᆮƀ;afᅻ㒦ְrť㒫ֱ»ᅼaròᅈȀcemt㒹㒾㓂㓅r;쀀𝓈tmîñiì㐕aræᆾĀar㓎㓕rĀ;f㓔ឿ昆Āan㓚㓭ightĀep㓣㓪psiloîỠhé⺯s»⡒ʀbcmnp㓻㕞ሉ㖋㖎Ҁ;Edemnprs㔎㔏㔑㔕㔞㔣㔬㔱㔶抂;櫅ot;檽Ā;dᇚ㔚ot;櫃ult;櫁ĀEe㔨㔪;櫋;把lus;檿arr;楹ƀeiu㔽㕒㕕tƀ;en㔎㕅㕋qĀ;qᇚ㔏eqĀ;q㔫㔨m;櫇Ābp㕚㕜;櫕;櫓c̀;acensᇭ㕬㕲㕹㕻㌦pproø㋺urlyeñᇾñᇳƀaes㖂㖈㌛pproø㌚qñ㌗g;晪ڀ123;Edehlmnps㖩㖬㖯ሜ㖲㖴㗀㗉㗕㗚㗟㗨㗭耻¹䂹耻²䂲耻³䂳;櫆Āos㖹㖼t;檾ub;櫘Ā;dሢ㗅ot;櫄sĀou㗏㗒l;柉b;櫗arr;楻ult;櫂ĀEe㗤㗦;櫌;抋lus;櫀ƀeiu㗴㘉㘌tƀ;enሜ㗼㘂qĀ;qሢ㖲eqĀ;q㗧㗤m;櫈Ābp㘑㘓;櫔;櫖ƀAan㘜㘠㘭rr;懙rĀhr㘦㘨ë∮Ā;oਫ਩war;椪lig耻ß䃟௡㙑㙝㙠ዎ㙳㙹\0㙾㛂\0\0\0\0\0㛛㜃\0㜉㝬\0\0\0㞇ɲ㙖\0\0㙛get;挖;䏄rë๟ƀaey㙦㙫㙰ron;䅥dil;䅣;䑂lrec;挕r;쀀𝔱Ȁeiko㚆㚝㚵㚼ǲ㚋\0㚑eĀ4fኄኁaƀ;sv㚘㚙㚛䎸ym;䏑Ācn㚢㚲kĀas㚨㚮pproø዁im»ኬsðኞĀas㚺㚮ð዁rn耻þ䃾Ǭ̟㛆⋧es膀×;bd㛏㛐㛘䃗Ā;aᤏ㛕r;樱;樰ƀeps㛡㛣㜀á⩍Ȁ;bcf҆㛬㛰㛴ot;挶ir;櫱Ā;o㛹㛼쀀𝕥rk;櫚á㍢rime;怴ƀaip㜏㜒㝤dåቈ΀adempst㜡㝍㝀㝑㝗㝜㝟ngleʀ;dlqr㜰㜱㜶㝀㝂斵own»ᶻeftĀ;e⠀㜾ñम;扜ightĀ;e㊪㝋ñၚot;旬inus;樺lus;樹b;槍ime;樻ezium;揢ƀcht㝲㝽㞁Āry㝷㝻;쀀𝓉;䑆cy;䑛rok;䅧Āio㞋㞎xô᝷headĀlr㞗㞠eftarro÷ࡏightarrow»ཝऀAHabcdfghlmoprstuw㟐㟓㟗㟤㟰㟼㠎㠜㠣㠴㡑㡝㡫㢩㣌㣒㣪㣶ròϭar;楣Ācr㟜㟢ute耻ú䃺òᅐrǣ㟪\0㟭y;䑞ve;䅭Āiy㟵㟺rc耻û䃻;䑃ƀabh㠃㠆㠋ròᎭlac;䅱aòᏃĀir㠓㠘sht;楾;쀀𝔲rave耻ù䃹š㠧㠱rĀlr㠬㠮»ॗ»ႃlk;斀Āct㠹㡍ɯ㠿\0\0㡊rnĀ;e㡅㡆挜r»㡆op;挏ri;旸Āal㡖㡚cr;䅫肻¨͉Āgp㡢㡦on;䅳f;쀀𝕦̀adhlsuᅋ㡸㡽፲㢑㢠ownáᎳarpoonĀlr㢈㢌efô㠭ighô㠯iƀ;hl㢙㢚㢜䏅»ᏺon»㢚parrows;懈ƀcit㢰㣄㣈ɯ㢶\0\0㣁rnĀ;e㢼㢽挝r»㢽op;挎ng;䅯ri;旹cr;쀀𝓊ƀdir㣙㣝㣢ot;拰lde;䅩iĀ;f㜰㣨»᠓Āam㣯㣲rò㢨l耻ü䃼angle;榧ހABDacdeflnoprsz㤜㤟㤩㤭㦵㦸㦽㧟㧤㧨㧳㧹㧽㨁㨠ròϷarĀ;v㤦㤧櫨;櫩asèϡĀnr㤲㤷grt;榜΀eknprst㓣㥆㥋㥒㥝㥤㦖appá␕othinçẖƀhir㓫⻈㥙opô⾵Ā;hᎷ㥢ïㆍĀiu㥩㥭gmá㎳Ābp㥲㦄setneqĀ;q㥽㦀쀀⊊︀;쀀⫋︀setneqĀ;q㦏㦒쀀⊋︀;쀀⫌︀Āhr㦛㦟etá㚜iangleĀlr㦪㦯eft»थight»ၑy;䐲ash»ံƀelr㧄㧒㧗ƀ;beⷪ㧋㧏ar;抻q;扚lip;拮Ābt㧜ᑨaòᑩr;쀀𝔳tré㦮suĀbp㧯㧱»ജ»൙pf;쀀𝕧roð໻tré㦴Ācu㨆㨋r;쀀𝓋Ābp㨐㨘nĀEe㦀㨖»㥾nĀEe㦒㨞»㦐igzag;榚΀cefoprs㨶㨻㩖㩛㩔㩡㩪irc;䅵Ādi㩀㩑Ābg㩅㩉ar;機eĀ;qᗺ㩏;扙erp;愘r;쀀𝔴pf;쀀𝕨Ā;eᑹ㩦atèᑹcr;쀀𝓌ૣណ㪇\0㪋\0㪐㪛\0\0㪝㪨㪫㪯\0\0㫃㫎\0㫘ៜ៟tré៑r;쀀𝔵ĀAa㪔㪗ròσrò৶;䎾ĀAa㪡㪤ròθrò৫að✓is;拻ƀdptឤ㪵㪾Āfl㪺ឩ;쀀𝕩imåឲĀAa㫇㫊ròώròਁĀcq㫒ីr;쀀𝓍Āpt៖㫜ré។Ѐacefiosu㫰㫽㬈㬌㬑㬕㬛㬡cĀuy㫶㫻te耻ý䃽;䑏Āiy㬂㬆rc;䅷;䑋n耻¥䂥r;쀀𝔶cy;䑗pf;쀀𝕪cr;쀀𝓎Ācm㬦㬩y;䑎l耻ÿ䃿Ԁacdefhiosw㭂㭈㭔㭘㭤㭩㭭㭴㭺㮀cute;䅺Āay㭍㭒ron;䅾;䐷ot;䅼Āet㭝㭡træᕟa;䎶r;쀀𝔷cy;䐶grarr;懝pf;쀀𝕫cr;쀀𝓏Ājn㮅㮇;怍j;怌'.split("").map((c) => c.charCodeAt(0))
);
const xmlDecodeTree = new Uint16Array(
  // prettier-ignore
  "Ȁaglq	\x1Bɭ\0\0p;䀦os;䀧t;䀾t;䀼uot;䀢".split("").map((c) => c.charCodeAt(0))
);
var _a;
const decodeMap = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
const fromCodePoint$1 = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
    let output = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  }
);
function replaceCodePoint(codePoint) {
  var _a2;
  if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
    return 65533;
  }
  return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint;
}
var CharCodes;
(function(CharCodes2) {
  CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
  CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
  CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
  CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
  CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
  CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
  CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
  CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
  CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
  CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
  CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
  CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
})(CharCodes || (CharCodes = {}));
const TO_LOWER_BIT = 32;
var BinTrieFlags;
(function(BinTrieFlags2) {
  BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
  BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
  BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
})(BinTrieFlags || (BinTrieFlags = {}));
function isNumber(code2) {
  return code2 >= CharCodes.ZERO && code2 <= CharCodes.NINE;
}
function isHexadecimalCharacter(code2) {
  return code2 >= CharCodes.UPPER_A && code2 <= CharCodes.UPPER_F || code2 >= CharCodes.LOWER_A && code2 <= CharCodes.LOWER_F;
}
function isAsciiAlphaNumeric(code2) {
  return code2 >= CharCodes.UPPER_A && code2 <= CharCodes.UPPER_Z || code2 >= CharCodes.LOWER_A && code2 <= CharCodes.LOWER_Z || isNumber(code2);
}
function isEntityInAttributeInvalidEnd(code2) {
  return code2 === CharCodes.EQUALS || isAsciiAlphaNumeric(code2);
}
var EntityDecoderState;
(function(EntityDecoderState2) {
  EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
  EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
  EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
  EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
  EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
})(EntityDecoderState || (EntityDecoderState = {}));
var DecodingMode;
(function(DecodingMode2) {
  DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
  DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
  DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
})(DecodingMode || (DecodingMode = {}));
class EntityDecoder {
  constructor(decodeTree, emitCodePoint, errors2) {
    this.decodeTree = decodeTree;
    this.emitCodePoint = emitCodePoint;
    this.errors = errors2;
    this.state = EntityDecoderState.EntityStart;
    this.consumed = 1;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.decodeMode = DecodingMode.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(decodeMode) {
    this.decodeMode = decodeMode;
    this.state = EntityDecoderState.EntityStart;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(str, offset) {
    switch (this.state) {
      case EntityDecoderState.EntityStart: {
        if (str.charCodeAt(offset) === CharCodes.NUM) {
          this.state = EntityDecoderState.NumericStart;
          this.consumed += 1;
          return this.stateNumericStart(str, offset + 1);
        }
        this.state = EntityDecoderState.NamedEntity;
        return this.stateNamedEntity(str, offset);
      }
      case EntityDecoderState.NumericStart: {
        return this.stateNumericStart(str, offset);
      }
      case EntityDecoderState.NumericDecimal: {
        return this.stateNumericDecimal(str, offset);
      }
      case EntityDecoderState.NumericHex: {
        return this.stateNumericHex(str, offset);
      }
      case EntityDecoderState.NamedEntity: {
        return this.stateNamedEntity(str, offset);
      }
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(str, offset) {
    if (offset >= str.length) {
      return -1;
    }
    if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
      this.state = EntityDecoderState.NumericHex;
      this.consumed += 1;
      return this.stateNumericHex(str, offset + 1);
    }
    this.state = EntityDecoderState.NumericDecimal;
    return this.stateNumericDecimal(str, offset);
  }
  addToNumericResult(str, start, end, base2) {
    if (start !== end) {
      const digitCount = end - start;
      this.result = this.result * Math.pow(base2, digitCount) + parseInt(str.substr(start, digitCount), base2);
      this.consumed += digitCount;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char2 = str.charCodeAt(offset);
      if (isNumber(char2) || isHexadecimalCharacter(char2)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 16);
        return this.emitNumericEntity(char2, 3);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 16);
    return -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char2 = str.charCodeAt(offset);
      if (isNumber(char2)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 10);
        return this.emitNumericEntity(char2, 2);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 10);
    return -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(lastCp, expectedLength) {
    var _a2;
    if (this.consumed <= expectedLength) {
      (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.absenceOfDigitsInNumericCharacterReference(this.consumed);
      return 0;
    }
    if (lastCp === CharCodes.SEMI) {
      this.consumed += 1;
    } else if (this.decodeMode === DecodingMode.Strict) {
      return 0;
    }
    this.emitCodePoint(replaceCodePoint(this.result), this.consumed);
    if (this.errors) {
      if (lastCp !== CharCodes.SEMI) {
        this.errors.missingSemicolonAfterCharacterReference();
      }
      this.errors.validateNumericCharacterReference(this.result);
    }
    return this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(str, offset) {
    const { decodeTree } = this;
    let current = decodeTree[this.treeIndex];
    let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
    for (; offset < str.length; offset++, this.excess++) {
      const char2 = str.charCodeAt(offset);
      this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char2);
      if (this.treeIndex < 0) {
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
        (valueLength === 0 || // And there should be no invalid characters.
        isEntityInAttributeInvalidEnd(char2)) ? 0 : this.emitNotTerminatedNamedEntity();
      }
      current = decodeTree[this.treeIndex];
      valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
      if (valueLength !== 0) {
        if (char2 === CharCodes.SEMI) {
          return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
        }
        if (this.decodeMode !== DecodingMode.Strict) {
          this.result = this.treeIndex;
          this.consumed += this.excess;
          this.excess = 0;
        }
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var _a2;
    const { result, decodeTree } = this;
    const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
    this.emitNamedEntityData(result, valueLength, this.consumed);
    (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.missingSemicolonAfterCharacterReference();
    return this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(result, valueLength, consumed) {
    const { decodeTree } = this;
    this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
    if (valueLength === 3) {
      this.emitCodePoint(decodeTree[result + 2], consumed);
    }
    return consumed;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var _a2;
    switch (this.state) {
      case EntityDecoderState.NamedEntity: {
        return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      }
      // Otherwise, emit a numeric entity if we have one.
      case EntityDecoderState.NumericDecimal: {
        return this.emitNumericEntity(0, 2);
      }
      case EntityDecoderState.NumericHex: {
        return this.emitNumericEntity(0, 3);
      }
      case EntityDecoderState.NumericStart: {
        (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.absenceOfDigitsInNumericCharacterReference(this.consumed);
        return 0;
      }
      case EntityDecoderState.EntityStart: {
        return 0;
      }
    }
  }
}
function getDecoder(decodeTree) {
  let ret = "";
  const decoder = new EntityDecoder(decodeTree, (str) => ret += fromCodePoint$1(str));
  return function decodeWithTrie(str, decodeMode) {
    let lastIndex = 0;
    let offset = 0;
    while ((offset = str.indexOf("&", offset)) >= 0) {
      ret += str.slice(lastIndex, offset);
      decoder.startEntity(decodeMode);
      const len = decoder.write(
        str,
        // Skip the "&"
        offset + 1
      );
      if (len < 0) {
        lastIndex = offset + decoder.end();
        break;
      }
      lastIndex = offset + len;
      offset = len === 0 ? lastIndex + 1 : lastIndex;
    }
    const result = ret + str.slice(lastIndex);
    ret = "";
    return result;
  };
}
function determineBranch(decodeTree, current, nodeIdx, char2) {
  const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
  const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
  if (branchCount === 0) {
    return jumpOffset !== 0 && char2 === jumpOffset ? nodeIdx : -1;
  }
  if (jumpOffset) {
    const value = char2 - jumpOffset;
    return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
  }
  let lo = nodeIdx;
  let hi = lo + branchCount - 1;
  while (lo <= hi) {
    const mid = lo + hi >>> 1;
    const midVal = decodeTree[mid];
    if (midVal < char2) {
      lo = mid + 1;
    } else if (midVal > char2) {
      hi = mid - 1;
    } else {
      return decodeTree[mid + branchCount];
    }
  }
  return -1;
}
const htmlDecoder = getDecoder(htmlDecodeTree);
getDecoder(xmlDecodeTree);
function decodeHTML(str, mode = DecodingMode.Legacy) {
  return htmlDecoder(str, mode);
}
function _class$1(obj) {
  return Object.prototype.toString.call(obj);
}
function isString$2(obj) {
  return _class$1(obj) === "[object String]";
}
const _hasOwnProperty = Object.prototype.hasOwnProperty;
function has(object, key) {
  return _hasOwnProperty.call(object, key);
}
function assign$2(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  sources.forEach(function(source) {
    if (!source) {
      return;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be object");
    }
    Object.keys(source).forEach(function(key) {
      obj[key] = source[key];
    });
  });
  return obj;
}
function arrayReplaceAt(src, pos, newElements) {
  return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
}
function isValidEntityCode(c) {
  if (c >= 55296 && c <= 57343) {
    return false;
  }
  if (c >= 64976 && c <= 65007) {
    return false;
  }
  if ((c & 65535) === 65535 || (c & 65535) === 65534) {
    return false;
  }
  if (c >= 0 && c <= 8) {
    return false;
  }
  if (c === 11) {
    return false;
  }
  if (c >= 14 && c <= 31) {
    return false;
  }
  if (c >= 127 && c <= 159) {
    return false;
  }
  if (c > 1114111) {
    return false;
  }
  return true;
}
function fromCodePoint(c) {
  if (c > 65535) {
    c -= 65536;
    const surrogate1 = 55296 + (c >> 10);
    const surrogate2 = 56320 + (c & 1023);
    return String.fromCharCode(surrogate1, surrogate2);
  }
  return String.fromCharCode(c);
}
const UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-./:;<=>?@[\\\]^_`{|}~])/g;
const ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
const UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + "|" + ENTITY_RE.source, "gi");
const DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i;
function replaceEntityPattern(match3, name) {
  if (name.charCodeAt(0) === 35 && DIGITAL_ENTITY_TEST_RE.test(name)) {
    const code2 = name[1].toLowerCase() === "x" ? parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);
    if (isValidEntityCode(code2)) {
      return fromCodePoint(code2);
    }
    return match3;
  }
  const decoded = decodeHTML(match3);
  if (decoded !== match3) {
    return decoded;
  }
  return match3;
}
function unescapeMd(str) {
  if (str.indexOf("\\") < 0) {
    return str;
  }
  return str.replace(UNESCAPE_MD_RE, "$1");
}
function unescapeAll(str) {
  if (str.indexOf("\\") < 0 && str.indexOf("&") < 0) {
    return str;
  }
  return str.replace(UNESCAPE_ALL_RE, function(match3, escaped, entity2) {
    if (escaped) {
      return escaped;
    }
    return replaceEntityPattern(match3, entity2);
  });
}
const HTML_ESCAPE_TEST_RE = /[&<>"]/;
const HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
const HTML_REPLACEMENTS = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;"
};
function replaceUnsafeChar(ch) {
  return HTML_REPLACEMENTS[ch];
}
function escapeHtml(str) {
  if (HTML_ESCAPE_TEST_RE.test(str)) {
    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
  }
  return str;
}
const REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;
function escapeRE$1(str) {
  return str.replace(REGEXP_ESCAPE_RE, "\\$&");
}
function isSpace(code2) {
  switch (code2) {
    case 9:
    case 32:
      return true;
  }
  return false;
}
function isWhiteSpace(code2) {
  if (code2 >= 8192 && code2 <= 8202) {
    return true;
  }
  switch (code2) {
    case 9:
    // \t
    case 10:
    // \n
    case 11:
    // \v
    case 12:
    // \f
    case 13:
    // \r
    case 32:
    case 160:
    case 5760:
    case 8239:
    case 8287:
    case 12288:
      return true;
  }
  return false;
}
function isPunctChar(ch) {
  return P$1.test(ch) || regex.test(ch);
}
function isMdAsciiPunct(ch) {
  switch (ch) {
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 124:
    case 125:
    case 126:
      return true;
    default:
      return false;
  }
}
function normalizeReference(str) {
  str = str.trim().replace(/\s+/g, " ");
  if ("ẞ".toLowerCase() === "Ṿ") {
    str = str.replace(/ẞ/g, "ß");
  }
  return str.toLowerCase().toUpperCase();
}
const lib = { mdurl, ucmicro };
const utils$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  arrayReplaceAt,
  assign: assign$2,
  escapeHtml,
  escapeRE: escapeRE$1,
  fromCodePoint,
  has,
  isMdAsciiPunct,
  isPunctChar,
  isSpace,
  isString: isString$2,
  isValidEntityCode,
  isWhiteSpace,
  lib,
  normalizeReference,
  unescapeAll,
  unescapeMd
}, Symbol.toStringTag, { value: "Module" }));
function parseLinkLabel(state2, start, disableNested) {
  let level, found, marker, prevPos;
  const max = state2.posMax;
  const oldPos = state2.pos;
  state2.pos = start + 1;
  level = 1;
  while (state2.pos < max) {
    marker = state2.src.charCodeAt(state2.pos);
    if (marker === 93) {
      level--;
      if (level === 0) {
        found = true;
        break;
      }
    }
    prevPos = state2.pos;
    state2.md.inline.skipToken(state2);
    if (marker === 91) {
      if (prevPos === state2.pos - 1) {
        level++;
      } else if (disableNested) {
        state2.pos = oldPos;
        return -1;
      }
    }
  }
  let labelEnd = -1;
  if (found) {
    labelEnd = state2.pos;
  }
  state2.pos = oldPos;
  return labelEnd;
}
function parseLinkDestination(str, start, max) {
  let code2;
  let pos = start;
  const result = {
    ok: false,
    pos: 0,
    str: ""
  };
  if (str.charCodeAt(pos) === 60) {
    pos++;
    while (pos < max) {
      code2 = str.charCodeAt(pos);
      if (code2 === 10) {
        return result;
      }
      if (code2 === 60) {
        return result;
      }
      if (code2 === 62) {
        result.pos = pos + 1;
        result.str = unescapeAll(str.slice(start + 1, pos));
        result.ok = true;
        return result;
      }
      if (code2 === 92 && pos + 1 < max) {
        pos += 2;
        continue;
      }
      pos++;
    }
    return result;
  }
  let level = 0;
  while (pos < max) {
    code2 = str.charCodeAt(pos);
    if (code2 === 32) {
      break;
    }
    if (code2 < 32 || code2 === 127) {
      break;
    }
    if (code2 === 92 && pos + 1 < max) {
      if (str.charCodeAt(pos + 1) === 32) {
        break;
      }
      pos += 2;
      continue;
    }
    if (code2 === 40) {
      level++;
      if (level > 32) {
        return result;
      }
    }
    if (code2 === 41) {
      if (level === 0) {
        break;
      }
      level--;
    }
    pos++;
  }
  if (start === pos) {
    return result;
  }
  if (level !== 0) {
    return result;
  }
  result.str = unescapeAll(str.slice(start, pos));
  result.pos = pos;
  result.ok = true;
  return result;
}
function parseLinkTitle(str, start, max, prev_state) {
  let code2;
  let pos = start;
  const state2 = {
    // if `true`, this is a valid link title
    ok: false,
    // if `true`, this link can be continued on the next line
    can_continue: false,
    // if `ok`, it's the position of the first character after the closing marker
    pos: 0,
    // if `ok`, it's the unescaped title
    str: "",
    // expected closing marker character code
    marker: 0
  };
  if (prev_state) {
    state2.str = prev_state.str;
    state2.marker = prev_state.marker;
  } else {
    if (pos >= max) {
      return state2;
    }
    let marker = str.charCodeAt(pos);
    if (marker !== 34 && marker !== 39 && marker !== 40) {
      return state2;
    }
    start++;
    pos++;
    if (marker === 40) {
      marker = 41;
    }
    state2.marker = marker;
  }
  while (pos < max) {
    code2 = str.charCodeAt(pos);
    if (code2 === state2.marker) {
      state2.pos = pos + 1;
      state2.str += unescapeAll(str.slice(start, pos));
      state2.ok = true;
      return state2;
    } else if (code2 === 40 && state2.marker === 41) {
      return state2;
    } else if (code2 === 92 && pos + 1 < max) {
      pos++;
    }
    pos++;
  }
  state2.can_continue = true;
  state2.str += unescapeAll(str.slice(start, pos));
  return state2;
}
const helpers = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  parseLinkDestination,
  parseLinkLabel,
  parseLinkTitle
}, Symbol.toStringTag, { value: "Module" }));
const default_rules = {};
default_rules.code_inline = function(tokens, idx, options, env, slf) {
  const token2 = tokens[idx];
  return "<code" + slf.renderAttrs(token2) + ">" + escapeHtml(token2.content) + "</code>";
};
default_rules.code_block = function(tokens, idx, options, env, slf) {
  const token2 = tokens[idx];
  return "<pre" + slf.renderAttrs(token2) + "><code>" + escapeHtml(tokens[idx].content) + "</code></pre>\n";
};
default_rules.fence = function(tokens, idx, options, env, slf) {
  const token2 = tokens[idx];
  const info = token2.info ? unescapeAll(token2.info).trim() : "";
  let langName = "";
  let langAttrs = "";
  if (info) {
    const arr = info.split(/(\s+)/g);
    langName = arr[0];
    langAttrs = arr.slice(2).join("");
  }
  let highlighted;
  if (options.highlight) {
    highlighted = options.highlight(token2.content, langName, langAttrs) || escapeHtml(token2.content);
  } else {
    highlighted = escapeHtml(token2.content);
  }
  if (highlighted.indexOf("<pre") === 0) {
    return highlighted + "\n";
  }
  if (info) {
    const i = token2.attrIndex("class");
    const tmpAttrs = token2.attrs ? token2.attrs.slice() : [];
    if (i < 0) {
      tmpAttrs.push(["class", options.langPrefix + langName]);
    } else {
      tmpAttrs[i] = tmpAttrs[i].slice();
      tmpAttrs[i][1] += " " + options.langPrefix + langName;
    }
    const tmpToken = {
      attrs: tmpAttrs
    };
    return `<pre><code${slf.renderAttrs(tmpToken)}>${highlighted}</code></pre>
`;
  }
  return `<pre><code${slf.renderAttrs(token2)}>${highlighted}</code></pre>
`;
};
default_rules.image = function(tokens, idx, options, env, slf) {
  const token2 = tokens[idx];
  token2.attrs[token2.attrIndex("alt")][1] = slf.renderInlineAsText(token2.children, options, env);
  return slf.renderToken(tokens, idx, options);
};
default_rules.hardbreak = function(tokens, idx, options) {
  return options.xhtmlOut ? "<br />\n" : "<br>\n";
};
default_rules.softbreak = function(tokens, idx, options) {
  return options.breaks ? options.xhtmlOut ? "<br />\n" : "<br>\n" : "\n";
};
default_rules.text = function(tokens, idx) {
  return escapeHtml(tokens[idx].content);
};
default_rules.html_block = function(tokens, idx) {
  return tokens[idx].content;
};
default_rules.html_inline = function(tokens, idx) {
  return tokens[idx].content;
};
function Renderer() {
  this.rules = assign$2({}, default_rules);
}
Renderer.prototype.renderAttrs = function renderAttrs(token2) {
  let i, l, result;
  if (!token2.attrs) {
    return "";
  }
  result = "";
  for (i = 0, l = token2.attrs.length; i < l; i++) {
    result += " " + escapeHtml(token2.attrs[i][0]) + '="' + escapeHtml(token2.attrs[i][1]) + '"';
  }
  return result;
};
Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {
  const token2 = tokens[idx];
  let result = "";
  if (token2.hidden) {
    return "";
  }
  if (token2.block && token2.nesting !== -1 && idx && tokens[idx - 1].hidden) {
    result += "\n";
  }
  result += (token2.nesting === -1 ? "</" : "<") + token2.tag;
  result += this.renderAttrs(token2);
  if (token2.nesting === 0 && options.xhtmlOut) {
    result += " /";
  }
  let needLf = false;
  if (token2.block) {
    needLf = true;
    if (token2.nesting === 1) {
      if (idx + 1 < tokens.length) {
        const nextToken = tokens[idx + 1];
        if (nextToken.type === "inline" || nextToken.hidden) {
          needLf = false;
        } else if (nextToken.nesting === -1 && nextToken.tag === token2.tag) {
          needLf = false;
        }
      }
    }
  }
  result += needLf ? ">\n" : ">";
  return result;
};
Renderer.prototype.renderInline = function(tokens, options, env) {
  let result = "";
  const rules = this.rules;
  for (let i = 0, len = tokens.length; i < len; i++) {
    const type = tokens[i].type;
    if (typeof rules[type] !== "undefined") {
      result += rules[type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options);
    }
  }
  return result;
};
Renderer.prototype.renderInlineAsText = function(tokens, options, env) {
  let result = "";
  for (let i = 0, len = tokens.length; i < len; i++) {
    switch (tokens[i].type) {
      case "text":
        result += tokens[i].content;
        break;
      case "image":
        result += this.renderInlineAsText(tokens[i].children, options, env);
        break;
      case "html_inline":
      case "html_block":
        result += tokens[i].content;
        break;
      case "softbreak":
      case "hardbreak":
        result += "\n";
        break;
    }
  }
  return result;
};
Renderer.prototype.render = function(tokens, options, env) {
  let result = "";
  const rules = this.rules;
  for (let i = 0, len = tokens.length; i < len; i++) {
    const type = tokens[i].type;
    if (type === "inline") {
      result += this.renderInline(tokens[i].children, options, env);
    } else if (typeof rules[type] !== "undefined") {
      result += rules[type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options, env);
    }
  }
  return result;
};
function Ruler() {
  this.__rules__ = [];
  this.__cache__ = null;
}
Ruler.prototype.__find__ = function(name) {
  for (let i = 0; i < this.__rules__.length; i++) {
    if (this.__rules__[i].name === name) {
      return i;
    }
  }
  return -1;
};
Ruler.prototype.__compile__ = function() {
  const self2 = this;
  const chains = [""];
  self2.__rules__.forEach(function(rule) {
    if (!rule.enabled) {
      return;
    }
    rule.alt.forEach(function(altName) {
      if (chains.indexOf(altName) < 0) {
        chains.push(altName);
      }
    });
  });
  self2.__cache__ = {};
  chains.forEach(function(chain) {
    self2.__cache__[chain] = [];
    self2.__rules__.forEach(function(rule) {
      if (!rule.enabled) {
        return;
      }
      if (chain && rule.alt.indexOf(chain) < 0) {
        return;
      }
      self2.__cache__[chain].push(rule.fn);
    });
  });
};
Ruler.prototype.at = function(name, fn, options) {
  const index = this.__find__(name);
  const opt = options || {};
  if (index === -1) {
    throw new Error("Parser rule not found: " + name);
  }
  this.__rules__[index].fn = fn;
  this.__rules__[index].alt = opt.alt || [];
  this.__cache__ = null;
};
Ruler.prototype.before = function(beforeName, ruleName, fn, options) {
  const index = this.__find__(beforeName);
  const opt = options || {};
  if (index === -1) {
    throw new Error("Parser rule not found: " + beforeName);
  }
  this.__rules__.splice(index, 0, {
    name: ruleName,
    enabled: true,
    fn,
    alt: opt.alt || []
  });
  this.__cache__ = null;
};
Ruler.prototype.after = function(afterName, ruleName, fn, options) {
  const index = this.__find__(afterName);
  const opt = options || {};
  if (index === -1) {
    throw new Error("Parser rule not found: " + afterName);
  }
  this.__rules__.splice(index + 1, 0, {
    name: ruleName,
    enabled: true,
    fn,
    alt: opt.alt || []
  });
  this.__cache__ = null;
};
Ruler.prototype.push = function(ruleName, fn, options) {
  const opt = options || {};
  this.__rules__.push({
    name: ruleName,
    enabled: true,
    fn,
    alt: opt.alt || []
  });
  this.__cache__ = null;
};
Ruler.prototype.enable = function(list2, ignoreInvalid) {
  if (!Array.isArray(list2)) {
    list2 = [list2];
  }
  const result = [];
  list2.forEach(function(name) {
    const idx = this.__find__(name);
    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error("Rules manager: invalid rule name " + name);
    }
    this.__rules__[idx].enabled = true;
    result.push(name);
  }, this);
  this.__cache__ = null;
  return result;
};
Ruler.prototype.enableOnly = function(list2, ignoreInvalid) {
  if (!Array.isArray(list2)) {
    list2 = [list2];
  }
  this.__rules__.forEach(function(rule) {
    rule.enabled = false;
  });
  this.enable(list2, ignoreInvalid);
};
Ruler.prototype.disable = function(list2, ignoreInvalid) {
  if (!Array.isArray(list2)) {
    list2 = [list2];
  }
  const result = [];
  list2.forEach(function(name) {
    const idx = this.__find__(name);
    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error("Rules manager: invalid rule name " + name);
    }
    this.__rules__[idx].enabled = false;
    result.push(name);
  }, this);
  this.__cache__ = null;
  return result;
};
Ruler.prototype.getRules = function(chainName) {
  if (this.__cache__ === null) {
    this.__compile__();
  }
  return this.__cache__[chainName] || [];
};
function Token(type, tag, nesting) {
  this.type = type;
  this.tag = tag;
  this.attrs = null;
  this.map = null;
  this.nesting = nesting;
  this.level = 0;
  this.children = null;
  this.content = "";
  this.markup = "";
  this.info = "";
  this.meta = null;
  this.block = false;
  this.hidden = false;
}
Token.prototype.attrIndex = function attrIndex(name) {
  if (!this.attrs) {
    return -1;
  }
  const attrs = this.attrs;
  for (let i = 0, len = attrs.length; i < len; i++) {
    if (attrs[i][0] === name) {
      return i;
    }
  }
  return -1;
};
Token.prototype.attrPush = function attrPush(attrData) {
  if (this.attrs) {
    this.attrs.push(attrData);
  } else {
    this.attrs = [attrData];
  }
};
Token.prototype.attrSet = function attrSet(name, value) {
  const idx = this.attrIndex(name);
  const attrData = [name, value];
  if (idx < 0) {
    this.attrPush(attrData);
  } else {
    this.attrs[idx] = attrData;
  }
};
Token.prototype.attrGet = function attrGet(name) {
  const idx = this.attrIndex(name);
  let value = null;
  if (idx >= 0) {
    value = this.attrs[idx][1];
  }
  return value;
};
Token.prototype.attrJoin = function attrJoin(name, value) {
  const idx = this.attrIndex(name);
  if (idx < 0) {
    this.attrPush([name, value]);
  } else {
    this.attrs[idx][1] = this.attrs[idx][1] + " " + value;
  }
};
function StateCore(src, md, env) {
  this.src = src;
  this.env = env;
  this.tokens = [];
  this.inlineMode = false;
  this.md = md;
}
StateCore.prototype.Token = Token;
const NEWLINES_RE = /\r\n?|\n/g;
const NULL_RE = /\0/g;
function normalize(state2) {
  let str;
  str = state2.src.replace(NEWLINES_RE, "\n");
  str = str.replace(NULL_RE, "�");
  state2.src = str;
}
function block(state2) {
  let token2;
  if (state2.inlineMode) {
    token2 = new state2.Token("inline", "", 0);
    token2.content = state2.src;
    token2.map = [0, 1];
    token2.children = [];
    state2.tokens.push(token2);
  } else {
    state2.md.block.parse(state2.src, state2.md, state2.env, state2.tokens);
  }
}
function inline(state2) {
  const tokens = state2.tokens;
  for (let i = 0, l = tokens.length; i < l; i++) {
    const tok = tokens[i];
    if (tok.type === "inline") {
      state2.md.inline.parse(tok.content, state2.md, state2.env, tok.children);
    }
  }
}
function isLinkOpen$1(str) {
  return /^<a[>\s]/i.test(str);
}
function isLinkClose$1(str) {
  return /^<\/a\s*>/i.test(str);
}
function linkify$1(state2) {
  const blockTokens = state2.tokens;
  if (!state2.md.options.linkify) {
    return;
  }
  for (let j2 = 0, l = blockTokens.length; j2 < l; j2++) {
    if (blockTokens[j2].type !== "inline" || !state2.md.linkify.pretest(blockTokens[j2].content)) {
      continue;
    }
    let tokens = blockTokens[j2].children;
    let htmlLinkLevel = 0;
    for (let i = tokens.length - 1; i >= 0; i--) {
      const currentToken = tokens[i];
      if (currentToken.type === "link_close") {
        i--;
        while (tokens[i].level !== currentToken.level && tokens[i].type !== "link_open") {
          i--;
        }
        continue;
      }
      if (currentToken.type === "html_inline") {
        if (isLinkOpen$1(currentToken.content) && htmlLinkLevel > 0) {
          htmlLinkLevel--;
        }
        if (isLinkClose$1(currentToken.content)) {
          htmlLinkLevel++;
        }
      }
      if (htmlLinkLevel > 0) {
        continue;
      }
      if (currentToken.type === "text" && state2.md.linkify.test(currentToken.content)) {
        const text2 = currentToken.content;
        let links = state2.md.linkify.match(text2);
        const nodes = [];
        let level = currentToken.level;
        let lastPos = 0;
        if (links.length > 0 && links[0].index === 0 && i > 0 && tokens[i - 1].type === "text_special") {
          links = links.slice(1);
        }
        for (let ln = 0; ln < links.length; ln++) {
          const url = links[ln].url;
          const fullUrl = state2.md.normalizeLink(url);
          if (!state2.md.validateLink(fullUrl)) {
            continue;
          }
          let urlText = links[ln].text;
          if (!links[ln].schema) {
            urlText = state2.md.normalizeLinkText("http://" + urlText).replace(/^http:\/\//, "");
          } else if (links[ln].schema === "mailto:" && !/^mailto:/i.test(urlText)) {
            urlText = state2.md.normalizeLinkText("mailto:" + urlText).replace(/^mailto:/, "");
          } else {
            urlText = state2.md.normalizeLinkText(urlText);
          }
          const pos = links[ln].index;
          if (pos > lastPos) {
            const token2 = new state2.Token("text", "", 0);
            token2.content = text2.slice(lastPos, pos);
            token2.level = level;
            nodes.push(token2);
          }
          const token_o = new state2.Token("link_open", "a", 1);
          token_o.attrs = [["href", fullUrl]];
          token_o.level = level++;
          token_o.markup = "linkify";
          token_o.info = "auto";
          nodes.push(token_o);
          const token_t = new state2.Token("text", "", 0);
          token_t.content = urlText;
          token_t.level = level;
          nodes.push(token_t);
          const token_c = new state2.Token("link_close", "a", -1);
          token_c.level = --level;
          token_c.markup = "linkify";
          token_c.info = "auto";
          nodes.push(token_c);
          lastPos = links[ln].lastIndex;
        }
        if (lastPos < text2.length) {
          const token2 = new state2.Token("text", "", 0);
          token2.content = text2.slice(lastPos);
          token2.level = level;
          nodes.push(token2);
        }
        blockTokens[j2].children = tokens = arrayReplaceAt(tokens, i, nodes);
      }
    }
  }
}
const RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
const SCOPED_ABBR_TEST_RE = /\((c|tm|r)\)/i;
const SCOPED_ABBR_RE = /\((c|tm|r)\)/ig;
const SCOPED_ABBR = {
  c: "©",
  r: "®",
  tm: "™"
};
function replaceFn(match3, name) {
  return SCOPED_ABBR[name.toLowerCase()];
}
function replace_scoped(inlineTokens) {
  let inside_autolink = 0;
  for (let i = inlineTokens.length - 1; i >= 0; i--) {
    const token2 = inlineTokens[i];
    if (token2.type === "text" && !inside_autolink) {
      token2.content = token2.content.replace(SCOPED_ABBR_RE, replaceFn);
    }
    if (token2.type === "link_open" && token2.info === "auto") {
      inside_autolink--;
    }
    if (token2.type === "link_close" && token2.info === "auto") {
      inside_autolink++;
    }
  }
}
function replace_rare(inlineTokens) {
  let inside_autolink = 0;
  for (let i = inlineTokens.length - 1; i >= 0; i--) {
    const token2 = inlineTokens[i];
    if (token2.type === "text" && !inside_autolink) {
      if (RARE_RE.test(token2.content)) {
        token2.content = token2.content.replace(/\+-/g, "±").replace(/\.{2,}/g, "…").replace(/([?!])…/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1—").replace(/(^|\s)--(?=\s|$)/mg, "$1–").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1–");
      }
    }
    if (token2.type === "link_open" && token2.info === "auto") {
      inside_autolink--;
    }
    if (token2.type === "link_close" && token2.info === "auto") {
      inside_autolink++;
    }
  }
}
function replace$1(state2) {
  let blkIdx;
  if (!state2.md.options.typographer) {
    return;
  }
  for (blkIdx = state2.tokens.length - 1; blkIdx >= 0; blkIdx--) {
    if (state2.tokens[blkIdx].type !== "inline") {
      continue;
    }
    if (SCOPED_ABBR_TEST_RE.test(state2.tokens[blkIdx].content)) {
      replace_scoped(state2.tokens[blkIdx].children);
    }
    if (RARE_RE.test(state2.tokens[blkIdx].content)) {
      replace_rare(state2.tokens[blkIdx].children);
    }
  }
}
const QUOTE_TEST_RE = /['"]/;
const QUOTE_RE = /['"]/g;
const APOSTROPHE = "’";
function replaceAt(str, index, ch) {
  return str.slice(0, index) + ch + str.slice(index + 1);
}
function process_inlines(tokens, state2) {
  let j2;
  const stack = [];
  for (let i = 0; i < tokens.length; i++) {
    const token2 = tokens[i];
    const thisLevel = tokens[i].level;
    for (j2 = stack.length - 1; j2 >= 0; j2--) {
      if (stack[j2].level <= thisLevel) {
        break;
      }
    }
    stack.length = j2 + 1;
    if (token2.type !== "text") {
      continue;
    }
    let text2 = token2.content;
    let pos = 0;
    let max = text2.length;
    OUTER:
      while (pos < max) {
        QUOTE_RE.lastIndex = pos;
        const t = QUOTE_RE.exec(text2);
        if (!t) {
          break;
        }
        let canOpen = true;
        let canClose = true;
        pos = t.index + 1;
        const isSingle = t[0] === "'";
        let lastChar = 32;
        if (t.index - 1 >= 0) {
          lastChar = text2.charCodeAt(t.index - 1);
        } else {
          for (j2 = i - 1; j2 >= 0; j2--) {
            if (tokens[j2].type === "softbreak" || tokens[j2].type === "hardbreak") break;
            if (!tokens[j2].content) continue;
            lastChar = tokens[j2].content.charCodeAt(tokens[j2].content.length - 1);
            break;
          }
        }
        let nextChar = 32;
        if (pos < max) {
          nextChar = text2.charCodeAt(pos);
        } else {
          for (j2 = i + 1; j2 < tokens.length; j2++) {
            if (tokens[j2].type === "softbreak" || tokens[j2].type === "hardbreak") break;
            if (!tokens[j2].content) continue;
            nextChar = tokens[j2].content.charCodeAt(0);
            break;
          }
        }
        const isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
        const isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
        const isLastWhiteSpace = isWhiteSpace(lastChar);
        const isNextWhiteSpace = isWhiteSpace(nextChar);
        if (isNextWhiteSpace) {
          canOpen = false;
        } else if (isNextPunctChar) {
          if (!(isLastWhiteSpace || isLastPunctChar)) {
            canOpen = false;
          }
        }
        if (isLastWhiteSpace) {
          canClose = false;
        } else if (isLastPunctChar) {
          if (!(isNextWhiteSpace || isNextPunctChar)) {
            canClose = false;
          }
        }
        if (nextChar === 34 && t[0] === '"') {
          if (lastChar >= 48 && lastChar <= 57) {
            canClose = canOpen = false;
          }
        }
        if (canOpen && canClose) {
          canOpen = isLastPunctChar;
          canClose = isNextPunctChar;
        }
        if (!canOpen && !canClose) {
          if (isSingle) {
            token2.content = replaceAt(token2.content, t.index, APOSTROPHE);
          }
          continue;
        }
        if (canClose) {
          for (j2 = stack.length - 1; j2 >= 0; j2--) {
            let item = stack[j2];
            if (stack[j2].level < thisLevel) {
              break;
            }
            if (item.single === isSingle && stack[j2].level === thisLevel) {
              item = stack[j2];
              let openQuote;
              let closeQuote;
              if (isSingle) {
                openQuote = state2.md.options.quotes[2];
                closeQuote = state2.md.options.quotes[3];
              } else {
                openQuote = state2.md.options.quotes[0];
                closeQuote = state2.md.options.quotes[1];
              }
              token2.content = replaceAt(token2.content, t.index, closeQuote);
              tokens[item.token].content = replaceAt(
                tokens[item.token].content,
                item.pos,
                openQuote
              );
              pos += closeQuote.length - 1;
              if (item.token === i) {
                pos += openQuote.length - 1;
              }
              text2 = token2.content;
              max = text2.length;
              stack.length = j2;
              continue OUTER;
            }
          }
        }
        if (canOpen) {
          stack.push({
            token: i,
            pos: t.index,
            single: isSingle,
            level: thisLevel
          });
        } else if (canClose && isSingle) {
          token2.content = replaceAt(token2.content, t.index, APOSTROPHE);
        }
      }
  }
}
function smartquotes(state2) {
  if (!state2.md.options.typographer) {
    return;
  }
  for (let blkIdx = state2.tokens.length - 1; blkIdx >= 0; blkIdx--) {
    if (state2.tokens[blkIdx].type !== "inline" || !QUOTE_TEST_RE.test(state2.tokens[blkIdx].content)) {
      continue;
    }
    process_inlines(state2.tokens[blkIdx].children, state2);
  }
}
function text_join(state2) {
  let curr, last;
  const blockTokens = state2.tokens;
  const l = blockTokens.length;
  for (let j2 = 0; j2 < l; j2++) {
    if (blockTokens[j2].type !== "inline") continue;
    const tokens = blockTokens[j2].children;
    const max = tokens.length;
    for (curr = 0; curr < max; curr++) {
      if (tokens[curr].type === "text_special") {
        tokens[curr].type = "text";
      }
    }
    for (curr = last = 0; curr < max; curr++) {
      if (tokens[curr].type === "text" && curr + 1 < max && tokens[curr + 1].type === "text") {
        tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
      } else {
        if (curr !== last) {
          tokens[last] = tokens[curr];
        }
        last++;
      }
    }
    if (curr !== last) {
      tokens.length = last;
    }
  }
}
const _rules$2 = [
  ["normalize", normalize],
  ["block", block],
  ["inline", inline],
  ["linkify", linkify$1],
  ["replacements", replace$1],
  ["smartquotes", smartquotes],
  // `text_join` finds `text_special` tokens (for escape sequences)
  // and joins them with the rest of the text
  ["text_join", text_join]
];
function Core() {
  this.ruler = new Ruler();
  for (let i = 0; i < _rules$2.length; i++) {
    this.ruler.push(_rules$2[i][0], _rules$2[i][1]);
  }
}
Core.prototype.process = function(state2) {
  const rules = this.ruler.getRules("");
  for (let i = 0, l = rules.length; i < l; i++) {
    rules[i](state2);
  }
};
Core.prototype.State = StateCore;
function StateBlock(src, md, env, tokens) {
  this.src = src;
  this.md = md;
  this.env = env;
  this.tokens = tokens;
  this.bMarks = [];
  this.eMarks = [];
  this.tShift = [];
  this.sCount = [];
  this.bsCount = [];
  this.blkIndent = 0;
  this.line = 0;
  this.lineMax = 0;
  this.tight = false;
  this.ddIndent = -1;
  this.listIndent = -1;
  this.parentType = "root";
  this.level = 0;
  const s = this.src;
  for (let start = 0, pos = 0, indent = 0, offset = 0, len = s.length, indent_found = false; pos < len; pos++) {
    const ch = s.charCodeAt(pos);
    if (!indent_found) {
      if (isSpace(ch)) {
        indent++;
        if (ch === 9) {
          offset += 4 - offset % 4;
        } else {
          offset++;
        }
        continue;
      } else {
        indent_found = true;
      }
    }
    if (ch === 10 || pos === len - 1) {
      if (ch !== 10) {
        pos++;
      }
      this.bMarks.push(start);
      this.eMarks.push(pos);
      this.tShift.push(indent);
      this.sCount.push(offset);
      this.bsCount.push(0);
      indent_found = false;
      indent = 0;
      offset = 0;
      start = pos + 1;
    }
  }
  this.bMarks.push(s.length);
  this.eMarks.push(s.length);
  this.tShift.push(0);
  this.sCount.push(0);
  this.bsCount.push(0);
  this.lineMax = this.bMarks.length - 1;
}
StateBlock.prototype.push = function(type, tag, nesting) {
  const token2 = new Token(type, tag, nesting);
  token2.block = true;
  if (nesting < 0) this.level--;
  token2.level = this.level;
  if (nesting > 0) this.level++;
  this.tokens.push(token2);
  return token2;
};
StateBlock.prototype.isEmpty = function isEmpty(line2) {
  return this.bMarks[line2] + this.tShift[line2] >= this.eMarks[line2];
};
StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from2) {
  for (let max = this.lineMax; from2 < max; from2++) {
    if (this.bMarks[from2] + this.tShift[from2] < this.eMarks[from2]) {
      break;
    }
  }
  return from2;
};
StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
  for (let max = this.src.length; pos < max; pos++) {
    const ch = this.src.charCodeAt(pos);
    if (!isSpace(ch)) {
      break;
    }
  }
  return pos;
};
StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
  if (pos <= min) {
    return pos;
  }
  while (pos > min) {
    if (!isSpace(this.src.charCodeAt(--pos))) {
      return pos + 1;
    }
  }
  return pos;
};
StateBlock.prototype.skipChars = function skipChars(pos, code2) {
  for (let max = this.src.length; pos < max; pos++) {
    if (this.src.charCodeAt(pos) !== code2) {
      break;
    }
  }
  return pos;
};
StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code2, min) {
  if (pos <= min) {
    return pos;
  }
  while (pos > min) {
    if (code2 !== this.src.charCodeAt(--pos)) {
      return pos + 1;
    }
  }
  return pos;
};
StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
  if (begin >= end) {
    return "";
  }
  const queue = new Array(end - begin);
  for (let i = 0, line2 = begin; line2 < end; line2++, i++) {
    let lineIndent = 0;
    const lineStart = this.bMarks[line2];
    let first = lineStart;
    let last;
    if (line2 + 1 < end || keepLastLF) {
      last = this.eMarks[line2] + 1;
    } else {
      last = this.eMarks[line2];
    }
    while (first < last && lineIndent < indent) {
      const ch = this.src.charCodeAt(first);
      if (isSpace(ch)) {
        if (ch === 9) {
          lineIndent += 4 - (lineIndent + this.bsCount[line2]) % 4;
        } else {
          lineIndent++;
        }
      } else if (first - lineStart < this.tShift[line2]) {
        lineIndent++;
      } else {
        break;
      }
      first++;
    }
    if (lineIndent > indent) {
      queue[i] = new Array(lineIndent - indent + 1).join(" ") + this.src.slice(first, last);
    } else {
      queue[i] = this.src.slice(first, last);
    }
  }
  return queue.join("");
};
StateBlock.prototype.Token = Token;
const MAX_AUTOCOMPLETED_CELLS = 65536;
function getLine(state2, line2) {
  const pos = state2.bMarks[line2] + state2.tShift[line2];
  const max = state2.eMarks[line2];
  return state2.src.slice(pos, max);
}
function escapedSplit(str) {
  const result = [];
  const max = str.length;
  let pos = 0;
  let ch = str.charCodeAt(pos);
  let isEscaped = false;
  let lastPos = 0;
  let current = "";
  while (pos < max) {
    if (ch === 124) {
      if (!isEscaped) {
        result.push(current + str.substring(lastPos, pos));
        current = "";
        lastPos = pos + 1;
      } else {
        current += str.substring(lastPos, pos - 1);
        lastPos = pos;
      }
    }
    isEscaped = ch === 92;
    pos++;
    ch = str.charCodeAt(pos);
  }
  result.push(current + str.substring(lastPos));
  return result;
}
function table(state2, startLine, endLine, silent2) {
  if (startLine + 2 > endLine) {
    return false;
  }
  let nextLine = startLine + 1;
  if (state2.sCount[nextLine] < state2.blkIndent) {
    return false;
  }
  if (state2.sCount[nextLine] - state2.blkIndent >= 4) {
    return false;
  }
  let pos = state2.bMarks[nextLine] + state2.tShift[nextLine];
  if (pos >= state2.eMarks[nextLine]) {
    return false;
  }
  const firstCh = state2.src.charCodeAt(pos++);
  if (firstCh !== 124 && firstCh !== 45 && firstCh !== 58) {
    return false;
  }
  if (pos >= state2.eMarks[nextLine]) {
    return false;
  }
  const secondCh = state2.src.charCodeAt(pos++);
  if (secondCh !== 124 && secondCh !== 45 && secondCh !== 58 && !isSpace(secondCh)) {
    return false;
  }
  if (firstCh === 45 && isSpace(secondCh)) {
    return false;
  }
  while (pos < state2.eMarks[nextLine]) {
    const ch = state2.src.charCodeAt(pos);
    if (ch !== 124 && ch !== 45 && ch !== 58 && !isSpace(ch)) {
      return false;
    }
    pos++;
  }
  let lineText = getLine(state2, startLine + 1);
  let columns = lineText.split("|");
  const aligns = [];
  for (let i = 0; i < columns.length; i++) {
    const t = columns[i].trim();
    if (!t) {
      if (i === 0 || i === columns.length - 1) {
        continue;
      } else {
        return false;
      }
    }
    if (!/^:?-+:?$/.test(t)) {
      return false;
    }
    if (t.charCodeAt(t.length - 1) === 58) {
      aligns.push(t.charCodeAt(0) === 58 ? "center" : "right");
    } else if (t.charCodeAt(0) === 58) {
      aligns.push("left");
    } else {
      aligns.push("");
    }
  }
  lineText = getLine(state2, startLine).trim();
  if (lineText.indexOf("|") === -1) {
    return false;
  }
  if (state2.sCount[startLine] - state2.blkIndent >= 4) {
    return false;
  }
  columns = escapedSplit(lineText);
  if (columns.length && columns[0] === "") columns.shift();
  if (columns.length && columns[columns.length - 1] === "") columns.pop();
  const columnCount = columns.length;
  if (columnCount === 0 || columnCount !== aligns.length) {
    return false;
  }
  if (silent2) {
    return true;
  }
  const oldParentType = state2.parentType;
  state2.parentType = "table";
  const terminatorRules = state2.md.block.ruler.getRules("blockquote");
  const token_to = state2.push("table_open", "table", 1);
  const tableLines = [startLine, 0];
  token_to.map = tableLines;
  const token_tho = state2.push("thead_open", "thead", 1);
  token_tho.map = [startLine, startLine + 1];
  const token_htro = state2.push("tr_open", "tr", 1);
  token_htro.map = [startLine, startLine + 1];
  for (let i = 0; i < columns.length; i++) {
    const token_ho = state2.push("th_open", "th", 1);
    if (aligns[i]) {
      token_ho.attrs = [["style", "text-align:" + aligns[i]]];
    }
    const token_il = state2.push("inline", "", 0);
    token_il.content = columns[i].trim();
    token_il.children = [];
    state2.push("th_close", "th", -1);
  }
  state2.push("tr_close", "tr", -1);
  state2.push("thead_close", "thead", -1);
  let tbodyLines;
  let autocompletedCells = 0;
  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
    if (state2.sCount[nextLine] < state2.blkIndent) {
      break;
    }
    let terminate = false;
    for (let i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state2, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
    lineText = getLine(state2, nextLine).trim();
    if (!lineText) {
      break;
    }
    if (state2.sCount[nextLine] - state2.blkIndent >= 4) {
      break;
    }
    columns = escapedSplit(lineText);
    if (columns.length && columns[0] === "") columns.shift();
    if (columns.length && columns[columns.length - 1] === "") columns.pop();
    autocompletedCells += columnCount - columns.length;
    if (autocompletedCells > MAX_AUTOCOMPLETED_CELLS) {
      break;
    }
    if (nextLine === startLine + 2) {
      const token_tbo = state2.push("tbody_open", "tbody", 1);
      token_tbo.map = tbodyLines = [startLine + 2, 0];
    }
    const token_tro = state2.push("tr_open", "tr", 1);
    token_tro.map = [nextLine, nextLine + 1];
    for (let i = 0; i < columnCount; i++) {
      const token_tdo = state2.push("td_open", "td", 1);
      if (aligns[i]) {
        token_tdo.attrs = [["style", "text-align:" + aligns[i]]];
      }
      const token_il = state2.push("inline", "", 0);
      token_il.content = columns[i] ? columns[i].trim() : "";
      token_il.children = [];
      state2.push("td_close", "td", -1);
    }
    state2.push("tr_close", "tr", -1);
  }
  if (tbodyLines) {
    state2.push("tbody_close", "tbody", -1);
    tbodyLines[1] = nextLine;
  }
  state2.push("table_close", "table", -1);
  tableLines[1] = nextLine;
  state2.parentType = oldParentType;
  state2.line = nextLine;
  return true;
}
function code(state2, startLine, endLine) {
  if (state2.sCount[startLine] - state2.blkIndent < 4) {
    return false;
  }
  let nextLine = startLine + 1;
  let last = nextLine;
  while (nextLine < endLine) {
    if (state2.isEmpty(nextLine)) {
      nextLine++;
      continue;
    }
    if (state2.sCount[nextLine] - state2.blkIndent >= 4) {
      nextLine++;
      last = nextLine;
      continue;
    }
    break;
  }
  state2.line = last;
  const token2 = state2.push("code_block", "code", 0);
  token2.content = state2.getLines(startLine, last, 4 + state2.blkIndent, false) + "\n";
  token2.map = [startLine, state2.line];
  return true;
}
function fence(state2, startLine, endLine, silent2) {
  let pos = state2.bMarks[startLine] + state2.tShift[startLine];
  let max = state2.eMarks[startLine];
  if (state2.sCount[startLine] - state2.blkIndent >= 4) {
    return false;
  }
  if (pos + 3 > max) {
    return false;
  }
  const marker = state2.src.charCodeAt(pos);
  if (marker !== 126 && marker !== 96) {
    return false;
  }
  let mem = pos;
  pos = state2.skipChars(pos, marker);
  let len = pos - mem;
  if (len < 3) {
    return false;
  }
  const markup = state2.src.slice(mem, pos);
  const params = state2.src.slice(pos, max);
  if (marker === 96) {
    if (params.indexOf(String.fromCharCode(marker)) >= 0) {
      return false;
    }
  }
  if (silent2) {
    return true;
  }
  let nextLine = startLine;
  let haveEndMarker = false;
  for (; ; ) {
    nextLine++;
    if (nextLine >= endLine) {
      break;
    }
    pos = mem = state2.bMarks[nextLine] + state2.tShift[nextLine];
    max = state2.eMarks[nextLine];
    if (pos < max && state2.sCount[nextLine] < state2.blkIndent) {
      break;
    }
    if (state2.src.charCodeAt(pos) !== marker) {
      continue;
    }
    if (state2.sCount[nextLine] - state2.blkIndent >= 4) {
      continue;
    }
    pos = state2.skipChars(pos, marker);
    if (pos - mem < len) {
      continue;
    }
    pos = state2.skipSpaces(pos);
    if (pos < max) {
      continue;
    }
    haveEndMarker = true;
    break;
  }
  len = state2.sCount[startLine];
  state2.line = nextLine + (haveEndMarker ? 1 : 0);
  const token2 = state2.push("fence", "code", 0);
  token2.info = params;
  token2.content = state2.getLines(startLine + 1, nextLine, len, true);
  token2.markup = markup;
  token2.map = [startLine, state2.line];
  return true;
}
function blockquote(state2, startLine, endLine, silent2) {
  let pos = state2.bMarks[startLine] + state2.tShift[startLine];
  let max = state2.eMarks[startLine];
  const oldLineMax = state2.lineMax;
  if (state2.sCount[startLine] - state2.blkIndent >= 4) {
    return false;
  }
  if (state2.src.charCodeAt(pos) !== 62) {
    return false;
  }
  if (silent2) {
    return true;
  }
  const oldBMarks = [];
  const oldBSCount = [];
  const oldSCount = [];
  const oldTShift = [];
  const terminatorRules = state2.md.block.ruler.getRules("blockquote");
  const oldParentType = state2.parentType;
  state2.parentType = "blockquote";
  let lastLineEmpty = false;
  let nextLine;
  for (nextLine = startLine; nextLine < endLine; nextLine++) {
    const isOutdented = state2.sCount[nextLine] < state2.blkIndent;
    pos = state2.bMarks[nextLine] + state2.tShift[nextLine];
    max = state2.eMarks[nextLine];
    if (pos >= max) {
      break;
    }
    if (state2.src.charCodeAt(pos++) === 62 && !isOutdented) {
      let initial = state2.sCount[nextLine] + 1;
      let spaceAfterMarker;
      let adjustTab;
      if (state2.src.charCodeAt(pos) === 32) {
        pos++;
        initial++;
        adjustTab = false;
        spaceAfterMarker = true;
      } else if (state2.src.charCodeAt(pos) === 9) {
        spaceAfterMarker = true;
        if ((state2.bsCount[nextLine] + initial) % 4 === 3) {
          pos++;
          initial++;
          adjustTab = false;
        } else {
          adjustTab = true;
        }
      } else {
        spaceAfterMarker = false;
      }
      let offset = initial;
      oldBMarks.push(state2.bMarks[nextLine]);
      state2.bMarks[nextLine] = pos;
      while (pos < max) {
        const ch = state2.src.charCodeAt(pos);
        if (isSpace(ch)) {
          if (ch === 9) {
            offset += 4 - (offset + state2.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
          } else {
            offset++;
          }
        } else {
          break;
        }
        pos++;
      }
      lastLineEmpty = pos >= max;
      oldBSCount.push(state2.bsCount[nextLine]);
      state2.bsCount[nextLine] = state2.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);
      oldSCount.push(state2.sCount[nextLine]);
      state2.sCount[nextLine] = offset - initial;
      oldTShift.push(state2.tShift[nextLine]);
      state2.tShift[nextLine] = pos - state2.bMarks[nextLine];
      continue;
    }
    if (lastLineEmpty) {
      break;
    }
    let terminate = false;
    for (let i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state2, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      state2.lineMax = nextLine;
      if (state2.blkIndent !== 0) {
        oldBMarks.push(state2.bMarks[nextLine]);
        oldBSCount.push(state2.bsCount[nextLine]);
        oldTShift.push(state2.tShift[nextLine]);
        oldSCount.push(state2.sCount[nextLine]);
        state2.sCount[nextLine] -= state2.blkIndent;
      }
      break;
    }
    oldBMarks.push(state2.bMarks[nextLine]);
    oldBSCount.push(state2.bsCount[nextLine]);
    oldTShift.push(state2.tShift[nextLine]);
    oldSCount.push(state2.sCount[nextLine]);
    state2.sCount[nextLine] = -1;
  }
  const oldIndent = state2.blkIndent;
  state2.blkIndent = 0;
  const token_o = state2.push("blockquote_open", "blockquote", 1);
  token_o.markup = ">";
  const lines = [startLine, 0];
  token_o.map = lines;
  state2.md.block.tokenize(state2, startLine, nextLine);
  const token_c = state2.push("blockquote_close", "blockquote", -1);
  token_c.markup = ">";
  state2.lineMax = oldLineMax;
  state2.parentType = oldParentType;
  lines[1] = state2.line;
  for (let i = 0; i < oldTShift.length; i++) {
    state2.bMarks[i + startLine] = oldBMarks[i];
    state2.tShift[i + startLine] = oldTShift[i];
    state2.sCount[i + startLine] = oldSCount[i];
    state2.bsCount[i + startLine] = oldBSCount[i];
  }
  state2.blkIndent = oldIndent;
  return true;
}
function hr(state2, startLine, endLine, silent2) {
  const max = state2.eMarks[startLine];
  if (state2.sCount[startLine] - state2.blkIndent >= 4) {
    return false;
  }
  let pos = state2.bMarks[startLine] + state2.tShift[startLine];
  const marker = state2.src.charCodeAt(pos++);
  if (marker !== 42 && marker !== 45 && marker !== 95) {
    return false;
  }
  let cnt = 1;
  while (pos < max) {
    const ch = state2.src.charCodeAt(pos++);
    if (ch !== marker && !isSpace(ch)) {
      return false;
    }
    if (ch === marker) {
      cnt++;
    }
  }
  if (cnt < 3) {
    return false;
  }
  if (silent2) {
    return true;
  }
  state2.line = startLine + 1;
  const token2 = state2.push("hr", "hr", 0);
  token2.map = [startLine, state2.line];
  token2.markup = Array(cnt + 1).join(String.fromCharCode(marker));
  return true;
}
function skipBulletListMarker(state2, startLine) {
  const max = state2.eMarks[startLine];
  let pos = state2.bMarks[startLine] + state2.tShift[startLine];
  const marker = state2.src.charCodeAt(pos++);
  if (marker !== 42 && marker !== 45 && marker !== 43) {
    return -1;
  }
  if (pos < max) {
    const ch = state2.src.charCodeAt(pos);
    if (!isSpace(ch)) {
      return -1;
    }
  }
  return pos;
}
function skipOrderedListMarker(state2, startLine) {
  const start = state2.bMarks[startLine] + state2.tShift[startLine];
  const max = state2.eMarks[startLine];
  let pos = start;
  if (pos + 1 >= max) {
    return -1;
  }
  let ch = state2.src.charCodeAt(pos++);
  if (ch < 48 || ch > 57) {
    return -1;
  }
  for (; ; ) {
    if (pos >= max) {
      return -1;
    }
    ch = state2.src.charCodeAt(pos++);
    if (ch >= 48 && ch <= 57) {
      if (pos - start >= 10) {
        return -1;
      }
      continue;
    }
    if (ch === 41 || ch === 46) {
      break;
    }
    return -1;
  }
  if (pos < max) {
    ch = state2.src.charCodeAt(pos);
    if (!isSpace(ch)) {
      return -1;
    }
  }
  return pos;
}
function markTightParagraphs(state2, idx) {
  const level = state2.level + 2;
  for (let i = idx + 2, l = state2.tokens.length - 2; i < l; i++) {
    if (state2.tokens[i].level === level && state2.tokens[i].type === "paragraph_open") {
      state2.tokens[i + 2].hidden = true;
      state2.tokens[i].hidden = true;
      i += 2;
    }
  }
}
function list(state2, startLine, endLine, silent2) {
  let max, pos, start, token2;
  let nextLine = startLine;
  let tight = true;
  if (state2.sCount[nextLine] - state2.blkIndent >= 4) {
    return false;
  }
  if (state2.listIndent >= 0 && state2.sCount[nextLine] - state2.listIndent >= 4 && state2.sCount[nextLine] < state2.blkIndent) {
    return false;
  }
  let isTerminatingParagraph = false;
  if (silent2 && state2.parentType === "paragraph") {
    if (state2.sCount[nextLine] >= state2.blkIndent) {
      isTerminatingParagraph = true;
    }
  }
  let isOrdered;
  let markerValue;
  let posAfterMarker;
  if ((posAfterMarker = skipOrderedListMarker(state2, nextLine)) >= 0) {
    isOrdered = true;
    start = state2.bMarks[nextLine] + state2.tShift[nextLine];
    markerValue = Number(state2.src.slice(start, posAfterMarker - 1));
    if (isTerminatingParagraph && markerValue !== 1) return false;
  } else if ((posAfterMarker = skipBulletListMarker(state2, nextLine)) >= 0) {
    isOrdered = false;
  } else {
    return false;
  }
  if (isTerminatingParagraph) {
    if (state2.skipSpaces(posAfterMarker) >= state2.eMarks[nextLine]) return false;
  }
  if (silent2) {
    return true;
  }
  const markerCharCode = state2.src.charCodeAt(posAfterMarker - 1);
  const listTokIdx = state2.tokens.length;
  if (isOrdered) {
    token2 = state2.push("ordered_list_open", "ol", 1);
    if (markerValue !== 1) {
      token2.attrs = [["start", markerValue]];
    }
  } else {
    token2 = state2.push("bullet_list_open", "ul", 1);
  }
  const listLines = [nextLine, 0];
  token2.map = listLines;
  token2.markup = String.fromCharCode(markerCharCode);
  let prevEmptyEnd = false;
  const terminatorRules = state2.md.block.ruler.getRules("list");
  const oldParentType = state2.parentType;
  state2.parentType = "list";
  while (nextLine < endLine) {
    pos = posAfterMarker;
    max = state2.eMarks[nextLine];
    const initial = state2.sCount[nextLine] + posAfterMarker - (state2.bMarks[nextLine] + state2.tShift[nextLine]);
    let offset = initial;
    while (pos < max) {
      const ch = state2.src.charCodeAt(pos);
      if (ch === 9) {
        offset += 4 - (offset + state2.bsCount[nextLine]) % 4;
      } else if (ch === 32) {
        offset++;
      } else {
        break;
      }
      pos++;
    }
    const contentStart = pos;
    let indentAfterMarker;
    if (contentStart >= max) {
      indentAfterMarker = 1;
    } else {
      indentAfterMarker = offset - initial;
    }
    if (indentAfterMarker > 4) {
      indentAfterMarker = 1;
    }
    const indent = initial + indentAfterMarker;
    token2 = state2.push("list_item_open", "li", 1);
    token2.markup = String.fromCharCode(markerCharCode);
    const itemLines = [nextLine, 0];
    token2.map = itemLines;
    if (isOrdered) {
      token2.info = state2.src.slice(start, posAfterMarker - 1);
    }
    const oldTight = state2.tight;
    const oldTShift = state2.tShift[nextLine];
    const oldSCount = state2.sCount[nextLine];
    const oldListIndent = state2.listIndent;
    state2.listIndent = state2.blkIndent;
    state2.blkIndent = indent;
    state2.tight = true;
    state2.tShift[nextLine] = contentStart - state2.bMarks[nextLine];
    state2.sCount[nextLine] = offset;
    if (contentStart >= max && state2.isEmpty(nextLine + 1)) {
      state2.line = Math.min(state2.line + 2, endLine);
    } else {
      state2.md.block.tokenize(state2, nextLine, endLine, true);
    }
    if (!state2.tight || prevEmptyEnd) {
      tight = false;
    }
    prevEmptyEnd = state2.line - nextLine > 1 && state2.isEmpty(state2.line - 1);
    state2.blkIndent = state2.listIndent;
    state2.listIndent = oldListIndent;
    state2.tShift[nextLine] = oldTShift;
    state2.sCount[nextLine] = oldSCount;
    state2.tight = oldTight;
    token2 = state2.push("list_item_close", "li", -1);
    token2.markup = String.fromCharCode(markerCharCode);
    nextLine = state2.line;
    itemLines[1] = nextLine;
    if (nextLine >= endLine) {
      break;
    }
    if (state2.sCount[nextLine] < state2.blkIndent) {
      break;
    }
    if (state2.sCount[nextLine] - state2.blkIndent >= 4) {
      break;
    }
    let terminate = false;
    for (let i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state2, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
    if (isOrdered) {
      posAfterMarker = skipOrderedListMarker(state2, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
      start = state2.bMarks[nextLine] + state2.tShift[nextLine];
    } else {
      posAfterMarker = skipBulletListMarker(state2, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
    }
    if (markerCharCode !== state2.src.charCodeAt(posAfterMarker - 1)) {
      break;
    }
  }
  if (isOrdered) {
    token2 = state2.push("ordered_list_close", "ol", -1);
  } else {
    token2 = state2.push("bullet_list_close", "ul", -1);
  }
  token2.markup = String.fromCharCode(markerCharCode);
  listLines[1] = nextLine;
  state2.line = nextLine;
  state2.parentType = oldParentType;
  if (tight) {
    markTightParagraphs(state2, listTokIdx);
  }
  return true;
}
function reference(state2, startLine, _endLine, silent2) {
  let pos = state2.bMarks[startLine] + state2.tShift[startLine];
  let max = state2.eMarks[startLine];
  let nextLine = startLine + 1;
  if (state2.sCount[startLine] - state2.blkIndent >= 4) {
    return false;
  }
  if (state2.src.charCodeAt(pos) !== 91) {
    return false;
  }
  function getNextLine(nextLine2) {
    const endLine = state2.lineMax;
    if (nextLine2 >= endLine || state2.isEmpty(nextLine2)) {
      return null;
    }
    let isContinuation = false;
    if (state2.sCount[nextLine2] - state2.blkIndent > 3) {
      isContinuation = true;
    }
    if (state2.sCount[nextLine2] < 0) {
      isContinuation = true;
    }
    if (!isContinuation) {
      const terminatorRules = state2.md.block.ruler.getRules("reference");
      const oldParentType = state2.parentType;
      state2.parentType = "reference";
      let terminate = false;
      for (let i = 0, l = terminatorRules.length; i < l; i++) {
        if (terminatorRules[i](state2, nextLine2, endLine, true)) {
          terminate = true;
          break;
        }
      }
      state2.parentType = oldParentType;
      if (terminate) {
        return null;
      }
    }
    const pos2 = state2.bMarks[nextLine2] + state2.tShift[nextLine2];
    const max2 = state2.eMarks[nextLine2];
    return state2.src.slice(pos2, max2 + 1);
  }
  let str = state2.src.slice(pos, max + 1);
  max = str.length;
  let labelEnd = -1;
  for (pos = 1; pos < max; pos++) {
    const ch = str.charCodeAt(pos);
    if (ch === 91) {
      return false;
    } else if (ch === 93) {
      labelEnd = pos;
      break;
    } else if (ch === 10) {
      const lineContent = getNextLine(nextLine);
      if (lineContent !== null) {
        str += lineContent;
        max = str.length;
        nextLine++;
      }
    } else if (ch === 92) {
      pos++;
      if (pos < max && str.charCodeAt(pos) === 10) {
        const lineContent = getNextLine(nextLine);
        if (lineContent !== null) {
          str += lineContent;
          max = str.length;
          nextLine++;
        }
      }
    }
  }
  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 58) {
    return false;
  }
  for (pos = labelEnd + 2; pos < max; pos++) {
    const ch = str.charCodeAt(pos);
    if (ch === 10) {
      const lineContent = getNextLine(nextLine);
      if (lineContent !== null) {
        str += lineContent;
        max = str.length;
        nextLine++;
      }
    } else if (isSpace(ch)) ;
    else {
      break;
    }
  }
  const destRes = state2.md.helpers.parseLinkDestination(str, pos, max);
  if (!destRes.ok) {
    return false;
  }
  const href = state2.md.normalizeLink(destRes.str);
  if (!state2.md.validateLink(href)) {
    return false;
  }
  pos = destRes.pos;
  const destEndPos = pos;
  const destEndLineNo = nextLine;
  const start = pos;
  for (; pos < max; pos++) {
    const ch = str.charCodeAt(pos);
    if (ch === 10) {
      const lineContent = getNextLine(nextLine);
      if (lineContent !== null) {
        str += lineContent;
        max = str.length;
        nextLine++;
      }
    } else if (isSpace(ch)) ;
    else {
      break;
    }
  }
  let titleRes = state2.md.helpers.parseLinkTitle(str, pos, max);
  while (titleRes.can_continue) {
    const lineContent = getNextLine(nextLine);
    if (lineContent === null) break;
    str += lineContent;
    pos = max;
    max = str.length;
    nextLine++;
    titleRes = state2.md.helpers.parseLinkTitle(str, pos, max, titleRes);
  }
  let title;
  if (pos < max && start !== pos && titleRes.ok) {
    title = titleRes.str;
    pos = titleRes.pos;
  } else {
    title = "";
    pos = destEndPos;
    nextLine = destEndLineNo;
  }
  while (pos < max) {
    const ch = str.charCodeAt(pos);
    if (!isSpace(ch)) {
      break;
    }
    pos++;
  }
  if (pos < max && str.charCodeAt(pos) !== 10) {
    if (title) {
      title = "";
      pos = destEndPos;
      nextLine = destEndLineNo;
      while (pos < max) {
        const ch = str.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
        pos++;
      }
    }
  }
  if (pos < max && str.charCodeAt(pos) !== 10) {
    return false;
  }
  const label = normalizeReference(str.slice(1, labelEnd));
  if (!label) {
    return false;
  }
  if (silent2) {
    return true;
  }
  if (typeof state2.env.references === "undefined") {
    state2.env.references = {};
  }
  if (typeof state2.env.references[label] === "undefined") {
    state2.env.references[label] = { title, href };
  }
  state2.line = nextLine;
  return true;
}
const block_names = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];
const attr_name = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
const unquoted = "[^\"'=<>`\\x00-\\x20]+";
const single_quoted = "'[^']*'";
const double_quoted = '"[^"]*"';
const attr_value = "(?:" + unquoted + "|" + single_quoted + "|" + double_quoted + ")";
const attribute = "(?:\\s+" + attr_name + "(?:\\s*=\\s*" + attr_value + ")?)";
const open_tag = "<[A-Za-z][A-Za-z0-9\\-]*" + attribute + "*\\s*\\/?>";
const close_tag = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
const comment$1 = "<!---?>|<!--(?:[^-]|-[^-]|--[^>])*-->";
const processing = "<[?][\\s\\S]*?[?]>";
const declaration$1 = "<![A-Za-z][^>]*>";
const cdata = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
const HTML_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + "|" + comment$1 + "|" + processing + "|" + declaration$1 + "|" + cdata + ")");
const HTML_OPEN_CLOSE_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + ")");
const HTML_SEQUENCES = [
  [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true],
  [/^<!--/, /-->/, true],
  [/^<\?/, /\?>/, true],
  [/^<![A-Z]/, />/, true],
  [/^<!\[CDATA\[/, /\]\]>/, true],
  [new RegExp("^</?(" + block_names.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, true],
  [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + "\\s*$"), /^$/, false]
];
function html_block(state2, startLine, endLine, silent2) {
  let pos = state2.bMarks[startLine] + state2.tShift[startLine];
  let max = state2.eMarks[startLine];
  if (state2.sCount[startLine] - state2.blkIndent >= 4) {
    return false;
  }
  if (!state2.md.options.html) {
    return false;
  }
  if (state2.src.charCodeAt(pos) !== 60) {
    return false;
  }
  let lineText = state2.src.slice(pos, max);
  let i = 0;
  for (; i < HTML_SEQUENCES.length; i++) {
    if (HTML_SEQUENCES[i][0].test(lineText)) {
      break;
    }
  }
  if (i === HTML_SEQUENCES.length) {
    return false;
  }
  if (silent2) {
    return HTML_SEQUENCES[i][2];
  }
  let nextLine = startLine + 1;
  if (!HTML_SEQUENCES[i][1].test(lineText)) {
    for (; nextLine < endLine; nextLine++) {
      if (state2.sCount[nextLine] < state2.blkIndent) {
        break;
      }
      pos = state2.bMarks[nextLine] + state2.tShift[nextLine];
      max = state2.eMarks[nextLine];
      lineText = state2.src.slice(pos, max);
      if (HTML_SEQUENCES[i][1].test(lineText)) {
        if (lineText.length !== 0) {
          nextLine++;
        }
        break;
      }
    }
  }
  state2.line = nextLine;
  const token2 = state2.push("html_block", "", 0);
  token2.map = [startLine, nextLine];
  token2.content = state2.getLines(startLine, nextLine, state2.blkIndent, true);
  return true;
}
function heading(state2, startLine, endLine, silent2) {
  let pos = state2.bMarks[startLine] + state2.tShift[startLine];
  let max = state2.eMarks[startLine];
  if (state2.sCount[startLine] - state2.blkIndent >= 4) {
    return false;
  }
  let ch = state2.src.charCodeAt(pos);
  if (ch !== 35 || pos >= max) {
    return false;
  }
  let level = 1;
  ch = state2.src.charCodeAt(++pos);
  while (ch === 35 && pos < max && level <= 6) {
    level++;
    ch = state2.src.charCodeAt(++pos);
  }
  if (level > 6 || pos < max && !isSpace(ch)) {
    return false;
  }
  if (silent2) {
    return true;
  }
  max = state2.skipSpacesBack(max, pos);
  const tmp = state2.skipCharsBack(max, 35, pos);
  if (tmp > pos && isSpace(state2.src.charCodeAt(tmp - 1))) {
    max = tmp;
  }
  state2.line = startLine + 1;
  const token_o = state2.push("heading_open", "h" + String(level), 1);
  token_o.markup = "########".slice(0, level);
  token_o.map = [startLine, state2.line];
  const token_i = state2.push("inline", "", 0);
  token_i.content = state2.src.slice(pos, max).trim();
  token_i.map = [startLine, state2.line];
  token_i.children = [];
  const token_c = state2.push("heading_close", "h" + String(level), -1);
  token_c.markup = "########".slice(0, level);
  return true;
}
function lheading(state2, startLine, endLine) {
  const terminatorRules = state2.md.block.ruler.getRules("paragraph");
  if (state2.sCount[startLine] - state2.blkIndent >= 4) {
    return false;
  }
  const oldParentType = state2.parentType;
  state2.parentType = "paragraph";
  let level = 0;
  let marker;
  let nextLine = startLine + 1;
  for (; nextLine < endLine && !state2.isEmpty(nextLine); nextLine++) {
    if (state2.sCount[nextLine] - state2.blkIndent > 3) {
      continue;
    }
    if (state2.sCount[nextLine] >= state2.blkIndent) {
      let pos = state2.bMarks[nextLine] + state2.tShift[nextLine];
      const max = state2.eMarks[nextLine];
      if (pos < max) {
        marker = state2.src.charCodeAt(pos);
        if (marker === 45 || marker === 61) {
          pos = state2.skipChars(pos, marker);
          pos = state2.skipSpaces(pos);
          if (pos >= max) {
            level = marker === 61 ? 1 : 2;
            break;
          }
        }
      }
    }
    if (state2.sCount[nextLine] < 0) {
      continue;
    }
    let terminate = false;
    for (let i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state2, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }
  if (!level) {
    return false;
  }
  const content = state2.getLines(startLine, nextLine, state2.blkIndent, false).trim();
  state2.line = nextLine + 1;
  const token_o = state2.push("heading_open", "h" + String(level), 1);
  token_o.markup = String.fromCharCode(marker);
  token_o.map = [startLine, state2.line];
  const token_i = state2.push("inline", "", 0);
  token_i.content = content;
  token_i.map = [startLine, state2.line - 1];
  token_i.children = [];
  const token_c = state2.push("heading_close", "h" + String(level), -1);
  token_c.markup = String.fromCharCode(marker);
  state2.parentType = oldParentType;
  return true;
}
function paragraph(state2, startLine, endLine) {
  const terminatorRules = state2.md.block.ruler.getRules("paragraph");
  const oldParentType = state2.parentType;
  let nextLine = startLine + 1;
  state2.parentType = "paragraph";
  for (; nextLine < endLine && !state2.isEmpty(nextLine); nextLine++) {
    if (state2.sCount[nextLine] - state2.blkIndent > 3) {
      continue;
    }
    if (state2.sCount[nextLine] < 0) {
      continue;
    }
    let terminate = false;
    for (let i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state2, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }
  const content = state2.getLines(startLine, nextLine, state2.blkIndent, false).trim();
  state2.line = nextLine;
  const token_o = state2.push("paragraph_open", "p", 1);
  token_o.map = [startLine, state2.line];
  const token_i = state2.push("inline", "", 0);
  token_i.content = content;
  token_i.map = [startLine, state2.line];
  token_i.children = [];
  state2.push("paragraph_close", "p", -1);
  state2.parentType = oldParentType;
  return true;
}
const _rules$1 = [
  // First 2 params - rule name & source. Secondary array - list of rules,
  // which can be terminated by this one.
  ["table", table, ["paragraph", "reference"]],
  ["code", code],
  ["fence", fence, ["paragraph", "reference", "blockquote", "list"]],
  ["blockquote", blockquote, ["paragraph", "reference", "blockquote", "list"]],
  ["hr", hr, ["paragraph", "reference", "blockquote", "list"]],
  ["list", list, ["paragraph", "reference", "blockquote"]],
  ["reference", reference],
  ["html_block", html_block, ["paragraph", "reference", "blockquote"]],
  ["heading", heading, ["paragraph", "reference", "blockquote"]],
  ["lheading", lheading],
  ["paragraph", paragraph]
];
function ParserBlock() {
  this.ruler = new Ruler();
  for (let i = 0; i < _rules$1.length; i++) {
    this.ruler.push(_rules$1[i][0], _rules$1[i][1], { alt: (_rules$1[i][2] || []).slice() });
  }
}
ParserBlock.prototype.tokenize = function(state2, startLine, endLine) {
  const rules = this.ruler.getRules("");
  const len = rules.length;
  const maxNesting = state2.md.options.maxNesting;
  let line2 = startLine;
  let hasEmptyLines = false;
  while (line2 < endLine) {
    state2.line = line2 = state2.skipEmptyLines(line2);
    if (line2 >= endLine) {
      break;
    }
    if (state2.sCount[line2] < state2.blkIndent) {
      break;
    }
    if (state2.level >= maxNesting) {
      state2.line = endLine;
      break;
    }
    const prevLine = state2.line;
    let ok = false;
    for (let i = 0; i < len; i++) {
      ok = rules[i](state2, line2, endLine, false);
      if (ok) {
        if (prevLine >= state2.line) {
          throw new Error("block rule didn't increment state.line");
        }
        break;
      }
    }
    if (!ok) throw new Error("none of the block rules matched");
    state2.tight = !hasEmptyLines;
    if (state2.isEmpty(state2.line - 1)) {
      hasEmptyLines = true;
    }
    line2 = state2.line;
    if (line2 < endLine && state2.isEmpty(line2)) {
      hasEmptyLines = true;
      line2++;
      state2.line = line2;
    }
  }
};
ParserBlock.prototype.parse = function(src, md, env, outTokens) {
  if (!src) {
    return;
  }
  const state2 = new this.State(src, md, env, outTokens);
  this.tokenize(state2, state2.line, state2.lineMax);
};
ParserBlock.prototype.State = StateBlock;
function StateInline(src, md, env, outTokens) {
  this.src = src;
  this.env = env;
  this.md = md;
  this.tokens = outTokens;
  this.tokens_meta = Array(outTokens.length);
  this.pos = 0;
  this.posMax = this.src.length;
  this.level = 0;
  this.pending = "";
  this.pendingLevel = 0;
  this.cache = {};
  this.delimiters = [];
  this._prev_delimiters = [];
  this.backticks = {};
  this.backticksScanned = false;
  this.linkLevel = 0;
}
StateInline.prototype.pushPending = function() {
  const token2 = new Token("text", "", 0);
  token2.content = this.pending;
  token2.level = this.pendingLevel;
  this.tokens.push(token2);
  this.pending = "";
  return token2;
};
StateInline.prototype.push = function(type, tag, nesting) {
  if (this.pending) {
    this.pushPending();
  }
  const token2 = new Token(type, tag, nesting);
  let token_meta = null;
  if (nesting < 0) {
    this.level--;
    this.delimiters = this._prev_delimiters.pop();
  }
  token2.level = this.level;
  if (nesting > 0) {
    this.level++;
    this._prev_delimiters.push(this.delimiters);
    this.delimiters = [];
    token_meta = { delimiters: this.delimiters };
  }
  this.pendingLevel = this.level;
  this.tokens.push(token2);
  this.tokens_meta.push(token_meta);
  return token2;
};
StateInline.prototype.scanDelims = function(start, canSplitWord) {
  const max = this.posMax;
  const marker = this.src.charCodeAt(start);
  const lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 32;
  let pos = start;
  while (pos < max && this.src.charCodeAt(pos) === marker) {
    pos++;
  }
  const count = pos - start;
  const nextChar = pos < max ? this.src.charCodeAt(pos) : 32;
  const isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
  const isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
  const isLastWhiteSpace = isWhiteSpace(lastChar);
  const isNextWhiteSpace = isWhiteSpace(nextChar);
  const left_flanking = !isNextWhiteSpace && (!isNextPunctChar || isLastWhiteSpace || isLastPunctChar);
  const right_flanking = !isLastWhiteSpace && (!isLastPunctChar || isNextWhiteSpace || isNextPunctChar);
  const can_open = left_flanking && (canSplitWord || !right_flanking || isLastPunctChar);
  const can_close = right_flanking && (canSplitWord || !left_flanking || isNextPunctChar);
  return { can_open, can_close, length: count };
};
StateInline.prototype.Token = Token;
function isTerminatorChar(ch) {
  switch (ch) {
    case 10:
    case 33:
    case 35:
    case 36:
    case 37:
    case 38:
    case 42:
    case 43:
    case 45:
    case 58:
    case 60:
    case 61:
    case 62:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 125:
    case 126:
      return true;
    default:
      return false;
  }
}
function text(state2, silent2) {
  let pos = state2.pos;
  while (pos < state2.posMax && !isTerminatorChar(state2.src.charCodeAt(pos))) {
    pos++;
  }
  if (pos === state2.pos) {
    return false;
  }
  if (!silent2) {
    state2.pending += state2.src.slice(state2.pos, pos);
  }
  state2.pos = pos;
  return true;
}
const SCHEME_RE = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;
function linkify(state2, silent2) {
  if (!state2.md.options.linkify) return false;
  if (state2.linkLevel > 0) return false;
  const pos = state2.pos;
  const max = state2.posMax;
  if (pos + 3 > max) return false;
  if (state2.src.charCodeAt(pos) !== 58) return false;
  if (state2.src.charCodeAt(pos + 1) !== 47) return false;
  if (state2.src.charCodeAt(pos + 2) !== 47) return false;
  const match3 = state2.pending.match(SCHEME_RE);
  if (!match3) return false;
  const proto = match3[1];
  const link2 = state2.md.linkify.matchAtStart(state2.src.slice(pos - proto.length));
  if (!link2) return false;
  let url = link2.url;
  if (url.length <= proto.length) return false;
  url = url.replace(/\*+$/, "");
  const fullUrl = state2.md.normalizeLink(url);
  if (!state2.md.validateLink(fullUrl)) return false;
  if (!silent2) {
    state2.pending = state2.pending.slice(0, -proto.length);
    const token_o = state2.push("link_open", "a", 1);
    token_o.attrs = [["href", fullUrl]];
    token_o.markup = "linkify";
    token_o.info = "auto";
    const token_t = state2.push("text", "", 0);
    token_t.content = state2.md.normalizeLinkText(url);
    const token_c = state2.push("link_close", "a", -1);
    token_c.markup = "linkify";
    token_c.info = "auto";
  }
  state2.pos += url.length - proto.length;
  return true;
}
function newline(state2, silent2) {
  let pos = state2.pos;
  if (state2.src.charCodeAt(pos) !== 10) {
    return false;
  }
  const pmax = state2.pending.length - 1;
  const max = state2.posMax;
  if (!silent2) {
    if (pmax >= 0 && state2.pending.charCodeAt(pmax) === 32) {
      if (pmax >= 1 && state2.pending.charCodeAt(pmax - 1) === 32) {
        let ws = pmax - 1;
        while (ws >= 1 && state2.pending.charCodeAt(ws - 1) === 32) ws--;
        state2.pending = state2.pending.slice(0, ws);
        state2.push("hardbreak", "br", 0);
      } else {
        state2.pending = state2.pending.slice(0, -1);
        state2.push("softbreak", "br", 0);
      }
    } else {
      state2.push("softbreak", "br", 0);
    }
  }
  pos++;
  while (pos < max && isSpace(state2.src.charCodeAt(pos))) {
    pos++;
  }
  state2.pos = pos;
  return true;
}
const ESCAPED = [];
for (let i = 0; i < 256; i++) {
  ESCAPED.push(0);
}
"\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(ch) {
  ESCAPED[ch.charCodeAt(0)] = 1;
});
function escape$1(state2, silent2) {
  let pos = state2.pos;
  const max = state2.posMax;
  if (state2.src.charCodeAt(pos) !== 92) return false;
  pos++;
  if (pos >= max) return false;
  let ch1 = state2.src.charCodeAt(pos);
  if (ch1 === 10) {
    if (!silent2) {
      state2.push("hardbreak", "br", 0);
    }
    pos++;
    while (pos < max) {
      ch1 = state2.src.charCodeAt(pos);
      if (!isSpace(ch1)) break;
      pos++;
    }
    state2.pos = pos;
    return true;
  }
  let escapedStr = state2.src[pos];
  if (ch1 >= 55296 && ch1 <= 56319 && pos + 1 < max) {
    const ch2 = state2.src.charCodeAt(pos + 1);
    if (ch2 >= 56320 && ch2 <= 57343) {
      escapedStr += state2.src[pos + 1];
      pos++;
    }
  }
  const origStr = "\\" + escapedStr;
  if (!silent2) {
    const token2 = state2.push("text_special", "", 0);
    if (ch1 < 256 && ESCAPED[ch1] !== 0) {
      token2.content = escapedStr;
    } else {
      token2.content = origStr;
    }
    token2.markup = origStr;
    token2.info = "escape";
  }
  state2.pos = pos + 1;
  return true;
}
function backtick(state2, silent2) {
  let pos = state2.pos;
  const ch = state2.src.charCodeAt(pos);
  if (ch !== 96) {
    return false;
  }
  const start = pos;
  pos++;
  const max = state2.posMax;
  while (pos < max && state2.src.charCodeAt(pos) === 96) {
    pos++;
  }
  const marker = state2.src.slice(start, pos);
  const openerLength = marker.length;
  if (state2.backticksScanned && (state2.backticks[openerLength] || 0) <= start) {
    if (!silent2) state2.pending += marker;
    state2.pos += openerLength;
    return true;
  }
  let matchEnd = pos;
  let matchStart;
  while ((matchStart = state2.src.indexOf("`", matchEnd)) !== -1) {
    matchEnd = matchStart + 1;
    while (matchEnd < max && state2.src.charCodeAt(matchEnd) === 96) {
      matchEnd++;
    }
    const closerLength = matchEnd - matchStart;
    if (closerLength === openerLength) {
      if (!silent2) {
        const token2 = state2.push("code_inline", "code", 0);
        token2.markup = marker;
        token2.content = state2.src.slice(pos, matchStart).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
      }
      state2.pos = matchEnd;
      return true;
    }
    state2.backticks[closerLength] = matchStart;
  }
  state2.backticksScanned = true;
  if (!silent2) state2.pending += marker;
  state2.pos += openerLength;
  return true;
}
function strikethrough_tokenize(state2, silent2) {
  const start = state2.pos;
  const marker = state2.src.charCodeAt(start);
  if (silent2) {
    return false;
  }
  if (marker !== 126) {
    return false;
  }
  const scanned = state2.scanDelims(state2.pos, true);
  let len = scanned.length;
  const ch = String.fromCharCode(marker);
  if (len < 2) {
    return false;
  }
  let token2;
  if (len % 2) {
    token2 = state2.push("text", "", 0);
    token2.content = ch;
    len--;
  }
  for (let i = 0; i < len; i += 2) {
    token2 = state2.push("text", "", 0);
    token2.content = ch + ch;
    state2.delimiters.push({
      marker,
      length: 0,
      // disable "rule of 3" length checks meant for emphasis
      token: state2.tokens.length - 1,
      end: -1,
      open: scanned.can_open,
      close: scanned.can_close
    });
  }
  state2.pos += scanned.length;
  return true;
}
function postProcess$1(state2, delimiters) {
  let token2;
  const loneMarkers = [];
  const max = delimiters.length;
  for (let i = 0; i < max; i++) {
    const startDelim = delimiters[i];
    if (startDelim.marker !== 126) {
      continue;
    }
    if (startDelim.end === -1) {
      continue;
    }
    const endDelim = delimiters[startDelim.end];
    token2 = state2.tokens[startDelim.token];
    token2.type = "s_open";
    token2.tag = "s";
    token2.nesting = 1;
    token2.markup = "~~";
    token2.content = "";
    token2 = state2.tokens[endDelim.token];
    token2.type = "s_close";
    token2.tag = "s";
    token2.nesting = -1;
    token2.markup = "~~";
    token2.content = "";
    if (state2.tokens[endDelim.token - 1].type === "text" && state2.tokens[endDelim.token - 1].content === "~") {
      loneMarkers.push(endDelim.token - 1);
    }
  }
  while (loneMarkers.length) {
    const i = loneMarkers.pop();
    let j2 = i + 1;
    while (j2 < state2.tokens.length && state2.tokens[j2].type === "s_close") {
      j2++;
    }
    j2--;
    if (i !== j2) {
      token2 = state2.tokens[j2];
      state2.tokens[j2] = state2.tokens[i];
      state2.tokens[i] = token2;
    }
  }
}
function strikethrough_postProcess(state2) {
  const tokens_meta = state2.tokens_meta;
  const max = state2.tokens_meta.length;
  postProcess$1(state2, state2.delimiters);
  for (let curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      postProcess$1(state2, tokens_meta[curr].delimiters);
    }
  }
}
const r_strikethrough = {
  tokenize: strikethrough_tokenize,
  postProcess: strikethrough_postProcess
};
function emphasis_tokenize(state2, silent2) {
  const start = state2.pos;
  const marker = state2.src.charCodeAt(start);
  if (silent2) {
    return false;
  }
  if (marker !== 95 && marker !== 42) {
    return false;
  }
  const scanned = state2.scanDelims(state2.pos, marker === 42);
  for (let i = 0; i < scanned.length; i++) {
    const token2 = state2.push("text", "", 0);
    token2.content = String.fromCharCode(marker);
    state2.delimiters.push({
      // Char code of the starting marker (number).
      //
      marker,
      // Total length of these series of delimiters.
      //
      length: scanned.length,
      // A position of the token this delimiter corresponds to.
      //
      token: state2.tokens.length - 1,
      // If this delimiter is matched as a valid opener, `end` will be
      // equal to its position, otherwise it's `-1`.
      //
      end: -1,
      // Boolean flags that determine if this delimiter could open or close
      // an emphasis.
      //
      open: scanned.can_open,
      close: scanned.can_close
    });
  }
  state2.pos += scanned.length;
  return true;
}
function postProcess(state2, delimiters) {
  const max = delimiters.length;
  for (let i = max - 1; i >= 0; i--) {
    const startDelim = delimiters[i];
    if (startDelim.marker !== 95 && startDelim.marker !== 42) {
      continue;
    }
    if (startDelim.end === -1) {
      continue;
    }
    const endDelim = delimiters[startDelim.end];
    const isStrong = i > 0 && delimiters[i - 1].end === startDelim.end + 1 && // check that first two markers match and adjacent
    delimiters[i - 1].marker === startDelim.marker && delimiters[i - 1].token === startDelim.token - 1 && // check that last two markers are adjacent (we can safely assume they match)
    delimiters[startDelim.end + 1].token === endDelim.token + 1;
    const ch = String.fromCharCode(startDelim.marker);
    const token_o = state2.tokens[startDelim.token];
    token_o.type = isStrong ? "strong_open" : "em_open";
    token_o.tag = isStrong ? "strong" : "em";
    token_o.nesting = 1;
    token_o.markup = isStrong ? ch + ch : ch;
    token_o.content = "";
    const token_c = state2.tokens[endDelim.token];
    token_c.type = isStrong ? "strong_close" : "em_close";
    token_c.tag = isStrong ? "strong" : "em";
    token_c.nesting = -1;
    token_c.markup = isStrong ? ch + ch : ch;
    token_c.content = "";
    if (isStrong) {
      state2.tokens[delimiters[i - 1].token].content = "";
      state2.tokens[delimiters[startDelim.end + 1].token].content = "";
      i--;
    }
  }
}
function emphasis_post_process(state2) {
  const tokens_meta = state2.tokens_meta;
  const max = state2.tokens_meta.length;
  postProcess(state2, state2.delimiters);
  for (let curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      postProcess(state2, tokens_meta[curr].delimiters);
    }
  }
}
const r_emphasis = {
  tokenize: emphasis_tokenize,
  postProcess: emphasis_post_process
};
function link(state2, silent2) {
  let code2, label, res, ref2;
  let href = "";
  let title = "";
  let start = state2.pos;
  let parseReference = true;
  if (state2.src.charCodeAt(state2.pos) !== 91) {
    return false;
  }
  const oldPos = state2.pos;
  const max = state2.posMax;
  const labelStart = state2.pos + 1;
  const labelEnd = state2.md.helpers.parseLinkLabel(state2, state2.pos, true);
  if (labelEnd < 0) {
    return false;
  }
  let pos = labelEnd + 1;
  if (pos < max && state2.src.charCodeAt(pos) === 40) {
    parseReference = false;
    pos++;
    for (; pos < max; pos++) {
      code2 = state2.src.charCodeAt(pos);
      if (!isSpace(code2) && code2 !== 10) {
        break;
      }
    }
    if (pos >= max) {
      return false;
    }
    start = pos;
    res = state2.md.helpers.parseLinkDestination(state2.src, pos, state2.posMax);
    if (res.ok) {
      href = state2.md.normalizeLink(res.str);
      if (state2.md.validateLink(href)) {
        pos = res.pos;
      } else {
        href = "";
      }
      start = pos;
      for (; pos < max; pos++) {
        code2 = state2.src.charCodeAt(pos);
        if (!isSpace(code2) && code2 !== 10) {
          break;
        }
      }
      res = state2.md.helpers.parseLinkTitle(state2.src, pos, state2.posMax);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;
        for (; pos < max; pos++) {
          code2 = state2.src.charCodeAt(pos);
          if (!isSpace(code2) && code2 !== 10) {
            break;
          }
        }
      }
    }
    if (pos >= max || state2.src.charCodeAt(pos) !== 41) {
      parseReference = true;
    }
    pos++;
  }
  if (parseReference) {
    if (typeof state2.env.references === "undefined") {
      return false;
    }
    if (pos < max && state2.src.charCodeAt(pos) === 91) {
      start = pos + 1;
      pos = state2.md.helpers.parseLinkLabel(state2, pos);
      if (pos >= 0) {
        label = state2.src.slice(start, pos++);
      } else {
        pos = labelEnd + 1;
      }
    } else {
      pos = labelEnd + 1;
    }
    if (!label) {
      label = state2.src.slice(labelStart, labelEnd);
    }
    ref2 = state2.env.references[normalizeReference(label)];
    if (!ref2) {
      state2.pos = oldPos;
      return false;
    }
    href = ref2.href;
    title = ref2.title;
  }
  if (!silent2) {
    state2.pos = labelStart;
    state2.posMax = labelEnd;
    const token_o = state2.push("link_open", "a", 1);
    const attrs = [["href", href]];
    token_o.attrs = attrs;
    if (title) {
      attrs.push(["title", title]);
    }
    state2.linkLevel++;
    state2.md.inline.tokenize(state2);
    state2.linkLevel--;
    state2.push("link_close", "a", -1);
  }
  state2.pos = pos;
  state2.posMax = max;
  return true;
}
function image(state2, silent2) {
  let code2, content, label, pos, ref2, res, title, start;
  let href = "";
  const oldPos = state2.pos;
  const max = state2.posMax;
  if (state2.src.charCodeAt(state2.pos) !== 33) {
    return false;
  }
  if (state2.src.charCodeAt(state2.pos + 1) !== 91) {
    return false;
  }
  const labelStart = state2.pos + 2;
  const labelEnd = state2.md.helpers.parseLinkLabel(state2, state2.pos + 1, false);
  if (labelEnd < 0) {
    return false;
  }
  pos = labelEnd + 1;
  if (pos < max && state2.src.charCodeAt(pos) === 40) {
    pos++;
    for (; pos < max; pos++) {
      code2 = state2.src.charCodeAt(pos);
      if (!isSpace(code2) && code2 !== 10) {
        break;
      }
    }
    if (pos >= max) {
      return false;
    }
    start = pos;
    res = state2.md.helpers.parseLinkDestination(state2.src, pos, state2.posMax);
    if (res.ok) {
      href = state2.md.normalizeLink(res.str);
      if (state2.md.validateLink(href)) {
        pos = res.pos;
      } else {
        href = "";
      }
    }
    start = pos;
    for (; pos < max; pos++) {
      code2 = state2.src.charCodeAt(pos);
      if (!isSpace(code2) && code2 !== 10) {
        break;
      }
    }
    res = state2.md.helpers.parseLinkTitle(state2.src, pos, state2.posMax);
    if (pos < max && start !== pos && res.ok) {
      title = res.str;
      pos = res.pos;
      for (; pos < max; pos++) {
        code2 = state2.src.charCodeAt(pos);
        if (!isSpace(code2) && code2 !== 10) {
          break;
        }
      }
    } else {
      title = "";
    }
    if (pos >= max || state2.src.charCodeAt(pos) !== 41) {
      state2.pos = oldPos;
      return false;
    }
    pos++;
  } else {
    if (typeof state2.env.references === "undefined") {
      return false;
    }
    if (pos < max && state2.src.charCodeAt(pos) === 91) {
      start = pos + 1;
      pos = state2.md.helpers.parseLinkLabel(state2, pos);
      if (pos >= 0) {
        label = state2.src.slice(start, pos++);
      } else {
        pos = labelEnd + 1;
      }
    } else {
      pos = labelEnd + 1;
    }
    if (!label) {
      label = state2.src.slice(labelStart, labelEnd);
    }
    ref2 = state2.env.references[normalizeReference(label)];
    if (!ref2) {
      state2.pos = oldPos;
      return false;
    }
    href = ref2.href;
    title = ref2.title;
  }
  if (!silent2) {
    content = state2.src.slice(labelStart, labelEnd);
    const tokens = [];
    state2.md.inline.parse(
      content,
      state2.md,
      state2.env,
      tokens
    );
    const token2 = state2.push("image", "img", 0);
    const attrs = [["src", href], ["alt", ""]];
    token2.attrs = attrs;
    token2.children = tokens;
    token2.content = content;
    if (title) {
      attrs.push(["title", title]);
    }
  }
  state2.pos = pos;
  state2.posMax = max;
  return true;
}
const EMAIL_RE = /^([a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
const AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.-]{1,31}):([^<>\x00-\x20]*)$/;
function autolink(state2, silent2) {
  let pos = state2.pos;
  if (state2.src.charCodeAt(pos) !== 60) {
    return false;
  }
  const start = state2.pos;
  const max = state2.posMax;
  for (; ; ) {
    if (++pos >= max) return false;
    const ch = state2.src.charCodeAt(pos);
    if (ch === 60) return false;
    if (ch === 62) break;
  }
  const url = state2.src.slice(start + 1, pos);
  if (AUTOLINK_RE.test(url)) {
    const fullUrl = state2.md.normalizeLink(url);
    if (!state2.md.validateLink(fullUrl)) {
      return false;
    }
    if (!silent2) {
      const token_o = state2.push("link_open", "a", 1);
      token_o.attrs = [["href", fullUrl]];
      token_o.markup = "autolink";
      token_o.info = "auto";
      const token_t = state2.push("text", "", 0);
      token_t.content = state2.md.normalizeLinkText(url);
      const token_c = state2.push("link_close", "a", -1);
      token_c.markup = "autolink";
      token_c.info = "auto";
    }
    state2.pos += url.length + 2;
    return true;
  }
  if (EMAIL_RE.test(url)) {
    const fullUrl = state2.md.normalizeLink("mailto:" + url);
    if (!state2.md.validateLink(fullUrl)) {
      return false;
    }
    if (!silent2) {
      const token_o = state2.push("link_open", "a", 1);
      token_o.attrs = [["href", fullUrl]];
      token_o.markup = "autolink";
      token_o.info = "auto";
      const token_t = state2.push("text", "", 0);
      token_t.content = state2.md.normalizeLinkText(url);
      const token_c = state2.push("link_close", "a", -1);
      token_c.markup = "autolink";
      token_c.info = "auto";
    }
    state2.pos += url.length + 2;
    return true;
  }
  return false;
}
function isLinkOpen(str) {
  return /^<a[>\s]/i.test(str);
}
function isLinkClose(str) {
  return /^<\/a\s*>/i.test(str);
}
function isLetter(ch) {
  const lc = ch | 32;
  return lc >= 97 && lc <= 122;
}
function html_inline(state2, silent2) {
  if (!state2.md.options.html) {
    return false;
  }
  const max = state2.posMax;
  const pos = state2.pos;
  if (state2.src.charCodeAt(pos) !== 60 || pos + 2 >= max) {
    return false;
  }
  const ch = state2.src.charCodeAt(pos + 1);
  if (ch !== 33 && ch !== 63 && ch !== 47 && !isLetter(ch)) {
    return false;
  }
  const match3 = state2.src.slice(pos).match(HTML_TAG_RE);
  if (!match3) {
    return false;
  }
  if (!silent2) {
    const token2 = state2.push("html_inline", "", 0);
    token2.content = match3[0];
    if (isLinkOpen(token2.content)) state2.linkLevel++;
    if (isLinkClose(token2.content)) state2.linkLevel--;
  }
  state2.pos += match3[0].length;
  return true;
}
const DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
const NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;
function entity(state2, silent2) {
  const pos = state2.pos;
  const max = state2.posMax;
  if (state2.src.charCodeAt(pos) !== 38) return false;
  if (pos + 1 >= max) return false;
  const ch = state2.src.charCodeAt(pos + 1);
  if (ch === 35) {
    const match3 = state2.src.slice(pos).match(DIGITAL_RE);
    if (match3) {
      if (!silent2) {
        const code2 = match3[1][0].toLowerCase() === "x" ? parseInt(match3[1].slice(1), 16) : parseInt(match3[1], 10);
        const token2 = state2.push("text_special", "", 0);
        token2.content = isValidEntityCode(code2) ? fromCodePoint(code2) : fromCodePoint(65533);
        token2.markup = match3[0];
        token2.info = "entity";
      }
      state2.pos += match3[0].length;
      return true;
    }
  } else {
    const match3 = state2.src.slice(pos).match(NAMED_RE);
    if (match3) {
      const decoded = decodeHTML(match3[0]);
      if (decoded !== match3[0]) {
        if (!silent2) {
          const token2 = state2.push("text_special", "", 0);
          token2.content = decoded;
          token2.markup = match3[0];
          token2.info = "entity";
        }
        state2.pos += match3[0].length;
        return true;
      }
    }
  }
  return false;
}
function processDelimiters(delimiters) {
  const openersBottom = {};
  const max = delimiters.length;
  if (!max) return;
  let headerIdx = 0;
  let lastTokenIdx = -2;
  const jumps = [];
  for (let closerIdx = 0; closerIdx < max; closerIdx++) {
    const closer = delimiters[closerIdx];
    jumps.push(0);
    if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {
      headerIdx = closerIdx;
    }
    lastTokenIdx = closer.token;
    closer.length = closer.length || 0;
    if (!closer.close) continue;
    if (!openersBottom.hasOwnProperty(closer.marker)) {
      openersBottom[closer.marker] = [-1, -1, -1, -1, -1, -1];
    }
    const minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + closer.length % 3];
    let openerIdx = headerIdx - jumps[headerIdx] - 1;
    let newMinOpenerIdx = openerIdx;
    for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {
      const opener = delimiters[openerIdx];
      if (opener.marker !== closer.marker) continue;
      if (opener.open && opener.end < 0) {
        let isOddMatch = false;
        if (opener.close || closer.open) {
          if ((opener.length + closer.length) % 3 === 0) {
            if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {
              isOddMatch = true;
            }
          }
        }
        if (!isOddMatch) {
          const lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ? jumps[openerIdx - 1] + 1 : 0;
          jumps[closerIdx] = closerIdx - openerIdx + lastJump;
          jumps[openerIdx] = lastJump;
          closer.open = false;
          opener.end = closerIdx;
          opener.close = false;
          newMinOpenerIdx = -1;
          lastTokenIdx = -2;
          break;
        }
      }
    }
    if (newMinOpenerIdx !== -1) {
      openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length || 0) % 3] = newMinOpenerIdx;
    }
  }
}
function link_pairs(state2) {
  const tokens_meta = state2.tokens_meta;
  const max = state2.tokens_meta.length;
  processDelimiters(state2.delimiters);
  for (let curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      processDelimiters(tokens_meta[curr].delimiters);
    }
  }
}
function fragments_join(state2) {
  let curr, last;
  let level = 0;
  const tokens = state2.tokens;
  const max = state2.tokens.length;
  for (curr = last = 0; curr < max; curr++) {
    if (tokens[curr].nesting < 0) level--;
    tokens[curr].level = level;
    if (tokens[curr].nesting > 0) level++;
    if (tokens[curr].type === "text" && curr + 1 < max && tokens[curr + 1].type === "text") {
      tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
    } else {
      if (curr !== last) {
        tokens[last] = tokens[curr];
      }
      last++;
    }
  }
  if (curr !== last) {
    tokens.length = last;
  }
}
const _rules = [
  ["text", text],
  ["linkify", linkify],
  ["newline", newline],
  ["escape", escape$1],
  ["backticks", backtick],
  ["strikethrough", r_strikethrough.tokenize],
  ["emphasis", r_emphasis.tokenize],
  ["link", link],
  ["image", image],
  ["autolink", autolink],
  ["html_inline", html_inline],
  ["entity", entity]
];
const _rules2 = [
  ["balance_pairs", link_pairs],
  ["strikethrough", r_strikethrough.postProcess],
  ["emphasis", r_emphasis.postProcess],
  // rules for pairs separate '**' into its own text tokens, which may be left unused,
  // rule below merges unused segments back with the rest of the text
  ["fragments_join", fragments_join]
];
function ParserInline() {
  this.ruler = new Ruler();
  for (let i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }
  this.ruler2 = new Ruler();
  for (let i = 0; i < _rules2.length; i++) {
    this.ruler2.push(_rules2[i][0], _rules2[i][1]);
  }
}
ParserInline.prototype.skipToken = function(state2) {
  const pos = state2.pos;
  const rules = this.ruler.getRules("");
  const len = rules.length;
  const maxNesting = state2.md.options.maxNesting;
  const cache = state2.cache;
  if (typeof cache[pos] !== "undefined") {
    state2.pos = cache[pos];
    return;
  }
  let ok = false;
  if (state2.level < maxNesting) {
    for (let i = 0; i < len; i++) {
      state2.level++;
      ok = rules[i](state2, true);
      state2.level--;
      if (ok) {
        if (pos >= state2.pos) {
          throw new Error("inline rule didn't increment state.pos");
        }
        break;
      }
    }
  } else {
    state2.pos = state2.posMax;
  }
  if (!ok) {
    state2.pos++;
  }
  cache[pos] = state2.pos;
};
ParserInline.prototype.tokenize = function(state2) {
  const rules = this.ruler.getRules("");
  const len = rules.length;
  const end = state2.posMax;
  const maxNesting = state2.md.options.maxNesting;
  while (state2.pos < end) {
    const prevPos = state2.pos;
    let ok = false;
    if (state2.level < maxNesting) {
      for (let i = 0; i < len; i++) {
        ok = rules[i](state2, false);
        if (ok) {
          if (prevPos >= state2.pos) {
            throw new Error("inline rule didn't increment state.pos");
          }
          break;
        }
      }
    }
    if (ok) {
      if (state2.pos >= end) {
        break;
      }
      continue;
    }
    state2.pending += state2.src[state2.pos++];
  }
  if (state2.pending) {
    state2.pushPending();
  }
};
ParserInline.prototype.parse = function(str, md, env, outTokens) {
  const state2 = new this.State(str, md, env, outTokens);
  this.tokenize(state2);
  const rules = this.ruler2.getRules("");
  const len = rules.length;
  for (let i = 0; i < len; i++) {
    rules[i](state2);
  }
};
ParserInline.prototype.State = StateInline;
function reFactory(opts) {
  const re = {};
  opts = opts || {};
  re.src_Any = Any.source;
  re.src_Cc = Cc.source;
  re.src_Z = Z.source;
  re.src_P = P$1.source;
  re.src_ZPCc = [re.src_Z, re.src_P, re.src_Cc].join("|");
  re.src_ZCc = [re.src_Z, re.src_Cc].join("|");
  const text_separators = "[><｜]";
  re.src_pseudo_letter = "(?:(?!" + text_separators + "|" + re.src_ZPCc + ")" + re.src_Any + ")";
  re.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)";
  re.src_auth = "(?:(?:(?!" + re.src_ZCc + "|[@/\\[\\]()]).)+@)?";
  re.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?";
  re.src_host_terminator = "(?=$|" + text_separators + "|" + re.src_ZPCc + ")(?!" + (opts["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + re.src_ZPCc + "))";
  re.src_path = "(?:[/?#](?:(?!" + re.src_ZCc + "|" + text_separators + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + re.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + re.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + re.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + re.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + re.src_ZCc + "|[']).)+\\'|\\'(?=" + re.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + re.src_ZCc + "|[.]|$)|" + (opts["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + // allow `,,,` in paths
  ",(?!" + re.src_ZCc + "|$)|;(?!" + re.src_ZCc + "|$)|\\!+(?!" + re.src_ZCc + "|[!]|$)|\\?(?!" + re.src_ZCc + "|[?]|$))+|\\/)?";
  re.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*';
  re.src_xn = "xn--[a-z0-9\\-]{1,59}";
  re.src_domain_root = // Allow letters & digits (http://test1)
  "(?:" + re.src_xn + "|" + re.src_pseudo_letter + "{1,63})";
  re.src_domain = "(?:" + re.src_xn + "|(?:" + re.src_pseudo_letter + ")|(?:" + re.src_pseudo_letter + "(?:-|" + re.src_pseudo_letter + "){0,61}" + re.src_pseudo_letter + "))";
  re.src_host = "(?:(?:(?:(?:" + re.src_domain + ")\\.)*" + re.src_domain + "))";
  re.tpl_host_fuzzy = "(?:" + re.src_ip4 + "|(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%)))";
  re.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%))";
  re.src_host_strict = re.src_host + re.src_host_terminator;
  re.tpl_host_fuzzy_strict = re.tpl_host_fuzzy + re.src_host_terminator;
  re.src_host_port_strict = re.src_host + re.src_port + re.src_host_terminator;
  re.tpl_host_port_fuzzy_strict = re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;
  re.tpl_host_port_no_ip_fuzzy_strict = re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;
  re.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + re.src_ZPCc + "|>|$))";
  re.tpl_email_fuzzy = "(^|" + text_separators + '|"|\\(|' + re.src_ZCc + ")(" + re.src_email_name + "@" + re.tpl_host_fuzzy_strict + ")";
  re.tpl_link_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  "(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|" + re.src_ZPCc + "))((?![$+<=>^`|｜])" + re.tpl_host_port_fuzzy_strict + re.src_path + ")";
  re.tpl_link_no_ip_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  "(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|" + re.src_ZPCc + "))((?![$+<=>^`|｜])" + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ")";
  return re;
}
function assign$1(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  sources.forEach(function(source) {
    if (!source) {
      return;
    }
    Object.keys(source).forEach(function(key) {
      obj[key] = source[key];
    });
  });
  return obj;
}
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function isString$1(obj) {
  return _class(obj) === "[object String]";
}
function isObject(obj) {
  return _class(obj) === "[object Object]";
}
function isRegExp(obj) {
  return _class(obj) === "[object RegExp]";
}
function isFunction(obj) {
  return _class(obj) === "[object Function]";
}
function escapeRE(str) {
  return str.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
}
const defaultOptions$1 = {
  fuzzyLink: true,
  fuzzyEmail: true,
  fuzzyIP: false
};
function isOptionsObj(obj) {
  return Object.keys(obj || {}).reduce(function(acc, k2) {
    return acc || defaultOptions$1.hasOwnProperty(k2);
  }, false);
}
const defaultSchemas = {
  "http:": {
    validate: function(text2, pos, self2) {
      const tail = text2.slice(pos);
      if (!self2.re.http) {
        self2.re.http = new RegExp(
          "^\\/\\/" + self2.re.src_auth + self2.re.src_host_port_strict + self2.re.src_path,
          "i"
        );
      }
      if (self2.re.http.test(tail)) {
        return tail.match(self2.re.http)[0].length;
      }
      return 0;
    }
  },
  "https:": "http:",
  "ftp:": "http:",
  "//": {
    validate: function(text2, pos, self2) {
      const tail = text2.slice(pos);
      if (!self2.re.no_http) {
        self2.re.no_http = new RegExp(
          "^" + self2.re.src_auth + // Don't allow single-level domains, because of false positives like '//test'
          // with code comments
          "(?:localhost|(?:(?:" + self2.re.src_domain + ")\\.)+" + self2.re.src_domain_root + ")" + self2.re.src_port + self2.re.src_host_terminator + self2.re.src_path,
          "i"
        );
      }
      if (self2.re.no_http.test(tail)) {
        if (pos >= 3 && text2[pos - 3] === ":") {
          return 0;
        }
        if (pos >= 3 && text2[pos - 3] === "/") {
          return 0;
        }
        return tail.match(self2.re.no_http)[0].length;
      }
      return 0;
    }
  },
  "mailto:": {
    validate: function(text2, pos, self2) {
      const tail = text2.slice(pos);
      if (!self2.re.mailto) {
        self2.re.mailto = new RegExp(
          "^" + self2.re.src_email_name + "@" + self2.re.src_host_strict,
          "i"
        );
      }
      if (self2.re.mailto.test(tail)) {
        return tail.match(self2.re.mailto)[0].length;
      }
      return 0;
    }
  }
};
const tlds_2ch_src_re = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
const tlds_default = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф".split("|");
function resetScanCache(self2) {
  self2.__index__ = -1;
  self2.__text_cache__ = "";
}
function createValidator(re) {
  return function(text2, pos) {
    const tail = text2.slice(pos);
    if (re.test(tail)) {
      return tail.match(re)[0].length;
    }
    return 0;
  };
}
function createNormalizer() {
  return function(match3, self2) {
    self2.normalize(match3);
  };
}
function compile$1(self2) {
  const re = self2.re = reFactory(self2.__opts__);
  const tlds2 = self2.__tlds__.slice();
  self2.onCompile();
  if (!self2.__tlds_replaced__) {
    tlds2.push(tlds_2ch_src_re);
  }
  tlds2.push(re.src_xn);
  re.src_tlds = tlds2.join("|");
  function untpl(tpl) {
    return tpl.replace("%TLDS%", re.src_tlds);
  }
  re.email_fuzzy = RegExp(untpl(re.tpl_email_fuzzy), "i");
  re.link_fuzzy = RegExp(untpl(re.tpl_link_fuzzy), "i");
  re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), "i");
  re.host_fuzzy_test = RegExp(untpl(re.tpl_host_fuzzy_test), "i");
  const aliases2 = [];
  self2.__compiled__ = {};
  function schemaError(name, val) {
    throw new Error('(LinkifyIt) Invalid schema "' + name + '": ' + val);
  }
  Object.keys(self2.__schemas__).forEach(function(name) {
    const val = self2.__schemas__[name];
    if (val === null) {
      return;
    }
    const compiled = { validate: null, link: null };
    self2.__compiled__[name] = compiled;
    if (isObject(val)) {
      if (isRegExp(val.validate)) {
        compiled.validate = createValidator(val.validate);
      } else if (isFunction(val.validate)) {
        compiled.validate = val.validate;
      } else {
        schemaError(name, val);
      }
      if (isFunction(val.normalize)) {
        compiled.normalize = val.normalize;
      } else if (!val.normalize) {
        compiled.normalize = createNormalizer();
      } else {
        schemaError(name, val);
      }
      return;
    }
    if (isString$1(val)) {
      aliases2.push(name);
      return;
    }
    schemaError(name, val);
  });
  aliases2.forEach(function(alias) {
    if (!self2.__compiled__[self2.__schemas__[alias]]) {
      return;
    }
    self2.__compiled__[alias].validate = self2.__compiled__[self2.__schemas__[alias]].validate;
    self2.__compiled__[alias].normalize = self2.__compiled__[self2.__schemas__[alias]].normalize;
  });
  self2.__compiled__[""] = { validate: null, normalize: createNormalizer() };
  const slist = Object.keys(self2.__compiled__).filter(function(name) {
    return name.length > 0 && self2.__compiled__[name];
  }).map(escapeRE).join("|");
  self2.re.schema_test = RegExp("(^|(?!_)(?:[><｜]|" + re.src_ZPCc + "))(" + slist + ")", "i");
  self2.re.schema_search = RegExp("(^|(?!_)(?:[><｜]|" + re.src_ZPCc + "))(" + slist + ")", "ig");
  self2.re.schema_at_start = RegExp("^" + self2.re.schema_search.source, "i");
  self2.re.pretest = RegExp(
    "(" + self2.re.schema_test.source + ")|(" + self2.re.host_fuzzy_test.source + ")|@",
    "i"
  );
  resetScanCache(self2);
}
function Match(self2, shift) {
  const start = self2.__index__;
  const end = self2.__last_index__;
  const text2 = self2.__text_cache__.slice(start, end);
  this.schema = self2.__schema__.toLowerCase();
  this.index = start + shift;
  this.lastIndex = end + shift;
  this.raw = text2;
  this.text = text2;
  this.url = text2;
}
function createMatch(self2, shift) {
  const match3 = new Match(self2, shift);
  self2.__compiled__[match3.schema].normalize(match3, self2);
  return match3;
}
function LinkifyIt(schemas, options) {
  if (!(this instanceof LinkifyIt)) {
    return new LinkifyIt(schemas, options);
  }
  if (!options) {
    if (isOptionsObj(schemas)) {
      options = schemas;
      schemas = {};
    }
  }
  this.__opts__ = assign$1({}, defaultOptions$1, options);
  this.__index__ = -1;
  this.__last_index__ = -1;
  this.__schema__ = "";
  this.__text_cache__ = "";
  this.__schemas__ = assign$1({}, defaultSchemas, schemas);
  this.__compiled__ = {};
  this.__tlds__ = tlds_default;
  this.__tlds_replaced__ = false;
  this.re = {};
  compile$1(this);
}
LinkifyIt.prototype.add = function add(schema, definition) {
  this.__schemas__[schema] = definition;
  compile$1(this);
  return this;
};
LinkifyIt.prototype.set = function set(options) {
  this.__opts__ = assign$1(this.__opts__, options);
  return this;
};
LinkifyIt.prototype.test = function test(text2) {
  this.__text_cache__ = text2;
  this.__index__ = -1;
  if (!text2.length) {
    return false;
  }
  let m2, ml, me, len, shift, next2, re, tld_pos, at_pos;
  if (this.re.schema_test.test(text2)) {
    re = this.re.schema_search;
    re.lastIndex = 0;
    while ((m2 = re.exec(text2)) !== null) {
      len = this.testSchemaAt(text2, m2[2], re.lastIndex);
      if (len) {
        this.__schema__ = m2[2];
        this.__index__ = m2.index + m2[1].length;
        this.__last_index__ = m2.index + m2[0].length + len;
        break;
      }
    }
  }
  if (this.__opts__.fuzzyLink && this.__compiled__["http:"]) {
    tld_pos = text2.search(this.re.host_fuzzy_test);
    if (tld_pos >= 0) {
      if (this.__index__ < 0 || tld_pos < this.__index__) {
        if ((ml = text2.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {
          shift = ml.index + ml[1].length;
          if (this.__index__ < 0 || shift < this.__index__) {
            this.__schema__ = "";
            this.__index__ = shift;
            this.__last_index__ = ml.index + ml[0].length;
          }
        }
      }
    }
  }
  if (this.__opts__.fuzzyEmail && this.__compiled__["mailto:"]) {
    at_pos = text2.indexOf("@");
    if (at_pos >= 0) {
      if ((me = text2.match(this.re.email_fuzzy)) !== null) {
        shift = me.index + me[1].length;
        next2 = me.index + me[0].length;
        if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next2 > this.__last_index__) {
          this.__schema__ = "mailto:";
          this.__index__ = shift;
          this.__last_index__ = next2;
        }
      }
    }
  }
  return this.__index__ >= 0;
};
LinkifyIt.prototype.pretest = function pretest(text2) {
  return this.re.pretest.test(text2);
};
LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text2, schema, pos) {
  if (!this.__compiled__[schema.toLowerCase()]) {
    return 0;
  }
  return this.__compiled__[schema.toLowerCase()].validate(text2, pos, this);
};
LinkifyIt.prototype.match = function match(text2) {
  const result = [];
  let shift = 0;
  if (this.__index__ >= 0 && this.__text_cache__ === text2) {
    result.push(createMatch(this, shift));
    shift = this.__last_index__;
  }
  let tail = shift ? text2.slice(shift) : text2;
  while (this.test(tail)) {
    result.push(createMatch(this, shift));
    tail = tail.slice(this.__last_index__);
    shift += this.__last_index__;
  }
  if (result.length) {
    return result;
  }
  return null;
};
LinkifyIt.prototype.matchAtStart = function matchAtStart(text2) {
  this.__text_cache__ = text2;
  this.__index__ = -1;
  if (!text2.length) return null;
  const m2 = this.re.schema_at_start.exec(text2);
  if (!m2) return null;
  const len = this.testSchemaAt(text2, m2[2], m2[0].length);
  if (!len) return null;
  this.__schema__ = m2[2];
  this.__index__ = m2.index + m2[1].length;
  this.__last_index__ = m2.index + m2[0].length + len;
  return createMatch(this, 0);
};
LinkifyIt.prototype.tlds = function tlds(list2, keepOld) {
  list2 = Array.isArray(list2) ? list2 : [list2];
  if (!keepOld) {
    this.__tlds__ = list2.slice();
    this.__tlds_replaced__ = true;
    compile$1(this);
    return this;
  }
  this.__tlds__ = this.__tlds__.concat(list2).sort().filter(function(el, idx, arr) {
    return el !== arr[idx - 1];
  }).reverse();
  compile$1(this);
  return this;
};
LinkifyIt.prototype.normalize = function normalize2(match3) {
  if (!match3.schema) {
    match3.url = "http://" + match3.url;
  }
  if (match3.schema === "mailto:" && !/^mailto:/i.test(match3.url)) {
    match3.url = "mailto:" + match3.url;
  }
};
LinkifyIt.prototype.onCompile = function onCompile() {
};
const maxInt = 2147483647;
const base = 36;
const tMin = 1;
const tMax = 26;
const skew = 38;
const damp = 700;
const initialBias = 72;
const initialN = 128;
const delimiter$1 = "-";
const regexPunycode = /^xn--/;
const regexNonASCII = /[^\0-\x7F]/;
const regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
const errors = {
  "overflow": "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
};
const baseMinusTMin = base - tMin;
const floor = Math.floor;
const stringFromCharCode = String.fromCharCode;
function error(type) {
  throw new RangeError(errors[type]);
}
function map(array, callback) {
  const result = [];
  let length2 = array.length;
  while (length2--) {
    result[length2] = callback(array[length2]);
  }
  return result;
}
function mapDomain(domain, callback) {
  const parts = domain.split("@");
  let result = "";
  if (parts.length > 1) {
    result = parts[0] + "@";
    domain = parts[1];
  }
  domain = domain.replace(regexSeparators, ".");
  const labels = domain.split(".");
  const encoded = map(labels, callback).join(".");
  return result + encoded;
}
function ucs2decode(string) {
  const output = [];
  let counter = 0;
  const length2 = string.length;
  while (counter < length2) {
    const value = string.charCodeAt(counter++);
    if (value >= 55296 && value <= 56319 && counter < length2) {
      const extra = string.charCodeAt(counter++);
      if ((extra & 64512) == 56320) {
        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
}
const basicToDigit = function(codePoint) {
  if (codePoint >= 48 && codePoint < 58) {
    return 26 + (codePoint - 48);
  }
  if (codePoint >= 65 && codePoint < 91) {
    return codePoint - 65;
  }
  if (codePoint >= 97 && codePoint < 123) {
    return codePoint - 97;
  }
  return base;
};
const digitToBasic = function(digit, flag) {
  return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
};
const adapt = function(delta, numPoints, firstTime) {
  let k2 = 0;
  delta = firstTime ? floor(delta / damp) : delta >> 1;
  delta += floor(delta / numPoints);
  for (; delta > baseMinusTMin * tMax >> 1; k2 += base) {
    delta = floor(delta / baseMinusTMin);
  }
  return floor(k2 + (baseMinusTMin + 1) * delta / (delta + skew));
};
const decode = function(input) {
  const output = [];
  const inputLength = input.length;
  let i = 0;
  let n = initialN;
  let bias = initialBias;
  let basic = input.lastIndexOf(delimiter$1);
  if (basic < 0) {
    basic = 0;
  }
  for (let j2 = 0; j2 < basic; ++j2) {
    if (input.charCodeAt(j2) >= 128) {
      error("not-basic");
    }
    output.push(input.charCodeAt(j2));
  }
  for (let index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
    const oldi = i;
    for (let w2 = 1, k2 = base; ; k2 += base) {
      if (index >= inputLength) {
        error("invalid-input");
      }
      const digit = basicToDigit(input.charCodeAt(index++));
      if (digit >= base) {
        error("invalid-input");
      }
      if (digit > floor((maxInt - i) / w2)) {
        error("overflow");
      }
      i += digit * w2;
      const t = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
      if (digit < t) {
        break;
      }
      const baseMinusT = base - t;
      if (w2 > floor(maxInt / baseMinusT)) {
        error("overflow");
      }
      w2 *= baseMinusT;
    }
    const out = output.length + 1;
    bias = adapt(i - oldi, out, oldi == 0);
    if (floor(i / out) > maxInt - n) {
      error("overflow");
    }
    n += floor(i / out);
    i %= out;
    output.splice(i++, 0, n);
  }
  return String.fromCodePoint(...output);
};
const encode = function(input) {
  const output = [];
  input = ucs2decode(input);
  const inputLength = input.length;
  let n = initialN;
  let delta = 0;
  let bias = initialBias;
  for (const currentValue of input) {
    if (currentValue < 128) {
      output.push(stringFromCharCode(currentValue));
    }
  }
  const basicLength = output.length;
  let handledCPCount = basicLength;
  if (basicLength) {
    output.push(delimiter$1);
  }
  while (handledCPCount < inputLength) {
    let m2 = maxInt;
    for (const currentValue of input) {
      if (currentValue >= n && currentValue < m2) {
        m2 = currentValue;
      }
    }
    const handledCPCountPlusOne = handledCPCount + 1;
    if (m2 - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
      error("overflow");
    }
    delta += (m2 - n) * handledCPCountPlusOne;
    n = m2;
    for (const currentValue of input) {
      if (currentValue < n && ++delta > maxInt) {
        error("overflow");
      }
      if (currentValue === n) {
        let q = delta;
        for (let k2 = base; ; k2 += base) {
          const t = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
          if (q < t) {
            break;
          }
          const qMinusT = q - t;
          const baseMinusT = base - t;
          output.push(
            stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
          );
          q = floor(qMinusT / baseMinusT);
        }
        output.push(stringFromCharCode(digitToBasic(q, 0)));
        bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
        delta = 0;
        ++handledCPCount;
      }
    }
    ++delta;
    ++n;
  }
  return output.join("");
};
const toUnicode = function(input) {
  return mapDomain(input, function(string) {
    return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
  });
};
const toASCII = function(input) {
  return mapDomain(input, function(string) {
    return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
  });
};
const punycode = {
  "toASCII": toASCII,
  "toUnicode": toUnicode
};
const cfg_default = {
  options: {
    // Enable HTML tags in source
    html: false,
    // Use '/' to close single tags (<br />)
    xhtmlOut: false,
    // Convert '\n' in paragraphs into <br>
    breaks: false,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: false,
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: "“”‘’",
    /* “”‘’ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 100
  },
  components: {
    core: {},
    block: {},
    inline: {}
  }
};
const cfg_zero = {
  options: {
    // Enable HTML tags in source
    html: false,
    // Use '/' to close single tags (<br />)
    xhtmlOut: false,
    // Convert '\n' in paragraphs into <br>
    breaks: false,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: false,
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: "“”‘’",
    /* “”‘’ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "text"
      ],
      rules2: [
        "balance_pairs",
        "fragments_join"
      ]
    }
  }
};
const cfg_commonmark = {
  options: {
    // Enable HTML tags in source
    html: true,
    // Use '/' to close single tags (<br />)
    xhtmlOut: true,
    // Convert '\n' in paragraphs into <br>
    breaks: false,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: false,
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: "“”‘’",
    /* “”‘’ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "blockquote",
        "code",
        "fence",
        "heading",
        "hr",
        "html_block",
        "lheading",
        "list",
        "reference",
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "autolink",
        "backticks",
        "emphasis",
        "entity",
        "escape",
        "html_inline",
        "image",
        "link",
        "newline",
        "text"
      ],
      rules2: [
        "balance_pairs",
        "emphasis",
        "fragments_join"
      ]
    }
  }
};
const config$1 = {
  default: cfg_default,
  zero: cfg_zero,
  commonmark: cfg_commonmark
};
const BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
const GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;
function validateLink(url) {
  const str = url.trim().toLowerCase();
  return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) : true;
}
const RECODE_HOSTNAME_FOR = ["http:", "https:", "mailto:"];
function normalizeLink(url) {
  const parsed = urlParse(url, true);
  if (parsed.hostname) {
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toASCII(parsed.hostname);
      } catch (er) {
      }
    }
  }
  return encode$1(format$1(parsed));
}
function normalizeLinkText(url) {
  const parsed = urlParse(url, true);
  if (parsed.hostname) {
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toUnicode(parsed.hostname);
      } catch (er) {
      }
    }
  }
  return decode$1(format$1(parsed), decode$1.defaultChars + "%");
}
function MarkdownIt(presetName, options) {
  if (!(this instanceof MarkdownIt)) {
    return new MarkdownIt(presetName, options);
  }
  if (!options) {
    if (!isString$2(presetName)) {
      options = presetName || {};
      presetName = "default";
    }
  }
  this.inline = new ParserInline();
  this.block = new ParserBlock();
  this.core = new Core();
  this.renderer = new Renderer();
  this.linkify = new LinkifyIt();
  this.validateLink = validateLink;
  this.normalizeLink = normalizeLink;
  this.normalizeLinkText = normalizeLinkText;
  this.utils = utils$2;
  this.helpers = assign$2({}, helpers);
  this.options = {};
  this.configure(presetName);
  if (options) {
    this.set(options);
  }
}
MarkdownIt.prototype.set = function(options) {
  assign$2(this.options, options);
  return this;
};
MarkdownIt.prototype.configure = function(presets) {
  const self2 = this;
  if (isString$2(presets)) {
    const presetName = presets;
    presets = config$1[presetName];
    if (!presets) {
      throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
    }
  }
  if (!presets) {
    throw new Error("Wrong `markdown-it` preset, can't be empty");
  }
  if (presets.options) {
    self2.set(presets.options);
  }
  if (presets.components) {
    Object.keys(presets.components).forEach(function(name) {
      if (presets.components[name].rules) {
        self2[name].ruler.enableOnly(presets.components[name].rules);
      }
      if (presets.components[name].rules2) {
        self2[name].ruler2.enableOnly(presets.components[name].rules2);
      }
    });
  }
  return this;
};
MarkdownIt.prototype.enable = function(list2, ignoreInvalid) {
  let result = [];
  if (!Array.isArray(list2)) {
    list2 = [list2];
  }
  ["core", "block", "inline"].forEach(function(chain) {
    result = result.concat(this[chain].ruler.enable(list2, true));
  }, this);
  result = result.concat(this.inline.ruler2.enable(list2, true));
  const missed = list2.filter(function(name) {
    return result.indexOf(name) < 0;
  });
  if (missed.length && !ignoreInvalid) {
    throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + missed);
  }
  return this;
};
MarkdownIt.prototype.disable = function(list2, ignoreInvalid) {
  let result = [];
  if (!Array.isArray(list2)) {
    list2 = [list2];
  }
  ["core", "block", "inline"].forEach(function(chain) {
    result = result.concat(this[chain].ruler.disable(list2, true));
  }, this);
  result = result.concat(this.inline.ruler2.disable(list2, true));
  const missed = list2.filter(function(name) {
    return result.indexOf(name) < 0;
  });
  if (missed.length && !ignoreInvalid) {
    throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + missed);
  }
  return this;
};
MarkdownIt.prototype.use = function(plugin) {
  const args = [this].concat(Array.prototype.slice.call(arguments, 1));
  plugin.apply(plugin, args);
  return this;
};
MarkdownIt.prototype.parse = function(src, env) {
  if (typeof src !== "string") {
    throw new Error("Input data should be a String");
  }
  const state2 = new this.core.State(src, this, env);
  this.core.process(state2);
  return state2.tokens;
};
MarkdownIt.prototype.render = function(src, env) {
  env = env || {};
  return this.renderer.render(this.parse(src, env), this.options, env);
};
MarkdownIt.prototype.parseInline = function(src, env) {
  const state2 = new this.core.State(src, this, env);
  state2.inlineMode = true;
  this.core.process(state2);
  return state2.tokens;
};
MarkdownIt.prototype.renderInline = function(src, env) {
  env = env || {};
  return this.renderer.render(this.parseInline(src, env), this.options, env);
};
const UNESCAPE_RE = /\\([ \\!"#$%&'()*+,./:;<=>?@[\]^_`{|}~-])/g;
function superscript(state2, silent2) {
  const max = state2.posMax;
  const start = state2.pos;
  if (state2.src.charCodeAt(start) !== 94) {
    return false;
  }
  if (silent2) {
    return false;
  }
  if (start + 2 >= max) {
    return false;
  }
  state2.pos = start + 1;
  let found = false;
  while (state2.pos < max) {
    if (state2.src.charCodeAt(state2.pos) === 94) {
      found = true;
      break;
    }
    state2.md.inline.skipToken(state2);
  }
  if (!found || start + 1 === state2.pos) {
    state2.pos = start;
    return false;
  }
  const content = state2.src.slice(start + 1, state2.pos);
  if (content.match(/(^|[^\\])(\\\\)*\s/)) {
    state2.pos = start;
    return false;
  }
  state2.posMax = state2.pos;
  state2.pos = start + 1;
  const token_so = state2.push("sup_open", "sup", 1);
  token_so.markup = "^";
  const token_t = state2.push("text", "", 0);
  token_t.content = content.replace(UNESCAPE_RE, "$1");
  const token_sc = state2.push("sup_close", "sup", -1);
  token_sc.markup = "^";
  state2.pos = state2.posMax + 1;
  state2.posMax = max;
  return true;
}
function sup_plugin(md) {
  md.inline.ruler.after("emphasis", "sup", superscript);
}
var markdownItSanitizer$1;
var hasRequiredMarkdownItSanitizer;
function requireMarkdownItSanitizer() {
  if (hasRequiredMarkdownItSanitizer) return markdownItSanitizer$1;
  hasRequiredMarkdownItSanitizer = 1;
  markdownItSanitizer$1 = function sanitizer_plugin(md, options) {
    var linkify2 = md.linkify, escapeHtml2 = md.utils.escapeHtml, patternLinkOpen = '<a\\s([^<>]*href="[^"<>]*"[^<>]*)\\s?>', regexpLinkOpen = RegExp(patternLinkOpen, "i"), patternImage = '<img\\s([^<>]*src="[^"<>]*"[^<>]*)\\s?\\/?>', regexpImage = RegExp(patternImage, "i"), regexpImageProtocols = /^(?:https?:)?\/\//i, regexpLinkProtocols = /^(?:https?:\/\/|ftp:\/\/|\/\/|mailto:|xmpp:)/i;
    options = options ? options : {};
    var removeUnknown = typeof options.removeUnknown !== "undefined" ? options.removeUnknown : false;
    var removeUnbalanced = typeof options.removeUnbalanced !== "undefined" ? options.removeUnbalanced : false;
    var imageClass = typeof options.imageClass !== "undefined" ? options.imageClass : "";
    var runBalancer = false;
    var j2;
    var allowedTags = [
      "a",
      "b",
      "blockquote",
      "code",
      "em",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "li",
      "ol",
      "p",
      "pre",
      "s",
      "sub",
      "sup",
      "strong",
      "ul"
    ];
    var openTagCount = new Array(allowedTags.length);
    var removeTag = new Array(allowedTags.length);
    for (j2 = 0; j2 < allowedTags.length; j2++) {
      openTagCount[j2] = 0;
    }
    for (j2 = 0; j2 < allowedTags.length; j2++) {
      removeTag[j2] = false;
    }
    function getUrl(link2) {
      var match3 = linkify2.match(link2);
      if (match3 && match3.length === 1 && match3[0].index === 0 && match3[0].lastIndex === link2.length) {
        return match3[0].url;
      }
      return null;
    }
    function replaceUnknownTags(str) {
      str = str.replace(/<[^<>]*>?/gi, function(tag) {
        var match3, attrs, url, alt, title, tagnameIndex;
        if (/(^<->|^<-\s|^<3\s)/.test(tag)) {
          return tag;
        }
        match3 = tag.match(regexpImage);
        if (match3) {
          attrs = match3[1];
          url = getUrl(attrs.match(/src="([^"<>]*)"/i)[1]);
          alt = attrs.match(/alt="([^"<>]*)"/i);
          alt = alt && typeof alt[1] !== "undefined" ? alt[1] : "";
          title = attrs.match(/title="([^"<>]*)"/i);
          title = title && typeof title[1] !== "undefined" ? title[1] : "";
          if (url && regexpImageProtocols.test(url)) {
            if (imageClass !== "") {
              return '<img src="' + url + '" alt="' + alt + '" title="' + title + '" class="' + imageClass + '">';
            }
            return '<img src="' + url + '" alt="' + alt + '" title="' + title + '">';
          }
        }
        tagnameIndex = allowedTags.indexOf("a");
        match3 = tag.match(regexpLinkOpen);
        if (match3) {
          attrs = match3[1];
          url = getUrl(attrs.match(/href="([^"<>]*)"/i)[1]);
          title = attrs.match(/title="([^"<>]*)"/i);
          title = title && typeof title[1] !== "undefined" ? title[1] : "";
          if (url && regexpLinkProtocols.test(url)) {
            runBalancer = true;
            openTagCount[tagnameIndex] += 1;
            return '<a href="' + url + '" title="' + title + '" target="_blank">';
          }
        }
        match3 = /<\/a>/i.test(tag);
        if (match3) {
          runBalancer = true;
          openTagCount[tagnameIndex] -= 1;
          if (openTagCount[tagnameIndex] < 0) {
            removeTag[tagnameIndex] = true;
          }
          return "</a>";
        }
        match3 = tag.match(/<(br|hr)\s?\/?>/i);
        if (match3) {
          return "<" + match3[1].toLowerCase() + ">";
        }
        match3 = tag.match(/<(\/?)(b|blockquote|code|em|h[1-6]|li|ol(?: start="\d+")?|p|pre|s|sub|sup|strong|ul)>/i);
        if (match3 && !/<\/ol start="\d+"/i.test(tag)) {
          runBalancer = true;
          tagnameIndex = allowedTags.indexOf(match3[2].toLowerCase().split(" ")[0]);
          if (match3[1] === "/") {
            openTagCount[tagnameIndex] -= 1;
          } else {
            openTagCount[tagnameIndex] += 1;
          }
          if (openTagCount[tagnameIndex] < 0) {
            removeTag[tagnameIndex] = true;
          }
          return "<" + match3[1] + match3[2].toLowerCase() + ">";
        }
        if (removeUnknown === true) {
          return "";
        }
        return escapeHtml2(tag);
      });
      return str;
    }
    function sanitizeInlineAndBlock(state2) {
      var i, blkIdx, inlineTokens;
      for (j2 = 0; j2 < allowedTags.length; j2++) {
        openTagCount[j2] = 0;
      }
      for (j2 = 0; j2 < allowedTags.length; j2++) {
        removeTag[j2] = false;
      }
      runBalancer = false;
      for (blkIdx = 0; blkIdx < state2.tokens.length; blkIdx++) {
        if (state2.tokens[blkIdx].type === "html_block") {
          state2.tokens[blkIdx].content = replaceUnknownTags(state2.tokens[blkIdx].content);
        }
        if (state2.tokens[blkIdx].type !== "inline") {
          continue;
        }
        inlineTokens = state2.tokens[blkIdx].children;
        for (i = 0; i < inlineTokens.length; i++) {
          if (inlineTokens[i].type === "html_inline") {
            inlineTokens[i].content = replaceUnknownTags(inlineTokens[i].content);
          }
        }
      }
    }
    function balance(state2) {
      if (runBalancer === false) {
        return;
      }
      var blkIdx, inlineTokens;
      function replaceUnbalancedTag(str, tagname) {
        var openingRegexp, closingRegexp;
        if (tagname === "a") {
          openingRegexp = RegExp('<a href="[^"<>]*" title="[^"<>]*" target="_blank">', "g");
        } else if (tagname === "ol") {
          openingRegexp = /<ol(?: start="\d+")?>/g;
        } else {
          openingRegexp = RegExp("<" + tagname + ">", "g");
        }
        closingRegexp = RegExp("</" + tagname + ">", "g");
        if (removeUnbalanced === true) {
          str = str.replace(openingRegexp, "");
          str = str.replace(closingRegexp, "");
        } else {
          str = str.replace(openingRegexp, function(m2) {
            return escapeHtml2(m2);
          });
          str = str.replace(closingRegexp, function(m2) {
            return escapeHtml2(m2);
          });
        }
        return str;
      }
      function replaceAllUnbalancedTags(str) {
        var i;
        for (i = 0; i < allowedTags.length; i++) {
          if (removeTag[i] === true) {
            str = replaceUnbalancedTag(str, allowedTags[i]);
          }
        }
        return str;
      }
      for (j2 = 0; j2 < allowedTags.length; j2++) {
        if (openTagCount[j2] !== 0) {
          removeTag[j2] = true;
        }
      }
      for (blkIdx = 0; blkIdx < state2.tokens.length; blkIdx++) {
        if (state2.tokens[blkIdx].type === "html_block") {
          state2.tokens[blkIdx].content = replaceAllUnbalancedTags(state2.tokens[blkIdx].content);
          continue;
        }
        if (state2.tokens[blkIdx].type !== "inline") {
          continue;
        }
        inlineTokens = state2.tokens[blkIdx].children;
        for (j2 = 0; j2 < inlineTokens.length; j2++) {
          if (inlineTokens[j2].type === "html_inline") {
            inlineTokens[j2].content = replaceAllUnbalancedTags(inlineTokens[j2].content);
          }
        }
      }
    }
    md.core.ruler.after("linkify", "sanitize_inline", sanitizeInlineAndBlock);
    md.core.ruler.after("sanitize_inline", "sanitize_balance", balance);
  };
  return markdownItSanitizer$1;
}
var markdownItSanitizerExports = requireMarkdownItSanitizer();
const markdownItSanitizer = /* @__PURE__ */ getDefaultExportFromCjs(markdownItSanitizerExports);
var markdownItClass$1;
var hasRequiredMarkdownItClass;
function requireMarkdownItClass() {
  if (hasRequiredMarkdownItClass) return markdownItClass$1;
  hasRequiredMarkdownItClass = 1;
  let mapping = {};
  const splitWithSpace = (s) => s ? s.split(" ") : [];
  const toArray = (a) => Array.isArray(a) ? a : [a];
  function parseTokens(tokens) {
    tokens.forEach((token2) => {
      if (/(_open$|image)/.test(token2.type) && mapping[token2.tag]) {
        const orig = splitWithSpace(token2.attrGet("class"));
        const addition = toArray(mapping[token2.tag]);
        token2.attrSet("class", [...orig, ...addition].join(" "));
      }
      if (token2.children) {
        parseTokens(token2.children);
      }
    });
  }
  function parseState(state2) {
    parseTokens(state2.tokens);
  }
  function markdownitTagToClass(md, _mapping) {
    mapping = _mapping || {};
    md.core.ruler.push("markdownit-tag-to-class", parseState);
  }
  markdownItClass$1 = markdownitTagToClass;
  return markdownItClass$1;
}
var markdownItClassExports = requireMarkdownItClass();
const markdownItClass = /* @__PURE__ */ getDefaultExportFromCjs(markdownItClassExports);
var markdownItLinkAttributes$1;
var hasRequiredMarkdownItLinkAttributes;
function requireMarkdownItLinkAttributes() {
  if (hasRequiredMarkdownItLinkAttributes) return markdownItLinkAttributes$1;
  hasRequiredMarkdownItLinkAttributes = 1;
  function findFirstMatchingConfig(link2, configs) {
    var i, config2;
    var href = link2.attrs[link2.attrIndex("href")][1];
    for (i = 0; i < configs.length; ++i) {
      config2 = configs[i];
      if (typeof config2.matcher === "function") {
        if (config2.matcher(href, config2)) {
          return config2;
        } else {
          continue;
        }
      }
      return config2;
    }
  }
  function applyAttributes(idx, tokens, attributes) {
    Object.keys(attributes).forEach(function(attr) {
      var attrIndex2;
      var value = attributes[attr];
      if (attr === "className") {
        attr = "class";
      }
      attrIndex2 = tokens[idx].attrIndex(attr);
      if (attrIndex2 < 0) {
        tokens[idx].attrPush([attr, value]);
      } else {
        tokens[idx].attrs[attrIndex2][1] = value;
      }
    });
  }
  function markdownitLinkAttributes(md, configs) {
    if (!configs) {
      configs = [];
    } else {
      configs = Array.isArray(configs) ? configs : [configs];
    }
    Object.freeze(configs);
    var defaultRender = md.renderer.rules.link_open || this.defaultRender;
    md.renderer.rules.link_open = function(tokens, idx, options, env, self2) {
      var config2 = findFirstMatchingConfig(tokens[idx], configs);
      var attributes = config2 && config2.attrs;
      if (attributes) {
        applyAttributes(idx, tokens, attributes);
      }
      return defaultRender(tokens, idx, options, env, self2);
    };
  }
  markdownitLinkAttributes.defaultRender = function(tokens, idx, options, env, self2) {
    return self2.renderToken(tokens, idx, options);
  };
  markdownItLinkAttributes$1 = markdownitLinkAttributes;
  return markdownItLinkAttributes$1;
}
var markdownItLinkAttributesExports = requireMarkdownItLinkAttributes();
const markdownItLinkAttributes = /* @__PURE__ */ getDefaultExportFromCjs(markdownItLinkAttributesExports);
const g$1 = (e, t, l) => {
  let n;
  const a = t, r2 = { ok: false, pos: t, value: "" };
  for (n = e.charAt(t); t < l && /\d/.test(n) || n === "%"; ) n = e.charAt(++t);
  return r2.ok = true, r2.pos = t, r2.value = e.slice(a, t), r2;
}, k$1 = (e, t, l) => {
  const n = { ok: false, pos: 0, width: "", height: "" };
  if (t >= l || e.charAt(t) !== "=") return n;
  t++;
  const a = e.charAt(t);
  if (a !== "x" && !/\d/.test(a)) return n;
  const r2 = g$1(e, t, l);
  if (t = r2.pos, e.charAt(t) !== "x") return n;
  t++;
  const i = g$1(e, t, l);
  return t = i.pos, n.width = r2.value, n.height = i.value, n.pos = t, n.ok = true, n;
}, x = (e, t) => {
  const l = e.env, n = e.pos, a = e.posMax;
  if (e.src.charAt(e.pos) !== "!" || e.src.charAt(e.pos + 1) !== "[") return false;
  const r2 = e.pos + 2, i = e.md.helpers.parseLinkLabel(e, e.pos + 1, false);
  if (i < 0) return false;
  let s = i + 1, o, p2 = "", h = "", m2 = "", d2 = "";
  if (s < a && e.src.charAt(s) === "(") {
    for (s++; s < a && (o = e.src.charAt(s), !(o !== " " && o !== "	")); ) s++;
    if (s >= a) return false;
    let c;
    c = e.md.helpers.parseLinkDestination(e.src, s, e.posMax), c.ok && (p2 = e.md.normalizeLink(c.str), e.md.validateLink(p2) ? s = c.pos : p2 = "");
    const f = s;
    for (; s < a && (o = e.src.charAt(s), !(o !== " " && o !== "	")); s++) ;
    if (c = e.md.helpers.parseLinkTitle(e.src, s, e.posMax), s < a && f !== s && c.ok) for (h = c.str, s = c.pos; s < a && (o = e.src.charAt(s), !(o !== " " && o !== "	")); s++) ;
    else h = "";
    if (s - 1 >= 0 && (o = e.src.charAt(s - 1), o === " " && (c = k$1(e.src, s, e.posMax), c.ok))) for (m2 = c.width, d2 = c.height, s = c.pos; s < a && (o = e.src.charAt(s), !(o !== " " && o !== `
`)); s++) ;
    if (s >= a || e.src.charAt(s) !== ")") return e.pos = n, false;
    s++;
  } else {
    let c = "";
    if (typeof l.references > "u") return false;
    for (; s < a && (o = e.src.charAt(s), !(o !== " " && o !== "	")); s++) ;
    if (s < a && e.src.charAt(s) === "[") {
      const u2 = s + 1;
      s = e.md.helpers.parseLinkLabel(e, s), s >= 0 ? c = e.src.slice(u2, s++) : s = i + 1;
    } else s = i + 1;
    c || (c = e.src.slice(r2, i));
    const f = l.references[e.md.utils.normalizeReference(c)];
    if (!f) return e.pos = n, false;
    p2 = f.href, h = f.title ?? "";
  }
  if (!t) {
    e.pos = r2, e.posMax = i;
    const c = e.src.slice(r2, i), f = [];
    e.md.inline.parse(c, e.md, e.env, f);
    const u2 = e.push("image", "img", 0);
    u2.attrs = [["src", p2], ["alt", ""]], h && u2.attrs.push(["title", h]), m2 && u2.attrs.push(["width", m2]), d2 && u2.attrs.push(["height", d2]), u2.children = f, u2.content = c;
  }
  return e.pos = s, e.posMax = a, true;
}, L$1 = (e) => {
  e.inline.ruler.before("emphasis", "image", x);
};
const g = (e) => e.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
const R = /[^\t\n\f />"'=]/, E = " ", w = "=", k = ".", v = "#", p = (e, t, { left: i, right: n, allowed: r2 }) => {
  let s = "", l = "", o = true, a = false;
  const f = [];
  for (let h = t + i.length; h < e.length; h++) {
    if (e.slice(h, h + n.length) === n) {
      s !== "" && f.push([s, l]);
      break;
    }
    const c = e.charAt(h);
    if (c === w && o) {
      o = false;
      continue;
    }
    if (c === k && s === "") {
      e.charAt(h + 1) === k ? (s = "css-module", h++) : s = "class", o = false;
      continue;
    }
    if (c === v && s === "") {
      s = "id", o = false;
      continue;
    }
    if (c === '"' && l === "") {
      a = true;
      continue;
    }
    if (c === '"' && a) {
      a = false;
      continue;
    }
    if (c === E && !a) {
      if (s === "") continue;
      f.push([s, l]), s = "", l = "", o = true;
      continue;
    }
    if (!(o && c.search(R) === -1)) {
      if (o) {
        s += c;
        continue;
      }
      l += c;
    }
  }
  return r2.length ? f.filter(([h]) => r2.some((c) => c instanceof RegExp ? c.test(h) : c === h)) : f;
}, u = (e, t) => {
  t && e.forEach((i) => {
    const [n, r2] = i;
    n === "class" ? t.attrJoin("class", r2) : n === "css-module" ? t.attrJoin("css-module", r2) : t.attrPush(i);
  });
}, d = (e, t, i) => (n) => {
  const r2 = t.length, s = i.length, l = r2 + 1 + s;
  if (!n || typeof n != "string" || n.length < l) return false;
  const o = (g2) => {
    const x2 = g2.charAt(r2) === ".", O = g2.charAt(r2) === "#";
    return x2 || O ? g2.length >= l + 1 : g2.length >= l;
  };
  let a, f, h, c;
  const y = l - s;
  switch (e) {
    case "start":
      h = n.slice(0, r2), a = h === t ? 0 : -1, f = a === -1 ? -1 : n.indexOf(i, y), c = n.charAt(f + s), c && i.includes(c) && (f = -1);
      break;
    case "end":
      a = n.lastIndexOf(t), f = a === -1 ? -1 : n.indexOf(i, a + y), f = f === n.length - s ? f : -1;
      break;
    case "only":
      h = n.slice(0, r2), a = h === t ? 0 : -1, h = n.slice(n.length - s), f = h === i ? n.length - s : -1;
      break;
  }
  return a !== -1 && f !== -1 && o(n.substring(a, f + s));
}, $ = (e, t, i) => {
  const n = g(t), r2 = g(i), s = e.search(new RegExp(`[ \\n]?${n}[^${n}${r2}]+${r2}$`));
  return s !== -1 ? e.slice(0, s) : e;
}, m = (e, t) => {
  if (e[t].type === "softbreak") return null;
  if (e[t].nesting === 0) return e[t];
  const i = e[t].level, n = e[t].type.replace("_close", "_open");
  for (; t >= 0; --t) if (e[t].type === n && e[t].level === i) return e[t];
  return null;
}, I = (e) => ({ name: "code-block", tests: [{ shift: 0, block: true, info: d("end", e.left, e.right) }], transform: (t, i) => {
  const n = t[i];
  let r2 = "";
  const s = /{(?:[\d,-]+)}/.exec(n.info);
  s && (n.info = n.info.replace(s[0], ""), r2 = s[0]);
  const l = n.info.lastIndexOf(e.left), o = p(n.info, l, e);
  u(o, n), n.info = `${$(n.info, e.left, e.right)} ${r2}`;
} }), S = (e) => [{ name: "inline nesting 0", tests: [{ shift: 0, type: "inline", children: [{ shift: -1, type: (t) => t === "image" || t === "code_inline" }, { shift: 0, type: "text", content: d("start", e.left, e.right) }] }], transform: (t, i, n) => {
  const r2 = t[i].children[n], s = r2.content.indexOf(e.right), l = t[i].children[n - 1], o = p(r2.content, 0, e);
  u(o, l), r2.content.length === s + e.right.length ? t[i].children.splice(n, 1) : r2.content = r2.content.slice(s + e.right.length);
} }, { name: "inline attributes", tests: [{ shift: 0, type: "inline", children: [{ shift: -1, nesting: -1 }, { shift: 0, type: "text", content: d("start", e.left, e.right) }] }], transform: (t, i, n) => {
  const r2 = t[i].children[n], { content: s } = r2, l = p(s, 0, e), o = m(t[i].children, n - 1);
  u(l, o), r2.content = s.slice(s.indexOf(e.right) + e.right.length);
} }], j = (e) => ({ name: "table", tests: [{ shift: 0, type: "table_close" }, { shift: 1, type: "paragraph_open" }, { shift: 2, type: "inline", content: d("only", e.left, e.right) }], transform: (t, i) => {
  const n = t[i + 2], r2 = m(t, i), s = p(n.content, 0, e);
  u(s, r2), t.splice(i + 1, 3);
} }), D = (e) => [{ name: "list softbreak", tests: [{ shift: -2, type: "list_item_open" }, { shift: 0, type: "inline", children: [{ position: -2, type: "softbreak" }, { position: -1, type: "text", content: d("only", e.left, e.right) }] }], transform: (t, i, n) => {
  const r2 = t[i].children[n], s = p(r2.content, 0, e);
  let l = i - 2;
  for (; t[l - 1] && t[l - 1].type !== "ordered_list_open" && t[l - 1].type !== "bullet_list_open"; ) l--;
  u(s, t[l - 1]), t[i].children = t[i].children.slice(0, -2);
} }, { name: "list double softbreak", tests: [{ shift: 0, type: (t) => t === "bullet_list_close" || t === "ordered_list_close" }, { shift: 1, type: "paragraph_open" }, { shift: 2, type: "inline", content: d("only", e.left, e.right), children: (t) => t.length === 1 }, { shift: 3, type: "paragraph_close" }], transform: (t, i) => {
  const n = t[i + 2], r2 = p(n.content, 0, e), s = m(t, i);
  u(r2, s), t.splice(i + 1, 3);
} }, { name: "list item end", tests: [{ shift: -2, type: "list_item_open" }, { shift: 0, type: "inline", children: [{ position: -1, type: "text", content: d("end", e.left, e.right) }] }], transform: (t, i, n) => {
  const r2 = t[i].children[n], { content: s } = r2, l = p(s, s.lastIndexOf(e.left), e);
  u(l, t[i - 2]);
  const o = s.slice(0, s.lastIndexOf(e.left));
  r2.content = o[o.length - 1] === " " ? o.slice(0, -1) : o;
} }], K = (e) => ({ name: `
{.a} softbreak then curly in start`, tests: [{ shift: 0, type: "inline", children: [{ position: -2, type: "softbreak" }, { position: -1, type: "text", content: d("only", e.left, e.right) }] }], transform: (t, i, n) => {
  const r2 = t[i].children[n], s = p(r2.content, 0, e);
  let l = i + 1;
  for (; t[l + 1] && t[l + 1].nesting === -1; ) l++;
  const o = m(t, l);
  u(s, o), t[i].children = t[i].children.slice(0, -2);
} }), P = (e) => ({ name: "horizontal rule", tests: [{ shift: 0, type: "paragraph_open" }, { shift: 1, type: "inline", children: (t) => t.length === 1, content: (t) => new RegExp(`^ {0,3}[-*_]{3,} ?${g(e.left)}[^${g(e.right)}]`).test(t) }, { shift: 2, type: "paragraph_close" }], transform: (t, i) => {
  const n = t[i];
  n.type = "hr", n.tag = "hr", n.nesting = 0;
  const { content: r2 } = t[i + 1], s = r2.lastIndexOf(e.left), l = p(r2, s, e);
  u(l, n), n.markup = r2, t.splice(i + 1, 2);
} }), T = (e) => ({ name: "end of block", tests: [{ shift: 0, type: "inline", children: [{ position: -1, content: d("end", e.left, e.right), type: (t) => t !== "code_inline" && t !== "math_inline" }] }], transform: (t, i, n) => {
  const r2 = t[i].children[n], { content: s } = r2, l = p(s, s.lastIndexOf(e.left), e);
  let o = i + 1;
  for (; t[o + 1] && t[o + 1].nesting === -1; ) o++;
  const a = m(t, o);
  u(l, a);
  const f = s.slice(0, s.lastIndexOf(e.left));
  r2.content = f[f.length - 1] === " " ? f.slice(0, -1) : f;
} }), A = ["fence", "inline", "table", "list", "hr", "softbreak", "block"], L = (e) => {
  const t = e.rule === false ? [] : Array.isArray(e.rule) ? e.rule.filter((n) => A.includes(n)) : A, i = [];
  return t.includes("fence") && i.push(I(e)), t.includes("inline") && i.push(...S(e)), t.includes("list") && i.push(...D(e)), t.includes("table") && i.push(j(e)), t.includes("softbreak") && i.push(K(e)), t.includes("hr") && i.push(P(e)), t.includes("block") && i.push(T(e)), i;
}, M = (e, t) => t >= 0 ? e[t] : e[e.length + t], C = (e) => Array.isArray(e) && !!e.length && e.every((t) => typeof t == "function"), J = (e) => Array.isArray(e) && !!e.length && e.every((t) => typeof t == "object"), _ = (e, t, i) => {
  var _a2, _b;
  const n = { match: false, position: null }, r2 = i.shift !== void 0 ? t + i.shift : i.position;
  if (i.shift !== void 0 && r2 < 0) return n;
  const s = M(e, r2);
  if (s === void 0) return n;
  for (const l of Object.keys(i)) {
    if (l === "shift" || l === "position") continue;
    if (s[l] === void 0) return n;
    if (l === "children" && J(i.children)) {
      if (((_a2 = s.children) == null ? void 0 : _a2.length) === 0) return n;
      let a;
      const f = i.children, h = s.children;
      if (f.every((c) => c.position !== void 0)) {
        if (a = f.every((c) => _(h, c.position, c).match), a) {
          const c = ((_b = f[f.length - 1]) == null ? void 0 : _b.position) ?? 0;
          n.position = c >= 0 ? c : h.length + c;
        }
      } else for (let c = 0; c < h.length; c++) if (a = f.every((y) => _(h, c, y).match), a) {
        n.position = c;
        break;
      }
      if (a === false) return n;
      continue;
    }
    const o = i[l];
    switch (typeof o) {
      case "boolean":
      case "number":
      case "string":
        if (s[l] !== o) return n;
        break;
      case "function":
        if (!o(s[l])) return n;
        break;
      case "object":
        if (C(o)) {
          if (!o.every((a) => a(s[l]))) return n;
          break;
        }
        continue;
      default:
        throw new Error(`Unknown type of pattern test (key: ${l}). Test should be of type boolean, number, string, function or array of functions.`);
    }
  }
  return n.match = true, n;
}, Y = (e, { left: t = "{", right: i = "}", allowed: n = [], rule: r2 = "all" } = {}) => {
  const s = L({ left: t, right: i, allowed: n, rule: r2 }), l = ({ tokens: o }) => {
    for (let a = 0; a < o.length; a++) for (let f = 0; f < s.length; f++) {
      const h = s[f];
      let c = null;
      h.tests.every((y) => {
        const g2 = _(o, a, y);
        return g2.position !== null && ({ position: c } = g2), g2.match;
      }) && (h.transform(o, a, c), (h.name === "inline attributes" || h.name === "inline nesting 0") && f--);
    }
  };
  e.core.ruler.before("linkify", "attrs", l);
};
var classnames = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
classnames.exports;
var hasRequiredClassnames;
function requireClassnames() {
  if (hasRequiredClassnames) return classnames.exports;
  hasRequiredClassnames = 1;
  (function(module) {
    (function() {
      var hasOwn2 = {}.hasOwnProperty;
      function classNames() {
        var classes = "";
        for (var i = 0; i < arguments.length; i++) {
          var arg2 = arguments[i];
          if (arg2) {
            classes = appendClass(classes, parseValue(arg2));
          }
        }
        return classes;
      }
      function parseValue(arg2) {
        if (typeof arg2 === "string" || typeof arg2 === "number") {
          return arg2;
        }
        if (typeof arg2 !== "object") {
          return "";
        }
        if (Array.isArray(arg2)) {
          return classNames.apply(null, arg2);
        }
        if (arg2.toString !== Object.prototype.toString && !arg2.toString.toString().includes("[native code]")) {
          return arg2.toString();
        }
        var classes = "";
        for (var key in arg2) {
          if (hasOwn2.call(arg2, key) && arg2[key]) {
            classes = appendClass(classes, key);
          }
        }
        return classes;
      }
      function appendClass(value, newClass) {
        if (!newClass) {
          return value;
        }
        if (value) {
          return value + " " + newClass;
        }
        return value + newClass;
      }
      if (module.exports) {
        classNames.default = classNames;
        module.exports = classNames;
      } else {
        window.classNames = classNames;
      }
    })();
  })(classnames);
  return classnames.exports;
}
var classnamesExports = requireClassnames();
const cn = /* @__PURE__ */ getDefaultExportFromCjs(classnamesExports);
const daysInYear = 365.2425;
const millisecondsInWeek = 6048e5;
const millisecondsInDay = 864e5;
const millisecondsInMinute = 6e4;
const millisecondsInHour = 36e5;
const secondsInHour = 3600;
const secondsInMinute = 60;
const secondsInDay = secondsInHour * 24;
const secondsInWeek = secondsInDay * 7;
const secondsInYear = secondsInDay * daysInYear;
const secondsInMonth = secondsInYear / 12;
const secondsInQuarter = secondsInMonth * 3;
const constructFromSymbol = Symbol.for("constructDateFrom");
function constructFrom(date, value) {
  if (typeof date === "function") return date(value);
  if (date && typeof date === "object" && constructFromSymbol in date)
    return date[constructFromSymbol](value);
  if (date instanceof Date) return new date.constructor(value);
  return new Date(value);
}
function toDate(argument, context) {
  return constructFrom(context || argument, argument);
}
let defaultOptions = {};
function getDefaultOptions() {
  return defaultOptions;
}
function startOfWeek(date, options) {
  var _a2, _b, _c, _d;
  const defaultOptions2 = getDefaultOptions();
  const weekStartsOn = (options == null ? void 0 : options.weekStartsOn) ?? ((_b = (_a2 = options == null ? void 0 : options.locale) == null ? void 0 : _a2.options) == null ? void 0 : _b.weekStartsOn) ?? defaultOptions2.weekStartsOn ?? ((_d = (_c = defaultOptions2.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.weekStartsOn) ?? 0;
  const _date = toDate(date, options == null ? void 0 : options.in);
  const day = _date.getDay();
  const diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  _date.setDate(_date.getDate() - diff);
  _date.setHours(0, 0, 0, 0);
  return _date;
}
function startOfISOWeek(date, options) {
  return startOfWeek(date, { ...options, weekStartsOn: 1 });
}
function getISOWeekYear(date, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  const year = _date.getFullYear();
  const fourthOfJanuaryOfNextYear = constructFrom(_date, 0);
  fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);
  const fourthOfJanuaryOfThisYear = constructFrom(_date, 0);
  fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);
  if (_date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (_date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
function getTimezoneOffsetInMilliseconds(date) {
  const _date = toDate(date);
  const utcDate = new Date(
    Date.UTC(
      _date.getFullYear(),
      _date.getMonth(),
      _date.getDate(),
      _date.getHours(),
      _date.getMinutes(),
      _date.getSeconds(),
      _date.getMilliseconds()
    )
  );
  utcDate.setUTCFullYear(_date.getFullYear());
  return +date - +utcDate;
}
function normalizeDates(context, ...dates) {
  const normalize3 = constructFrom.bind(
    null,
    context || dates.find((date) => typeof date === "object")
  );
  return dates.map(normalize3);
}
function startOfDay(date, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  _date.setHours(0, 0, 0, 0);
  return _date;
}
function differenceInCalendarDays(laterDate, earlierDate, options) {
  const [laterDate_, earlierDate_] = normalizeDates(
    options == null ? void 0 : options.in,
    laterDate,
    earlierDate
  );
  const laterStartOfDay = startOfDay(laterDate_);
  const earlierStartOfDay = startOfDay(earlierDate_);
  const laterTimestamp = +laterStartOfDay - getTimezoneOffsetInMilliseconds(laterStartOfDay);
  const earlierTimestamp = +earlierStartOfDay - getTimezoneOffsetInMilliseconds(earlierStartOfDay);
  return Math.round((laterTimestamp - earlierTimestamp) / millisecondsInDay);
}
function startOfISOWeekYear(date, options) {
  const year = getISOWeekYear(date, options);
  const fourthOfJanuary = constructFrom(date, 0);
  fourthOfJanuary.setFullYear(year, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  return startOfISOWeek(fourthOfJanuary);
}
function isDate(value) {
  return value instanceof Date || typeof value === "object" && Object.prototype.toString.call(value) === "[object Date]";
}
function isValid(date) {
  return !(!isDate(date) && typeof date !== "number" || isNaN(+toDate(date)));
}
function differenceInCalendarMonths(laterDate, earlierDate, options) {
  const [laterDate_, earlierDate_] = normalizeDates(
    options == null ? void 0 : options.in,
    laterDate,
    earlierDate
  );
  const yearsDiff = laterDate_.getFullYear() - earlierDate_.getFullYear();
  const monthsDiff = laterDate_.getMonth() - earlierDate_.getMonth();
  return yearsDiff * 12 + monthsDiff;
}
function getQuarter(date, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  const quarter = Math.trunc(_date.getMonth() / 3) + 1;
  return quarter;
}
function differenceInCalendarQuarters(laterDate, earlierDate, options) {
  const [laterDate_, earlierDate_] = normalizeDates(
    options == null ? void 0 : options.in,
    laterDate,
    earlierDate
  );
  const yearsDiff = laterDate_.getFullYear() - earlierDate_.getFullYear();
  const quartersDiff = getQuarter(laterDate_) - getQuarter(earlierDate_);
  return yearsDiff * 4 + quartersDiff;
}
function differenceInCalendarWeeks(laterDate, earlierDate, options) {
  const [laterDate_, earlierDate_] = normalizeDates(
    options == null ? void 0 : options.in,
    laterDate,
    earlierDate
  );
  const laterStartOfWeek = startOfWeek(laterDate_, options);
  const earlierStartOfWeek = startOfWeek(earlierDate_, options);
  const laterTimestamp = +laterStartOfWeek - getTimezoneOffsetInMilliseconds(laterStartOfWeek);
  const earlierTimestamp = +earlierStartOfWeek - getTimezoneOffsetInMilliseconds(earlierStartOfWeek);
  return Math.round((laterTimestamp - earlierTimestamp) / millisecondsInWeek);
}
function differenceInCalendarYears(laterDate, earlierDate, options) {
  const [laterDate_, earlierDate_] = normalizeDates(
    options == null ? void 0 : options.in,
    laterDate,
    earlierDate
  );
  return laterDate_.getFullYear() - earlierDate_.getFullYear();
}
function getRoundingMethod(method) {
  return (number) => {
    const round2 = method ? Math[method] : Math.trunc;
    const result = round2(number);
    return result === 0 ? 0 : result;
  };
}
function differenceInHours(laterDate, earlierDate, options) {
  const [laterDate_, earlierDate_] = normalizeDates(
    options == null ? void 0 : options.in,
    laterDate,
    earlierDate
  );
  const diff = (+laterDate_ - +earlierDate_) / millisecondsInHour;
  return getRoundingMethod(options == null ? void 0 : options.roundingMethod)(diff);
}
function differenceInMilliseconds(laterDate, earlierDate) {
  return +toDate(laterDate) - +toDate(earlierDate);
}
function differenceInMinutes(dateLeft, dateRight, options) {
  const diff = differenceInMilliseconds(dateLeft, dateRight) / millisecondsInMinute;
  return getRoundingMethod(options == null ? void 0 : options.roundingMethod)(diff);
}
function differenceInSeconds(laterDate, earlierDate, options) {
  const diff = differenceInMilliseconds(laterDate, earlierDate) / 1e3;
  return getRoundingMethod(options == null ? void 0 : options.roundingMethod)(diff);
}
function startOfYear(date, options) {
  const date_ = toDate(date, options == null ? void 0 : options.in);
  date_.setFullYear(date_.getFullYear(), 0, 1);
  date_.setHours(0, 0, 0, 0);
  return date_;
}
const formatDistanceLocale = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
};
const formatDistance = (token2, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale[token2];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }
  if (options == null ? void 0 : options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }
  return result;
};
function buildFormatLongFn(args) {
  return (options = {}) => {
    const width2 = options.width ? String(options.width) : args.defaultWidth;
    const format2 = args.formats[width2] || args.formats[args.defaultWidth];
    return format2;
  };
}
const dateFormats = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
const timeFormats = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
const dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
};
const formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
};
const formatRelative = (token2, _date, _baseDate, _options) => formatRelativeLocale[token2];
function buildLocalizeFn(args) {
  return (value, options) => {
    const context = (options == null ? void 0 : options.context) ? String(options.context) : "standalone";
    let valuesArray;
    if (context === "formatting" && args.formattingValues) {
      const defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      const width2 = (options == null ? void 0 : options.width) ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width2] || args.formattingValues[defaultWidth];
    } else {
      const defaultWidth = args.defaultWidth;
      const width2 = (options == null ? void 0 : options.width) ? String(options.width) : args.defaultWidth;
      valuesArray = args.values[width2] || args.values[defaultWidth];
    }
    const index = args.argumentCallback ? args.argumentCallback(value) : value;
    return valuesArray[index];
  };
}
const eraValues = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
};
const quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
};
const monthValues = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ],
  wide: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ]
};
const dayValues = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ]
};
const dayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
};
const formattingDayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
};
const ordinalNumber = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);
  const rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + "st";
      case 2:
        return number + "nd";
      case 3:
        return number + "rd";
    }
  }
  return number + "th";
};
const localize = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
};
function buildMatchFn(args) {
  return (string, options = {}) => {
    const width2 = options.width;
    const matchPattern = width2 && args.matchPatterns[width2] || args.matchPatterns[args.defaultMatchWidth];
    const matchResult = string.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    const matchedString = matchResult[0];
    const parsePatterns = width2 && args.parsePatterns[width2] || args.parsePatterns[args.defaultParseWidth];
    const key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, (pattern) => pattern.test(matchedString)) : (
      // [TODO] -- I challenge you to fix the type
      findKey(parsePatterns, (pattern) => pattern.test(matchedString))
    );
    let value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? (
      // [TODO] -- I challenge you to fix the type
      options.valueCallback(value)
    ) : value;
    const rest = string.slice(matchedString.length);
    return { value, rest };
  };
}
function findKey(object, predicate) {
  for (const key in object) {
    if (Object.prototype.hasOwnProperty.call(object, key) && predicate(object[key])) {
      return key;
    }
  }
  return void 0;
}
function findIndex(array, predicate) {
  for (let key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }
  return void 0;
}
function buildMatchPatternFn(args) {
  return (string, options = {}) => {
    const matchResult = string.match(args.matchPattern);
    if (!matchResult) return null;
    const matchedString = matchResult[0];
    const parseResult = string.match(args.parsePattern);
    if (!parseResult) return null;
    let value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    const rest = string.slice(matchedString.length);
    return { value, rest };
  };
}
const matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
const parseOrdinalNumberPattern = /\d+/i;
const matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
const parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
const matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
const parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
const parseMonthPatterns = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^may/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
const matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
const parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
const matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
const parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
const match$1 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
};
const enUS = {
  code: "en-US",
  formatDistance,
  formatLong,
  formatRelative,
  localize,
  match: match$1,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
function getDayOfYear(date, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  const diff = differenceInCalendarDays(_date, startOfYear(_date));
  const dayOfYear = diff + 1;
  return dayOfYear;
}
function getISOWeek(date, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  const diff = +startOfISOWeek(_date) - +startOfISOWeekYear(_date);
  return Math.round(diff / millisecondsInWeek) + 1;
}
function getWeekYear(date, options) {
  var _a2, _b, _c, _d;
  const _date = toDate(date, options == null ? void 0 : options.in);
  const year = _date.getFullYear();
  const defaultOptions2 = getDefaultOptions();
  const firstWeekContainsDate = (options == null ? void 0 : options.firstWeekContainsDate) ?? ((_b = (_a2 = options == null ? void 0 : options.locale) == null ? void 0 : _a2.options) == null ? void 0 : _b.firstWeekContainsDate) ?? defaultOptions2.firstWeekContainsDate ?? ((_d = (_c = defaultOptions2.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.firstWeekContainsDate) ?? 1;
  const firstWeekOfNextYear = constructFrom((options == null ? void 0 : options.in) || date, 0);
  firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = startOfWeek(firstWeekOfNextYear, options);
  const firstWeekOfThisYear = constructFrom((options == null ? void 0 : options.in) || date, 0);
  firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = startOfWeek(firstWeekOfThisYear, options);
  if (+_date >= +startOfNextYear) {
    return year + 1;
  } else if (+_date >= +startOfThisYear) {
    return year;
  } else {
    return year - 1;
  }
}
function startOfWeekYear(date, options) {
  var _a2, _b, _c, _d;
  const defaultOptions2 = getDefaultOptions();
  const firstWeekContainsDate = (options == null ? void 0 : options.firstWeekContainsDate) ?? ((_b = (_a2 = options == null ? void 0 : options.locale) == null ? void 0 : _a2.options) == null ? void 0 : _b.firstWeekContainsDate) ?? defaultOptions2.firstWeekContainsDate ?? ((_d = (_c = defaultOptions2.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.firstWeekContainsDate) ?? 1;
  const year = getWeekYear(date, options);
  const firstWeek = constructFrom((options == null ? void 0 : options.in) || date, 0);
  firstWeek.setFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setHours(0, 0, 0, 0);
  const _date = startOfWeek(firstWeek, options);
  return _date;
}
function getWeek(date, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  const diff = +startOfWeek(_date, options) - +startOfWeekYear(_date, options);
  return Math.round(diff / millisecondsInWeek) + 1;
}
function addLeadingZeros(number, targetLength) {
  const sign = number < 0 ? "-" : "";
  const output = Math.abs(number).toString().padStart(targetLength, "0");
  return sign + output;
}
const lightFormatters = {
  // Year
  y(date, token2) {
    const signedYear = date.getFullYear();
    const year = signedYear > 0 ? signedYear : 1 - signedYear;
    return addLeadingZeros(token2 === "yy" ? year % 100 : year, token2.length);
  },
  // Month
  M(date, token2) {
    const month = date.getMonth();
    return token2 === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
  },
  // Day of the month
  d(date, token2) {
    return addLeadingZeros(date.getDate(), token2.length);
  },
  // AM or PM
  a(date, token2) {
    const dayPeriodEnumValue = date.getHours() / 12 >= 1 ? "pm" : "am";
    switch (token2) {
      case "a":
      case "aa":
        return dayPeriodEnumValue.toUpperCase();
      case "aaa":
        return dayPeriodEnumValue;
      case "aaaaa":
        return dayPeriodEnumValue[0];
      case "aaaa":
      default:
        return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
    }
  },
  // Hour [1-12]
  h(date, token2) {
    return addLeadingZeros(date.getHours() % 12 || 12, token2.length);
  },
  // Hour [0-23]
  H(date, token2) {
    return addLeadingZeros(date.getHours(), token2.length);
  },
  // Minute
  m(date, token2) {
    return addLeadingZeros(date.getMinutes(), token2.length);
  },
  // Second
  s(date, token2) {
    return addLeadingZeros(date.getSeconds(), token2.length);
  },
  // Fraction of second
  S(date, token2) {
    const numberOfDigits = token2.length;
    const milliseconds = date.getMilliseconds();
    const fractionalSeconds = Math.trunc(
      milliseconds * Math.pow(10, numberOfDigits - 3)
    );
    return addLeadingZeros(fractionalSeconds, token2.length);
  }
};
const dayPeriodEnum = {
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
};
const formatters = {
  // Era
  G: function(date, token2, localize2) {
    const era = date.getFullYear() > 0 ? 1 : 0;
    switch (token2) {
      // AD, BC
      case "G":
      case "GG":
      case "GGG":
        return localize2.era(era, { width: "abbreviated" });
      // A, B
      case "GGGGG":
        return localize2.era(era, { width: "narrow" });
      // Anno Domini, Before Christ
      case "GGGG":
      default:
        return localize2.era(era, { width: "wide" });
    }
  },
  // Year
  y: function(date, token2, localize2) {
    if (token2 === "yo") {
      const signedYear = date.getFullYear();
      const year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize2.ordinalNumber(year, { unit: "year" });
    }
    return lightFormatters.y(date, token2);
  },
  // Local week-numbering year
  Y: function(date, token2, localize2, options) {
    const signedWeekYear = getWeekYear(date, options);
    const weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
    if (token2 === "YY") {
      const twoDigitYear = weekYear % 100;
      return addLeadingZeros(twoDigitYear, 2);
    }
    if (token2 === "Yo") {
      return localize2.ordinalNumber(weekYear, { unit: "year" });
    }
    return addLeadingZeros(weekYear, token2.length);
  },
  // ISO week-numbering year
  R: function(date, token2) {
    const isoWeekYear = getISOWeekYear(date);
    return addLeadingZeros(isoWeekYear, token2.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function(date, token2) {
    const year = date.getFullYear();
    return addLeadingZeros(year, token2.length);
  },
  // Quarter
  Q: function(date, token2, localize2) {
    const quarter = Math.ceil((date.getMonth() + 1) / 3);
    switch (token2) {
      // 1, 2, 3, 4
      case "Q":
        return String(quarter);
      // 01, 02, 03, 04
      case "QQ":
        return addLeadingZeros(quarter, 2);
      // 1st, 2nd, 3rd, 4th
      case "Qo":
        return localize2.ordinalNumber(quarter, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "QQQ":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "formatting"
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "QQQQQ":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "formatting"
        });
      // 1st quarter, 2nd quarter, ...
      case "QQQQ":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone quarter
  q: function(date, token2, localize2) {
    const quarter = Math.ceil((date.getMonth() + 1) / 3);
    switch (token2) {
      // 1, 2, 3, 4
      case "q":
        return String(quarter);
      // 01, 02, 03, 04
      case "qq":
        return addLeadingZeros(quarter, 2);
      // 1st, 2nd, 3rd, 4th
      case "qo":
        return localize2.ordinalNumber(quarter, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "qqq":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "standalone"
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "qqqqq":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "standalone"
        });
      // 1st quarter, 2nd quarter, ...
      case "qqqq":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Month
  M: function(date, token2, localize2) {
    const month = date.getMonth();
    switch (token2) {
      case "M":
      case "MM":
        return lightFormatters.M(date, token2);
      // 1st, 2nd, ..., 12th
      case "Mo":
        return localize2.ordinalNumber(month + 1, { unit: "month" });
      // Jan, Feb, ..., Dec
      case "MMM":
        return localize2.month(month, {
          width: "abbreviated",
          context: "formatting"
        });
      // J, F, ..., D
      case "MMMMM":
        return localize2.month(month, {
          width: "narrow",
          context: "formatting"
        });
      // January, February, ..., December
      case "MMMM":
      default:
        return localize2.month(month, { width: "wide", context: "formatting" });
    }
  },
  // Stand-alone month
  L: function(date, token2, localize2) {
    const month = date.getMonth();
    switch (token2) {
      // 1, 2, ..., 12
      case "L":
        return String(month + 1);
      // 01, 02, ..., 12
      case "LL":
        return addLeadingZeros(month + 1, 2);
      // 1st, 2nd, ..., 12th
      case "Lo":
        return localize2.ordinalNumber(month + 1, { unit: "month" });
      // Jan, Feb, ..., Dec
      case "LLL":
        return localize2.month(month, {
          width: "abbreviated",
          context: "standalone"
        });
      // J, F, ..., D
      case "LLLLL":
        return localize2.month(month, {
          width: "narrow",
          context: "standalone"
        });
      // January, February, ..., December
      case "LLLL":
      default:
        return localize2.month(month, { width: "wide", context: "standalone" });
    }
  },
  // Local week of year
  w: function(date, token2, localize2, options) {
    const week = getWeek(date, options);
    if (token2 === "wo") {
      return localize2.ordinalNumber(week, { unit: "week" });
    }
    return addLeadingZeros(week, token2.length);
  },
  // ISO week of year
  I: function(date, token2, localize2) {
    const isoWeek = getISOWeek(date);
    if (token2 === "Io") {
      return localize2.ordinalNumber(isoWeek, { unit: "week" });
    }
    return addLeadingZeros(isoWeek, token2.length);
  },
  // Day of the month
  d: function(date, token2, localize2) {
    if (token2 === "do") {
      return localize2.ordinalNumber(date.getDate(), { unit: "date" });
    }
    return lightFormatters.d(date, token2);
  },
  // Day of year
  D: function(date, token2, localize2) {
    const dayOfYear = getDayOfYear(date);
    if (token2 === "Do") {
      return localize2.ordinalNumber(dayOfYear, { unit: "dayOfYear" });
    }
    return addLeadingZeros(dayOfYear, token2.length);
  },
  // Day of week
  E: function(date, token2, localize2) {
    const dayOfWeek = date.getDay();
    switch (token2) {
      // Tue
      case "E":
      case "EE":
      case "EEE":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "EEEEE":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "EEEEEE":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "EEEE":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Local day of week
  e: function(date, token2, localize2, options) {
    const dayOfWeek = date.getDay();
    const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token2) {
      // Numerical value (Nth day of week with current locale or weekStartsOn)
      case "e":
        return String(localDayOfWeek);
      // Padded numerical value
      case "ee":
        return addLeadingZeros(localDayOfWeek, 2);
      // 1st, 2nd, ..., 7th
      case "eo":
        return localize2.ordinalNumber(localDayOfWeek, { unit: "day" });
      case "eee":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "eeeee":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "eeeeee":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "eeee":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone local day of week
  c: function(date, token2, localize2, options) {
    const dayOfWeek = date.getDay();
    const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token2) {
      // Numerical value (same as in `e`)
      case "c":
        return String(localDayOfWeek);
      // Padded numerical value
      case "cc":
        return addLeadingZeros(localDayOfWeek, token2.length);
      // 1st, 2nd, ..., 7th
      case "co":
        return localize2.ordinalNumber(localDayOfWeek, { unit: "day" });
      case "ccc":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "standalone"
        });
      // T
      case "ccccc":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "standalone"
        });
      // Tu
      case "cccccc":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "standalone"
        });
      // Tuesday
      case "cccc":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // ISO day of week
  i: function(date, token2, localize2) {
    const dayOfWeek = date.getDay();
    const isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
    switch (token2) {
      // 2
      case "i":
        return String(isoDayOfWeek);
      // 02
      case "ii":
        return addLeadingZeros(isoDayOfWeek, token2.length);
      // 2nd
      case "io":
        return localize2.ordinalNumber(isoDayOfWeek, { unit: "day" });
      // Tue
      case "iii":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "iiiii":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "iiiiii":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "iiii":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM or PM
  a: function(date, token2, localize2) {
    const hours = date.getHours();
    const dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    switch (token2) {
      case "a":
      case "aa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM, PM, midnight, noon
  b: function(date, token2, localize2) {
    const hours = date.getHours();
    let dayPeriodEnumValue;
    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    }
    switch (token2) {
      case "b":
      case "bb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function(date, token2, localize2) {
    const hours = date.getHours();
    let dayPeriodEnumValue;
    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }
    switch (token2) {
      case "B":
      case "BB":
      case "BBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Hour [1-12]
  h: function(date, token2, localize2) {
    if (token2 === "ho") {
      let hours = date.getHours() % 12;
      if (hours === 0) hours = 12;
      return localize2.ordinalNumber(hours, { unit: "hour" });
    }
    return lightFormatters.h(date, token2);
  },
  // Hour [0-23]
  H: function(date, token2, localize2) {
    if (token2 === "Ho") {
      return localize2.ordinalNumber(date.getHours(), { unit: "hour" });
    }
    return lightFormatters.H(date, token2);
  },
  // Hour [0-11]
  K: function(date, token2, localize2) {
    const hours = date.getHours() % 12;
    if (token2 === "Ko") {
      return localize2.ordinalNumber(hours, { unit: "hour" });
    }
    return addLeadingZeros(hours, token2.length);
  },
  // Hour [1-24]
  k: function(date, token2, localize2) {
    let hours = date.getHours();
    if (hours === 0) hours = 24;
    if (token2 === "ko") {
      return localize2.ordinalNumber(hours, { unit: "hour" });
    }
    return addLeadingZeros(hours, token2.length);
  },
  // Minute
  m: function(date, token2, localize2) {
    if (token2 === "mo") {
      return localize2.ordinalNumber(date.getMinutes(), { unit: "minute" });
    }
    return lightFormatters.m(date, token2);
  },
  // Second
  s: function(date, token2, localize2) {
    if (token2 === "so") {
      return localize2.ordinalNumber(date.getSeconds(), { unit: "second" });
    }
    return lightFormatters.s(date, token2);
  },
  // Fraction of second
  S: function(date, token2) {
    return lightFormatters.S(date, token2);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function(date, token2, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    if (timezoneOffset === 0) {
      return "Z";
    }
    switch (token2) {
      // Hours and optional minutes
      case "X":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XX`
      case "XXXX":
      case "XX":
        return formatTimezone(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XXX`
      case "XXXXX":
      case "XXX":
      // Hours and minutes with `:` delimiter
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function(date, token2, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    switch (token2) {
      // Hours and optional minutes
      case "x":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xx`
      case "xxxx":
      case "xx":
        return formatTimezone(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xxx`
      case "xxxxx":
      case "xxx":
      // Hours and minutes with `:` delimiter
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (GMT)
  O: function(date, token2, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    switch (token2) {
      // Short
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      // Long
      case "OOOO":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (specific non-location)
  z: function(date, token2, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    switch (token2) {
      // Short
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      // Long
      case "zzzz":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  // Seconds timestamp
  t: function(date, token2, _localize) {
    const timestamp = Math.trunc(+date / 1e3);
    return addLeadingZeros(timestamp, token2.length);
  },
  // Milliseconds timestamp
  T: function(date, token2, _localize) {
    return addLeadingZeros(+date, token2.length);
  }
};
function formatTimezoneShort(offset, delimiter2 = "") {
  const sign = offset > 0 ? "-" : "+";
  const absOffset = Math.abs(offset);
  const hours = Math.trunc(absOffset / 60);
  const minutes = absOffset % 60;
  if (minutes === 0) {
    return sign + String(hours);
  }
  return sign + String(hours) + delimiter2 + addLeadingZeros(minutes, 2);
}
function formatTimezoneWithOptionalMinutes(offset, delimiter2) {
  if (offset % 60 === 0) {
    const sign = offset > 0 ? "-" : "+";
    return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
  }
  return formatTimezone(offset, delimiter2);
}
function formatTimezone(offset, delimiter2 = "") {
  const sign = offset > 0 ? "-" : "+";
  const absOffset = Math.abs(offset);
  const hours = addLeadingZeros(Math.trunc(absOffset / 60), 2);
  const minutes = addLeadingZeros(absOffset % 60, 2);
  return sign + hours + delimiter2 + minutes;
}
const dateLongFormatter = (pattern, formatLong2) => {
  switch (pattern) {
    case "P":
      return formatLong2.date({ width: "short" });
    case "PP":
      return formatLong2.date({ width: "medium" });
    case "PPP":
      return formatLong2.date({ width: "long" });
    case "PPPP":
    default:
      return formatLong2.date({ width: "full" });
  }
};
const timeLongFormatter = (pattern, formatLong2) => {
  switch (pattern) {
    case "p":
      return formatLong2.time({ width: "short" });
    case "pp":
      return formatLong2.time({ width: "medium" });
    case "ppp":
      return formatLong2.time({ width: "long" });
    case "pppp":
    default:
      return formatLong2.time({ width: "full" });
  }
};
const dateTimeLongFormatter = (pattern, formatLong2) => {
  const matchResult = pattern.match(/(P+)(p+)?/) || [];
  const datePattern = matchResult[1];
  const timePattern = matchResult[2];
  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong2);
  }
  let dateTimeFormat;
  switch (datePattern) {
    case "P":
      dateTimeFormat = formatLong2.dateTime({ width: "short" });
      break;
    case "PP":
      dateTimeFormat = formatLong2.dateTime({ width: "medium" });
      break;
    case "PPP":
      dateTimeFormat = formatLong2.dateTime({ width: "long" });
      break;
    case "PPPP":
    default:
      dateTimeFormat = formatLong2.dateTime({ width: "full" });
      break;
  }
  return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
};
const longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};
const dayOfYearTokenRE = /^D+$/;
const weekYearTokenRE = /^Y+$/;
const throwTokens = ["D", "DD", "YY", "YYYY"];
function isProtectedDayOfYearToken(token2) {
  return dayOfYearTokenRE.test(token2);
}
function isProtectedWeekYearToken(token2) {
  return weekYearTokenRE.test(token2);
}
function warnOrThrowProtectedError(token2, format2, input) {
  const _message = message(token2, format2, input);
  if (throwTokens.includes(token2)) throw new RangeError(_message);
}
function message(token2, format2, input) {
  const subject = token2[0] === "Y" ? "years" : "days of the month";
  return `Use \`${token2.toLowerCase()}\` instead of \`${token2}\` (in \`${format2}\`) for formatting ${subject} to the input \`${input}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
}
const formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
const longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
const escapedStringRegExp = /^'([^]*?)'?$/;
const doubleQuoteRegExp = /''/g;
const unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function format(date, formatStr, options) {
  var _a2, _b, _c, _d;
  const defaultOptions2 = getDefaultOptions();
  const locale = defaultOptions2.locale ?? enUS;
  const firstWeekContainsDate = defaultOptions2.firstWeekContainsDate ?? ((_b = (_a2 = defaultOptions2.locale) == null ? void 0 : _a2.options) == null ? void 0 : _b.firstWeekContainsDate) ?? 1;
  const weekStartsOn = defaultOptions2.weekStartsOn ?? ((_d = (_c = defaultOptions2.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.weekStartsOn) ?? 0;
  const originalDate = toDate(date, options == null ? void 0 : options.in);
  if (!isValid(originalDate)) {
    throw new RangeError("Invalid time value");
  }
  let parts = formatStr.match(longFormattingTokensRegExp).map((substring) => {
    const firstCharacter = substring[0];
    if (firstCharacter === "p" || firstCharacter === "P") {
      const longFormatter = longFormatters[firstCharacter];
      return longFormatter(substring, locale.formatLong);
    }
    return substring;
  }).join("").match(formattingTokensRegExp).map((substring) => {
    if (substring === "''") {
      return { isToken: false, value: "'" };
    }
    const firstCharacter = substring[0];
    if (firstCharacter === "'") {
      return { isToken: false, value: cleanEscapedString(substring) };
    }
    if (formatters[firstCharacter]) {
      return { isToken: true, value: substring };
    }
    if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
      throw new RangeError(
        "Format string contains an unescaped latin alphabet character `" + firstCharacter + "`"
      );
    }
    return { isToken: false, value: substring };
  });
  if (locale.localize.preprocessor) {
    parts = locale.localize.preprocessor(originalDate, parts);
  }
  const formatterOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale
  };
  return parts.map((part) => {
    if (!part.isToken) return part.value;
    const token2 = part.value;
    if (isProtectedWeekYearToken(token2) || isProtectedDayOfYearToken(token2)) {
      warnOrThrowProtectedError(token2, formatStr, String(date));
    }
    const formatter = formatters[token2[0]];
    return formatter(originalDate, token2, locale.localize, formatterOptions);
  }).join("");
}
function cleanEscapedString(input) {
  const matched = input.match(escapedStringRegExp);
  if (!matched) {
    return input;
  }
  return matched[1].replace(doubleQuoteRegExp, "'");
}
function intlFormatDistance(laterDate, earlierDate, options) {
  let value = 0;
  let unit;
  const [laterDate_, earlierDate_] = normalizeDates(
    options == null ? void 0 : options.in,
    laterDate,
    earlierDate
  );
  if (!(options == null ? void 0 : options.unit)) {
    const diffInSeconds = differenceInSeconds(laterDate_, earlierDate_);
    if (Math.abs(diffInSeconds) < secondsInMinute) {
      value = differenceInSeconds(laterDate_, earlierDate_);
      unit = "second";
    } else if (Math.abs(diffInSeconds) < secondsInHour) {
      value = differenceInMinutes(laterDate_, earlierDate_);
      unit = "minute";
    } else if (Math.abs(diffInSeconds) < secondsInDay && Math.abs(differenceInCalendarDays(laterDate_, earlierDate_)) < 1) {
      value = differenceInHours(laterDate_, earlierDate_);
      unit = "hour";
    } else if (Math.abs(diffInSeconds) < secondsInWeek && (value = differenceInCalendarDays(laterDate_, earlierDate_)) && Math.abs(value) < 7) {
      unit = "day";
    } else if (Math.abs(diffInSeconds) < secondsInMonth) {
      value = differenceInCalendarWeeks(laterDate_, earlierDate_);
      unit = "week";
    } else if (Math.abs(diffInSeconds) < secondsInQuarter) {
      value = differenceInCalendarMonths(laterDate_, earlierDate_);
      unit = "month";
    } else if (Math.abs(diffInSeconds) < secondsInYear) {
      if (differenceInCalendarQuarters(laterDate_, earlierDate_) < 4) {
        value = differenceInCalendarQuarters(laterDate_, earlierDate_);
        unit = "quarter";
      } else {
        value = differenceInCalendarYears(laterDate_, earlierDate_);
        unit = "year";
      }
    } else {
      value = differenceInCalendarYears(laterDate_, earlierDate_);
      unit = "year";
    }
  } else {
    unit = options == null ? void 0 : options.unit;
    if (unit === "second") {
      value = differenceInSeconds(laterDate_, earlierDate_);
    } else if (unit === "minute") {
      value = differenceInMinutes(laterDate_, earlierDate_);
    } else if (unit === "hour") {
      value = differenceInHours(laterDate_, earlierDate_);
    } else if (unit === "day") {
      value = differenceInCalendarDays(laterDate_, earlierDate_);
    } else if (unit === "week") {
      value = differenceInCalendarWeeks(laterDate_, earlierDate_);
    } else if (unit === "month") {
      value = differenceInCalendarMonths(laterDate_, earlierDate_);
    } else if (unit === "quarter") {
      value = differenceInCalendarQuarters(laterDate_, earlierDate_);
    } else if (unit === "year") {
      value = differenceInCalendarYears(laterDate_, earlierDate_);
    }
  }
  const rtf = new Intl.RelativeTimeFormat(options == null ? void 0 : options.locale, {
    numeric: "auto",
    ...options
  });
  return rtf.format(value, unit);
}
const format_time = (time, locale) => {
  const days = (Date.now() - time.getTime()) / 1e3 / 60 / 60 / 24;
  if (days < 30) {
    return intlFormatDistance(time, /* @__PURE__ */ new Date(), { locale });
  }
  let fmt = "hh:mm, dd MMM";
  if (days > 365) {
    fmt += ", yyyy";
  }
  return format(time, fmt);
};
const prepareIcon = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='24'%20height='24'%20viewBox='0%200%201024%201024'%3e%3cpath%20d='M469.333333%20597.333333c-12.8%200-21.333333-4.266667-29.866666-12.8-17.066667-17.066667-17.066667-42.666667%200-59.733333l469.333333-469.333333c17.066667-17.066667%2042.666667-17.066667%2059.733333%200s17.066667%2042.666667%200%2059.733333l-469.333333%20469.333333c-8.533333%208.533333-17.066667%2012.8-29.866667%2012.8z'/%3e%3cpath%20d='M640%20981.333333c-17.066667%200-34.133333-8.533333-38.4-25.6l-162.133333-366.933333-371.2-166.4C51.2%20413.866667%2042.666667%20401.066667%2042.666667%20384s12.8-34.133333%2029.866666-38.4l853.333334-298.666667c17.066667-4.266667%2034.133333%200%2042.666666%208.533334%2012.8%2012.8%2017.066667%2029.866667%208.533334%2042.666666l-298.666667%20853.333334c-4.266667%2017.066667-17.066667%2029.866667-38.4%2029.866666zM200.533333%20388.266667l285.866667%20128c8.533333%204.266667%2017.066667%2012.8%2021.333333%2021.333333l128%20285.866667%20234.666667-669.866667L200.533333%20388.266667z'/%3e%3c/svg%3e";
const sentIcon = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='24'%20height='24'%20viewBox='0%200%20256%20256'%3e%3cpolyline%20fill='none'%20stroke='%23000'%20stroke-linecap='round'%20stroke-linejoin='round'%20stroke-width='16'%20points='216%2072.005%20104%20184%2048%20128.005'/%3e%3c/svg%3e";
const readIcon = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='24'%20height='24'%3e%3cpath%20d='m6%2015.586%209.293-9.293%201.414%201.414-10%2010a1%201%200%200%201-1.414%200l-4-4%201.414-1.414L6%2015.586zm6%200%209.293-9.293%201.414%201.414-10%2010a1%201%200%200%201-1.414%200l-1.5-1.5%201.414-1.414.793.793z'/%3e%3c/svg%3e";
const errorIcon = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='24px'%20height='24px'%20viewBox='0%200%2024%2024'%20fill='%23EF5350'%3e%3cpath%20d='M11.953%202C6.465%202%202%206.486%202%2012s4.486%2010%2010%2010%2010-4.486%2010-10S17.493%202%2011.953%202zM12%2020c-4.411%200-8-3.589-8-8s3.567-8%207.953-8C16.391%204%2020%207.589%2020%2012s-3.589%208-8%208z'/%3e%3cpath%20d='M11%207h2v7h-2zm0%208h2v2h-2z'/%3e%3c/svg%3e";
const statuses = {
  prepare: prepareIcon,
  sent: sentIcon,
  read: readIcon,
  error: errorIcon
};
function Status$1({ message: message2, showTimeStamp, showStatus, locale, children }) {
  var _a2;
  const hasStatus = showStatus && message2.sender == "client" && message2.status && statuses[message2.status];
  const isStatusError = hasStatus && message2.status === "error";
  let statusTitle = "";
  if (hasStatus && message2.status == "error" && ((_a2 = message2.props) == null ? void 0 : _a2.error)) {
    const { error: error2 } = message2.props;
    if (error2) {
      if (error2 instanceof Error) {
        statusTitle = error2.message;
      } else if (typeof error2 != "string") {
        statusTitle = String(error2);
      }
    }
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cn(`rcw-${message2.sender}`, { "has-status": hasStatus, [`status-${message2.status}`]: message2.status }), children: [
    children,
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "status", children: [
      showTimeStamp && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "rcw-timestamp", title: format(message2.timestamp, "hh:mm:ss, dd MMM, yyyy"), children: format_time(message2.timestamp, locale) }),
      hasStatus && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "icon-status", title: statusTitle, children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: statuses[message2.status], alt: message2.status }) })
    ] }),
    hasStatus && isStatusError && /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: cn(`status-explained ${message2.status}`, { "can-retry": !!message2.props.retry }),
        onClick: message2.props.retry,
        children: statusTitle
      }
    )
  ] });
}
var reactIs$1 = { exports: {} };
var reactIs_production = {};
/**
 * @license React
 * https://esm.sh/react-is.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_production;
function requireReactIs_production() {
  if (hasRequiredReactIs_production) return reactIs_production;
  hasRequiredReactIs_production = 1;
  var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
  var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
  function typeOf(object) {
    if ("object" === typeof object && null !== object) {
      var $$typeof = object.$$typeof;
      switch ($$typeof) {
        case REACT_ELEMENT_TYPE:
          switch (object = object.type, object) {
            case REACT_FRAGMENT_TYPE:
            case REACT_PROFILER_TYPE:
            case REACT_STRICT_MODE_TYPE:
            case REACT_SUSPENSE_TYPE:
            case REACT_SUSPENSE_LIST_TYPE:
              return object;
            default:
              switch (object = object && object.$$typeof, object) {
                case REACT_CONTEXT_TYPE:
                case REACT_FORWARD_REF_TYPE:
                case REACT_LAZY_TYPE:
                case REACT_MEMO_TYPE:
                  return object;
                case REACT_CONSUMER_TYPE:
                  return object;
                default:
                  return $$typeof;
              }
          }
        case REACT_PORTAL_TYPE:
          return $$typeof;
      }
    }
  }
  reactIs_production.ContextConsumer = REACT_CONSUMER_TYPE;
  reactIs_production.ContextProvider = REACT_CONTEXT_TYPE;
  reactIs_production.Element = REACT_ELEMENT_TYPE;
  reactIs_production.ForwardRef = REACT_FORWARD_REF_TYPE;
  reactIs_production.Fragment = REACT_FRAGMENT_TYPE;
  reactIs_production.Lazy = REACT_LAZY_TYPE;
  reactIs_production.Memo = REACT_MEMO_TYPE;
  reactIs_production.Portal = REACT_PORTAL_TYPE;
  reactIs_production.Profiler = REACT_PROFILER_TYPE;
  reactIs_production.StrictMode = REACT_STRICT_MODE_TYPE;
  reactIs_production.Suspense = REACT_SUSPENSE_TYPE;
  reactIs_production.SuspenseList = REACT_SUSPENSE_LIST_TYPE;
  reactIs_production.isContextConsumer = function(object) {
    return typeOf(object) === REACT_CONSUMER_TYPE;
  };
  reactIs_production.isContextProvider = function(object) {
    return typeOf(object) === REACT_CONTEXT_TYPE;
  };
  reactIs_production.isElement = function(object) {
    return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
  };
  reactIs_production.isForwardRef = function(object) {
    return typeOf(object) === REACT_FORWARD_REF_TYPE;
  };
  reactIs_production.isFragment = function(object) {
    return typeOf(object) === REACT_FRAGMENT_TYPE;
  };
  reactIs_production.isLazy = function(object) {
    return typeOf(object) === REACT_LAZY_TYPE;
  };
  reactIs_production.isMemo = function(object) {
    return typeOf(object) === REACT_MEMO_TYPE;
  };
  reactIs_production.isPortal = function(object) {
    return typeOf(object) === REACT_PORTAL_TYPE;
  };
  reactIs_production.isProfiler = function(object) {
    return typeOf(object) === REACT_PROFILER_TYPE;
  };
  reactIs_production.isStrictMode = function(object) {
    return typeOf(object) === REACT_STRICT_MODE_TYPE;
  };
  reactIs_production.isSuspense = function(object) {
    return typeOf(object) === REACT_SUSPENSE_TYPE;
  };
  reactIs_production.isSuspenseList = function(object) {
    return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
  };
  reactIs_production.isValidElementType = function(type) {
    return "string" === typeof type || "function" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_OFFSCREEN_TYPE || "object" === typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || void 0 !== type.getModuleId) ? true : false;
  };
  reactIs_production.typeOf = typeOf;
  return reactIs_production;
}
reactIs$1.exports;
var hasRequiredReactIs$1;
function requireReactIs$1() {
  if (hasRequiredReactIs$1) return reactIs$1.exports;
  hasRequiredReactIs$1 = 1;
  {
    reactIs$1.exports = /* @__PURE__ */ requireReactIs_production();
  }
  return reactIs$1.exports;
}
var reactIsExports = /* @__PURE__ */ requireReactIs$1();
function r(e) {
  var t, f, n = "";
  if ("string" == typeof e || "number" == typeof e) n += e;
  else if ("object" == typeof e) if (Array.isArray(e)) {
    var o = e.length;
    for (t = 0; t < o; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
  } else for (f in e) e[f] && (n && (n += " "), n += f);
  return n;
}
function clsx() {
  for (var e, t, f = 0, n = "", o = arguments.length; f < o; f++) (e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
  return n;
}
function composeClasses(slots2, getUtilityClass, classes = void 0) {
  const output = {};
  for (const slotName in slots2) {
    const slot = slots2[slotName];
    let buffer = "";
    let start = true;
    for (let i = 0; i < slot.length; i += 1) {
      const value = slot[i];
      if (value) {
        buffer += (start === true ? "" : " ") + getUtilityClass(value);
        start = false;
        if (classes && classes[value]) {
          buffer += " " + classes[value];
        }
      }
    }
    output[slotName] = buffer;
  }
  return output;
}
const RtlContext = /* @__PURE__ */ React.createContext();
const useRtl = () => {
  const value = React.useContext(RtlContext);
  return value ?? false;
};
function setRef$1(ref2, value) {
  if (typeof ref2 === "function") {
    ref2(value);
  } else if (ref2) {
    ref2.current = value;
  }
}
function useForkRef$1(...refs) {
  return React.useMemo(() => {
    if (refs.every((ref2) => ref2 == null)) {
      return null;
    }
    return (instance) => {
      refs.forEach((ref2) => {
        setRef$1(ref2, instance);
      });
    };
  }, refs);
}
function isHostComponent$2(element) {
  return typeof element === "string";
}
function appendOwnerState$1(elementType, otherProps, ownerState) {
  if (elementType === void 0 || isHostComponent$2(elementType)) {
    return otherProps;
  }
  return {
    ...otherProps,
    ownerState: {
      ...otherProps.ownerState,
      ...ownerState
    }
  };
}
function extractEventHandlers$1(object, excludeKeys = []) {
  if (object === void 0) {
    return {};
  }
  const result = {};
  Object.keys(object).filter((prop) => prop.match(/^on[A-Z]/) && typeof object[prop] === "function" && !excludeKeys.includes(prop)).forEach((prop) => {
    result[prop] = object[prop];
  });
  return result;
}
function omitEventHandlers$1(object) {
  if (object === void 0) {
    return {};
  }
  const result = {};
  Object.keys(object).filter((prop) => !(prop.match(/^on[A-Z]/) && typeof object[prop] === "function")).forEach((prop) => {
    result[prop] = object[prop];
  });
  return result;
}
function mergeSlotProps$1(parameters) {
  const {
    getSlotProps,
    additionalProps,
    externalSlotProps,
    externalForwardedProps,
    className
  } = parameters;
  if (!getSlotProps) {
    const joinedClasses2 = clsx(additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
    const mergedStyle2 = {
      ...additionalProps == null ? void 0 : additionalProps.style,
      ...externalForwardedProps == null ? void 0 : externalForwardedProps.style,
      ...externalSlotProps == null ? void 0 : externalSlotProps.style
    };
    const props2 = {
      ...additionalProps,
      ...externalForwardedProps,
      ...externalSlotProps
    };
    if (joinedClasses2.length > 0) {
      props2.className = joinedClasses2;
    }
    if (Object.keys(mergedStyle2).length > 0) {
      props2.style = mergedStyle2;
    }
    return {
      props: props2,
      internalRef: void 0
    };
  }
  const eventHandlers = extractEventHandlers$1({
    ...externalForwardedProps,
    ...externalSlotProps
  });
  const componentsPropsWithoutEventHandlers = omitEventHandlers$1(externalSlotProps);
  const otherPropsWithoutEventHandlers = omitEventHandlers$1(externalForwardedProps);
  const internalSlotProps = getSlotProps(eventHandlers);
  const joinedClasses = clsx(internalSlotProps == null ? void 0 : internalSlotProps.className, additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
  const mergedStyle = {
    ...internalSlotProps == null ? void 0 : internalSlotProps.style,
    ...additionalProps == null ? void 0 : additionalProps.style,
    ...externalForwardedProps == null ? void 0 : externalForwardedProps.style,
    ...externalSlotProps == null ? void 0 : externalSlotProps.style
  };
  const props = {
    ...internalSlotProps,
    ...additionalProps,
    ...otherPropsWithoutEventHandlers,
    ...componentsPropsWithoutEventHandlers
  };
  if (joinedClasses.length > 0) {
    props.className = joinedClasses;
  }
  if (Object.keys(mergedStyle).length > 0) {
    props.style = mergedStyle;
  }
  return {
    props,
    internalRef: internalSlotProps.ref
  };
}
function resolveComponentProps$1(componentProps, ownerState, slotState) {
  if (typeof componentProps === "function") {
    return componentProps(ownerState, slotState);
  }
  return componentProps;
}
function useSlotProps$1(parameters) {
  var _a2;
  const {
    elementType,
    externalSlotProps,
    ownerState,
    skipResolvingSlotProps = false,
    ...other
  } = parameters;
  const resolvedComponentsProps = skipResolvingSlotProps ? {} : resolveComponentProps$1(externalSlotProps, ownerState);
  const {
    props: mergedProps,
    internalRef
  } = mergeSlotProps$1({
    ...other,
    externalSlotProps: resolvedComponentsProps
  });
  const ref2 = useForkRef$1(internalRef, resolvedComponentsProps == null ? void 0 : resolvedComponentsProps.ref, (_a2 = parameters.additionalProps) == null ? void 0 : _a2.ref);
  const props = appendOwnerState$1(elementType, {
    ...mergedProps,
    ref: ref2
  }, ownerState);
  return props;
}
function ownerDocument(node2) {
  return node2 && node2.ownerDocument || document;
}
function formatMuiErrorMessage(code2, ...args) {
  const url = new URL(`https://mui.com/production-error/?code=${code2}`);
  args.forEach((arg2) => url.searchParams.append("args[]", arg2));
  return `Minified MUI error #${code2}; visit ${url} for the full message.`;
}
function capitalize(string) {
  if (typeof string !== "string") {
    throw new Error(formatMuiErrorMessage(7));
  }
  return string.charAt(0).toUpperCase() + string.slice(1);
}
function isPlainObject(item) {
  if (typeof item !== "object" || item === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(item);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in item) && !(Symbol.iterator in item);
}
function deepClone(source) {
  if (/* @__PURE__ */ React.isValidElement(source) || reactIsExports.isValidElementType(source) || !isPlainObject(source)) {
    return source;
  }
  const output = {};
  Object.keys(source).forEach((key) => {
    output[key] = deepClone(source[key]);
  });
  return output;
}
function deepmerge(target, source, options = {
  clone: true
}) {
  const output = options.clone ? {
    ...target
  } : target;
  if (isPlainObject(target) && isPlainObject(source)) {
    Object.keys(source).forEach((key) => {
      if (/* @__PURE__ */ React.isValidElement(source[key]) || reactIsExports.isValidElementType(source[key])) {
        output[key] = source[key];
      } else if (isPlainObject(source[key]) && // Avoid prototype pollution
      Object.prototype.hasOwnProperty.call(target, key) && isPlainObject(target[key])) {
        output[key] = deepmerge(target[key], source[key], options);
      } else if (options.clone) {
        output[key] = isPlainObject(source[key]) ? deepClone(source[key]) : source[key];
      } else {
        output[key] = source[key];
      }
    });
  }
  return output;
}
function merge(acc, item) {
  if (!item) {
    return acc;
  }
  return deepmerge(acc, item, {
    clone: false
    // No need to clone deep, it's way faster.
  });
}
function sortContainerQueries(theme, css2) {
  if (!theme.containerQueries) {
    return css2;
  }
  const sorted = Object.keys(css2).filter((key) => key.startsWith("@container")).sort((a, b) => {
    var _a2, _b;
    const regex2 = /min-width:\s*([0-9.]+)/;
    return +(((_a2 = a.match(regex2)) == null ? void 0 : _a2[1]) || 0) - +(((_b = b.match(regex2)) == null ? void 0 : _b[1]) || 0);
  });
  if (!sorted.length) {
    return css2;
  }
  return sorted.reduce((acc, key) => {
    const value = css2[key];
    delete acc[key];
    acc[key] = value;
    return acc;
  }, {
    ...css2
  });
}
function isCqShorthand(breakpointKeys, value) {
  return value === "@" || value.startsWith("@") && (breakpointKeys.some((key) => value.startsWith(`@${key}`)) || !!value.match(/^@\d/));
}
function getContainerQuery(theme, shorthand) {
  const matches = shorthand.match(/^@([^/]+)?\/?(.+)?$/);
  if (!matches) {
    return null;
  }
  const [, containerQuery, containerName] = matches;
  const value = Number.isNaN(+containerQuery) ? containerQuery || 0 : +containerQuery;
  return theme.containerQueries(containerName).up(value);
}
function cssContainerQueries(themeInput) {
  const toContainerQuery = (mediaQuery, name) => mediaQuery.replace("@media", name ? `@container ${name}` : "@container");
  function attachCq(node22, name) {
    node22.up = (...args) => toContainerQuery(themeInput.breakpoints.up(...args), name);
    node22.down = (...args) => toContainerQuery(themeInput.breakpoints.down(...args), name);
    node22.between = (...args) => toContainerQuery(themeInput.breakpoints.between(...args), name);
    node22.only = (...args) => toContainerQuery(themeInput.breakpoints.only(...args), name);
    node22.not = (...args) => {
      const result = toContainerQuery(themeInput.breakpoints.not(...args), name);
      if (result.includes("not all and")) {
        return result.replace("not all and ", "").replace("min-width:", "width<").replace("max-width:", "width>").replace("and", "or");
      }
      return result;
    };
  }
  const node2 = {};
  const containerQueries = (name) => {
    attachCq(node2, name);
    return node2;
  };
  attachCq(containerQueries);
  return {
    ...themeInput,
    containerQueries
  };
}
const values$1 = {
  xs: 0,
  // phone
  sm: 600,
  // tablet
  md: 900,
  // small laptop
  lg: 1200,
  // desktop
  xl: 1536
  // large screen
};
const defaultBreakpoints = {
  // Sorted ASC by size. That's important.
  // It can't be configured as it's used statically for propTypes.
  keys: ["xs", "sm", "md", "lg", "xl"],
  up: (key) => `@media (min-width:${values$1[key]}px)`
};
const defaultContainerQueries = {
  containerQueries: (containerName) => ({
    up: (key) => {
      let result = typeof key === "number" ? key : values$1[key] || key;
      if (typeof result === "number") {
        result = `${result}px`;
      }
      return containerName ? `@container ${containerName} (min-width:${result})` : `@container (min-width:${result})`;
    }
  })
};
function handleBreakpoints(props, propValue, styleFromPropValue) {
  const theme = props.theme || {};
  if (Array.isArray(propValue)) {
    const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
    return propValue.reduce((acc, item, index) => {
      acc[themeBreakpoints.up(themeBreakpoints.keys[index])] = styleFromPropValue(propValue[index]);
      return acc;
    }, {});
  }
  if (typeof propValue === "object") {
    const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
    return Object.keys(propValue).reduce((acc, breakpoint) => {
      if (isCqShorthand(themeBreakpoints.keys, breakpoint)) {
        const containerKey = getContainerQuery(theme.containerQueries ? theme : defaultContainerQueries, breakpoint);
        if (containerKey) {
          acc[containerKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
        }
      } else if (Object.keys(themeBreakpoints.values || values$1).includes(breakpoint)) {
        const mediaKey = themeBreakpoints.up(breakpoint);
        acc[mediaKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
      } else {
        const cssKey = breakpoint;
        acc[cssKey] = propValue[cssKey];
      }
      return acc;
    }, {});
  }
  const output = styleFromPropValue(propValue);
  return output;
}
function createEmptyBreakpointObject(breakpointsInput = {}) {
  var _a2;
  const breakpointsInOrder = (_a2 = breakpointsInput.keys) == null ? void 0 : _a2.reduce((acc, key) => {
    const breakpointStyleKey = breakpointsInput.up(key);
    acc[breakpointStyleKey] = {};
    return acc;
  }, {});
  return breakpointsInOrder || {};
}
function removeUnusedBreakpoints(breakpointKeys, style2) {
  return breakpointKeys.reduce((acc, key) => {
    const breakpointOutput = acc[key];
    const isBreakpointUnused = !breakpointOutput || Object.keys(breakpointOutput).length === 0;
    if (isBreakpointUnused) {
      delete acc[key];
    }
    return acc;
  }, style2);
}
function getPath(obj, path, checkVars = true) {
  if (!path || typeof path !== "string") {
    return null;
  }
  if (obj && obj.vars && checkVars) {
    const val = `vars.${path}`.split(".").reduce((acc, item) => acc && acc[item] ? acc[item] : null, obj);
    if (val != null) {
      return val;
    }
  }
  return path.split(".").reduce((acc, item) => {
    if (acc && acc[item] != null) {
      return acc[item];
    }
    return null;
  }, obj);
}
function getStyleValue(themeMapping, transform, propValueFinal, userValue = propValueFinal) {
  let value;
  if (typeof themeMapping === "function") {
    value = themeMapping(propValueFinal);
  } else if (Array.isArray(themeMapping)) {
    value = themeMapping[propValueFinal] || userValue;
  } else {
    value = getPath(themeMapping, propValueFinal) || userValue;
  }
  if (transform) {
    value = transform(value, userValue, themeMapping);
  }
  return value;
}
function style$1(options) {
  const {
    prop,
    cssProperty = options.prop,
    themeKey,
    transform
  } = options;
  const fn = (props) => {
    if (props[prop] == null) {
      return null;
    }
    const propValue = props[prop];
    const theme = props.theme;
    const themeMapping = getPath(theme, themeKey) || {};
    const styleFromPropValue = (propValueFinal) => {
      let value = getStyleValue(themeMapping, transform, propValueFinal);
      if (propValueFinal === value && typeof propValueFinal === "string") {
        value = getStyleValue(themeMapping, transform, `${prop}${propValueFinal === "default" ? "" : capitalize(propValueFinal)}`, propValueFinal);
      }
      if (cssProperty === false) {
        return value;
      }
      return {
        [cssProperty]: value
      };
    };
    return handleBreakpoints(props, propValue, styleFromPropValue);
  };
  fn.propTypes = {};
  fn.filterProps = [prop];
  return fn;
}
function memoize$1(fn) {
  const cache = {};
  return (arg2) => {
    if (cache[arg2] === void 0) {
      cache[arg2] = fn(arg2);
    }
    return cache[arg2];
  };
}
const properties = {
  m: "margin",
  p: "padding"
};
const directions = {
  t: "Top",
  r: "Right",
  b: "Bottom",
  l: "Left",
  x: ["Left", "Right"],
  y: ["Top", "Bottom"]
};
const aliases = {
  marginX: "mx",
  marginY: "my",
  paddingX: "px",
  paddingY: "py"
};
const getCssProperties = memoize$1((prop) => {
  if (prop.length > 2) {
    if (aliases[prop]) {
      prop = aliases[prop];
    } else {
      return [prop];
    }
  }
  const [a, b] = prop.split("");
  const property = properties[a];
  const direction = directions[b] || "";
  return Array.isArray(direction) ? direction.map((dir) => property + dir) : [property + direction];
});
const marginKeys = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"];
const paddingKeys = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"];
[...marginKeys, ...paddingKeys];
function createUnaryUnit(theme, themeKey, defaultValue, propName) {
  const themeSpacing = getPath(theme, themeKey, true) ?? defaultValue;
  if (typeof themeSpacing === "number" || typeof themeSpacing === "string") {
    return (val) => {
      if (typeof val === "string") {
        return val;
      }
      if (typeof themeSpacing === "string") {
        return `calc(${val} * ${themeSpacing})`;
      }
      return themeSpacing * val;
    };
  }
  if (Array.isArray(themeSpacing)) {
    return (val) => {
      if (typeof val === "string") {
        return val;
      }
      const abs2 = Math.abs(val);
      const transformed = themeSpacing[abs2];
      if (val >= 0) {
        return transformed;
      }
      if (typeof transformed === "number") {
        return -transformed;
      }
      return `-${transformed}`;
    };
  }
  if (typeof themeSpacing === "function") {
    return themeSpacing;
  }
  return () => void 0;
}
function createUnarySpacing(theme) {
  return createUnaryUnit(theme, "spacing", 8);
}
function getValue(transformer, propValue) {
  if (typeof propValue === "string" || propValue == null) {
    return propValue;
  }
  return transformer(propValue);
}
function getStyleFromPropValue(cssProperties, transformer) {
  return (propValue) => cssProperties.reduce((acc, cssProperty) => {
    acc[cssProperty] = getValue(transformer, propValue);
    return acc;
  }, {});
}
function resolveCssProperty(props, keys, prop, transformer) {
  if (!keys.includes(prop)) {
    return null;
  }
  const cssProperties = getCssProperties(prop);
  const styleFromPropValue = getStyleFromPropValue(cssProperties, transformer);
  const propValue = props[prop];
  return handleBreakpoints(props, propValue, styleFromPropValue);
}
function style(props, keys) {
  const transformer = createUnarySpacing(props.theme);
  return Object.keys(props).map((prop) => resolveCssProperty(props, keys, prop, transformer)).reduce(merge, {});
}
function margin(props) {
  return style(props, marginKeys);
}
margin.propTypes = {};
margin.filterProps = marginKeys;
function padding(props) {
  return style(props, paddingKeys);
}
padding.propTypes = {};
padding.filterProps = paddingKeys;
function compose(...styles2) {
  const handlers = styles2.reduce((acc, style2) => {
    style2.filterProps.forEach((prop) => {
      acc[prop] = style2;
    });
    return acc;
  }, {});
  const fn = (props) => {
    return Object.keys(props).reduce((acc, prop) => {
      if (handlers[prop]) {
        return merge(acc, handlers[prop](props));
      }
      return acc;
    }, {});
  };
  fn.propTypes = {};
  fn.filterProps = styles2.reduce((acc, style2) => acc.concat(style2.filterProps), []);
  return fn;
}
function borderTransform(value) {
  if (typeof value !== "number") {
    return value;
  }
  return `${value}px solid`;
}
function createBorderStyle(prop, transform) {
  return style$1({
    prop,
    themeKey: "borders",
    transform
  });
}
const border = createBorderStyle("border", borderTransform);
const borderTop = createBorderStyle("borderTop", borderTransform);
const borderRight = createBorderStyle("borderRight", borderTransform);
const borderBottom = createBorderStyle("borderBottom", borderTransform);
const borderLeft = createBorderStyle("borderLeft", borderTransform);
const borderColor = createBorderStyle("borderColor");
const borderTopColor = createBorderStyle("borderTopColor");
const borderRightColor = createBorderStyle("borderRightColor");
const borderBottomColor = createBorderStyle("borderBottomColor");
const borderLeftColor = createBorderStyle("borderLeftColor");
const outline = createBorderStyle("outline", borderTransform);
const outlineColor = createBorderStyle("outlineColor");
const borderRadius = (props) => {
  if (props.borderRadius !== void 0 && props.borderRadius !== null) {
    const transformer = createUnaryUnit(props.theme, "shape.borderRadius", 4);
    const styleFromPropValue = (propValue) => ({
      borderRadius: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.borderRadius, styleFromPropValue);
  }
  return null;
};
borderRadius.propTypes = {};
borderRadius.filterProps = ["borderRadius"];
compose(border, borderTop, borderRight, borderBottom, borderLeft, borderColor, borderTopColor, borderRightColor, borderBottomColor, borderLeftColor, borderRadius, outline, outlineColor);
const gap = (props) => {
  if (props.gap !== void 0 && props.gap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8);
    const styleFromPropValue = (propValue) => ({
      gap: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.gap, styleFromPropValue);
  }
  return null;
};
gap.propTypes = {};
gap.filterProps = ["gap"];
const columnGap = (props) => {
  if (props.columnGap !== void 0 && props.columnGap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8);
    const styleFromPropValue = (propValue) => ({
      columnGap: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.columnGap, styleFromPropValue);
  }
  return null;
};
columnGap.propTypes = {};
columnGap.filterProps = ["columnGap"];
const rowGap = (props) => {
  if (props.rowGap !== void 0 && props.rowGap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8);
    const styleFromPropValue = (propValue) => ({
      rowGap: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.rowGap, styleFromPropValue);
  }
  return null;
};
rowGap.propTypes = {};
rowGap.filterProps = ["rowGap"];
const gridColumn = style$1({
  prop: "gridColumn"
});
const gridRow = style$1({
  prop: "gridRow"
});
const gridAutoFlow = style$1({
  prop: "gridAutoFlow"
});
const gridAutoColumns = style$1({
  prop: "gridAutoColumns"
});
const gridAutoRows = style$1({
  prop: "gridAutoRows"
});
const gridTemplateColumns = style$1({
  prop: "gridTemplateColumns"
});
const gridTemplateRows = style$1({
  prop: "gridTemplateRows"
});
const gridTemplateAreas = style$1({
  prop: "gridTemplateAreas"
});
const gridArea = style$1({
  prop: "gridArea"
});
compose(gap, columnGap, rowGap, gridColumn, gridRow, gridAutoFlow, gridAutoColumns, gridAutoRows, gridTemplateColumns, gridTemplateRows, gridTemplateAreas, gridArea);
function paletteTransform(value, userValue) {
  if (userValue === "grey") {
    return userValue;
  }
  return value;
}
const color = style$1({
  prop: "color",
  themeKey: "palette",
  transform: paletteTransform
});
const bgcolor = style$1({
  prop: "bgcolor",
  cssProperty: "backgroundColor",
  themeKey: "palette",
  transform: paletteTransform
});
const backgroundColor = style$1({
  prop: "backgroundColor",
  themeKey: "palette",
  transform: paletteTransform
});
compose(color, bgcolor, backgroundColor);
function sizingTransform(value) {
  return value <= 1 && value !== 0 ? `${value * 100}%` : value;
}
const width = style$1({
  prop: "width",
  transform: sizingTransform
});
const maxWidth = (props) => {
  if (props.maxWidth !== void 0 && props.maxWidth !== null) {
    const styleFromPropValue = (propValue) => {
      var _a2, _b, _c, _d, _e;
      const breakpoint = ((_c = (_b = (_a2 = props.theme) == null ? void 0 : _a2.breakpoints) == null ? void 0 : _b.values) == null ? void 0 : _c[propValue]) || values$1[propValue];
      if (!breakpoint) {
        return {
          maxWidth: sizingTransform(propValue)
        };
      }
      if (((_e = (_d = props.theme) == null ? void 0 : _d.breakpoints) == null ? void 0 : _e.unit) !== "px") {
        return {
          maxWidth: `${breakpoint}${props.theme.breakpoints.unit}`
        };
      }
      return {
        maxWidth: breakpoint
      };
    };
    return handleBreakpoints(props, props.maxWidth, styleFromPropValue);
  }
  return null;
};
maxWidth.filterProps = ["maxWidth"];
const minWidth = style$1({
  prop: "minWidth",
  transform: sizingTransform
});
const height = style$1({
  prop: "height",
  transform: sizingTransform
});
const maxHeight = style$1({
  prop: "maxHeight",
  transform: sizingTransform
});
const minHeight = style$1({
  prop: "minHeight",
  transform: sizingTransform
});
style$1({
  prop: "size",
  cssProperty: "width",
  transform: sizingTransform
});
style$1({
  prop: "size",
  cssProperty: "height",
  transform: sizingTransform
});
const boxSizing = style$1({
  prop: "boxSizing"
});
compose(width, maxWidth, minWidth, height, maxHeight, minHeight, boxSizing);
const defaultSxConfig = {
  // borders
  border: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderTop: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderRight: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderBottom: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderLeft: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderColor: {
    themeKey: "palette"
  },
  borderTopColor: {
    themeKey: "palette"
  },
  borderRightColor: {
    themeKey: "palette"
  },
  borderBottomColor: {
    themeKey: "palette"
  },
  borderLeftColor: {
    themeKey: "palette"
  },
  outline: {
    themeKey: "borders",
    transform: borderTransform
  },
  outlineColor: {
    themeKey: "palette"
  },
  borderRadius: {
    themeKey: "shape.borderRadius",
    style: borderRadius
  },
  // palette
  color: {
    themeKey: "palette",
    transform: paletteTransform
  },
  bgcolor: {
    themeKey: "palette",
    cssProperty: "backgroundColor",
    transform: paletteTransform
  },
  backgroundColor: {
    themeKey: "palette",
    transform: paletteTransform
  },
  // spacing
  p: {
    style: padding
  },
  pt: {
    style: padding
  },
  pr: {
    style: padding
  },
  pb: {
    style: padding
  },
  pl: {
    style: padding
  },
  px: {
    style: padding
  },
  py: {
    style: padding
  },
  padding: {
    style: padding
  },
  paddingTop: {
    style: padding
  },
  paddingRight: {
    style: padding
  },
  paddingBottom: {
    style: padding
  },
  paddingLeft: {
    style: padding
  },
  paddingX: {
    style: padding
  },
  paddingY: {
    style: padding
  },
  paddingInline: {
    style: padding
  },
  paddingInlineStart: {
    style: padding
  },
  paddingInlineEnd: {
    style: padding
  },
  paddingBlock: {
    style: padding
  },
  paddingBlockStart: {
    style: padding
  },
  paddingBlockEnd: {
    style: padding
  },
  m: {
    style: margin
  },
  mt: {
    style: margin
  },
  mr: {
    style: margin
  },
  mb: {
    style: margin
  },
  ml: {
    style: margin
  },
  mx: {
    style: margin
  },
  my: {
    style: margin
  },
  margin: {
    style: margin
  },
  marginTop: {
    style: margin
  },
  marginRight: {
    style: margin
  },
  marginBottom: {
    style: margin
  },
  marginLeft: {
    style: margin
  },
  marginX: {
    style: margin
  },
  marginY: {
    style: margin
  },
  marginInline: {
    style: margin
  },
  marginInlineStart: {
    style: margin
  },
  marginInlineEnd: {
    style: margin
  },
  marginBlock: {
    style: margin
  },
  marginBlockStart: {
    style: margin
  },
  marginBlockEnd: {
    style: margin
  },
  // display
  displayPrint: {
    cssProperty: false,
    transform: (value) => ({
      "@media print": {
        display: value
      }
    })
  },
  display: {},
  overflow: {},
  textOverflow: {},
  visibility: {},
  whiteSpace: {},
  // flexbox
  flexBasis: {},
  flexDirection: {},
  flexWrap: {},
  justifyContent: {},
  alignItems: {},
  alignContent: {},
  order: {},
  flex: {},
  flexGrow: {},
  flexShrink: {},
  alignSelf: {},
  justifyItems: {},
  justifySelf: {},
  // grid
  gap: {
    style: gap
  },
  rowGap: {
    style: rowGap
  },
  columnGap: {
    style: columnGap
  },
  gridColumn: {},
  gridRow: {},
  gridAutoFlow: {},
  gridAutoColumns: {},
  gridAutoRows: {},
  gridTemplateColumns: {},
  gridTemplateRows: {},
  gridTemplateAreas: {},
  gridArea: {},
  // positions
  position: {},
  zIndex: {
    themeKey: "zIndex"
  },
  top: {},
  right: {},
  bottom: {},
  left: {},
  // shadows
  boxShadow: {
    themeKey: "shadows"
  },
  // sizing
  width: {
    transform: sizingTransform
  },
  maxWidth: {
    style: maxWidth
  },
  minWidth: {
    transform: sizingTransform
  },
  height: {
    transform: sizingTransform
  },
  maxHeight: {
    transform: sizingTransform
  },
  minHeight: {
    transform: sizingTransform
  },
  boxSizing: {},
  // typography
  font: {
    themeKey: "font"
  },
  fontFamily: {
    themeKey: "typography"
  },
  fontSize: {
    themeKey: "typography"
  },
  fontStyle: {
    themeKey: "typography"
  },
  fontWeight: {
    themeKey: "typography"
  },
  letterSpacing: {},
  textTransform: {},
  lineHeight: {},
  textAlign: {},
  typography: {
    cssProperty: false,
    themeKey: "typography"
  }
};
function objectsHaveSameKeys(...objects2) {
  const allKeys = objects2.reduce((keys, object) => keys.concat(Object.keys(object)), []);
  const union = new Set(allKeys);
  return objects2.every((object) => union.size === Object.keys(object).length);
}
function callIfFn(maybeFn, arg2) {
  return typeof maybeFn === "function" ? maybeFn(arg2) : maybeFn;
}
function unstable_createStyleFunctionSx() {
  function getThemeValue(prop, val, theme, config2) {
    const props = {
      [prop]: val,
      theme
    };
    const options = config2[prop];
    if (!options) {
      return {
        [prop]: val
      };
    }
    const {
      cssProperty = prop,
      themeKey,
      transform,
      style: style2
    } = options;
    if (val == null) {
      return null;
    }
    if (themeKey === "typography" && val === "inherit") {
      return {
        [prop]: val
      };
    }
    const themeMapping = getPath(theme, themeKey) || {};
    if (style2) {
      return style2(props);
    }
    const styleFromPropValue = (propValueFinal) => {
      let value = getStyleValue(themeMapping, transform, propValueFinal);
      if (propValueFinal === value && typeof propValueFinal === "string") {
        value = getStyleValue(themeMapping, transform, `${prop}${propValueFinal === "default" ? "" : capitalize(propValueFinal)}`, propValueFinal);
      }
      if (cssProperty === false) {
        return value;
      }
      return {
        [cssProperty]: value
      };
    };
    return handleBreakpoints(props, val, styleFromPropValue);
  }
  function styleFunctionSx2(props) {
    const {
      sx,
      theme = {}
    } = props || {};
    if (!sx) {
      return null;
    }
    const config2 = theme.unstable_sxConfig ?? defaultSxConfig;
    function traverse(sxInput) {
      let sxObject = sxInput;
      if (typeof sxInput === "function") {
        sxObject = sxInput(theme);
      } else if (typeof sxInput !== "object") {
        return sxInput;
      }
      if (!sxObject) {
        return null;
      }
      const emptyBreakpoints = createEmptyBreakpointObject(theme.breakpoints);
      const breakpointsKeys = Object.keys(emptyBreakpoints);
      let css2 = emptyBreakpoints;
      Object.keys(sxObject).forEach((styleKey) => {
        const value = callIfFn(sxObject[styleKey], theme);
        if (value !== null && value !== void 0) {
          if (typeof value === "object") {
            if (config2[styleKey]) {
              css2 = merge(css2, getThemeValue(styleKey, value, theme, config2));
            } else {
              const breakpointsValues = handleBreakpoints({
                theme
              }, value, (x2) => ({
                [styleKey]: x2
              }));
              if (objectsHaveSameKeys(breakpointsValues, value)) {
                css2[styleKey] = styleFunctionSx2({
                  sx: value,
                  theme
                });
              } else {
                css2 = merge(css2, breakpointsValues);
              }
            }
          } else {
            css2 = merge(css2, getThemeValue(styleKey, value, theme, config2));
          }
        }
      });
      return sortContainerQueries(theme, removeUnusedBreakpoints(breakpointsKeys, css2));
    }
    return Array.isArray(sx) ? sx.map(traverse) : traverse(sx);
  }
  return styleFunctionSx2;
}
const styleFunctionSx = unstable_createStyleFunctionSx();
styleFunctionSx.filterProps = ["sx"];
function _extends$1() {
  return _extends$1 = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
    }
    return n;
  }, _extends$1.apply(null, arguments);
}
var isDevelopment$3 = false;
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (var i = 0; i < document.styleSheets.length; i++) {
    if (document.styleSheets[i].ownerNode === tag) {
      return document.styleSheets[i];
    }
  }
  return void 0;
}
function createStyleElement(options) {
  var tag = document.createElement("style");
  tag.setAttribute("data-emotion", options.key);
  if (options.nonce !== void 0) {
    tag.setAttribute("nonce", options.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  tag.setAttribute("data-s", "");
  return tag;
}
var StyleSheet = /* @__PURE__ */ function() {
  function StyleSheet2(options) {
    var _this = this;
    this._insertTag = function(tag) {
      var before;
      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag, before);
      _this.tags.push(tag);
    };
    this.isSpeedy = options.speedy === void 0 ? !isDevelopment$3 : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce;
    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.insertionPoint = options.insertionPoint;
    this.before = null;
  }
  var _proto = StyleSheet2.prototype;
  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };
  _proto.insert = function insert(rule) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }
    var tag = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);
      try {
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e) {
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  };
  _proto.flush = function flush() {
    this.tags.forEach(function(tag) {
      var _tag$parentNode;
      return (_tag$parentNode = tag.parentNode) == null ? void 0 : _tag$parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
  };
  return StyleSheet2;
}();
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";
var abs = Math.abs;
var from = String.fromCharCode;
var assign = Object.assign;
function hash(value, length2) {
  return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
function trim(value) {
  return value.trim();
}
function match2(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof(value, search) {
  return value.indexOf(search);
}
function charat(value, index) {
  return value.charCodeAt(index) | 0;
}
function substr(value, begin, end) {
  return value.slice(begin, end);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append(value, array) {
  return array.push(value), value;
}
function combine(array, callback) {
  return array.map(callback).join("");
}
var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node(value, root, parent, type, props, children, length2) {
  return { value, root, parent, type, props, children, line, column, length: length2, return: "" };
}
function copy(root, props) {
  return assign(node("", null, null, "", null, null, 0), root, { length: -root.length }, props);
}
function char() {
  return character;
}
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice(begin, end) {
  return substr(characters, begin, end);
}
function token(type) {
  switch (type) {
    // \0 \t \n \r \s whitespace token
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    // ! + , / > @ ~ isolate token
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    // ; { } breakpoint token
    case 59:
    case 123:
    case 125:
      return 4;
    // : accompanied token
    case 58:
      return 3;
    // " ' ( [ opening delimit token
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    // ) ] closing delimit token
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type) {
  return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
}
function whitespace(type) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index, count) {
  while (--count && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32));
}
function delimiter(type) {
  while (next())
    switch (character) {
      // ] ) " '
      case type:
        return position;
      // " '
      case 34:
      case 39:
        if (type !== 34 && type !== 39)
          delimiter(character);
        break;
      // (
      case 40:
        if (type === 41)
          delimiter(type);
        break;
      // \
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(type, index) {
  while (next())
    if (type + character === 47 + 10)
      break;
    else if (type + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index, position - 1) + "*" + from(type === 47 ? type : next());
}
function identifier(index) {
  while (!token(peek()))
    next();
  return slice(index, position);
}
function compile(value) {
  return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index = 0;
  var offset = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type = "";
  var props = rules;
  var children = rulesets;
  var reference2 = rule;
  var characters2 = type;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      // (
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      // " ' [
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      // \t \n \r \s
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      // \
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      // /
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      // {
      case 123 * variable:
        points[index++] = strlen(characters2) * ampersand;
      // } ; \0
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          // \0 }
          case 0:
          case 125:
            scanning = 0;
          // ;
          case 59 + offset:
            if (ampersand == -1) characters2 = replace(characters2, /\f/g, "");
            if (property > 0 && strlen(characters2) - length2)
              append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
            break;
          // @ ;
          case 59:
            characters2 += ";";
          // { rule/at-rule
          default:
            append(reference2 = ruleset(characters2, root, parent, index, offset, rules, points, type, props = [], children = [], length2), rulesets);
            if (character2 === 123)
              if (offset === 0)
                parse(characters2, root, reference2, reference2, props, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  // d l m s
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse(value, reference2, reference2, rule && append(ruleset(value, reference2, reference2, 0, 0, rules, points, type, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse(characters2, reference2, reference2, reference2, [""], children, 0, points, children);
                }
        }
        index = offset = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
        break;
      // :
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          // &
          case 38:
            ampersand = offset > 0 ? 1 : (characters2 += "\f", -1);
            break;
          // ,
          case 44:
            points[index++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          // @
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset = length2 = strlen(type = characters2 += identifier(caret())), character2++;
            break;
          // -
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root, parent, index, offset, rules, points, type, props, children, length2) {
  var post = offset - 1;
  var rule = offset === 0 ? rules : [""];
  var size = sizeof(rule);
  for (var i = 0, j2 = 0, k2 = 0; i < index; ++i)
    for (var x2 = 0, y = substr(value, post + 1, post = abs(j2 = points[i])), z = value; x2 < size; ++x2)
      if (z = trim(j2 > 0 ? rule[x2] + " " + y : replace(y, /&\f/g, rule[x2])))
        props[k2++] = z;
  return node(value, root, parent, offset === 0 ? RULESET : type, props, children, length2);
}
function comment(value, root, parent) {
  return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
}
function declaration(value, root, parent, length2) {
  return node(value, root, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
}
function serialize(children, callback) {
  var output = "";
  var length2 = sizeof(children);
  for (var i = 0; i < length2; i++)
    output += callback(children[i], i, children, callback) || "";
  return output;
}
function stringify(element, index, children, callback) {
  switch (element.type) {
    case LAYER:
      if (element.children.length) break;
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize(element.children, callback) + "}";
    case RULESET:
      element.value = element.props.join(",");
  }
  return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}
function middleware(collection) {
  var length2 = sizeof(collection);
  return function(element, index, children, callback) {
    var output = "";
    for (var i = 0; i < length2; i++)
      output += collection[i](element, index, children, callback) || "";
    return output;
  };
}
function rulesheet(callback) {
  return function(element) {
    if (!element.root) {
      if (element = element.return)
        callback(element);
    }
  };
}
function memoize(fn) {
  var cache = /* @__PURE__ */ Object.create(null);
  return function(arg2) {
    if (cache[arg2] === void 0) cache[arg2] = fn(arg2);
    return cache[arg2];
  };
}
var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index) {
  var previous = 0;
  var character2 = 0;
  while (true) {
    previous = character2;
    character2 = peek();
    if (previous === 38 && character2 === 12) {
      points[index] = 1;
    }
    if (token(character2)) {
      break;
    }
    next();
  }
  return slice(begin, position);
};
var toRules = function toRules2(parsed, points) {
  var index = -1;
  var character2 = 44;
  do {
    switch (token(character2)) {
      case 0:
        if (character2 === 38 && peek() === 12) {
          points[index] = 1;
        }
        parsed[index] += identifierWithPointTracking(position - 1, points, index);
        break;
      case 2:
        parsed[index] += delimit(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index] = peek() === 58 ? "&\f" : "";
          points[index] = parsed[index].length;
          break;
        }
      // fallthrough
      default:
        parsed[index] += from(character2);
    }
  } while (character2 = next());
  return parsed;
};
var getRules = function getRules2(value, points) {
  return dealloc(toRules(alloc(value), points));
};
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = function compat2(element) {
  if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element.length < 1) {
    return;
  }
  var value = element.value;
  var parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;
  while (parent.type !== "rule") {
    parent = parent.parent;
    if (!parent) return;
  }
  if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent.props;
  for (var i = 0, k2 = 0; i < rules.length; i++) {
    for (var j2 = 0; j2 < parentRules.length; j2++, k2++) {
      element.props[k2] = points[i] ? rules[i].replace(/&\f/g, parentRules[j2]) : parentRules[j2] + " " + rules[i];
    }
  }
};
var removeLabel = function removeLabel2(element) {
  if (element.type === "decl") {
    var value = element.value;
    if (
      // charcode for l
      value.charCodeAt(0) === 108 && // charcode for b
      value.charCodeAt(2) === 98
    ) {
      element["return"] = "";
      element.value = "";
    }
  }
};
function prefix(value, length2) {
  switch (hash(value, length2)) {
    // color-adjust
    case 5103:
      return WEBKIT + "print-" + value + value;
    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    // appearance, user-select, transform, hyphens, text-size-adjust
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    // flex, flex-direction
    case 6828:
    case 4268:
      return WEBKIT + value + MS + value + value;
    // order
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    // align-items
    case 5187:
      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    // align-self
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/, "") + value;
    // align-content
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/, "") + value;
    // flex-shrink
    case 5548:
      return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
    // flex-basis
    case 5292:
      return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
    // flex-grow
    case 6060:
      return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
    // transition
    case 4554:
      return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    // cursor
    case 6187:
      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    // background, background-image
    case 5495:
    case 3959:
      return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    // justify-content
    case 4968:
      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    // (margin|padding)-inline-(start|end)
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    // (min|max)?(width|height|inline-size|block-size)
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6) switch (charat(value, length2 + 1)) {
        // (m)ax-content, (m)in-content
        case 109:
          if (charat(value, length2 + 4) !== 45) break;
        // (f)ill-available, (f)it-content
        case 102:
          return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
        // (s)tretch
        case 115:
          return ~indexof(value, "stretch") ? prefix(replace(value, "stretch", "fill-available"), length2) + value : value;
      }
      break;
    // position: sticky
    case 4949:
      if (charat(value, length2 + 1) !== 115) break;
    // display: (flex|inline-flex)
    case 6444:
      switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
        // stic(k)y
        case 107:
          return replace(value, ":", ":" + WEBKIT) + value;
        // (inline-)?fl(e)x
        case 101:
          return replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
      }
      break;
    // writing-mode
    case 5936:
      switch (charat(value, length2 + 11)) {
        // vertical-l(r)
        case 114:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        // vertical-r(l)
        case 108:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        // horizontal(-)tb
        case 45:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
      return WEBKIT + value + MS + value + value;
  }
  return value;
}
var prefixer = function prefixer2(element, index, children, callback) {
  if (element.length > -1) {
    if (!element["return"]) switch (element.type) {
      case DECLARATION:
        element["return"] = prefix(element.value, element.length);
        break;
      case KEYFRAMES:
        return serialize([copy(element, {
          value: replace(element.value, "@", "@" + WEBKIT)
        })], callback);
      case RULESET:
        if (element.length) return combine(element.props, function(value) {
          switch (match2(value, /(::plac\w+|:read-\w+)/)) {
            // :read-(only|write)
            case ":read-only":
            case ":read-write":
              return serialize([copy(element, {
                props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")]
              })], callback);
            // :placeholder
            case "::placeholder":
              return serialize([copy(element, {
                props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
              }), copy(element, {
                props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")]
              }), copy(element, {
                props: [replace(value, /:(plac\w+)/, MS + "input-$1")]
              })], callback);
          }
          return "";
        });
    }
  }
};
var defaultStylisPlugins = [prefixer];
var createCache = function createCache2(options) {
  var key = options.key;
  if (key === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node2) {
      var dataEmotionAttribute = node2.getAttribute("data-emotion");
      if (dataEmotionAttribute.indexOf(" ") === -1) {
        return;
      }
      document.head.appendChild(node2);
      node2.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
  var inserted = {};
  var container;
  var nodesToHydrate = [];
  {
    container = options.container || document.head;
    Array.prototype.forEach.call(
      // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
      function(node2) {
        var attrib = node2.getAttribute("data-emotion").split(" ");
        for (var i = 1; i < attrib.length; i++) {
          inserted[attrib[i]] = true;
        }
        nodesToHydrate.push(node2);
      }
    );
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  {
    var currentSheet;
    var finalizingPlugins = [stringify, rulesheet(function(rule) {
      currentSheet.insert(rule);
    })];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis2(styles2) {
      return serialize(compile(styles2), serializer);
    };
    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache.inserted[serialized.name] = true;
      }
    };
  }
  var cache = {
    key,
    sheet: new StyleSheet({
      key,
      container,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend,
      insertionPoint: options.insertionPoint
    }),
    nonce: options.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  cache.sheet.hydrate(nodesToHydrate);
  return cache;
};
var reactIs = { exports: {} };
var reactIs_production_min = {};
/** @license React v16.13.1
 * https://esm.sh/react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_production_min;
function requireReactIs_production_min() {
  if (hasRequiredReactIs_production_min) return reactIs_production_min;
  hasRequiredReactIs_production_min = 1;
  var b = "function" === typeof Symbol && Symbol.for, c = b ? Symbol.for("react.element") : 60103, d2 = b ? Symbol.for("react.portal") : 60106, e = b ? Symbol.for("react.fragment") : 60107, f = b ? Symbol.for("react.strict_mode") : 60108, g2 = b ? Symbol.for("react.profiler") : 60114, h = b ? Symbol.for("react.provider") : 60109, k2 = b ? Symbol.for("react.context") : 60110, l = b ? Symbol.for("react.async_mode") : 60111, m2 = b ? Symbol.for("react.concurrent_mode") : 60111, n = b ? Symbol.for("react.forward_ref") : 60112, p2 = b ? Symbol.for("react.suspense") : 60113, q = b ? Symbol.for("react.suspense_list") : 60120, r2 = b ? Symbol.for("react.memo") : 60115, t = b ? Symbol.for("react.lazy") : 60116, v2 = b ? Symbol.for("react.block") : 60121, w2 = b ? Symbol.for("react.fundamental") : 60117, x2 = b ? Symbol.for("react.responder") : 60118, y = b ? Symbol.for("react.scope") : 60119;
  function z(a) {
    if ("object" === typeof a && null !== a) {
      var u2 = a.$$typeof;
      switch (u2) {
        case c:
          switch (a = a.type, a) {
            case l:
            case m2:
            case e:
            case g2:
            case f:
            case p2:
              return a;
            default:
              switch (a = a && a.$$typeof, a) {
                case k2:
                case n:
                case t:
                case r2:
                case h:
                  return a;
                default:
                  return u2;
              }
          }
        case d2:
          return u2;
      }
    }
  }
  function A2(a) {
    return z(a) === m2;
  }
  reactIs_production_min.AsyncMode = l;
  reactIs_production_min.ConcurrentMode = m2;
  reactIs_production_min.ContextConsumer = k2;
  reactIs_production_min.ContextProvider = h;
  reactIs_production_min.Element = c;
  reactIs_production_min.ForwardRef = n;
  reactIs_production_min.Fragment = e;
  reactIs_production_min.Lazy = t;
  reactIs_production_min.Memo = r2;
  reactIs_production_min.Portal = d2;
  reactIs_production_min.Profiler = g2;
  reactIs_production_min.StrictMode = f;
  reactIs_production_min.Suspense = p2;
  reactIs_production_min.isAsyncMode = function(a) {
    return A2(a) || z(a) === l;
  };
  reactIs_production_min.isConcurrentMode = A2;
  reactIs_production_min.isContextConsumer = function(a) {
    return z(a) === k2;
  };
  reactIs_production_min.isContextProvider = function(a) {
    return z(a) === h;
  };
  reactIs_production_min.isElement = function(a) {
    return "object" === typeof a && null !== a && a.$$typeof === c;
  };
  reactIs_production_min.isForwardRef = function(a) {
    return z(a) === n;
  };
  reactIs_production_min.isFragment = function(a) {
    return z(a) === e;
  };
  reactIs_production_min.isLazy = function(a) {
    return z(a) === t;
  };
  reactIs_production_min.isMemo = function(a) {
    return z(a) === r2;
  };
  reactIs_production_min.isPortal = function(a) {
    return z(a) === d2;
  };
  reactIs_production_min.isProfiler = function(a) {
    return z(a) === g2;
  };
  reactIs_production_min.isStrictMode = function(a) {
    return z(a) === f;
  };
  reactIs_production_min.isSuspense = function(a) {
    return z(a) === p2;
  };
  reactIs_production_min.isValidElementType = function(a) {
    return "string" === typeof a || "function" === typeof a || a === e || a === m2 || a === g2 || a === f || a === p2 || a === q || "object" === typeof a && null !== a && (a.$$typeof === t || a.$$typeof === r2 || a.$$typeof === h || a.$$typeof === k2 || a.$$typeof === n || a.$$typeof === w2 || a.$$typeof === x2 || a.$$typeof === y || a.$$typeof === v2);
  };
  reactIs_production_min.typeOf = z;
  return reactIs_production_min;
}
reactIs.exports;
var hasRequiredReactIs;
function requireReactIs() {
  if (hasRequiredReactIs) return reactIs.exports;
  hasRequiredReactIs = 1;
  {
    reactIs.exports = requireReactIs_production_min();
  }
  return reactIs.exports;
}
var hoistNonReactStatics_cjs;
var hasRequiredHoistNonReactStatics_cjs;
function requireHoistNonReactStatics_cjs() {
  if (hasRequiredHoistNonReactStatics_cjs) return hoistNonReactStatics_cjs;
  hasRequiredHoistNonReactStatics_cjs = 1;
  var reactIs2 = requireReactIs();
  var REACT_STATICS = {
    childContextTypes: true,
    contextType: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    getDerivedStateFromError: true,
    getDerivedStateFromProps: true,
    mixins: true,
    propTypes: true,
    type: true
  };
  var KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    callee: true,
    arguments: true,
    arity: true
  };
  var FORWARD_REF_STATICS = {
    "$$typeof": true,
    render: true,
    defaultProps: true,
    displayName: true,
    propTypes: true
  };
  var MEMO_STATICS = {
    "$$typeof": true,
    compare: true,
    defaultProps: true,
    displayName: true,
    propTypes: true,
    type: true
  };
  var TYPE_STATICS = {};
  TYPE_STATICS[reactIs2.ForwardRef] = FORWARD_REF_STATICS;
  TYPE_STATICS[reactIs2.Memo] = MEMO_STATICS;
  function getStatics(component) {
    if (reactIs2.isMemo(component)) {
      return MEMO_STATICS;
    }
    return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
  }
  var defineProperty = Object.defineProperty;
  var getOwnPropertyNames = Object.getOwnPropertyNames;
  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  var getPrototypeOf = Object.getPrototypeOf;
  var objectPrototype = Object.prototype;
  function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
    if (typeof sourceComponent !== "string") {
      if (objectPrototype) {
        var inheritedComponent = getPrototypeOf(sourceComponent);
        if (inheritedComponent && inheritedComponent !== objectPrototype) {
          hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
        }
      }
      var keys = getOwnPropertyNames(sourceComponent);
      if (getOwnPropertySymbols) {
        keys = keys.concat(getOwnPropertySymbols(sourceComponent));
      }
      var targetStatics = getStatics(targetComponent);
      var sourceStatics = getStatics(sourceComponent);
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
          var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
          try {
            defineProperty(targetComponent, key, descriptor);
          } catch (e) {
          }
        }
      }
    }
    return targetComponent;
  }
  hoistNonReactStatics_cjs = hoistNonReactStatics;
  return hoistNonReactStatics_cjs;
}
requireHoistNonReactStatics_cjs();
var isBrowser = true;
function getRegisteredStyles(registered, registeredStyles, classNames) {
  var rawClassName = "";
  classNames.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else if (className) {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles2(cache, serialized, isStringTag2) {
  var className = cache.key + "-" + serialized.name;
  if (
    // we only need to add the styles to the registered cache if the
    // class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    (isStringTag2 === false || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    isBrowser === false) && cache.registered[className] === void 0
  ) {
    cache.registered[className] = serialized.styles;
  }
};
var insertStyles = function insertStyles2(cache, serialized, isStringTag2) {
  registerStyles(cache, serialized, isStringTag2);
  var className = cache.key + "-" + serialized.name;
  if (cache.inserted[serialized.name] === void 0) {
    var current = serialized;
    do {
      cache.insert(serialized === current ? "." + className : "", current, cache.sheet, true);
      current = current.next;
    } while (current !== void 0);
  }
};
function murmur2(str) {
  var h = 0;
  var k2, i = 0, len = str.length;
  for (; len >= 4; ++i, len -= 4) {
    k2 = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
    k2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
    k2 ^= /* k >>> r: */
    k2 >>> 24;
    h = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h ^= (str.charCodeAt(i + 2) & 255) << 16;
    case 2:
      h ^= (str.charCodeAt(i + 1) & 255) << 8;
    case 1:
      h ^= str.charCodeAt(i) & 255;
      h = /* Math.imul(h, m): */
      (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  }
  h ^= h >>> 13;
  h = /* Math.imul(h, m): */
  (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  return ((h ^ h >>> 15) >>> 0).toString(36);
}
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
var isDevelopment$2 = false;
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty2(property) {
  return property.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue2(value) {
  return value != null && typeof value !== "boolean";
};
var processStyleName = /* @__PURE__ */ memoize(function(styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue = function processStyleValue2(key, value) {
  switch (key) {
    case "animation":
    case "animationName": {
      if (typeof value === "string") {
        return value.replace(animationRegex, function(match3, p1, p2) {
          cursor = {
            name: p1,
            styles: p2,
            next: cursor
          };
          return p1;
        });
      }
    }
  }
  if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
    return value + "px";
  }
  return value;
};
var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  var componentSelector = interpolation;
  if (componentSelector.__emotion_styles !== void 0) {
    return componentSelector;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      var keyframes2 = interpolation;
      if (keyframes2.anim === 1) {
        cursor = {
          name: keyframes2.name,
          styles: keyframes2.styles,
          next: cursor
        };
        return keyframes2.name;
      }
      var serializedStyles = interpolation;
      if (serializedStyles.styles !== void 0) {
        var next2 = serializedStyles.next;
        if (next2 !== void 0) {
          while (next2 !== void 0) {
            cursor = {
              name: next2.name,
              styles: next2.styles,
              next: cursor
            };
            next2 = next2.next;
          }
        }
        var styles2 = serializedStyles.styles + ";";
        return styles2;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor;
        var result = interpolation(mergedProps);
        cursor = previousCursor;
        return handleInterpolation(mergedProps, registered, result);
      }
      break;
    }
  }
  var asString = interpolation;
  if (registered == null) {
    return asString;
  }
  var cached = registered[asString];
  return cached !== void 0 ? cached : asString;
}
function createStringFromObject(mergedProps, registered, obj) {
  var string = "";
  if (Array.isArray(obj)) {
    for (var i = 0; i < obj.length; i++) {
      string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
    }
  } else {
    for (var key in obj) {
      var value = obj[key];
      if (typeof value !== "object") {
        var asString = value;
        if (registered != null && registered[asString] !== void 0) {
          string += key + "{" + registered[asString] + "}";
        } else if (isProcessableValue(asString)) {
          string += processStyleName(key) + ":" + processStyleValue(key, asString) + ";";
        }
      } else {
        if (key === "NO_COMPONENT_SELECTOR" && isDevelopment$2) {
          throw new Error(noComponentSelectorMessage);
        }
        if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
          for (var _i = 0; _i < value.length; _i++) {
            if (isProcessableValue(value[_i])) {
              string += processStyleName(key) + ":" + processStyleValue(key, value[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);
          switch (key) {
            case "animation":
            case "animationName": {
              string += processStyleName(key) + ":" + interpolated + ";";
              break;
            }
            default: {
              string += key + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string;
}
var labelPattern = /label:\s*([^\s;{]+)\s*(;|$)/g;
var cursor;
function serializeStyles(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
    return args[0];
  }
  var stringMode = true;
  var styles2 = "";
  cursor = void 0;
  var strings = args[0];
  if (strings == null || strings.raw === void 0) {
    stringMode = false;
    styles2 += handleInterpolation(mergedProps, registered, strings);
  } else {
    var asTemplateStringsArr = strings;
    styles2 += asTemplateStringsArr[0];
  }
  for (var i = 1; i < args.length; i++) {
    styles2 += handleInterpolation(mergedProps, registered, args[i]);
    if (stringMode) {
      var templateStringsArr = strings;
      styles2 += templateStringsArr[i];
    }
  }
  labelPattern.lastIndex = 0;
  var identifierName = "";
  var match3;
  while ((match3 = labelPattern.exec(styles2)) !== null) {
    identifierName += "-" + match3[1];
  }
  var name = murmur2(styles2) + identifierName;
  return {
    name,
    styles: styles2,
    next: cursor
  };
}
var syncFallback = function syncFallback2(create) {
  return create();
};
var useInsertionEffect = React["useInsertionEffect"] ? React["useInsertionEffect"] : false;
var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;
var isDevelopment$1 = false;
var EmotionCacheContext = /* @__PURE__ */ React.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in https://esm.sh/react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache({
    key: "css"
  }) : null
);
EmotionCacheContext.Provider;
var withEmotionCache = function withEmotionCache2(func) {
  return /* @__PURE__ */ forwardRef(function(props, ref2) {
    var cache = useContext(EmotionCacheContext);
    return func(props, cache, ref2);
  });
};
var ThemeContext = /* @__PURE__ */ React.createContext({});
var hasOwn = {}.hasOwnProperty;
var typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__";
var createEmotionProps = function createEmotionProps2(type, props) {
  var newProps = {};
  for (var _key in props) {
    if (hasOwn.call(props, _key)) {
      newProps[_key] = props[_key];
    }
  }
  newProps[typePropName] = type;
  return newProps;
};
var Insertion$1 = function Insertion(_ref) {
  var cache = _ref.cache, serialized = _ref.serialized, isStringTag2 = _ref.isStringTag;
  registerStyles(cache, serialized, isStringTag2);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache, serialized, isStringTag2);
  });
  return null;
};
var Emotion = /* @__PURE__ */ withEmotionCache(function(props, cache, ref2) {
  var cssProp = props.css;
  if (typeof cssProp === "string" && cache.registered[cssProp] !== void 0) {
    cssProp = cache.registered[cssProp];
  }
  var WrappedComponent = props[typePropName];
  var registeredStyles = [cssProp];
  var className = "";
  if (typeof props.className === "string") {
    className = getRegisteredStyles(cache.registered, registeredStyles, props.className);
  } else if (props.className != null) {
    className = props.className + " ";
  }
  var serialized = serializeStyles(registeredStyles, void 0, React.useContext(ThemeContext));
  className += cache.key + "-" + serialized.name;
  var newProps = {};
  for (var _key2 in props) {
    if (hasOwn.call(props, _key2) && _key2 !== "css" && _key2 !== typePropName && !isDevelopment$1) {
      newProps[_key2] = props[_key2];
    }
  }
  newProps.className = className;
  if (ref2) {
    newProps.ref = ref2;
  }
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Insertion$1, {
    cache,
    serialized,
    isStringTag: typeof WrappedComponent === "string"
  }), /* @__PURE__ */ React.createElement(WrappedComponent, newProps));
});
var Emotion$1 = Emotion;
var jsx = function jsx2(type, props) {
  var args = arguments;
  if (props == null || !hasOwn.call(props, "css")) {
    return React.createElement.apply(void 0, args);
  }
  var argsLength = args.length;
  var createElementArgArray = new Array(argsLength);
  createElementArgArray[0] = Emotion$1;
  createElementArgArray[1] = createEmotionProps(type, props);
  for (var i = 2; i < argsLength; i++) {
    createElementArgArray[i] = args[i];
  }
  return React.createElement.apply(null, createElementArgArray);
};
(function(_jsx) {
  var JSX;
  /* @__PURE__ */ (function(_JSX) {
  })(JSX || (JSX = _jsx.JSX || (_jsx.JSX = {})));
})(jsx || (jsx = {}));
function css() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return serializeStyles(args);
}
function keyframes() {
  var insertable = css.apply(void 0, arguments);
  var name = "animation-" + insertable.name;
  return {
    name,
    styles: "@keyframes " + name + "{" + insertable.styles + "}",
    anim: 1,
    toString: function toString() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
}
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
var isPropValid = /* @__PURE__ */ memoize(
  function(prop) {
    return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
  }
  /* Z+1 */
);
var isDevelopment = false;
var testOmitPropsOnStringTag = isPropValid;
var testOmitPropsOnComponent = function testOmitPropsOnComponent2(key) {
  return key !== "theme";
};
var getDefaultShouldForwardProp = function getDefaultShouldForwardProp2(tag) {
  return typeof tag === "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
};
var composeShouldForwardProps = function composeShouldForwardProps2(tag, options, isReal) {
  var shouldForwardProp2;
  if (options) {
    var optionsShouldForwardProp = options.shouldForwardProp;
    shouldForwardProp2 = tag.__emotion_forwardProp && optionsShouldForwardProp ? function(propName) {
      return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
    } : optionsShouldForwardProp;
  }
  if (typeof shouldForwardProp2 !== "function" && isReal) {
    shouldForwardProp2 = tag.__emotion_forwardProp;
  }
  return shouldForwardProp2;
};
var Insertion2 = function Insertion3(_ref) {
  var cache = _ref.cache, serialized = _ref.serialized, isStringTag2 = _ref.isStringTag;
  registerStyles(cache, serialized, isStringTag2);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache, serialized, isStringTag2);
  });
  return null;
};
var createStyled$1 = function createStyled(tag, options) {
  var isReal = tag.__emotion_real === tag;
  var baseTag = isReal && tag.__emotion_base || tag;
  var identifierName;
  var targetClassName;
  if (options !== void 0) {
    identifierName = options.label;
    targetClassName = options.target;
  }
  var shouldForwardProp2 = composeShouldForwardProps(tag, options, isReal);
  var defaultShouldForwardProp = shouldForwardProp2 || getDefaultShouldForwardProp(baseTag);
  var shouldUseAs = !defaultShouldForwardProp("as");
  return function() {
    var args = arguments;
    var styles2 = isReal && tag.__emotion_styles !== void 0 ? tag.__emotion_styles.slice(0) : [];
    if (identifierName !== void 0) {
      styles2.push("label:" + identifierName + ";");
    }
    if (args[0] == null || args[0].raw === void 0) {
      styles2.push.apply(styles2, args);
    } else {
      var templateStringsArr = args[0];
      styles2.push(templateStringsArr[0]);
      var len = args.length;
      var i = 1;
      for (; i < len; i++) {
        styles2.push(args[i], templateStringsArr[i]);
      }
    }
    var Styled = withEmotionCache(function(props, cache, ref2) {
      var FinalTag = shouldUseAs && props.as || baseTag;
      var className = "";
      var classInterpolations = [];
      var mergedProps = props;
      if (props.theme == null) {
        mergedProps = {};
        for (var key in props) {
          mergedProps[key] = props[key];
        }
        mergedProps.theme = React.useContext(ThemeContext);
      }
      if (typeof props.className === "string") {
        className = getRegisteredStyles(cache.registered, classInterpolations, props.className);
      } else if (props.className != null) {
        className = props.className + " ";
      }
      var serialized = serializeStyles(styles2.concat(classInterpolations), cache.registered, mergedProps);
      className += cache.key + "-" + serialized.name;
      if (targetClassName !== void 0) {
        className += " " + targetClassName;
      }
      var finalShouldForwardProp = shouldUseAs && shouldForwardProp2 === void 0 ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
      var newProps = {};
      for (var _key in props) {
        if (shouldUseAs && _key === "as") continue;
        if (finalShouldForwardProp(_key)) {
          newProps[_key] = props[_key];
        }
      }
      newProps.className = className;
      if (ref2) {
        newProps.ref = ref2;
      }
      return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Insertion2, {
        cache,
        serialized,
        isStringTag: typeof FinalTag === "string"
      }), /* @__PURE__ */ React.createElement(FinalTag, newProps));
    });
    Styled.displayName = identifierName !== void 0 ? identifierName : "Styled(" + (typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component") + ")";
    Styled.defaultProps = tag.defaultProps;
    Styled.__emotion_real = Styled;
    Styled.__emotion_base = baseTag;
    Styled.__emotion_styles = styles2;
    Styled.__emotion_forwardProp = shouldForwardProp2;
    Object.defineProperty(Styled, "toString", {
      value: function value() {
        if (targetClassName === void 0 && isDevelopment) {
          return "NO_COMPONENT_SELECTOR";
        }
        return "." + targetClassName;
      }
    });
    Styled.withComponent = function(nextTag, nextOptions) {
      var newStyled2 = createStyled(nextTag, _extends$1({}, options, nextOptions, {
        shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
      }));
      return newStyled2.apply(void 0, styles2);
    };
    return Styled;
  };
};
var tags = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
];
var newStyled = createStyled$1.bind(null);
tags.forEach(function(tagName) {
  newStyled[tagName] = newStyled(tagName);
});
/**
 * @mui/styled-engine v6.4.2
 *
 * @license MIT
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
function styled$1(tag, options) {
  const stylesFactory = newStyled(tag, options);
  return stylesFactory;
}
function internal_mutateStyles(tag, processor) {
  if (Array.isArray(tag.__emotion_styles)) {
    tag.__emotion_styles = processor(tag.__emotion_styles);
  }
}
const wrapper = [];
function internal_serializeStyles(styles2) {
  wrapper[0] = styles2;
  return serializeStyles(wrapper);
}
const sortBreakpointsValues = (values2) => {
  const breakpointsAsArray = Object.keys(values2).map((key) => ({
    key,
    val: values2[key]
  })) || [];
  breakpointsAsArray.sort((breakpoint1, breakpoint2) => breakpoint1.val - breakpoint2.val);
  return breakpointsAsArray.reduce((acc, obj) => {
    return {
      ...acc,
      [obj.key]: obj.val
    };
  }, {});
};
function createBreakpoints(breakpoints) {
  const {
    // The breakpoint **start** at this value.
    // For instance with the first breakpoint xs: [xs, sm).
    values: values2 = {
      xs: 0,
      // phone
      sm: 600,
      // tablet
      md: 900,
      // small laptop
      lg: 1200,
      // desktop
      xl: 1536
      // large screen
    },
    unit = "px",
    step = 5,
    ...other
  } = breakpoints;
  const sortedValues = sortBreakpointsValues(values2);
  const keys = Object.keys(sortedValues);
  function up(key) {
    const value = typeof values2[key] === "number" ? values2[key] : key;
    return `@media (min-width:${value}${unit})`;
  }
  function down(key) {
    const value = typeof values2[key] === "number" ? values2[key] : key;
    return `@media (max-width:${value - step / 100}${unit})`;
  }
  function between(start, end) {
    const endIndex = keys.indexOf(end);
    return `@media (min-width:${typeof values2[start] === "number" ? values2[start] : start}${unit}) and (max-width:${(endIndex !== -1 && typeof values2[keys[endIndex]] === "number" ? values2[keys[endIndex]] : end) - step / 100}${unit})`;
  }
  function only(key) {
    if (keys.indexOf(key) + 1 < keys.length) {
      return between(key, keys[keys.indexOf(key) + 1]);
    }
    return up(key);
  }
  function not(key) {
    const keyIndex = keys.indexOf(key);
    if (keyIndex === 0) {
      return up(keys[1]);
    }
    if (keyIndex === keys.length - 1) {
      return down(keys[keyIndex]);
    }
    return between(key, keys[keys.indexOf(key) + 1]).replace("@media", "@media not all and");
  }
  return {
    keys,
    values: sortedValues,
    up,
    down,
    between,
    only,
    not,
    unit,
    ...other
  };
}
const shape = {
  borderRadius: 4
};
function createSpacing(spacingInput = 8, transform = createUnarySpacing({
  spacing: spacingInput
})) {
  if (spacingInput.mui) {
    return spacingInput;
  }
  const spacing = (...argsInput) => {
    const args = argsInput.length === 0 ? [1] : argsInput;
    return args.map((argument) => {
      const output = transform(argument);
      return typeof output === "number" ? `${output}px` : output;
    }).join(" ");
  };
  spacing.mui = true;
  return spacing;
}
function applyStyles(key, styles2) {
  var _a2;
  const theme = this;
  if (theme.vars) {
    if (!((_a2 = theme.colorSchemes) == null ? void 0 : _a2[key]) || typeof theme.getColorSchemeSelector !== "function") {
      return {};
    }
    let selector = theme.getColorSchemeSelector(key);
    if (selector === "&") {
      return styles2;
    }
    if (selector.includes("data-") || selector.includes(".")) {
      selector = `*:where(${selector.replace(/\s*&$/, "")}) &`;
    }
    return {
      [selector]: styles2
    };
  }
  if (theme.palette.mode === key) {
    return styles2;
  }
  return {};
}
function createTheme$1(options = {}, ...args) {
  const {
    breakpoints: breakpointsInput = {},
    palette: paletteInput = {},
    spacing: spacingInput,
    shape: shapeInput = {},
    ...other
  } = options;
  const breakpoints = createBreakpoints(breakpointsInput);
  const spacing = createSpacing(spacingInput);
  let muiTheme = deepmerge({
    breakpoints,
    direction: "ltr",
    components: {},
    // Inject component definitions.
    palette: {
      mode: "light",
      ...paletteInput
    },
    spacing,
    shape: {
      ...shape,
      ...shapeInput
    }
  }, other);
  muiTheme = cssContainerQueries(muiTheme);
  muiTheme.applyStyles = applyStyles;
  muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
  muiTheme.unstable_sxConfig = {
    ...defaultSxConfig,
    ...other == null ? void 0 : other.unstable_sxConfig
  };
  muiTheme.unstable_sx = function sx(props) {
    return styleFunctionSx({
      sx: props,
      theme: this
    });
  };
  return muiTheme;
}
function isObjectEmpty$1(obj) {
  return Object.keys(obj).length === 0;
}
function useTheme$2(defaultTheme2 = null) {
  const contextTheme = React.useContext(ThemeContext);
  return !contextTheme || isObjectEmpty$1(contextTheme) ? defaultTheme2 : contextTheme;
}
const systemDefaultTheme$1 = createTheme$1();
function useTheme$1(defaultTheme2 = systemDefaultTheme$1) {
  return useTheme$2(defaultTheme2);
}
const defaultGenerator = (componentName) => componentName;
const createClassNameGenerator = () => {
  let generate = defaultGenerator;
  return {
    configure(generator) {
      generate = generator;
    },
    generate(componentName) {
      return generate(componentName);
    },
    reset() {
      generate = defaultGenerator;
    }
  };
};
const ClassNameGenerator = createClassNameGenerator();
const globalStateClasses = {
  active: "active",
  checked: "checked",
  completed: "completed",
  disabled: "disabled",
  error: "error",
  expanded: "expanded",
  focused: "focused",
  focusVisible: "focusVisible",
  open: "open",
  readOnly: "readOnly",
  required: "required",
  selected: "selected"
};
function generateUtilityClass(componentName, slot, globalStatePrefix = "Mui") {
  const globalStateClass = globalStateClasses[slot];
  return globalStateClass ? `${globalStatePrefix}-${globalStateClass}` : `${ClassNameGenerator.generate(componentName)}-${slot}`;
}
function generateUtilityClasses(componentName, slots2, globalStatePrefix = "Mui") {
  const result = {};
  slots2.forEach((slot) => {
    result[slot] = generateUtilityClass(componentName, slot, globalStatePrefix);
  });
  return result;
}
function preprocessStyles(input) {
  const {
    variants,
    ...style2
  } = input;
  const result = {
    variants,
    style: internal_serializeStyles(style2),
    isProcessed: true
  };
  if (result.style === style2) {
    return result;
  }
  if (variants) {
    variants.forEach((variant) => {
      if (typeof variant.style !== "function") {
        variant.style = internal_serializeStyles(variant.style);
      }
    });
  }
  return result;
}
const systemDefaultTheme = createTheme$1();
function shouldForwardProp(prop) {
  return prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as";
}
function defaultOverridesResolver(slot) {
  if (!slot) {
    return null;
  }
  return (_props, styles2) => styles2[slot];
}
function attachTheme(props, themeId, defaultTheme2) {
  props.theme = isObjectEmpty(props.theme) ? defaultTheme2 : props.theme[themeId] || props.theme;
}
function processStyle(props, style2) {
  const resolvedStyle = typeof style2 === "function" ? style2(props) : style2;
  if (Array.isArray(resolvedStyle)) {
    return resolvedStyle.flatMap((subStyle) => processStyle(props, subStyle));
  }
  if (Array.isArray(resolvedStyle == null ? void 0 : resolvedStyle.variants)) {
    let rootStyle;
    if (resolvedStyle.isProcessed) {
      rootStyle = resolvedStyle.style;
    } else {
      const {
        variants,
        ...otherStyles
      } = resolvedStyle;
      rootStyle = otherStyles;
    }
    return processStyleVariants(props, resolvedStyle.variants, [rootStyle]);
  }
  if (resolvedStyle == null ? void 0 : resolvedStyle.isProcessed) {
    return resolvedStyle.style;
  }
  return resolvedStyle;
}
function processStyleVariants(props, variants, results = []) {
  var _a2;
  let mergedState;
  variantLoop: for (let i = 0; i < variants.length; i += 1) {
    const variant = variants[i];
    if (typeof variant.props === "function") {
      mergedState ?? (mergedState = {
        ...props,
        ...props.ownerState,
        ownerState: props.ownerState
      });
      if (!variant.props(mergedState)) {
        continue;
      }
    } else {
      for (const key in variant.props) {
        if (props[key] !== variant.props[key] && ((_a2 = props.ownerState) == null ? void 0 : _a2[key]) !== variant.props[key]) {
          continue variantLoop;
        }
      }
    }
    if (typeof variant.style === "function") {
      mergedState ?? (mergedState = {
        ...props,
        ...props.ownerState,
        ownerState: props.ownerState
      });
      results.push(variant.style(mergedState));
    } else {
      results.push(variant.style);
    }
  }
  return results;
}
function createStyled2(input = {}) {
  const {
    themeId,
    defaultTheme: defaultTheme2 = systemDefaultTheme,
    rootShouldForwardProp: rootShouldForwardProp2 = shouldForwardProp,
    slotShouldForwardProp: slotShouldForwardProp2 = shouldForwardProp
  } = input;
  function styleAttachTheme(props) {
    attachTheme(props, themeId, defaultTheme2);
  }
  const styled2 = (tag, inputOptions = {}) => {
    internal_mutateStyles(tag, (styles2) => styles2.filter((style2) => style2 !== styleFunctionSx));
    const {
      name: componentName,
      slot: componentSlot,
      skipVariantsResolver: inputSkipVariantsResolver,
      skipSx: inputSkipSx,
      // TODO v6: remove `lowercaseFirstLetter()` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      overridesResolver: overridesResolver2 = defaultOverridesResolver(lowercaseFirstLetter(componentSlot)),
      ...options
    } = inputOptions;
    const skipVariantsResolver = inputSkipVariantsResolver !== void 0 ? inputSkipVariantsResolver : (
      // TODO v6: remove `Root` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      componentSlot && componentSlot !== "Root" && componentSlot !== "root" || false
    );
    const skipSx = inputSkipSx || false;
    let shouldForwardPropOption = shouldForwardProp;
    if (componentSlot === "Root" || componentSlot === "root") {
      shouldForwardPropOption = rootShouldForwardProp2;
    } else if (componentSlot) {
      shouldForwardPropOption = slotShouldForwardProp2;
    } else if (isStringTag(tag)) {
      shouldForwardPropOption = void 0;
    }
    const defaultStyledResolver = styled$1(tag, {
      shouldForwardProp: shouldForwardPropOption,
      label: generateStyledLabel(),
      ...options
    });
    const transformStyle = (style2) => {
      if (typeof style2 === "function" && style2.__emotion_real !== style2) {
        return function styleFunctionProcessor(props) {
          return processStyle(props, style2);
        };
      }
      if (isPlainObject(style2)) {
        const serialized = preprocessStyles(style2);
        if (!serialized.variants) {
          return serialized.style;
        }
        return function styleObjectProcessor(props) {
          return processStyle(props, serialized);
        };
      }
      return style2;
    };
    const muiStyledResolver = (...expressionsInput) => {
      const expressionsHead = [];
      const expressionsBody = expressionsInput.map(transformStyle);
      const expressionsTail = [];
      expressionsHead.push(styleAttachTheme);
      if (componentName && overridesResolver2) {
        expressionsTail.push(function styleThemeOverrides(props) {
          var _a2, _b;
          const theme = props.theme;
          const styleOverrides = (_b = (_a2 = theme.components) == null ? void 0 : _a2[componentName]) == null ? void 0 : _b.styleOverrides;
          if (!styleOverrides) {
            return null;
          }
          const resolvedStyleOverrides = {};
          for (const slotKey in styleOverrides) {
            resolvedStyleOverrides[slotKey] = processStyle(props, styleOverrides[slotKey]);
          }
          return overridesResolver2(props, resolvedStyleOverrides);
        });
      }
      if (componentName && !skipVariantsResolver) {
        expressionsTail.push(function styleThemeVariants(props) {
          var _a2, _b;
          const theme = props.theme;
          const themeVariants = (_b = (_a2 = theme == null ? void 0 : theme.components) == null ? void 0 : _a2[componentName]) == null ? void 0 : _b.variants;
          if (!themeVariants) {
            return null;
          }
          return processStyleVariants(props, themeVariants);
        });
      }
      if (!skipSx) {
        expressionsTail.push(styleFunctionSx);
      }
      if (Array.isArray(expressionsBody[0])) {
        const inputStrings = expressionsBody.shift();
        const placeholdersHead = new Array(expressionsHead.length).fill("");
        const placeholdersTail = new Array(expressionsTail.length).fill("");
        let outputStrings;
        {
          outputStrings = [...placeholdersHead, ...inputStrings, ...placeholdersTail];
          outputStrings.raw = [...placeholdersHead, ...inputStrings.raw, ...placeholdersTail];
        }
        expressionsHead.unshift(outputStrings);
      }
      const expressions = [...expressionsHead, ...expressionsBody, ...expressionsTail];
      const Component2 = defaultStyledResolver(...expressions);
      if (tag.muiName) {
        Component2.muiName = tag.muiName;
      }
      return Component2;
    };
    if (defaultStyledResolver.withConfig) {
      muiStyledResolver.withConfig = defaultStyledResolver.withConfig;
    }
    return muiStyledResolver;
  };
  return styled2;
}
function generateStyledLabel(componentName, componentSlot) {
  let label;
  return label;
}
function isObjectEmpty(object) {
  for (const _2 in object) {
    return false;
  }
  return true;
}
function isStringTag(tag) {
  return typeof tag === "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  tag.charCodeAt(0) > 96;
}
function lowercaseFirstLetter(string) {
  if (!string) {
    return string;
  }
  return string.charAt(0).toLowerCase() + string.slice(1);
}
function resolveProps(defaultProps2, props) {
  const output = {
    ...props
  };
  for (const key in defaultProps2) {
    if (Object.prototype.hasOwnProperty.call(defaultProps2, key)) {
      const propName = key;
      if (propName === "components" || propName === "slots") {
        output[propName] = {
          ...defaultProps2[propName],
          ...output[propName]
        };
      } else if (propName === "componentsProps" || propName === "slotProps") {
        const defaultSlotProps = defaultProps2[propName];
        const slotProps = props[propName];
        if (!slotProps) {
          output[propName] = defaultSlotProps || {};
        } else if (!defaultSlotProps) {
          output[propName] = slotProps;
        } else {
          output[propName] = {
            ...slotProps
          };
          for (const slotKey in defaultSlotProps) {
            if (Object.prototype.hasOwnProperty.call(defaultSlotProps, slotKey)) {
              const slotPropName = slotKey;
              output[propName][slotPropName] = resolveProps(defaultSlotProps[slotPropName], slotProps[slotPropName]);
            }
          }
        }
      } else if (output[propName] === void 0) {
        output[propName] = defaultProps2[propName];
      }
    }
  }
  return output;
}
const useEnhancedEffect = typeof window !== "undefined" ? React.useLayoutEffect : React.useEffect;
function clamp(val, min = Number.MIN_SAFE_INTEGER, max = Number.MAX_SAFE_INTEGER) {
  return Math.max(min, Math.min(val, max));
}
function clampWrapper(value, min = 0, max = 1) {
  return clamp(value, min, max);
}
function hexToRgb(color2) {
  color2 = color2.slice(1);
  const re = new RegExp(`.{1,${color2.length >= 6 ? 2 : 1}}`, "g");
  let colors = color2.match(re);
  if (colors && colors[0].length === 1) {
    colors = colors.map((n) => n + n);
  }
  return colors ? `rgb${colors.length === 4 ? "a" : ""}(${colors.map((n, index) => {
    return index < 3 ? parseInt(n, 16) : Math.round(parseInt(n, 16) / 255 * 1e3) / 1e3;
  }).join(", ")})` : "";
}
function decomposeColor(color2) {
  if (color2.type) {
    return color2;
  }
  if (color2.charAt(0) === "#") {
    return decomposeColor(hexToRgb(color2));
  }
  const marker = color2.indexOf("(");
  const type = color2.substring(0, marker);
  if (!["rgb", "rgba", "hsl", "hsla", "color"].includes(type)) {
    throw new Error(formatMuiErrorMessage(9, color2));
  }
  let values2 = color2.substring(marker + 1, color2.length - 1);
  let colorSpace;
  if (type === "color") {
    values2 = values2.split(" ");
    colorSpace = values2.shift();
    if (values2.length === 4 && values2[3].charAt(0) === "/") {
      values2[3] = values2[3].slice(1);
    }
    if (!["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].includes(colorSpace)) {
      throw new Error(formatMuiErrorMessage(10, colorSpace));
    }
  } else {
    values2 = values2.split(",");
  }
  values2 = values2.map((value) => parseFloat(value));
  return {
    type,
    values: values2,
    colorSpace
  };
}
const colorChannel = (color2) => {
  const decomposedColor = decomposeColor(color2);
  return decomposedColor.values.slice(0, 3).map((val, idx) => decomposedColor.type.includes("hsl") && idx !== 0 ? `${val}%` : val).join(" ");
};
const private_safeColorChannel = (color2, warning) => {
  try {
    return colorChannel(color2);
  } catch (error2) {
    return color2;
  }
};
function recomposeColor(color2) {
  const {
    type,
    colorSpace
  } = color2;
  let {
    values: values2
  } = color2;
  if (type.includes("rgb")) {
    values2 = values2.map((n, i) => i < 3 ? parseInt(n, 10) : n);
  } else if (type.includes("hsl")) {
    values2[1] = `${values2[1]}%`;
    values2[2] = `${values2[2]}%`;
  }
  if (type.includes("color")) {
    values2 = `${colorSpace} ${values2.join(" ")}`;
  } else {
    values2 = `${values2.join(", ")}`;
  }
  return `${type}(${values2})`;
}
function hslToRgb(color2) {
  color2 = decomposeColor(color2);
  const {
    values: values2
  } = color2;
  const h = values2[0];
  const s = values2[1] / 100;
  const l = values2[2] / 100;
  const a = s * Math.min(l, 1 - l);
  const f = (n, k2 = (n + h / 30) % 12) => l - a * Math.max(Math.min(k2 - 3, 9 - k2, 1), -1);
  let type = "rgb";
  const rgb = [Math.round(f(0) * 255), Math.round(f(8) * 255), Math.round(f(4) * 255)];
  if (color2.type === "hsla") {
    type += "a";
    rgb.push(values2[3]);
  }
  return recomposeColor({
    type,
    values: rgb
  });
}
function getLuminance(color2) {
  color2 = decomposeColor(color2);
  let rgb = color2.type === "hsl" || color2.type === "hsla" ? decomposeColor(hslToRgb(color2)).values : color2.values;
  rgb = rgb.map((val) => {
    if (color2.type !== "color") {
      val /= 255;
    }
    return val <= 0.03928 ? val / 12.92 : ((val + 0.055) / 1.055) ** 2.4;
  });
  return Number((0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2]).toFixed(3));
}
function getContrastRatio(foreground, background) {
  const lumA = getLuminance(foreground);
  const lumB = getLuminance(background);
  return (Math.max(lumA, lumB) + 0.05) / (Math.min(lumA, lumB) + 0.05);
}
function alpha(color2, value) {
  color2 = decomposeColor(color2);
  value = clampWrapper(value);
  if (color2.type === "rgb" || color2.type === "hsl") {
    color2.type += "a";
  }
  if (color2.type === "color") {
    color2.values[3] = `/${value}`;
  } else {
    color2.values[3] = value;
  }
  return recomposeColor(color2);
}
function private_safeAlpha(color2, value, warning) {
  try {
    return alpha(color2, value);
  } catch (error2) {
    return color2;
  }
}
function darken(color2, coefficient) {
  color2 = decomposeColor(color2);
  coefficient = clampWrapper(coefficient);
  if (color2.type.includes("hsl")) {
    color2.values[2] *= 1 - coefficient;
  } else if (color2.type.includes("rgb") || color2.type.includes("color")) {
    for (let i = 0; i < 3; i += 1) {
      color2.values[i] *= 1 - coefficient;
    }
  }
  return recomposeColor(color2);
}
function private_safeDarken(color2, coefficient, warning) {
  try {
    return darken(color2, coefficient);
  } catch (error2) {
    return color2;
  }
}
function lighten(color2, coefficient) {
  color2 = decomposeColor(color2);
  coefficient = clampWrapper(coefficient);
  if (color2.type.includes("hsl")) {
    color2.values[2] += (100 - color2.values[2]) * coefficient;
  } else if (color2.type.includes("rgb")) {
    for (let i = 0; i < 3; i += 1) {
      color2.values[i] += (255 - color2.values[i]) * coefficient;
    }
  } else if (color2.type.includes("color")) {
    for (let i = 0; i < 3; i += 1) {
      color2.values[i] += (1 - color2.values[i]) * coefficient;
    }
  }
  return recomposeColor(color2);
}
function private_safeLighten(color2, coefficient, warning) {
  try {
    return lighten(color2, coefficient);
  } catch (error2) {
    return color2;
  }
}
function emphasize(color2, coefficient = 0.15) {
  return getLuminance(color2) > 0.5 ? darken(color2, coefficient) : lighten(color2, coefficient);
}
function private_safeEmphasize(color2, coefficient, warning) {
  try {
    return emphasize(color2, coefficient);
  } catch (error2) {
    return color2;
  }
}
function createChainedFunction(...funcs) {
  return funcs.reduce((acc, func) => {
    if (func == null) {
      return acc;
    }
    return function chainedFunction(...args) {
      acc.apply(this, args);
      func.apply(this, args);
    };
  }, () => {
  });
}
function debounce(func, wait = 166) {
  let timeout;
  function debounced(...args) {
    const later = () => {
      func.apply(this, args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  }
  debounced.clear = () => {
    clearTimeout(timeout);
  };
  return debounced;
}
function ownerWindow(node2) {
  const doc = ownerDocument(node2);
  return doc.defaultView || window;
}
let globalId = 0;
function useGlobalId(idOverride) {
  const [defaultId, setDefaultId] = React.useState(idOverride);
  const id = idOverride || defaultId;
  React.useEffect(() => {
    if (defaultId == null) {
      globalId += 1;
      setDefaultId(`mui-${globalId}`);
    }
  }, [defaultId]);
  return id;
}
const safeReact = {
  ...React
};
const maybeReactUseId = safeReact.useId;
function useId(idOverride) {
  if (maybeReactUseId !== void 0) {
    const reactId = maybeReactUseId();
    return idOverride ?? reactId;
  }
  return useGlobalId(idOverride);
}
function useEventCallback(fn) {
  const ref2 = React.useRef(fn);
  useEnhancedEffect(() => {
    ref2.current = fn;
  });
  return React.useRef((...args) => (
    // @ts-expect-error hide `this`
    (0, ref2.current)(...args)
  )).current;
}
const UNINITIALIZED = {};
function useLazyRef(init, initArg) {
  const ref2 = React.useRef(UNINITIALIZED);
  if (ref2.current === UNINITIALIZED) {
    ref2.current = init(initArg);
  }
  return ref2;
}
const EMPTY = [];
function useOnMount(fn) {
  React.useEffect(fn, EMPTY);
}
class Timeout {
  constructor() {
    __publicField(this, "currentId", null);
    __publicField(this, "clear", () => {
      if (this.currentId !== null) {
        clearTimeout(this.currentId);
        this.currentId = null;
      }
    });
    __publicField(this, "disposeEffect", () => {
      return this.clear;
    });
  }
  static create() {
    return new Timeout();
  }
  /**
   * Executes `fn` after `delay`, clearing any previously scheduled call.
   */
  start(delay, fn) {
    this.clear();
    this.currentId = setTimeout(() => {
      this.currentId = null;
      fn();
    }, delay);
  }
}
function useTimeout() {
  const timeout = useLazyRef(Timeout.create).current;
  useOnMount(timeout.disposeEffect);
  return timeout;
}
function isFocusVisible(element) {
  try {
    return element.matches(":focus-visible");
  } catch (error2) {
  }
  return false;
}
function getScrollbarSize(win = window) {
  const documentWidth = win.document.documentElement.clientWidth;
  return win.innerWidth - documentWidth;
}
const usePreviousProps = (value) => {
  const ref2 = React.useRef({});
  React.useEffect(() => {
    ref2.current = value;
  });
  return ref2.current;
};
function getReactElementRef(element) {
  var _a2;
  if (parseInt(React.version, 10) >= 19) {
    return ((_a2 = element == null ? void 0 : element.props) == null ? void 0 : _a2.ref) || null;
  }
  return (element == null ? void 0 : element.ref) || null;
}
const PropsContext = /* @__PURE__ */ React.createContext(void 0);
function getThemeProps(params) {
  const {
    theme,
    name,
    props
  } = params;
  if (!theme || !theme.components || !theme.components[name]) {
    return props;
  }
  const config2 = theme.components[name];
  if (config2.defaultProps) {
    return resolveProps(config2.defaultProps, props);
  }
  if (!config2.styleOverrides && !config2.variants) {
    return resolveProps(config2, props);
  }
  return props;
}
function useDefaultProps$1({
  props,
  name
}) {
  const ctx = React.useContext(PropsContext);
  return getThemeProps({
    props,
    name,
    theme: {
      components: ctx
    }
  });
}
const arg = {
  theme: void 0
};
function unstable_memoTheme(styleFn) {
  let lastValue;
  let lastTheme;
  return function styleMemoized(props) {
    let value = lastValue;
    if (value === void 0 || props.theme !== lastTheme) {
      arg.theme = props.theme;
      value = preprocessStyles(styleFn(arg));
      lastValue = value;
      lastTheme = props.theme;
    }
    return value;
  };
}
function createGetCssVar$1(prefix2 = "") {
  function appendVar(...vars) {
    if (!vars.length) {
      return "";
    }
    const value = vars[0];
    if (typeof value === "string" && !value.match(/(#|\(|\)|(-?(\d*\.)?\d+)(px|em|%|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc))|^(-?(\d*\.)?\d+)$|(\d+ \d+ \d+)/)) {
      return `, var(--${prefix2 ? `${prefix2}-` : ""}${value}${appendVar(...vars.slice(1))})`;
    }
    return `, ${value}`;
  }
  const getCssVar = (field, ...fallbacks) => {
    return `var(--${prefix2 ? `${prefix2}-` : ""}${field}${appendVar(...fallbacks)})`;
  };
  return getCssVar;
}
const assignNestedKeys = (obj, keys, value, arrayKeys = []) => {
  let temp = obj;
  keys.forEach((k2, index) => {
    if (index === keys.length - 1) {
      if (Array.isArray(temp)) {
        temp[Number(k2)] = value;
      } else if (temp && typeof temp === "object") {
        temp[k2] = value;
      }
    } else if (temp && typeof temp === "object") {
      if (!temp[k2]) {
        temp[k2] = arrayKeys.includes(k2) ? [] : {};
      }
      temp = temp[k2];
    }
  });
};
const walkObjectDeep = (obj, callback, shouldSkipPaths) => {
  function recurse(object, parentKeys = [], arrayKeys = []) {
    Object.entries(object).forEach(([key, value]) => {
      if (!shouldSkipPaths || shouldSkipPaths && !shouldSkipPaths([...parentKeys, key])) {
        if (value !== void 0 && value !== null) {
          if (typeof value === "object" && Object.keys(value).length > 0) {
            recurse(value, [...parentKeys, key], Array.isArray(value) ? [...arrayKeys, key] : arrayKeys);
          } else {
            callback([...parentKeys, key], value, arrayKeys);
          }
        }
      }
    });
  }
  recurse(obj);
};
const getCssValue = (keys, value) => {
  if (typeof value === "number") {
    if (["lineHeight", "fontWeight", "opacity", "zIndex"].some((prop) => keys.includes(prop))) {
      return value;
    }
    const lastKey = keys[keys.length - 1];
    if (lastKey.toLowerCase().includes("opacity")) {
      return value;
    }
    return `${value}px`;
  }
  return value;
};
function cssVarsParser(theme, options) {
  const {
    prefix: prefix2,
    shouldSkipGeneratingVar: shouldSkipGeneratingVar2
  } = options || {};
  const css2 = {};
  const vars = {};
  const varsWithDefaults = {};
  walkObjectDeep(
    theme,
    (keys, value, arrayKeys) => {
      if (typeof value === "string" || typeof value === "number") {
        if (!shouldSkipGeneratingVar2 || !shouldSkipGeneratingVar2(keys, value)) {
          const cssVar = `--${prefix2 ? `${prefix2}-` : ""}${keys.join("-")}`;
          const resolvedValue = getCssValue(keys, value);
          Object.assign(css2, {
            [cssVar]: resolvedValue
          });
          assignNestedKeys(vars, keys, `var(${cssVar})`, arrayKeys);
          assignNestedKeys(varsWithDefaults, keys, `var(${cssVar}, ${resolvedValue})`, arrayKeys);
        }
      }
    },
    (keys) => keys[0] === "vars"
    // skip 'vars/*' paths
  );
  return {
    css: css2,
    vars,
    varsWithDefaults
  };
}
function prepareCssVars(theme, parserConfig = {}) {
  const {
    getSelector = defaultGetSelector2,
    disableCssColorScheme,
    colorSchemeSelector: selector
  } = parserConfig;
  const {
    colorSchemes = {},
    components,
    defaultColorScheme = "light",
    ...otherTheme
  } = theme;
  const {
    vars: rootVars,
    css: rootCss,
    varsWithDefaults: rootVarsWithDefaults
  } = cssVarsParser(otherTheme, parserConfig);
  let themeVars = rootVarsWithDefaults;
  const colorSchemesMap = {};
  const {
    [defaultColorScheme]: defaultScheme,
    ...otherColorSchemes
  } = colorSchemes;
  Object.entries(otherColorSchemes || {}).forEach(([key, scheme]) => {
    const {
      vars,
      css: css2,
      varsWithDefaults
    } = cssVarsParser(scheme, parserConfig);
    themeVars = deepmerge(themeVars, varsWithDefaults);
    colorSchemesMap[key] = {
      css: css2,
      vars
    };
  });
  if (defaultScheme) {
    const {
      css: css2,
      vars,
      varsWithDefaults
    } = cssVarsParser(defaultScheme, parserConfig);
    themeVars = deepmerge(themeVars, varsWithDefaults);
    colorSchemesMap[defaultColorScheme] = {
      css: css2,
      vars
    };
  }
  function defaultGetSelector2(colorScheme, cssObject) {
    var _a2, _b;
    let rule = selector;
    if (selector === "class") {
      rule = ".%s";
    }
    if (selector === "data") {
      rule = "[data-%s]";
    }
    if ((selector == null ? void 0 : selector.startsWith("data-")) && !selector.includes("%s")) {
      rule = `[${selector}="%s"]`;
    }
    if (colorScheme) {
      if (rule === "media") {
        if (theme.defaultColorScheme === colorScheme) {
          return ":root";
        }
        const mode = ((_b = (_a2 = colorSchemes[colorScheme]) == null ? void 0 : _a2.palette) == null ? void 0 : _b.mode) || colorScheme;
        return {
          [`@media (prefers-color-scheme: ${mode})`]: {
            ":root": cssObject
          }
        };
      }
      if (rule) {
        if (theme.defaultColorScheme === colorScheme) {
          return `:root, ${rule.replace("%s", String(colorScheme))}`;
        }
        return rule.replace("%s", String(colorScheme));
      }
    }
    return ":root";
  }
  const generateThemeVars = () => {
    let vars = {
      ...rootVars
    };
    Object.entries(colorSchemesMap).forEach(([, {
      vars: schemeVars
    }]) => {
      vars = deepmerge(vars, schemeVars);
    });
    return vars;
  };
  const generateStyleSheets = () => {
    var _a2, _b;
    const stylesheets = [];
    const colorScheme = theme.defaultColorScheme || "light";
    function insertStyleSheet(key, css2) {
      if (Object.keys(css2).length) {
        stylesheets.push(typeof key === "string" ? {
          [key]: {
            ...css2
          }
        } : key);
      }
    }
    insertStyleSheet(getSelector(void 0, {
      ...rootCss
    }), rootCss);
    const {
      [colorScheme]: defaultSchemeVal,
      ...other
    } = colorSchemesMap;
    if (defaultSchemeVal) {
      const {
        css: css2
      } = defaultSchemeVal;
      const cssColorSheme = (_b = (_a2 = colorSchemes[colorScheme]) == null ? void 0 : _a2.palette) == null ? void 0 : _b.mode;
      const finalCss = !disableCssColorScheme && cssColorSheme ? {
        colorScheme: cssColorSheme,
        ...css2
      } : {
        ...css2
      };
      insertStyleSheet(getSelector(colorScheme, {
        ...finalCss
      }), finalCss);
    }
    Object.entries(other).forEach(([key, {
      css: css2
    }]) => {
      var _a3, _b2;
      const cssColorSheme = (_b2 = (_a3 = colorSchemes[key]) == null ? void 0 : _a3.palette) == null ? void 0 : _b2.mode;
      const finalCss = !disableCssColorScheme && cssColorSheme ? {
        colorScheme: cssColorSheme,
        ...css2
      } : {
        ...css2
      };
      insertStyleSheet(getSelector(key, {
        ...finalCss
      }), finalCss);
    });
    return stylesheets;
  };
  return {
    vars: themeVars,
    generateThemeVars,
    generateStyleSheets
  };
}
function createGetColorSchemeSelector(selector) {
  return function getColorSchemeSelector(colorScheme) {
    if (selector === "media") {
      return `@media (prefers-color-scheme: ${colorScheme})`;
    }
    if (selector) {
      if (selector.startsWith("data-") && !selector.includes("%s")) {
        return `[${selector}="${colorScheme}"] &`;
      }
      if (selector === "class") {
        return `.${colorScheme} &`;
      }
      if (selector === "data") {
        return `[data-${colorScheme}] &`;
      }
      return `${selector.replace("%s", colorScheme)} &`;
    }
    return "&";
  };
}
const common = {
  black: "#000",
  white: "#fff"
};
const grey = {
  50: "#fafafa",
  100: "#f5f5f5",
  200: "#eeeeee",
  300: "#e0e0e0",
  400: "#bdbdbd",
  500: "#9e9e9e",
  600: "#757575",
  700: "#616161",
  800: "#424242",
  900: "#212121",
  A100: "#f5f5f5",
  A200: "#eeeeee",
  A400: "#bdbdbd",
  A700: "#616161"
};
const purple = {
  50: "#f3e5f5",
  200: "#ce93d8",
  300: "#ba68c8",
  400: "#ab47bc",
  500: "#9c27b0",
  700: "#7b1fa2"
};
const red = {
  300: "#e57373",
  400: "#ef5350",
  500: "#f44336",
  700: "#d32f2f",
  800: "#c62828"
};
const orange = {
  300: "#ffb74d",
  400: "#ffa726",
  500: "#ff9800",
  700: "#f57c00",
  900: "#e65100"
};
const blue = {
  50: "#e3f2fd",
  200: "#90caf9",
  400: "#42a5f5",
  700: "#1976d2",
  800: "#1565c0"
};
const lightBlue = {
  300: "#4fc3f7",
  400: "#29b6f6",
  500: "#03a9f4",
  700: "#0288d1",
  900: "#01579b"
};
const green = {
  300: "#81c784",
  400: "#66bb6a",
  500: "#4caf50",
  700: "#388e3c",
  800: "#2e7d32",
  900: "#1b5e20"
};
function getLight() {
  return {
    // The colors used to style the text.
    text: {
      // The most important text.
      primary: "rgba(0, 0, 0, 0.87)",
      // Secondary text.
      secondary: "rgba(0, 0, 0, 0.6)",
      // Disabled text have even lower visual prominence.
      disabled: "rgba(0, 0, 0, 0.38)"
    },
    // The color used to divide different elements.
    divider: "rgba(0, 0, 0, 0.12)",
    // The background colors used to style the surfaces.
    // Consistency between these values is important.
    background: {
      paper: common.white,
      default: common.white
    },
    // The colors used to style the action elements.
    action: {
      // The color of an active action like an icon button.
      active: "rgba(0, 0, 0, 0.54)",
      // The color of an hovered action.
      hover: "rgba(0, 0, 0, 0.04)",
      hoverOpacity: 0.04,
      // The color of a selected action.
      selected: "rgba(0, 0, 0, 0.08)",
      selectedOpacity: 0.08,
      // The color of a disabled action.
      disabled: "rgba(0, 0, 0, 0.26)",
      // The background color of a disabled action.
      disabledBackground: "rgba(0, 0, 0, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(0, 0, 0, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.12
    }
  };
}
const light = getLight();
function getDark() {
  return {
    text: {
      primary: common.white,
      secondary: "rgba(255, 255, 255, 0.7)",
      disabled: "rgba(255, 255, 255, 0.5)",
      icon: "rgba(255, 255, 255, 0.5)"
    },
    divider: "rgba(255, 255, 255, 0.12)",
    background: {
      paper: "#121212",
      default: "#121212"
    },
    action: {
      active: common.white,
      hover: "rgba(255, 255, 255, 0.08)",
      hoverOpacity: 0.08,
      selected: "rgba(255, 255, 255, 0.16)",
      selectedOpacity: 0.16,
      disabled: "rgba(255, 255, 255, 0.3)",
      disabledBackground: "rgba(255, 255, 255, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(255, 255, 255, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.24
    }
  };
}
const dark = getDark();
function addLightOrDark(intent, direction, shade, tonalOffset) {
  const tonalOffsetLight = tonalOffset.light || tonalOffset;
  const tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;
  if (!intent[direction]) {
    if (intent.hasOwnProperty(shade)) {
      intent[direction] = intent[shade];
    } else if (direction === "light") {
      intent.light = lighten(intent.main, tonalOffsetLight);
    } else if (direction === "dark") {
      intent.dark = darken(intent.main, tonalOffsetDark);
    }
  }
}
function getDefaultPrimary(mode = "light") {
  if (mode === "dark") {
    return {
      main: blue[200],
      light: blue[50],
      dark: blue[400]
    };
  }
  return {
    main: blue[700],
    light: blue[400],
    dark: blue[800]
  };
}
function getDefaultSecondary(mode = "light") {
  if (mode === "dark") {
    return {
      main: purple[200],
      light: purple[50],
      dark: purple[400]
    };
  }
  return {
    main: purple[500],
    light: purple[300],
    dark: purple[700]
  };
}
function getDefaultError(mode = "light") {
  if (mode === "dark") {
    return {
      main: red[500],
      light: red[300],
      dark: red[700]
    };
  }
  return {
    main: red[700],
    light: red[400],
    dark: red[800]
  };
}
function getDefaultInfo(mode = "light") {
  if (mode === "dark") {
    return {
      main: lightBlue[400],
      light: lightBlue[300],
      dark: lightBlue[700]
    };
  }
  return {
    main: lightBlue[700],
    light: lightBlue[500],
    dark: lightBlue[900]
  };
}
function getDefaultSuccess(mode = "light") {
  if (mode === "dark") {
    return {
      main: green[400],
      light: green[300],
      dark: green[700]
    };
  }
  return {
    main: green[800],
    light: green[500],
    dark: green[900]
  };
}
function getDefaultWarning(mode = "light") {
  if (mode === "dark") {
    return {
      main: orange[400],
      light: orange[300],
      dark: orange[700]
    };
  }
  return {
    main: "#ed6c02",
    // closest to orange[800] that pass 3:1.
    light: orange[500],
    dark: orange[900]
  };
}
function createPalette(palette) {
  const {
    mode = "light",
    contrastThreshold = 3,
    tonalOffset = 0.2,
    ...other
  } = palette;
  const primary = palette.primary || getDefaultPrimary(mode);
  const secondary = palette.secondary || getDefaultSecondary(mode);
  const error2 = palette.error || getDefaultError(mode);
  const info = palette.info || getDefaultInfo(mode);
  const success = palette.success || getDefaultSuccess(mode);
  const warning = palette.warning || getDefaultWarning(mode);
  function getContrastText(background) {
    const contrastText = getContrastRatio(background, dark.text.primary) >= contrastThreshold ? dark.text.primary : light.text.primary;
    return contrastText;
  }
  const augmentColor = ({
    color: color2,
    name,
    mainShade = 500,
    lightShade = 300,
    darkShade = 700
  }) => {
    color2 = {
      ...color2
    };
    if (!color2.main && color2[mainShade]) {
      color2.main = color2[mainShade];
    }
    if (!color2.hasOwnProperty("main")) {
      throw new Error(formatMuiErrorMessage(11, name ? ` (${name})` : "", mainShade));
    }
    if (typeof color2.main !== "string") {
      throw new Error(formatMuiErrorMessage(12, name ? ` (${name})` : "", JSON.stringify(color2.main)));
    }
    addLightOrDark(color2, "light", lightShade, tonalOffset);
    addLightOrDark(color2, "dark", darkShade, tonalOffset);
    if (!color2.contrastText) {
      color2.contrastText = getContrastText(color2.main);
    }
    return color2;
  };
  let modeHydrated;
  if (mode === "light") {
    modeHydrated = getLight();
  } else if (mode === "dark") {
    modeHydrated = getDark();
  }
  const paletteOutput = deepmerge({
    // A collection of common colors.
    common: {
      ...common
    },
    // prevent mutable object.
    // The palette mode, can be light or dark.
    mode,
    // The colors used to represent primary interface elements for a user.
    primary: augmentColor({
      color: primary,
      name: "primary"
    }),
    // The colors used to represent secondary interface elements for a user.
    secondary: augmentColor({
      color: secondary,
      name: "secondary",
      mainShade: "A400",
      lightShade: "A200",
      darkShade: "A700"
    }),
    // The colors used to represent interface elements that the user should be made aware of.
    error: augmentColor({
      color: error2,
      name: "error"
    }),
    // The colors used to represent potentially dangerous actions or important messages.
    warning: augmentColor({
      color: warning,
      name: "warning"
    }),
    // The colors used to present information to the user that is neutral and not necessarily important.
    info: augmentColor({
      color: info,
      name: "info"
    }),
    // The colors used to indicate the successful completion of an action that user triggered.
    success: augmentColor({
      color: success,
      name: "success"
    }),
    // The grey colors.
    grey,
    // Used by `getContrastText()` to maximize the contrast between
    // the background and the text.
    contrastThreshold,
    // Takes a background color and returns the text color that maximizes the contrast.
    getContrastText,
    // Generate a rich color object.
    augmentColor,
    // Used by the functions below to shift a color's luminance by approximately
    // two indexes within its tonal palette.
    // E.g., shift from Red 500 to Red 300 or Red 700.
    tonalOffset,
    // The light and dark mode object.
    ...modeHydrated
  }, other);
  return paletteOutput;
}
function prepareTypographyVars(typography) {
  const vars = {};
  const entries = Object.entries(typography);
  entries.forEach((entry) => {
    const [key, value] = entry;
    if (typeof value === "object") {
      vars[key] = `${value.fontStyle ? `${value.fontStyle} ` : ""}${value.fontVariant ? `${value.fontVariant} ` : ""}${value.fontWeight ? `${value.fontWeight} ` : ""}${value.fontStretch ? `${value.fontStretch} ` : ""}${value.fontSize || ""}${value.lineHeight ? `/${value.lineHeight} ` : ""}${value.fontFamily || ""}`;
    }
  });
  return vars;
}
function createMixins(breakpoints, mixins) {
  return {
    toolbar: {
      minHeight: 56,
      [breakpoints.up("xs")]: {
        "@media (orientation: landscape)": {
          minHeight: 48
        }
      },
      [breakpoints.up("sm")]: {
        minHeight: 64
      }
    },
    ...mixins
  };
}
function round(value) {
  return Math.round(value * 1e5) / 1e5;
}
const caseAllCaps = {
  textTransform: "uppercase"
};
const defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';
function createTypography(palette, typography) {
  const {
    fontFamily = defaultFontFamily,
    // The default font size of the Material Specification.
    fontSize = 14,
    // px
    fontWeightLight = 300,
    fontWeightRegular = 400,
    fontWeightMedium = 500,
    fontWeightBold = 700,
    // Tell MUI what's the font-size on the html element.
    // 16px is the default font-size used by browsers.
    htmlFontSize = 16,
    // Apply the CSS properties to all the variants.
    allVariants,
    pxToRem: pxToRem2,
    ...other
  } = typeof typography === "function" ? typography(palette) : typography;
  const coef = fontSize / 14;
  const pxToRem = pxToRem2 || ((size) => `${size / htmlFontSize * coef}rem`);
  const buildVariant = (fontWeight, size, lineHeight, letterSpacing, casing) => ({
    fontFamily,
    fontWeight,
    fontSize: pxToRem(size),
    // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
    lineHeight,
    // The letter spacing was designed for the Roboto font-family. Using the same letter-spacing
    // across font-families can cause issues with the kerning.
    ...fontFamily === defaultFontFamily ? {
      letterSpacing: `${round(letterSpacing / size)}em`
    } : {},
    ...casing,
    ...allVariants
  });
  const variants = {
    h1: buildVariant(fontWeightLight, 96, 1.167, -1.5),
    h2: buildVariant(fontWeightLight, 60, 1.2, -0.5),
    h3: buildVariant(fontWeightRegular, 48, 1.167, 0),
    h4: buildVariant(fontWeightRegular, 34, 1.235, 0.25),
    h5: buildVariant(fontWeightRegular, 24, 1.334, 0),
    h6: buildVariant(fontWeightMedium, 20, 1.6, 0.15),
    subtitle1: buildVariant(fontWeightRegular, 16, 1.75, 0.15),
    subtitle2: buildVariant(fontWeightMedium, 14, 1.57, 0.1),
    body1: buildVariant(fontWeightRegular, 16, 1.5, 0.15),
    body2: buildVariant(fontWeightRegular, 14, 1.43, 0.15),
    button: buildVariant(fontWeightMedium, 14, 1.75, 0.4, caseAllCaps),
    caption: buildVariant(fontWeightRegular, 12, 1.66, 0.4),
    overline: buildVariant(fontWeightRegular, 12, 2.66, 1, caseAllCaps),
    // TODO v6: Remove handling of 'inherit' variant from the theme as it is already handled in Material UI's Typography component. Also, remember to remove the associated types.
    inherit: {
      fontFamily: "inherit",
      fontWeight: "inherit",
      fontSize: "inherit",
      lineHeight: "inherit",
      letterSpacing: "inherit"
    }
  };
  return deepmerge({
    htmlFontSize,
    pxToRem,
    fontFamily,
    fontSize,
    fontWeightLight,
    fontWeightRegular,
    fontWeightMedium,
    fontWeightBold,
    ...variants
  }, other, {
    clone: false
    // No need to clone deep
  });
}
const shadowKeyUmbraOpacity = 0.2;
const shadowKeyPenumbraOpacity = 0.14;
const shadowAmbientShadowOpacity = 0.12;
function createShadow(...px) {
  return [`${px[0]}px ${px[1]}px ${px[2]}px ${px[3]}px rgba(0,0,0,${shadowKeyUmbraOpacity})`, `${px[4]}px ${px[5]}px ${px[6]}px ${px[7]}px rgba(0,0,0,${shadowKeyPenumbraOpacity})`, `${px[8]}px ${px[9]}px ${px[10]}px ${px[11]}px rgba(0,0,0,${shadowAmbientShadowOpacity})`].join(",");
}
const shadows = ["none", createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)];
const easing = {
  // This is the most common easing curve.
  easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
  // Objects enter the screen at full velocity from off-screen and
  // slowly decelerate to a resting point.
  easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
  // Objects leave the screen at full velocity. They do not decelerate when off-screen.
  easeIn: "cubic-bezier(0.4, 0, 1, 1)",
  // The sharp curve is used by objects that may return to the screen at any time.
  sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
};
const duration = {
  shortest: 150,
  shorter: 200,
  short: 250,
  // most basic recommended timing
  standard: 300,
  // this is to be used in complex animations
  complex: 375,
  // recommended when something is entering screen
  enteringScreen: 225,
  // recommended when something is leaving screen
  leavingScreen: 195
};
function formatMs(milliseconds) {
  return `${Math.round(milliseconds)}ms`;
}
function getAutoHeightDuration(height2) {
  if (!height2) {
    return 0;
  }
  const constant = height2 / 36;
  return Math.min(Math.round((4 + 15 * constant ** 0.25 + constant / 5) * 10), 3e3);
}
function createTransitions(inputTransitions) {
  const mergedEasing = {
    ...easing,
    ...inputTransitions.easing
  };
  const mergedDuration = {
    ...duration,
    ...inputTransitions.duration
  };
  const create = (props = ["all"], options = {}) => {
    const {
      duration: durationOption = mergedDuration.standard,
      easing: easingOption = mergedEasing.easeInOut,
      delay = 0,
      ...other
    } = options;
    return (Array.isArray(props) ? props : [props]).map((animatedProp) => `${animatedProp} ${typeof durationOption === "string" ? durationOption : formatMs(durationOption)} ${easingOption} ${typeof delay === "string" ? delay : formatMs(delay)}`).join(",");
  };
  return {
    getAutoHeightDuration,
    create,
    ...inputTransitions,
    easing: mergedEasing,
    duration: mergedDuration
  };
}
const zIndex = {
  mobileStepper: 1e3,
  fab: 1050,
  speedDial: 1050,
  appBar: 1100,
  drawer: 1200,
  modal: 1300,
  snackbar: 1400,
  tooltip: 1500
};
function isSerializable(val) {
  return isPlainObject(val) || typeof val === "undefined" || typeof val === "string" || typeof val === "boolean" || typeof val === "number" || Array.isArray(val);
}
function stringifyTheme(baseTheme = {}) {
  const serializableTheme = {
    ...baseTheme
  };
  function serializeTheme(object) {
    const array = Object.entries(object);
    for (let index = 0; index < array.length; index++) {
      const [key, value] = array[index];
      if (!isSerializable(value) || key.startsWith("unstable_")) {
        delete object[key];
      } else if (isPlainObject(value)) {
        object[key] = {
          ...value
        };
        serializeTheme(object[key]);
      }
    }
  }
  serializeTheme(serializableTheme);
  return `import { unstable_createBreakpoints as createBreakpoints, createTransitions } from '@mui/material/styles';

const theme = ${JSON.stringify(serializableTheme, null, 2)};

theme.breakpoints = createBreakpoints(theme.breakpoints || {});
theme.transitions = createTransitions(theme.transitions || {});

export default theme;`;
}
function createThemeNoVars(options = {}, ...args) {
  const {
    breakpoints: breakpointsInput,
    mixins: mixinsInput = {},
    spacing: spacingInput,
    palette: paletteInput = {},
    transitions: transitionsInput = {},
    typography: typographyInput = {},
    shape: shapeInput,
    ...other
  } = options;
  if (options.vars) {
    throw new Error(formatMuiErrorMessage(20));
  }
  const palette = createPalette(paletteInput);
  const systemTheme = createTheme$1(options);
  let muiTheme = deepmerge(systemTheme, {
    mixins: createMixins(systemTheme.breakpoints, mixinsInput),
    palette,
    // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
    shadows: shadows.slice(),
    typography: createTypography(palette, typographyInput),
    transitions: createTransitions(transitionsInput),
    zIndex: {
      ...zIndex
    }
  });
  muiTheme = deepmerge(muiTheme, other);
  muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
  muiTheme.unstable_sxConfig = {
    ...defaultSxConfig,
    ...other == null ? void 0 : other.unstable_sxConfig
  };
  muiTheme.unstable_sx = function sx(props) {
    return styleFunctionSx({
      sx: props,
      theme: this
    });
  };
  muiTheme.toRuntimeSource = stringifyTheme;
  return muiTheme;
}
function getOverlayAlpha(elevation) {
  let alphaValue;
  if (elevation < 1) {
    alphaValue = 5.11916 * elevation ** 2;
  } else {
    alphaValue = 4.5 * Math.log(elevation + 1) + 2;
  }
  return Math.round(alphaValue * 10) / 1e3;
}
const defaultDarkOverlays = [...Array(25)].map((_2, index) => {
  if (index === 0) {
    return "none";
  }
  const overlay = getOverlayAlpha(index);
  return `linear-gradient(rgba(255 255 255 / ${overlay}), rgba(255 255 255 / ${overlay}))`;
});
function getOpacity(mode) {
  return {
    inputPlaceholder: mode === "dark" ? 0.5 : 0.42,
    inputUnderline: mode === "dark" ? 0.7 : 0.42,
    switchTrackDisabled: mode === "dark" ? 0.2 : 0.12,
    switchTrack: mode === "dark" ? 0.3 : 0.38
  };
}
function getOverlays(mode) {
  return mode === "dark" ? defaultDarkOverlays : [];
}
function createColorScheme(options) {
  const {
    palette: paletteInput = {
      mode: "light"
    },
    // need to cast to avoid module augmentation test
    opacity,
    overlays,
    ...rest
  } = options;
  const palette = createPalette(paletteInput);
  return {
    palette,
    opacity: {
      ...getOpacity(palette.mode),
      ...opacity
    },
    overlays: overlays || getOverlays(palette.mode),
    ...rest
  };
}
function shouldSkipGeneratingVar(keys) {
  var _a2;
  return !!keys[0].match(/(cssVarPrefix|colorSchemeSelector|rootSelector|typography|mixins|breakpoints|direction|transitions)/) || !!keys[0].match(/sxConfig$/) || // ends with sxConfig
  keys[0] === "palette" && !!((_a2 = keys[1]) == null ? void 0 : _a2.match(/(mode|contrastThreshold|tonalOffset)/));
}
const excludeVariablesFromRoot = (cssVarPrefix) => [...[...Array(25)].map((_2, index) => `--${cssVarPrefix ? `${cssVarPrefix}-` : ""}overlays-${index}`), `--${cssVarPrefix ? `${cssVarPrefix}-` : ""}palette-AppBar-darkBg`, `--${cssVarPrefix ? `${cssVarPrefix}-` : ""}palette-AppBar-darkColor`];
const defaultGetSelector = (theme) => (colorScheme, css2) => {
  const root = theme.rootSelector || ":root";
  const selector = theme.colorSchemeSelector;
  let rule = selector;
  if (selector === "class") {
    rule = ".%s";
  }
  if (selector === "data") {
    rule = "[data-%s]";
  }
  if ((selector == null ? void 0 : selector.startsWith("data-")) && !selector.includes("%s")) {
    rule = `[${selector}="%s"]`;
  }
  if (theme.defaultColorScheme === colorScheme) {
    if (colorScheme === "dark") {
      const excludedVariables = {};
      excludeVariablesFromRoot(theme.cssVarPrefix).forEach((cssVar) => {
        excludedVariables[cssVar] = css2[cssVar];
        delete css2[cssVar];
      });
      if (rule === "media") {
        return {
          [root]: css2,
          [`@media (prefers-color-scheme: dark)`]: {
            [root]: excludedVariables
          }
        };
      }
      if (rule) {
        return {
          [rule.replace("%s", colorScheme)]: excludedVariables,
          [`${root}, ${rule.replace("%s", colorScheme)}`]: css2
        };
      }
      return {
        [root]: {
          ...css2,
          ...excludedVariables
        }
      };
    }
    if (rule && rule !== "media") {
      return `${root}, ${rule.replace("%s", String(colorScheme))}`;
    }
  } else if (colorScheme) {
    if (rule === "media") {
      return {
        [`@media (prefers-color-scheme: ${String(colorScheme)})`]: {
          [root]: css2
        }
      };
    }
    if (rule) {
      return rule.replace("%s", String(colorScheme));
    }
  }
  return root;
};
function assignNode(obj, keys) {
  keys.forEach((k2) => {
    if (!obj[k2]) {
      obj[k2] = {};
    }
  });
}
function setColor(obj, key, defaultValue) {
  if (!obj[key] && defaultValue) {
    obj[key] = defaultValue;
  }
}
function toRgb(color2) {
  if (typeof color2 !== "string" || !color2.startsWith("hsl")) {
    return color2;
  }
  return hslToRgb(color2);
}
function setColorChannel(obj, key) {
  if (!(`${key}Channel` in obj)) {
    obj[`${key}Channel`] = private_safeColorChannel(toRgb(obj[key]));
  }
}
function getSpacingVal(spacingInput) {
  if (typeof spacingInput === "number") {
    return `${spacingInput}px`;
  }
  if (typeof spacingInput === "string" || typeof spacingInput === "function" || Array.isArray(spacingInput)) {
    return spacingInput;
  }
  return "8px";
}
const silent = (fn) => {
  try {
    return fn();
  } catch (error2) {
  }
  return void 0;
};
const createGetCssVar = (cssVarPrefix = "mui") => createGetCssVar$1(cssVarPrefix);
function attachColorScheme$1(colorSchemes, scheme, restTheme, colorScheme) {
  if (!scheme) {
    return void 0;
  }
  scheme = scheme === true ? {} : scheme;
  const mode = colorScheme === "dark" ? "dark" : "light";
  if (!restTheme) {
    colorSchemes[colorScheme] = createColorScheme({
      ...scheme,
      palette: {
        mode,
        ...scheme == null ? void 0 : scheme.palette
      }
    });
    return void 0;
  }
  const {
    palette,
    ...muiTheme
  } = createThemeNoVars({
    ...restTheme,
    palette: {
      mode,
      ...scheme == null ? void 0 : scheme.palette
    }
  });
  colorSchemes[colorScheme] = {
    ...scheme,
    palette,
    opacity: {
      ...getOpacity(mode),
      ...scheme == null ? void 0 : scheme.opacity
    },
    overlays: (scheme == null ? void 0 : scheme.overlays) || getOverlays(mode)
  };
  return muiTheme;
}
function createThemeWithVars(options = {}, ...args) {
  const {
    colorSchemes: colorSchemesInput = {
      light: true
    },
    defaultColorScheme: defaultColorSchemeInput,
    disableCssColorScheme = false,
    cssVarPrefix = "mui",
    shouldSkipGeneratingVar: shouldSkipGeneratingVar$1 = shouldSkipGeneratingVar,
    colorSchemeSelector: selector = colorSchemesInput.light && colorSchemesInput.dark ? "media" : void 0,
    rootSelector = ":root",
    ...input
  } = options;
  const firstColorScheme = Object.keys(colorSchemesInput)[0];
  const defaultColorScheme = defaultColorSchemeInput || (colorSchemesInput.light && firstColorScheme !== "light" ? "light" : firstColorScheme);
  const getCssVar = createGetCssVar(cssVarPrefix);
  const {
    [defaultColorScheme]: defaultSchemeInput,
    light: builtInLight,
    dark: builtInDark,
    ...customColorSchemes
  } = colorSchemesInput;
  const colorSchemes = {
    ...customColorSchemes
  };
  let defaultScheme = defaultSchemeInput;
  if (defaultColorScheme === "dark" && !("dark" in colorSchemesInput) || defaultColorScheme === "light" && !("light" in colorSchemesInput)) {
    defaultScheme = true;
  }
  if (!defaultScheme) {
    throw new Error(formatMuiErrorMessage(21, defaultColorScheme));
  }
  const muiTheme = attachColorScheme$1(colorSchemes, defaultScheme, input, defaultColorScheme);
  if (builtInLight && !colorSchemes.light) {
    attachColorScheme$1(colorSchemes, builtInLight, void 0, "light");
  }
  if (builtInDark && !colorSchemes.dark) {
    attachColorScheme$1(colorSchemes, builtInDark, void 0, "dark");
  }
  let theme = {
    defaultColorScheme,
    ...muiTheme,
    cssVarPrefix,
    colorSchemeSelector: selector,
    rootSelector,
    getCssVar,
    colorSchemes,
    font: {
      ...prepareTypographyVars(muiTheme.typography),
      ...muiTheme.font
    },
    spacing: getSpacingVal(input.spacing)
  };
  Object.keys(theme.colorSchemes).forEach((key) => {
    const palette = theme.colorSchemes[key].palette;
    const setCssVarColor = (cssVar) => {
      const tokens = cssVar.split("-");
      const color2 = tokens[1];
      const colorToken = tokens[2];
      return getCssVar(cssVar, palette[color2][colorToken]);
    };
    if (palette.mode === "light") {
      setColor(palette.common, "background", "#fff");
      setColor(palette.common, "onBackground", "#000");
    }
    if (palette.mode === "dark") {
      setColor(palette.common, "background", "#000");
      setColor(palette.common, "onBackground", "#fff");
    }
    assignNode(palette, ["Alert", "AppBar", "Avatar", "Button", "Chip", "FilledInput", "LinearProgress", "Skeleton", "Slider", "SnackbarContent", "SpeedDialAction", "StepConnector", "StepContent", "Switch", "TableCell", "Tooltip"]);
    if (palette.mode === "light") {
      setColor(palette.Alert, "errorColor", private_safeDarken(palette.error.light, 0.6));
      setColor(palette.Alert, "infoColor", private_safeDarken(palette.info.light, 0.6));
      setColor(palette.Alert, "successColor", private_safeDarken(palette.success.light, 0.6));
      setColor(palette.Alert, "warningColor", private_safeDarken(palette.warning.light, 0.6));
      setColor(palette.Alert, "errorFilledBg", setCssVarColor("palette-error-main"));
      setColor(palette.Alert, "infoFilledBg", setCssVarColor("palette-info-main"));
      setColor(palette.Alert, "successFilledBg", setCssVarColor("palette-success-main"));
      setColor(palette.Alert, "warningFilledBg", setCssVarColor("palette-warning-main"));
      setColor(palette.Alert, "errorFilledColor", silent(() => palette.getContrastText(palette.error.main)));
      setColor(palette.Alert, "infoFilledColor", silent(() => palette.getContrastText(palette.info.main)));
      setColor(palette.Alert, "successFilledColor", silent(() => palette.getContrastText(palette.success.main)));
      setColor(palette.Alert, "warningFilledColor", silent(() => palette.getContrastText(palette.warning.main)));
      setColor(palette.Alert, "errorStandardBg", private_safeLighten(palette.error.light, 0.9));
      setColor(palette.Alert, "infoStandardBg", private_safeLighten(palette.info.light, 0.9));
      setColor(palette.Alert, "successStandardBg", private_safeLighten(palette.success.light, 0.9));
      setColor(palette.Alert, "warningStandardBg", private_safeLighten(palette.warning.light, 0.9));
      setColor(palette.Alert, "errorIconColor", setCssVarColor("palette-error-main"));
      setColor(palette.Alert, "infoIconColor", setCssVarColor("palette-info-main"));
      setColor(palette.Alert, "successIconColor", setCssVarColor("palette-success-main"));
      setColor(palette.Alert, "warningIconColor", setCssVarColor("palette-warning-main"));
      setColor(palette.AppBar, "defaultBg", setCssVarColor("palette-grey-100"));
      setColor(palette.Avatar, "defaultBg", setCssVarColor("palette-grey-400"));
      setColor(palette.Button, "inheritContainedBg", setCssVarColor("palette-grey-300"));
      setColor(palette.Button, "inheritContainedHoverBg", setCssVarColor("palette-grey-A100"));
      setColor(palette.Chip, "defaultBorder", setCssVarColor("palette-grey-400"));
      setColor(palette.Chip, "defaultAvatarColor", setCssVarColor("palette-grey-700"));
      setColor(palette.Chip, "defaultIconColor", setCssVarColor("palette-grey-700"));
      setColor(palette.FilledInput, "bg", "rgba(0, 0, 0, 0.06)");
      setColor(palette.FilledInput, "hoverBg", "rgba(0, 0, 0, 0.09)");
      setColor(palette.FilledInput, "disabledBg", "rgba(0, 0, 0, 0.12)");
      setColor(palette.LinearProgress, "primaryBg", private_safeLighten(palette.primary.main, 0.62));
      setColor(palette.LinearProgress, "secondaryBg", private_safeLighten(palette.secondary.main, 0.62));
      setColor(palette.LinearProgress, "errorBg", private_safeLighten(palette.error.main, 0.62));
      setColor(palette.LinearProgress, "infoBg", private_safeLighten(palette.info.main, 0.62));
      setColor(palette.LinearProgress, "successBg", private_safeLighten(palette.success.main, 0.62));
      setColor(palette.LinearProgress, "warningBg", private_safeLighten(palette.warning.main, 0.62));
      setColor(palette.Skeleton, "bg", `rgba(${setCssVarColor("palette-text-primaryChannel")} / 0.11)`);
      setColor(palette.Slider, "primaryTrack", private_safeLighten(palette.primary.main, 0.62));
      setColor(palette.Slider, "secondaryTrack", private_safeLighten(palette.secondary.main, 0.62));
      setColor(palette.Slider, "errorTrack", private_safeLighten(palette.error.main, 0.62));
      setColor(palette.Slider, "infoTrack", private_safeLighten(palette.info.main, 0.62));
      setColor(palette.Slider, "successTrack", private_safeLighten(palette.success.main, 0.62));
      setColor(palette.Slider, "warningTrack", private_safeLighten(palette.warning.main, 0.62));
      const snackbarContentBackground = private_safeEmphasize(palette.background.default, 0.8);
      setColor(palette.SnackbarContent, "bg", snackbarContentBackground);
      setColor(palette.SnackbarContent, "color", silent(() => palette.getContrastText(snackbarContentBackground)));
      setColor(palette.SpeedDialAction, "fabHoverBg", private_safeEmphasize(palette.background.paper, 0.15));
      setColor(palette.StepConnector, "border", setCssVarColor("palette-grey-400"));
      setColor(palette.StepContent, "border", setCssVarColor("palette-grey-400"));
      setColor(palette.Switch, "defaultColor", setCssVarColor("palette-common-white"));
      setColor(palette.Switch, "defaultDisabledColor", setCssVarColor("palette-grey-100"));
      setColor(palette.Switch, "primaryDisabledColor", private_safeLighten(palette.primary.main, 0.62));
      setColor(palette.Switch, "secondaryDisabledColor", private_safeLighten(palette.secondary.main, 0.62));
      setColor(palette.Switch, "errorDisabledColor", private_safeLighten(palette.error.main, 0.62));
      setColor(palette.Switch, "infoDisabledColor", private_safeLighten(palette.info.main, 0.62));
      setColor(palette.Switch, "successDisabledColor", private_safeLighten(palette.success.main, 0.62));
      setColor(palette.Switch, "warningDisabledColor", private_safeLighten(palette.warning.main, 0.62));
      setColor(palette.TableCell, "border", private_safeLighten(private_safeAlpha(palette.divider, 1), 0.88));
      setColor(palette.Tooltip, "bg", private_safeAlpha(palette.grey[700], 0.92));
    }
    if (palette.mode === "dark") {
      setColor(palette.Alert, "errorColor", private_safeLighten(palette.error.light, 0.6));
      setColor(palette.Alert, "infoColor", private_safeLighten(palette.info.light, 0.6));
      setColor(palette.Alert, "successColor", private_safeLighten(palette.success.light, 0.6));
      setColor(palette.Alert, "warningColor", private_safeLighten(palette.warning.light, 0.6));
      setColor(palette.Alert, "errorFilledBg", setCssVarColor("palette-error-dark"));
      setColor(palette.Alert, "infoFilledBg", setCssVarColor("palette-info-dark"));
      setColor(palette.Alert, "successFilledBg", setCssVarColor("palette-success-dark"));
      setColor(palette.Alert, "warningFilledBg", setCssVarColor("palette-warning-dark"));
      setColor(palette.Alert, "errorFilledColor", silent(() => palette.getContrastText(palette.error.dark)));
      setColor(palette.Alert, "infoFilledColor", silent(() => palette.getContrastText(palette.info.dark)));
      setColor(palette.Alert, "successFilledColor", silent(() => palette.getContrastText(palette.success.dark)));
      setColor(palette.Alert, "warningFilledColor", silent(() => palette.getContrastText(palette.warning.dark)));
      setColor(palette.Alert, "errorStandardBg", private_safeDarken(palette.error.light, 0.9));
      setColor(palette.Alert, "infoStandardBg", private_safeDarken(palette.info.light, 0.9));
      setColor(palette.Alert, "successStandardBg", private_safeDarken(palette.success.light, 0.9));
      setColor(palette.Alert, "warningStandardBg", private_safeDarken(palette.warning.light, 0.9));
      setColor(palette.Alert, "errorIconColor", setCssVarColor("palette-error-main"));
      setColor(palette.Alert, "infoIconColor", setCssVarColor("palette-info-main"));
      setColor(palette.Alert, "successIconColor", setCssVarColor("palette-success-main"));
      setColor(palette.Alert, "warningIconColor", setCssVarColor("palette-warning-main"));
      setColor(palette.AppBar, "defaultBg", setCssVarColor("palette-grey-900"));
      setColor(palette.AppBar, "darkBg", setCssVarColor("palette-background-paper"));
      setColor(palette.AppBar, "darkColor", setCssVarColor("palette-text-primary"));
      setColor(palette.Avatar, "defaultBg", setCssVarColor("palette-grey-600"));
      setColor(palette.Button, "inheritContainedBg", setCssVarColor("palette-grey-800"));
      setColor(palette.Button, "inheritContainedHoverBg", setCssVarColor("palette-grey-700"));
      setColor(palette.Chip, "defaultBorder", setCssVarColor("palette-grey-700"));
      setColor(palette.Chip, "defaultAvatarColor", setCssVarColor("palette-grey-300"));
      setColor(palette.Chip, "defaultIconColor", setCssVarColor("palette-grey-300"));
      setColor(palette.FilledInput, "bg", "rgba(255, 255, 255, 0.09)");
      setColor(palette.FilledInput, "hoverBg", "rgba(255, 255, 255, 0.13)");
      setColor(palette.FilledInput, "disabledBg", "rgba(255, 255, 255, 0.12)");
      setColor(palette.LinearProgress, "primaryBg", private_safeDarken(palette.primary.main, 0.5));
      setColor(palette.LinearProgress, "secondaryBg", private_safeDarken(palette.secondary.main, 0.5));
      setColor(palette.LinearProgress, "errorBg", private_safeDarken(palette.error.main, 0.5));
      setColor(palette.LinearProgress, "infoBg", private_safeDarken(palette.info.main, 0.5));
      setColor(palette.LinearProgress, "successBg", private_safeDarken(palette.success.main, 0.5));
      setColor(palette.LinearProgress, "warningBg", private_safeDarken(palette.warning.main, 0.5));
      setColor(palette.Skeleton, "bg", `rgba(${setCssVarColor("palette-text-primaryChannel")} / 0.13)`);
      setColor(palette.Slider, "primaryTrack", private_safeDarken(palette.primary.main, 0.5));
      setColor(palette.Slider, "secondaryTrack", private_safeDarken(palette.secondary.main, 0.5));
      setColor(palette.Slider, "errorTrack", private_safeDarken(palette.error.main, 0.5));
      setColor(palette.Slider, "infoTrack", private_safeDarken(palette.info.main, 0.5));
      setColor(palette.Slider, "successTrack", private_safeDarken(palette.success.main, 0.5));
      setColor(palette.Slider, "warningTrack", private_safeDarken(palette.warning.main, 0.5));
      const snackbarContentBackground = private_safeEmphasize(palette.background.default, 0.98);
      setColor(palette.SnackbarContent, "bg", snackbarContentBackground);
      setColor(palette.SnackbarContent, "color", silent(() => palette.getContrastText(snackbarContentBackground)));
      setColor(palette.SpeedDialAction, "fabHoverBg", private_safeEmphasize(palette.background.paper, 0.15));
      setColor(palette.StepConnector, "border", setCssVarColor("palette-grey-600"));
      setColor(palette.StepContent, "border", setCssVarColor("palette-grey-600"));
      setColor(palette.Switch, "defaultColor", setCssVarColor("palette-grey-300"));
      setColor(palette.Switch, "defaultDisabledColor", setCssVarColor("palette-grey-600"));
      setColor(palette.Switch, "primaryDisabledColor", private_safeDarken(palette.primary.main, 0.55));
      setColor(palette.Switch, "secondaryDisabledColor", private_safeDarken(palette.secondary.main, 0.55));
      setColor(palette.Switch, "errorDisabledColor", private_safeDarken(palette.error.main, 0.55));
      setColor(palette.Switch, "infoDisabledColor", private_safeDarken(palette.info.main, 0.55));
      setColor(palette.Switch, "successDisabledColor", private_safeDarken(palette.success.main, 0.55));
      setColor(palette.Switch, "warningDisabledColor", private_safeDarken(palette.warning.main, 0.55));
      setColor(palette.TableCell, "border", private_safeDarken(private_safeAlpha(palette.divider, 1), 0.68));
      setColor(palette.Tooltip, "bg", private_safeAlpha(palette.grey[700], 0.92));
    }
    setColorChannel(palette.background, "default");
    setColorChannel(palette.background, "paper");
    setColorChannel(palette.common, "background");
    setColorChannel(palette.common, "onBackground");
    setColorChannel(palette, "divider");
    Object.keys(palette).forEach((color2) => {
      const colors = palette[color2];
      if (color2 !== "tonalOffset" && colors && typeof colors === "object") {
        if (colors.main) {
          setColor(palette[color2], "mainChannel", private_safeColorChannel(toRgb(colors.main)));
        }
        if (colors.light) {
          setColor(palette[color2], "lightChannel", private_safeColorChannel(toRgb(colors.light)));
        }
        if (colors.dark) {
          setColor(palette[color2], "darkChannel", private_safeColorChannel(toRgb(colors.dark)));
        }
        if (colors.contrastText) {
          setColor(palette[color2], "contrastTextChannel", private_safeColorChannel(toRgb(colors.contrastText)));
        }
        if (color2 === "text") {
          setColorChannel(palette[color2], "primary");
          setColorChannel(palette[color2], "secondary");
        }
        if (color2 === "action") {
          if (colors.active) {
            setColorChannel(palette[color2], "active");
          }
          if (colors.selected) {
            setColorChannel(palette[color2], "selected");
          }
        }
      }
    });
  });
  theme = args.reduce((acc, argument) => deepmerge(acc, argument), theme);
  const parserConfig = {
    prefix: cssVarPrefix,
    disableCssColorScheme,
    shouldSkipGeneratingVar: shouldSkipGeneratingVar$1,
    getSelector: defaultGetSelector(theme)
  };
  const {
    vars,
    generateThemeVars,
    generateStyleSheets
  } = prepareCssVars(theme, parserConfig);
  theme.vars = vars;
  Object.entries(theme.colorSchemes[theme.defaultColorScheme]).forEach(([key, value]) => {
    theme[key] = value;
  });
  theme.generateThemeVars = generateThemeVars;
  theme.generateStyleSheets = generateStyleSheets;
  theme.generateSpacing = function generateSpacing() {
    return createSpacing(input.spacing, createUnarySpacing(this));
  };
  theme.getColorSchemeSelector = createGetColorSchemeSelector(selector);
  theme.spacing = theme.generateSpacing();
  theme.shouldSkipGeneratingVar = shouldSkipGeneratingVar$1;
  theme.unstable_sxConfig = {
    ...defaultSxConfig,
    ...input == null ? void 0 : input.unstable_sxConfig
  };
  theme.unstable_sx = function sx(props) {
    return styleFunctionSx({
      sx: props,
      theme: this
    });
  };
  theme.toRuntimeSource = stringifyTheme;
  return theme;
}
function attachColorScheme(theme, scheme, colorScheme) {
  if (!theme.colorSchemes) {
    return void 0;
  }
  if (colorScheme) {
    theme.colorSchemes[scheme] = {
      ...colorScheme !== true && colorScheme,
      palette: createPalette({
        ...colorScheme === true ? {} : colorScheme.palette,
        mode: scheme
      })
      // cast type to skip module augmentation test
    };
  }
}
function createTheme(options = {}, ...args) {
  const {
    palette,
    cssVariables = false,
    colorSchemes: initialColorSchemes = !palette ? {
      light: true
    } : void 0,
    defaultColorScheme: initialDefaultColorScheme = palette == null ? void 0 : palette.mode,
    ...rest
  } = options;
  const defaultColorSchemeInput = initialDefaultColorScheme || "light";
  const defaultScheme = initialColorSchemes == null ? void 0 : initialColorSchemes[defaultColorSchemeInput];
  const colorSchemesInput = {
    ...initialColorSchemes,
    ...palette ? {
      [defaultColorSchemeInput]: {
        ...typeof defaultScheme !== "boolean" && defaultScheme,
        palette
      }
    } : void 0
  };
  if (cssVariables === false) {
    if (!("colorSchemes" in options)) {
      return createThemeNoVars(options, ...args);
    }
    let paletteOptions = palette;
    if (!("palette" in options)) {
      if (colorSchemesInput[defaultColorSchemeInput]) {
        if (colorSchemesInput[defaultColorSchemeInput] !== true) {
          paletteOptions = colorSchemesInput[defaultColorSchemeInput].palette;
        } else if (defaultColorSchemeInput === "dark") {
          paletteOptions = {
            mode: "dark"
          };
        }
      }
    }
    const theme = createThemeNoVars({
      ...options,
      palette: paletteOptions
    }, ...args);
    theme.defaultColorScheme = defaultColorSchemeInput;
    theme.colorSchemes = colorSchemesInput;
    if (theme.palette.mode === "light") {
      theme.colorSchemes.light = {
        ...colorSchemesInput.light !== true && colorSchemesInput.light,
        palette: theme.palette
      };
      attachColorScheme(theme, "dark", colorSchemesInput.dark);
    }
    if (theme.palette.mode === "dark") {
      theme.colorSchemes.dark = {
        ...colorSchemesInput.dark !== true && colorSchemesInput.dark,
        palette: theme.palette
      };
      attachColorScheme(theme, "light", colorSchemesInput.light);
    }
    return theme;
  }
  if (!palette && !("light" in colorSchemesInput) && defaultColorSchemeInput === "light") {
    colorSchemesInput.light = true;
  }
  return createThemeWithVars({
    ...rest,
    colorSchemes: colorSchemesInput,
    defaultColorScheme: defaultColorSchemeInput,
    ...typeof cssVariables !== "boolean" && cssVariables
  }, ...args);
}
const defaultTheme = createTheme();
const THEME_ID = "$$material";
function useTheme() {
  const theme = useTheme$1(defaultTheme);
  return theme[THEME_ID] || theme;
}
function slotShouldForwardProp(prop) {
  return prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as";
}
const rootShouldForwardProp = (prop) => slotShouldForwardProp(prop) && prop !== "classes";
const styled = createStyled2({
  themeId: THEME_ID,
  defaultTheme,
  rootShouldForwardProp
});
function useDefaultProps(params) {
  return useDefaultProps$1(params);
}
const ListContext = /* @__PURE__ */ React.createContext({});
function getListUtilityClass(slot) {
  return generateUtilityClass("MuiList", slot);
}
generateUtilityClasses("MuiList", ["root", "padding", "dense", "subheader"]);
const useUtilityClasses$g = (ownerState) => {
  const {
    classes,
    disablePadding,
    dense,
    subheader
  } = ownerState;
  const slots2 = {
    root: ["root", !disablePadding && "padding", dense && "dense", subheader && "subheader"]
  };
  return composeClasses(slots2, getListUtilityClass, classes);
};
const ListRoot = styled("ul", {
  name: "MuiList",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, !ownerState.disablePadding && styles2.padding, ownerState.dense && styles2.dense, ownerState.subheader && styles2.subheader];
  }
})({
  listStyle: "none",
  margin: 0,
  padding: 0,
  position: "relative",
  variants: [{
    props: ({
      ownerState
    }) => !ownerState.disablePadding,
    style: {
      paddingTop: 8,
      paddingBottom: 8
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.subheader,
    style: {
      paddingTop: 0
    }
  }]
});
const List = /* @__PURE__ */ React.forwardRef(function List2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiList"
  });
  const {
    children,
    className,
    component = "ul",
    dense = false,
    disablePadding = false,
    subheader,
    ...other
  } = props;
  const context = React.useMemo(() => ({
    dense
  }), [dense]);
  const ownerState = {
    ...props,
    component,
    dense,
    disablePadding
  };
  const classes = useUtilityClasses$g(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext.Provider, {
    value: context,
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ListRoot, {
      as: component,
      className: clsx(classes.root, className),
      ref: ref2,
      ownerState,
      ...other,
      children: [subheader, children]
    })
  });
});
const memoTheme = unstable_memoTheme;
function getSvgIconUtilityClass(slot) {
  return generateUtilityClass("MuiSvgIcon", slot);
}
generateUtilityClasses("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
const useUtilityClasses$f = (ownerState) => {
  const {
    color: color2,
    fontSize,
    classes
  } = ownerState;
  const slots2 = {
    root: ["root", color2 !== "inherit" && `color${capitalize(color2)}`, `fontSize${capitalize(fontSize)}`]
  };
  return composeClasses(slots2, getSvgIconUtilityClass, classes);
};
const SvgIconRoot = styled("svg", {
  name: "MuiSvgIcon",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.color !== "inherit" && styles2[`color${capitalize(ownerState.color)}`], styles2[`fontSize${capitalize(ownerState.fontSize)}`]];
  }
})(memoTheme(({
  theme
}) => {
  var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
  return {
    userSelect: "none",
    width: "1em",
    height: "1em",
    display: "inline-block",
    flexShrink: 0,
    transition: (_d = (_a2 = theme.transitions) == null ? void 0 : _a2.create) == null ? void 0 : _d.call(_a2, "fill", {
      duration: (_c = (_b = (theme.vars ?? theme).transitions) == null ? void 0 : _b.duration) == null ? void 0 : _c.shorter
    }),
    variants: [
      {
        props: (props) => !props.hasSvgAsChild,
        style: {
          // the <svg> will define the property that has `currentColor`
          // for example heroicons uses fill="none" and stroke="currentColor"
          fill: "currentColor"
        }
      },
      {
        props: {
          fontSize: "inherit"
        },
        style: {
          fontSize: "inherit"
        }
      },
      {
        props: {
          fontSize: "small"
        },
        style: {
          fontSize: ((_f = (_e = theme.typography) == null ? void 0 : _e.pxToRem) == null ? void 0 : _f.call(_e, 20)) || "1.25rem"
        }
      },
      {
        props: {
          fontSize: "medium"
        },
        style: {
          fontSize: ((_h = (_g = theme.typography) == null ? void 0 : _g.pxToRem) == null ? void 0 : _h.call(_g, 24)) || "1.5rem"
        }
      },
      {
        props: {
          fontSize: "large"
        },
        style: {
          fontSize: ((_j = (_i = theme.typography) == null ? void 0 : _i.pxToRem) == null ? void 0 : _j.call(_i, 35)) || "2.1875rem"
        }
      },
      // TODO v5 deprecate color prop, v6 remove for sx
      ...Object.entries((theme.vars ?? theme).palette).filter(([, value]) => value && value.main).map(([color2]) => {
        var _a3, _b2;
        return {
          props: {
            color: color2
          },
          style: {
            color: (_b2 = (_a3 = (theme.vars ?? theme).palette) == null ? void 0 : _a3[color2]) == null ? void 0 : _b2.main
          }
        };
      }),
      {
        props: {
          color: "action"
        },
        style: {
          color: (_l = (_k = (theme.vars ?? theme).palette) == null ? void 0 : _k.action) == null ? void 0 : _l.active
        }
      },
      {
        props: {
          color: "disabled"
        },
        style: {
          color: (_n = (_m = (theme.vars ?? theme).palette) == null ? void 0 : _m.action) == null ? void 0 : _n.disabled
        }
      },
      {
        props: {
          color: "inherit"
        },
        style: {
          color: void 0
        }
      }
    ]
  };
}));
const SvgIcon = /* @__PURE__ */ React.forwardRef(function SvgIcon2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiSvgIcon"
  });
  const {
    children,
    className,
    color: color2 = "inherit",
    component = "svg",
    fontSize = "medium",
    htmlColor,
    inheritViewBox = false,
    titleAccess,
    viewBox = "0 0 24 24",
    ...other
  } = props;
  const hasSvgAsChild = /* @__PURE__ */ React.isValidElement(children) && children.type === "svg";
  const ownerState = {
    ...props,
    color: color2,
    component,
    fontSize,
    instanceFontSize: inProps.fontSize,
    inheritViewBox,
    viewBox,
    hasSvgAsChild
  };
  const more = {};
  if (!inheritViewBox) {
    more.viewBox = viewBox;
  }
  const classes = useUtilityClasses$f(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(SvgIconRoot, {
    as: component,
    className: clsx(classes.root, className),
    focusable: "false",
    color: htmlColor,
    "aria-hidden": titleAccess ? void 0 : true,
    role: titleAccess ? "img" : void 0,
    ref: ref2,
    ...more,
    ...other,
    ...hasSvgAsChild && children.props,
    ownerState,
    children: [hasSvgAsChild ? children.props.children : children, titleAccess ? /* @__PURE__ */ jsxRuntimeExports.jsx("title", {
      children: titleAccess
    }) : null]
  });
});
SvgIcon.muiName = "SvgIcon";
function createSvgIcon(path, displayName) {
  function Component2(props, ref2) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SvgIcon, {
      "data-testid": `${displayName}Icon`,
      ref: ref2,
      ...props,
      children: path
    });
  }
  Component2.muiName = SvgIcon.muiName;
  return /* @__PURE__ */ React.memo(/* @__PURE__ */ React.forwardRef(Component2));
}
function nextItem(list2, item, disableListWrap) {
  if (list2 === item) {
    return list2.firstChild;
  }
  if (item && item.nextElementSibling) {
    return item.nextElementSibling;
  }
  return disableListWrap ? null : list2.firstChild;
}
function previousItem(list2, item, disableListWrap) {
  if (list2 === item) {
    return disableListWrap ? list2.firstChild : list2.lastChild;
  }
  if (item && item.previousElementSibling) {
    return item.previousElementSibling;
  }
  return disableListWrap ? null : list2.lastChild;
}
function textCriteriaMatches(nextFocus, textCriteria) {
  if (textCriteria === void 0) {
    return true;
  }
  let text2 = nextFocus.innerText;
  if (text2 === void 0) {
    text2 = nextFocus.textContent;
  }
  text2 = text2.trim().toLowerCase();
  if (text2.length === 0) {
    return false;
  }
  if (textCriteria.repeating) {
    return text2[0] === textCriteria.keys[0];
  }
  return text2.startsWith(textCriteria.keys.join(""));
}
function moveFocus(list2, currentFocus, disableListWrap, disabledItemsFocusable, traversalFunction, textCriteria) {
  let wrappedOnce = false;
  let nextFocus = traversalFunction(list2, currentFocus, currentFocus ? disableListWrap : false);
  while (nextFocus) {
    if (nextFocus === list2.firstChild) {
      if (wrappedOnce) {
        return false;
      }
      wrappedOnce = true;
    }
    const nextFocusDisabled = disabledItemsFocusable ? false : nextFocus.disabled || nextFocus.getAttribute("aria-disabled") === "true";
    if (!nextFocus.hasAttribute("tabindex") || !textCriteriaMatches(nextFocus, textCriteria) || nextFocusDisabled) {
      nextFocus = traversalFunction(list2, nextFocus, disableListWrap);
    } else {
      nextFocus.focus();
      return true;
    }
  }
  return false;
}
const MenuList = /* @__PURE__ */ React.forwardRef(function MenuList2(props, ref2) {
  const {
    // private
    // eslint-disable-next-line https://esm.sh/react/prop-types
    actions,
    autoFocus = false,
    autoFocusItem = false,
    children,
    className,
    disabledItemsFocusable = false,
    disableListWrap = false,
    onKeyDown,
    variant = "selectedMenu",
    ...other
  } = props;
  const listRef = React.useRef(null);
  const textCriteriaRef = React.useRef({
    keys: [],
    repeating: true,
    previousKeyMatched: true,
    lastTime: null
  });
  useEnhancedEffect(() => {
    if (autoFocus) {
      listRef.current.focus();
    }
  }, [autoFocus]);
  React.useImperativeHandle(actions, () => ({
    adjustStyleForScrollbar: (containerElement, {
      direction
    }) => {
      const noExplicitWidth = !listRef.current.style.width;
      if (containerElement.clientHeight < listRef.current.clientHeight && noExplicitWidth) {
        const scrollbarSize = `${getScrollbarSize(ownerWindow(containerElement))}px`;
        listRef.current.style[direction === "rtl" ? "paddingLeft" : "paddingRight"] = scrollbarSize;
        listRef.current.style.width = `calc(100% + ${scrollbarSize})`;
      }
      return listRef.current;
    }
  }), []);
  const handleKeyDown = (event) => {
    const list2 = listRef.current;
    const key = event.key;
    const isModifierKeyPressed = event.ctrlKey || event.metaKey || event.altKey;
    if (isModifierKeyPressed) {
      if (onKeyDown) {
        onKeyDown(event);
      }
      return;
    }
    const currentFocus = ownerDocument(list2).activeElement;
    if (key === "ArrowDown") {
      event.preventDefault();
      moveFocus(list2, currentFocus, disableListWrap, disabledItemsFocusable, nextItem);
    } else if (key === "ArrowUp") {
      event.preventDefault();
      moveFocus(list2, currentFocus, disableListWrap, disabledItemsFocusable, previousItem);
    } else if (key === "Home") {
      event.preventDefault();
      moveFocus(list2, null, disableListWrap, disabledItemsFocusable, nextItem);
    } else if (key === "End") {
      event.preventDefault();
      moveFocus(list2, null, disableListWrap, disabledItemsFocusable, previousItem);
    } else if (key.length === 1) {
      const criteria = textCriteriaRef.current;
      const lowerKey = key.toLowerCase();
      const currTime = performance.now();
      if (criteria.keys.length > 0) {
        if (currTime - criteria.lastTime > 500) {
          criteria.keys = [];
          criteria.repeating = true;
          criteria.previousKeyMatched = true;
        } else if (criteria.repeating && lowerKey !== criteria.keys[0]) {
          criteria.repeating = false;
        }
      }
      criteria.lastTime = currTime;
      criteria.keys.push(lowerKey);
      const keepFocusOnCurrent = currentFocus && !criteria.repeating && textCriteriaMatches(currentFocus, criteria);
      if (criteria.previousKeyMatched && (keepFocusOnCurrent || moveFocus(list2, currentFocus, false, disabledItemsFocusable, nextItem, criteria))) {
        event.preventDefault();
      } else {
        criteria.previousKeyMatched = false;
      }
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
  };
  const handleRef = useForkRef$1(listRef, ref2);
  let activeItemIndex = -1;
  React.Children.forEach(children, (child, index) => {
    if (!/* @__PURE__ */ React.isValidElement(child)) {
      if (activeItemIndex === index) {
        activeItemIndex += 1;
        if (activeItemIndex >= children.length) {
          activeItemIndex = -1;
        }
      }
      return;
    }
    if (!child.props.disabled) {
      if (variant === "selectedMenu" && child.props.selected) {
        activeItemIndex = index;
      } else if (activeItemIndex === -1) {
        activeItemIndex = index;
      }
    }
    if (activeItemIndex === index && (child.props.disabled || child.props.muiSkipListHighlight || child.type.muiSkipListHighlight)) {
      activeItemIndex += 1;
      if (activeItemIndex >= children.length) {
        activeItemIndex = -1;
      }
    }
  });
  const items = React.Children.map(children, (child, index) => {
    if (index === activeItemIndex) {
      const newChildProps = {};
      if (autoFocusItem) {
        newChildProps.autoFocus = true;
      }
      if (child.props.tabIndex === void 0 && variant === "selectedMenu") {
        newChildProps.tabIndex = 0;
      }
      return /* @__PURE__ */ React.cloneElement(child, newChildProps);
    }
    return child;
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(List, {
    role: "menu",
    ref: handleRef,
    className,
    onKeyDown: handleKeyDown,
    tabIndex: autoFocus ? 0 : -1,
    ...other,
    children: items
  });
});
function isHostComponent$1(element) {
  return typeof element === "string";
}
function _objectWithoutPropertiesLoose$1(r2, e) {
  if (null == r2) return {};
  var t = {};
  for (var n in r2) if ({}.hasOwnProperty.call(r2, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r2[n];
  }
  return t;
}
function _setPrototypeOf$1(t, e) {
  return _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
    return t2.__proto__ = e2, t2;
  }, _setPrototypeOf$1(t, e);
}
function _inheritsLoose$1(t, o) {
  t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf$1(t, o);
}
const config = {
  disabled: false
};
const TransitionGroupContext = React__default.createContext(null);
var forceReflow = function forceReflow2(node2) {
  return node2.scrollTop;
};
var UNMOUNTED = "unmounted";
var EXITED = "exited";
var ENTERING = "entering";
var ENTERED = "entered";
var EXITING = "exiting";
var Transition = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose$1(Transition2, _React$Component);
  function Transition2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var parentGroup = context;
    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
    var initialStatus;
    _this.appearStatus = null;
    if (props.in) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }
    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }
  Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref.in;
    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }
    return null;
  };
  var _proto = Transition2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;
    if (prevProps !== this.props) {
      var status = this.state.status;
      if (this.props.in) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }
    this.updateStatus(false, nextStatus);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };
  _proto.getTimeouts = function getTimeouts() {
    var timeout2 = this.props.timeout;
    var exit, enter, appear;
    exit = enter = appear = timeout2;
    if (timeout2 != null && typeof timeout2 !== "number") {
      exit = timeout2.exit;
      enter = timeout2.enter;
      appear = timeout2.appear !== void 0 ? timeout2.appear : enter;
    }
    return {
      exit,
      enter,
      appear
    };
  };
  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }
    if (nextStatus !== null) {
      this.cancelNextCallback();
      if (nextStatus === ENTERING) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var node2 = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM__default.findDOMNode(this);
          if (node2) forceReflow(node2);
        }
        this.performEnter(mounting);
      } else {
        this.performExit();
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  };
  _proto.performEnter = function performEnter(mounting) {
    var _this2 = this;
    var enter = this.props.enter;
    var appearing = this.context ? this.context.isMounting : mounting;
    var _ref2 = this.props.nodeRef ? [appearing] : [ReactDOM__default.findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
    var timeouts = this.getTimeouts();
    var enterTimeout = appearing ? timeouts.appear : timeouts.enter;
    if (!mounting && !enter || config.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function() {
        _this2.props.onEntered(maybeNode);
      });
      return;
    }
    this.props.onEnter(maybeNode, maybeAppearing);
    this.safeSetState({
      status: ENTERING
    }, function() {
      _this2.props.onEntering(maybeNode, maybeAppearing);
      _this2.onTransitionEnd(enterTimeout, function() {
        _this2.safeSetState({
          status: ENTERED
        }, function() {
          _this2.props.onEntered(maybeNode, maybeAppearing);
        });
      });
    });
  };
  _proto.performExit = function performExit() {
    var _this3 = this;
    var exit = this.props.exit;
    var timeouts = this.getTimeouts();
    var maybeNode = this.props.nodeRef ? void 0 : ReactDOM__default.findDOMNode(this);
    if (!exit || config.disabled) {
      this.safeSetState({
        status: EXITED
      }, function() {
        _this3.props.onExited(maybeNode);
      });
      return;
    }
    this.props.onExit(maybeNode);
    this.safeSetState({
      status: EXITING
    }, function() {
      _this3.props.onExiting(maybeNode);
      _this3.onTransitionEnd(timeouts.exit, function() {
        _this3.safeSetState({
          status: EXITED
        }, function() {
          _this3.props.onExited(maybeNode);
        });
      });
    });
  };
  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };
  _proto.safeSetState = function safeSetState(nextState, callback) {
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  };
  _proto.setNextCallback = function setNextCallback(callback) {
    var _this4 = this;
    var active = true;
    this.nextCallback = function(event) {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback(event);
      }
    };
    this.nextCallback.cancel = function() {
      active = false;
    };
    return this.nextCallback;
  };
  _proto.onTransitionEnd = function onTransitionEnd(timeout2, handler) {
    this.setNextCallback(handler);
    var node2 = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM__default.findDOMNode(this);
    var doesNotHaveTimeoutOrListener = timeout2 == null && !this.props.addEndListener;
    if (!node2 || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node2, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
      this.props.addEndListener(maybeNode, maybeNextCallback);
    }
    if (timeout2 != null) {
      setTimeout(this.nextCallback, timeout2);
    }
  };
  _proto.render = function render() {
    var status = this.state.status;
    if (status === UNMOUNTED) {
      return null;
    }
    var _this$props = this.props, children = _this$props.children;
    _this$props.in;
    _this$props.mountOnEnter;
    _this$props.unmountOnExit;
    _this$props.appear;
    _this$props.enter;
    _this$props.exit;
    _this$props.timeout;
    _this$props.addEndListener;
    _this$props.onEnter;
    _this$props.onEntering;
    _this$props.onEntered;
    _this$props.onExit;
    _this$props.onExiting;
    _this$props.onExited;
    _this$props.nodeRef;
    var childProps = _objectWithoutPropertiesLoose$1(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return (
      // allows for nested Transitions
      /* @__PURE__ */ React__default.createElement(TransitionGroupContext.Provider, {
        value: null
      }, typeof children === "function" ? children(status, childProps) : React__default.cloneElement(React__default.Children.only(children), childProps))
    );
  };
  return Transition2;
}(React__default.Component);
Transition.contextType = TransitionGroupContext;
Transition.propTypes = {};
function noop$1() {
}
Transition.defaultProps = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop$1,
  onEntering: noop$1,
  onEntered: noop$1,
  onExit: noop$1,
  onExiting: noop$1,
  onExited: noop$1
};
Transition.UNMOUNTED = UNMOUNTED;
Transition.EXITED = EXITED;
Transition.ENTERING = ENTERING;
Transition.ENTERED = ENTERED;
Transition.EXITING = EXITING;
const Transition$1 = Transition;
function _assertThisInitialized(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function getChildMapping(children, mapFn) {
  var mapper = function mapper2(child) {
    return mapFn && isValidElement(child) ? mapFn(child) : child;
  };
  var result = /* @__PURE__ */ Object.create(null);
  if (children) Children.map(children, function(c) {
    return c;
  }).forEach(function(child) {
    result[child.key] = mapper(child);
  });
  return result;
}
function mergeChildMappings(prev2, next2) {
  prev2 = prev2 || {};
  next2 = next2 || {};
  function getValueForKey(key) {
    return key in next2 ? next2[key] : prev2[key];
  }
  var nextKeysPending = /* @__PURE__ */ Object.create(null);
  var pendingKeys = [];
  for (var prevKey in prev2) {
    if (prevKey in next2) {
      if (pendingKeys.length) {
        nextKeysPending[prevKey] = pendingKeys;
        pendingKeys = [];
      }
    } else {
      pendingKeys.push(prevKey);
    }
  }
  var i;
  var childMapping = {};
  for (var nextKey in next2) {
    if (nextKeysPending[nextKey]) {
      for (i = 0; i < nextKeysPending[nextKey].length; i++) {
        var pendingNextKey = nextKeysPending[nextKey][i];
        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
      }
    }
    childMapping[nextKey] = getValueForKey(nextKey);
  }
  for (i = 0; i < pendingKeys.length; i++) {
    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
  }
  return childMapping;
}
function getProp(child, prop, props) {
  return props[prop] != null ? props[prop] : child.props[prop];
}
function getInitialChildMapping(props, onExited) {
  return getChildMapping(props.children, function(child) {
    return cloneElement(child, {
      onExited: onExited.bind(null, child),
      in: true,
      appear: getProp(child, "appear", props),
      enter: getProp(child, "enter", props),
      exit: getProp(child, "exit", props)
    });
  });
}
function getNextChildMapping(nextProps, prevChildMapping, onExited) {
  var nextChildMapping = getChildMapping(nextProps.children);
  var children = mergeChildMappings(prevChildMapping, nextChildMapping);
  Object.keys(children).forEach(function(key) {
    var child = children[key];
    if (!isValidElement(child)) return;
    var hasPrev = key in prevChildMapping;
    var hasNext = key in nextChildMapping;
    var prevChild = prevChildMapping[key];
    var isLeaving = isValidElement(prevChild) && !prevChild.props.in;
    if (hasNext && (!hasPrev || isLeaving)) {
      children[key] = cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: true,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    } else if (!hasNext && hasPrev && !isLeaving) {
      children[key] = cloneElement(child, {
        in: false
      });
    } else if (hasNext && hasPrev && isValidElement(prevChild)) {
      children[key] = cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: prevChild.props.in,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    }
  });
  return children;
}
var values = Object.values || function(obj) {
  return Object.keys(obj).map(function(k2) {
    return obj[k2];
  });
};
var defaultProps = {
  component: "div",
  childFactory: function childFactory(child) {
    return child;
  }
};
var TransitionGroup = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose$1(TransitionGroup2, _React$Component);
  function TransitionGroup2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var handleExited = _this.handleExited.bind(_assertThisInitialized(_this));
    _this.state = {
      contextValue: {
        isMounting: true
      },
      handleExited,
      firstRender: true
    };
    return _this;
  }
  var _proto = TransitionGroup2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.mounted = true;
    this.setState({
      contextValue: {
        isMounting: false
      }
    });
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.mounted = false;
  };
  TransitionGroup2.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
    var prevChildMapping = _ref.children, handleExited = _ref.handleExited, firstRender = _ref.firstRender;
    return {
      children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
      firstRender: false
    };
  };
  _proto.handleExited = function handleExited(child, node2) {
    var currentChildMapping = getChildMapping(this.props.children);
    if (child.key in currentChildMapping) return;
    if (child.props.onExited) {
      child.props.onExited(node2);
    }
    if (this.mounted) {
      this.setState(function(state2) {
        var children = _extends$1({}, state2.children);
        delete children[child.key];
        return {
          children
        };
      });
    }
  };
  _proto.render = function render() {
    var _this$props = this.props, Component2 = _this$props.component, childFactory2 = _this$props.childFactory, props = _objectWithoutPropertiesLoose$1(_this$props, ["component", "childFactory"]);
    var contextValue = this.state.contextValue;
    var children = values(this.state.children).map(childFactory2);
    delete props.appear;
    delete props.enter;
    delete props.exit;
    if (Component2 === null) {
      return /* @__PURE__ */ React__default.createElement(TransitionGroupContext.Provider, {
        value: contextValue
      }, children);
    }
    return /* @__PURE__ */ React__default.createElement(TransitionGroupContext.Provider, {
      value: contextValue
    }, /* @__PURE__ */ React__default.createElement(Component2, props, children));
  };
  return TransitionGroup2;
}(React__default.Component);
TransitionGroup.propTypes = {};
TransitionGroup.defaultProps = defaultProps;
const TransitionGroup$1 = TransitionGroup;
const reflow = (node2) => node2.scrollTop;
function getTransitionProps(props, options) {
  const {
    timeout,
    easing: easing2,
    style: style2 = {}
  } = props;
  return {
    duration: style2.transitionDuration ?? (typeof timeout === "number" ? timeout : timeout[options.mode] || 0),
    easing: style2.transitionTimingFunction ?? (typeof easing2 === "object" ? easing2[options.mode] : easing2),
    delay: style2.transitionDelay
  };
}
function getScale(value) {
  return `scale(${value}, ${value ** 2})`;
}
const styles$l = {
  entering: {
    opacity: 1,
    transform: getScale(1)
  },
  entered: {
    opacity: 1,
    transform: "none"
  }
};
const isWebKit154 = typeof navigator !== "undefined" && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent);
const Grow = /* @__PURE__ */ React.forwardRef(function Grow2(props, ref2) {
  const {
    addEndListener,
    appear = true,
    children,
    easing: easing2,
    in: inProp,
    onEnter,
    onEntered,
    onEntering,
    onExit,
    onExited,
    onExiting,
    style: style2,
    timeout = "auto",
    // eslint-disable-next-line https://esm.sh/react/prop-types
    TransitionComponent = Transition$1,
    ...other
  } = props;
  const timer = useTimeout();
  const autoTimeout = React.useRef();
  const theme = useTheme();
  const nodeRef = React.useRef(null);
  const handleRef = useForkRef$1(nodeRef, getReactElementRef(children), ref2);
  const normalizedTransitionCallback = (callback) => (maybeIsAppearing) => {
    if (callback) {
      const node2 = nodeRef.current;
      if (maybeIsAppearing === void 0) {
        callback(node2);
      } else {
        callback(node2, maybeIsAppearing);
      }
    }
  };
  const handleEntering = normalizedTransitionCallback(onEntering);
  const handleEnter = normalizedTransitionCallback((node2, isAppearing) => {
    reflow(node2);
    const {
      duration: transitionDuration,
      delay,
      easing: transitionTimingFunction
    } = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "enter"
    });
    let duration2;
    if (timeout === "auto") {
      duration2 = theme.transitions.getAutoHeightDuration(node2.clientHeight);
      autoTimeout.current = duration2;
    } else {
      duration2 = transitionDuration;
    }
    node2.style.transition = [theme.transitions.create("opacity", {
      duration: duration2,
      delay
    }), theme.transitions.create("transform", {
      duration: isWebKit154 ? duration2 : duration2 * 0.666,
      delay,
      easing: transitionTimingFunction
    })].join(",");
    if (onEnter) {
      onEnter(node2, isAppearing);
    }
  });
  const handleEntered = normalizedTransitionCallback(onEntered);
  const handleExiting = normalizedTransitionCallback(onExiting);
  const handleExit = normalizedTransitionCallback((node2) => {
    const {
      duration: transitionDuration,
      delay,
      easing: transitionTimingFunction
    } = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "exit"
    });
    let duration2;
    if (timeout === "auto") {
      duration2 = theme.transitions.getAutoHeightDuration(node2.clientHeight);
      autoTimeout.current = duration2;
    } else {
      duration2 = transitionDuration;
    }
    node2.style.transition = [theme.transitions.create("opacity", {
      duration: duration2,
      delay
    }), theme.transitions.create("transform", {
      duration: isWebKit154 ? duration2 : duration2 * 0.666,
      delay: isWebKit154 ? delay : delay || duration2 * 0.333,
      easing: transitionTimingFunction
    })].join(",");
    node2.style.opacity = 0;
    node2.style.transform = getScale(0.75);
    if (onExit) {
      onExit(node2);
    }
  });
  const handleExited = normalizedTransitionCallback(onExited);
  const handleAddEndListener = (next2) => {
    if (timeout === "auto") {
      timer.start(autoTimeout.current || 0, next2);
    }
    if (addEndListener) {
      addEndListener(nodeRef.current, next2);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, {
    appear,
    in: inProp,
    nodeRef,
    onEnter: handleEnter,
    onEntered: handleEntered,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited: handleExited,
    onExiting: handleExiting,
    addEndListener: handleAddEndListener,
    timeout: timeout === "auto" ? null : timeout,
    ...other,
    children: (state2, {
      ownerState,
      ...restChildProps
    }) => {
      return /* @__PURE__ */ React.cloneElement(children, {
        style: {
          opacity: 0,
          transform: getScale(0.75),
          visibility: state2 === "exited" && !inProp ? "hidden" : void 0,
          ...styles$l[state2],
          ...style2,
          ...children.props.style
        },
        ref: handleRef,
        ...restChildProps
      });
    }
  });
});
if (Grow) {
  Grow.muiSupportAuto = true;
}
function isOverflowing(container) {
  const doc = ownerDocument(container);
  if (doc.body === container) {
    return ownerWindow(container).innerWidth > doc.documentElement.clientWidth;
  }
  return container.scrollHeight > container.clientHeight;
}
function ariaHidden(element, hide) {
  if (hide) {
    element.setAttribute("aria-hidden", "true");
  } else {
    element.removeAttribute("aria-hidden");
  }
}
function getPaddingRight(element) {
  return parseInt(ownerWindow(element).getComputedStyle(element).paddingRight, 10) || 0;
}
function isAriaHiddenForbiddenOnElement(element) {
  const forbiddenTagNames = ["TEMPLATE", "SCRIPT", "STYLE", "LINK", "MAP", "META", "NOSCRIPT", "PICTURE", "COL", "COLGROUP", "PARAM", "SLOT", "SOURCE", "TRACK"];
  const isForbiddenTagName = forbiddenTagNames.includes(element.tagName);
  const isInputHidden = element.tagName === "INPUT" && element.getAttribute("type") === "hidden";
  return isForbiddenTagName || isInputHidden;
}
function ariaHiddenSiblings(container, mountElement, currentElement, elementsToExclude, hide) {
  const blacklist = [mountElement, currentElement, ...elementsToExclude];
  [].forEach.call(container.children, (element) => {
    const isNotExcludedElement = !blacklist.includes(element);
    const isNotForbiddenElement = !isAriaHiddenForbiddenOnElement(element);
    if (isNotExcludedElement && isNotForbiddenElement) {
      ariaHidden(element, hide);
    }
  });
}
function findIndexOf(items, callback) {
  let idx = -1;
  items.some((item, index) => {
    if (callback(item)) {
      idx = index;
      return true;
    }
    return false;
  });
  return idx;
}
function handleContainer(containerInfo, props) {
  const restoreStyle = [];
  const container = containerInfo.container;
  if (!props.disableScrollLock) {
    if (isOverflowing(container)) {
      const scrollbarSize = getScrollbarSize(ownerWindow(container));
      restoreStyle.push({
        value: container.style.paddingRight,
        property: "padding-right",
        el: container
      });
      container.style.paddingRight = `${getPaddingRight(container) + scrollbarSize}px`;
      const fixedElements2 = ownerDocument(container).querySelectorAll(".mui-fixed");
      [].forEach.call(fixedElements2, (element) => {
        restoreStyle.push({
          value: element.style.paddingRight,
          property: "padding-right",
          el: element
        });
        element.style.paddingRight = `${getPaddingRight(element) + scrollbarSize}px`;
      });
    }
    let scrollContainer;
    if (container.parentNode instanceof DocumentFragment) {
      scrollContainer = ownerDocument(container).body;
    } else {
      const parent = container.parentElement;
      const containerWindow = ownerWindow(container);
      scrollContainer = (parent == null ? void 0 : parent.nodeName) === "HTML" && containerWindow.getComputedStyle(parent).overflowY === "scroll" ? parent : container;
    }
    restoreStyle.push({
      value: scrollContainer.style.overflow,
      property: "overflow",
      el: scrollContainer
    }, {
      value: scrollContainer.style.overflowX,
      property: "overflow-x",
      el: scrollContainer
    }, {
      value: scrollContainer.style.overflowY,
      property: "overflow-y",
      el: scrollContainer
    });
    scrollContainer.style.overflow = "hidden";
  }
  const restore = () => {
    restoreStyle.forEach(({
      value,
      el,
      property
    }) => {
      if (value) {
        el.style.setProperty(property, value);
      } else {
        el.style.removeProperty(property);
      }
    });
  };
  return restore;
}
function getHiddenSiblings(container) {
  const hiddenSiblings = [];
  [].forEach.call(container.children, (element) => {
    if (element.getAttribute("aria-hidden") === "true") {
      hiddenSiblings.push(element);
    }
  });
  return hiddenSiblings;
}
class ModalManager {
  constructor() {
    this.modals = [];
    this.containers = [];
  }
  add(modal, container) {
    let modalIndex = this.modals.indexOf(modal);
    if (modalIndex !== -1) {
      return modalIndex;
    }
    modalIndex = this.modals.length;
    this.modals.push(modal);
    if (modal.modalRef) {
      ariaHidden(modal.modalRef, false);
    }
    const hiddenSiblings = getHiddenSiblings(container);
    ariaHiddenSiblings(container, modal.mount, modal.modalRef, hiddenSiblings, true);
    const containerIndex = findIndexOf(this.containers, (item) => item.container === container);
    if (containerIndex !== -1) {
      this.containers[containerIndex].modals.push(modal);
      return modalIndex;
    }
    this.containers.push({
      modals: [modal],
      container,
      restore: null,
      hiddenSiblings
    });
    return modalIndex;
  }
  mount(modal, props) {
    const containerIndex = findIndexOf(this.containers, (item) => item.modals.includes(modal));
    const containerInfo = this.containers[containerIndex];
    if (!containerInfo.restore) {
      containerInfo.restore = handleContainer(containerInfo, props);
    }
  }
  remove(modal, ariaHiddenState = true) {
    const modalIndex = this.modals.indexOf(modal);
    if (modalIndex === -1) {
      return modalIndex;
    }
    const containerIndex = findIndexOf(this.containers, (item) => item.modals.includes(modal));
    const containerInfo = this.containers[containerIndex];
    containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);
    this.modals.splice(modalIndex, 1);
    if (containerInfo.modals.length === 0) {
      if (containerInfo.restore) {
        containerInfo.restore();
      }
      if (modal.modalRef) {
        ariaHidden(modal.modalRef, ariaHiddenState);
      }
      ariaHiddenSiblings(containerInfo.container, modal.mount, modal.modalRef, containerInfo.hiddenSiblings, false);
      this.containers.splice(containerIndex, 1);
    } else {
      const nextTop = containerInfo.modals[containerInfo.modals.length - 1];
      if (nextTop.modalRef) {
        ariaHidden(nextTop.modalRef, false);
      }
    }
    return modalIndex;
  }
  isTopModal(modal) {
    return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal;
  }
}
const candidatesSelector = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(",");
function getTabIndex(node2) {
  const tabindexAttr = parseInt(node2.getAttribute("tabindex") || "", 10);
  if (!Number.isNaN(tabindexAttr)) {
    return tabindexAttr;
  }
  if (node2.contentEditable === "true" || (node2.nodeName === "AUDIO" || node2.nodeName === "VIDEO" || node2.nodeName === "DETAILS") && node2.getAttribute("tabindex") === null) {
    return 0;
  }
  return node2.tabIndex;
}
function isNonTabbableRadio(node2) {
  if (node2.tagName !== "INPUT" || node2.type !== "radio") {
    return false;
  }
  if (!node2.name) {
    return false;
  }
  const getRadio = (selector) => node2.ownerDocument.querySelector(`input[type="radio"]${selector}`);
  let roving = getRadio(`[name="${node2.name}"]:checked`);
  if (!roving) {
    roving = getRadio(`[name="${node2.name}"]`);
  }
  return roving !== node2;
}
function isNodeMatchingSelectorFocusable(node2) {
  if (node2.disabled || node2.tagName === "INPUT" && node2.type === "hidden" || isNonTabbableRadio(node2)) {
    return false;
  }
  return true;
}
function defaultGetTabbable(root) {
  const regularTabNodes = [];
  const orderedTabNodes = [];
  Array.from(root.querySelectorAll(candidatesSelector)).forEach((node2, i) => {
    const nodeTabIndex = getTabIndex(node2);
    if (nodeTabIndex === -1 || !isNodeMatchingSelectorFocusable(node2)) {
      return;
    }
    if (nodeTabIndex === 0) {
      regularTabNodes.push(node2);
    } else {
      orderedTabNodes.push({
        documentOrder: i,
        tabIndex: nodeTabIndex,
        node: node2
      });
    }
  });
  return orderedTabNodes.sort((a, b) => a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex).map((a) => a.node).concat(regularTabNodes);
}
function defaultIsEnabled() {
  return true;
}
function FocusTrap(props) {
  const {
    children,
    disableAutoFocus = false,
    disableEnforceFocus = false,
    disableRestoreFocus = false,
    getTabbable = defaultGetTabbable,
    isEnabled = defaultIsEnabled,
    open
  } = props;
  const ignoreNextEnforceFocus = React.useRef(false);
  const sentinelStart = React.useRef(null);
  const sentinelEnd = React.useRef(null);
  const nodeToRestore = React.useRef(null);
  const reactFocusEventTarget = React.useRef(null);
  const activated = React.useRef(false);
  const rootRef = React.useRef(null);
  const handleRef = useForkRef$1(getReactElementRef(children), rootRef);
  const lastKeydown = React.useRef(null);
  React.useEffect(() => {
    if (!open || !rootRef.current) {
      return;
    }
    activated.current = !disableAutoFocus;
  }, [disableAutoFocus, open]);
  React.useEffect(() => {
    if (!open || !rootRef.current) {
      return;
    }
    const doc = ownerDocument(rootRef.current);
    if (!rootRef.current.contains(doc.activeElement)) {
      if (!rootRef.current.hasAttribute("tabIndex")) {
        rootRef.current.setAttribute("tabIndex", "-1");
      }
      if (activated.current) {
        rootRef.current.focus();
      }
    }
    return () => {
      if (!disableRestoreFocus) {
        if (nodeToRestore.current && nodeToRestore.current.focus) {
          ignoreNextEnforceFocus.current = true;
          nodeToRestore.current.focus();
        }
        nodeToRestore.current = null;
      }
    };
  }, [open]);
  React.useEffect(() => {
    if (!open || !rootRef.current) {
      return;
    }
    const doc = ownerDocument(rootRef.current);
    const loopFocus = (nativeEvent) => {
      lastKeydown.current = nativeEvent;
      if (disableEnforceFocus || !isEnabled() || nativeEvent.key !== "Tab") {
        return;
      }
      if (doc.activeElement === rootRef.current && nativeEvent.shiftKey) {
        ignoreNextEnforceFocus.current = true;
        if (sentinelEnd.current) {
          sentinelEnd.current.focus();
        }
      }
    };
    const contain = () => {
      var _a2, _b;
      const rootElement = rootRef.current;
      if (rootElement === null) {
        return;
      }
      if (!doc.hasFocus() || !isEnabled() || ignoreNextEnforceFocus.current) {
        ignoreNextEnforceFocus.current = false;
        return;
      }
      if (rootElement.contains(doc.activeElement)) {
        return;
      }
      if (disableEnforceFocus && doc.activeElement !== sentinelStart.current && doc.activeElement !== sentinelEnd.current) {
        return;
      }
      if (doc.activeElement !== reactFocusEventTarget.current) {
        reactFocusEventTarget.current = null;
      } else if (reactFocusEventTarget.current !== null) {
        return;
      }
      if (!activated.current) {
        return;
      }
      let tabbable = [];
      if (doc.activeElement === sentinelStart.current || doc.activeElement === sentinelEnd.current) {
        tabbable = getTabbable(rootRef.current);
      }
      if (tabbable.length > 0) {
        const isShiftTab = Boolean(((_a2 = lastKeydown.current) == null ? void 0 : _a2.shiftKey) && ((_b = lastKeydown.current) == null ? void 0 : _b.key) === "Tab");
        const focusNext = tabbable[0];
        const focusPrevious = tabbable[tabbable.length - 1];
        if (typeof focusNext !== "string" && typeof focusPrevious !== "string") {
          if (isShiftTab) {
            focusPrevious.focus();
          } else {
            focusNext.focus();
          }
        }
      } else {
        rootElement.focus();
      }
    };
    doc.addEventListener("focusin", contain);
    doc.addEventListener("keydown", loopFocus, true);
    const interval = setInterval(() => {
      if (doc.activeElement && doc.activeElement.tagName === "BODY") {
        contain();
      }
    }, 50);
    return () => {
      clearInterval(interval);
      doc.removeEventListener("focusin", contain);
      doc.removeEventListener("keydown", loopFocus, true);
    };
  }, [disableAutoFocus, disableEnforceFocus, disableRestoreFocus, isEnabled, open, getTabbable]);
  const onFocus = (event) => {
    if (nodeToRestore.current === null) {
      nodeToRestore.current = event.relatedTarget;
    }
    activated.current = true;
    reactFocusEventTarget.current = event.target;
    const childrenPropsHandler = children.props.onFocus;
    if (childrenPropsHandler) {
      childrenPropsHandler(event);
    }
  };
  const handleFocusSentinel = (event) => {
    if (nodeToRestore.current === null) {
      nodeToRestore.current = event.relatedTarget;
    }
    activated.current = true;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(React.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx("div", {
      tabIndex: open ? 0 : -1,
      onFocus: handleFocusSentinel,
      ref: sentinelStart,
      "data-testid": "sentinelStart"
    }), /* @__PURE__ */ React.cloneElement(children, {
      ref: handleRef,
      onFocus
    }), /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
      tabIndex: open ? 0 : -1,
      onFocus: handleFocusSentinel,
      ref: sentinelEnd,
      "data-testid": "sentinelEnd"
    })]
  });
}
function getContainer$1(container) {
  return typeof container === "function" ? container() : container;
}
const Portal = /* @__PURE__ */ React.forwardRef(function Portal2(props, forwardedRef) {
  const {
    children,
    container,
    disablePortal = false
  } = props;
  const [mountNode, setMountNode] = React.useState(null);
  const handleRef = useForkRef$1(/* @__PURE__ */ React.isValidElement(children) ? getReactElementRef(children) : null, forwardedRef);
  useEnhancedEffect(() => {
    if (!disablePortal) {
      setMountNode(getContainer$1(container) || document.body);
    }
  }, [container, disablePortal]);
  useEnhancedEffect(() => {
    if (mountNode && !disablePortal) {
      setRef$1(forwardedRef, mountNode);
      return () => {
        setRef$1(forwardedRef, null);
      };
    }
    return void 0;
  }, [forwardedRef, mountNode, disablePortal]);
  if (disablePortal) {
    if (/* @__PURE__ */ React.isValidElement(children)) {
      const newProps = {
        ref: handleRef
      };
      return /* @__PURE__ */ React.cloneElement(children, newProps);
    }
    return children;
  }
  return mountNode ? /* @__PURE__ */ ReactDOM.createPortal(children, mountNode) : mountNode;
});
function useSlot(name, parameters) {
  const {
    className,
    elementType: initialElementType,
    ownerState,
    externalForwardedProps,
    internalForwardedProps,
    shouldForwardComponentProp = false,
    ...useSlotPropsParams
  } = parameters;
  const {
    component: rootComponent,
    slots: slots2 = {
      [name]: void 0
    },
    slotProps = {
      [name]: void 0
    },
    ...other
  } = externalForwardedProps;
  const elementType = slots2[name] || initialElementType;
  const resolvedComponentsProps = resolveComponentProps$1(slotProps[name], ownerState);
  const {
    props: {
      component: slotComponent,
      ...mergedProps
    },
    internalRef
  } = mergeSlotProps$1({
    className,
    ...useSlotPropsParams,
    externalForwardedProps: name === "root" ? other : void 0,
    externalSlotProps: resolvedComponentsProps
  });
  const ref2 = useForkRef$1(internalRef, resolvedComponentsProps == null ? void 0 : resolvedComponentsProps.ref, parameters.ref);
  const LeafComponent = name === "root" ? slotComponent || rootComponent : slotComponent;
  const props = appendOwnerState$1(elementType, {
    ...name === "root" && !rootComponent && !slots2[name] && internalForwardedProps,
    ...name !== "root" && !slots2[name] && internalForwardedProps,
    ...mergedProps,
    ...LeafComponent && !shouldForwardComponentProp && {
      as: LeafComponent
    },
    ...LeafComponent && shouldForwardComponentProp && {
      component: LeafComponent
    },
    ref: ref2
  }, ownerState);
  return [elementType, props];
}
const styles$k = {
  entering: {
    opacity: 1
  },
  entered: {
    opacity: 1
  }
};
const Fade = /* @__PURE__ */ React.forwardRef(function Fade2(props, ref2) {
  const theme = useTheme();
  const defaultTimeout = {
    enter: theme.transitions.duration.enteringScreen,
    exit: theme.transitions.duration.leavingScreen
  };
  const {
    addEndListener,
    appear = true,
    children,
    easing: easing2,
    in: inProp,
    onEnter,
    onEntered,
    onEntering,
    onExit,
    onExited,
    onExiting,
    style: style2,
    timeout = defaultTimeout,
    // eslint-disable-next-line https://esm.sh/react/prop-types
    TransitionComponent = Transition$1,
    ...other
  } = props;
  const nodeRef = React.useRef(null);
  const handleRef = useForkRef$1(nodeRef, getReactElementRef(children), ref2);
  const normalizedTransitionCallback = (callback) => (maybeIsAppearing) => {
    if (callback) {
      const node2 = nodeRef.current;
      if (maybeIsAppearing === void 0) {
        callback(node2);
      } else {
        callback(node2, maybeIsAppearing);
      }
    }
  };
  const handleEntering = normalizedTransitionCallback(onEntering);
  const handleEnter = normalizedTransitionCallback((node2, isAppearing) => {
    reflow(node2);
    const transitionProps = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "enter"
    });
    node2.style.webkitTransition = theme.transitions.create("opacity", transitionProps);
    node2.style.transition = theme.transitions.create("opacity", transitionProps);
    if (onEnter) {
      onEnter(node2, isAppearing);
    }
  });
  const handleEntered = normalizedTransitionCallback(onEntered);
  const handleExiting = normalizedTransitionCallback(onExiting);
  const handleExit = normalizedTransitionCallback((node2) => {
    const transitionProps = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "exit"
    });
    node2.style.webkitTransition = theme.transitions.create("opacity", transitionProps);
    node2.style.transition = theme.transitions.create("opacity", transitionProps);
    if (onExit) {
      onExit(node2);
    }
  });
  const handleExited = normalizedTransitionCallback(onExited);
  const handleAddEndListener = (next2) => {
    if (addEndListener) {
      addEndListener(nodeRef.current, next2);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, {
    appear,
    in: inProp,
    nodeRef,
    onEnter: handleEnter,
    onEntered: handleEntered,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited: handleExited,
    onExiting: handleExiting,
    addEndListener: handleAddEndListener,
    timeout,
    ...other,
    children: (state2, {
      ownerState,
      ...restChildProps
    }) => {
      return /* @__PURE__ */ React.cloneElement(children, {
        style: {
          opacity: 0,
          visibility: state2 === "exited" && !inProp ? "hidden" : void 0,
          ...styles$k[state2],
          ...style2,
          ...children.props.style
        },
        ref: handleRef,
        ...restChildProps
      });
    }
  });
});
function getBackdropUtilityClass(slot) {
  return generateUtilityClass("MuiBackdrop", slot);
}
generateUtilityClasses("MuiBackdrop", ["root", "invisible"]);
const useUtilityClasses$e = (ownerState) => {
  const {
    classes,
    invisible
  } = ownerState;
  const slots2 = {
    root: ["root", invisible && "invisible"]
  };
  return composeClasses(slots2, getBackdropUtilityClass, classes);
};
const BackdropRoot = styled("div", {
  name: "MuiBackdrop",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.invisible && styles2.invisible];
  }
})({
  position: "fixed",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  right: 0,
  bottom: 0,
  top: 0,
  left: 0,
  backgroundColor: "rgba(0, 0, 0, 0.5)",
  WebkitTapHighlightColor: "transparent",
  variants: [{
    props: {
      invisible: true
    },
    style: {
      backgroundColor: "transparent"
    }
  }]
});
const Backdrop = /* @__PURE__ */ React.forwardRef(function Backdrop2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiBackdrop"
  });
  const {
    children,
    className,
    component = "div",
    invisible = false,
    open,
    components = {},
    componentsProps = {},
    slotProps = {},
    slots: slots2 = {},
    TransitionComponent: TransitionComponentProp,
    transitionDuration,
    ...other
  } = props;
  const ownerState = {
    ...props,
    component,
    invisible
  };
  const classes = useUtilityClasses$e(ownerState);
  const backwardCompatibleSlots = {
    transition: TransitionComponentProp,
    root: components.Root,
    ...slots2
  };
  const backwardCompatibleSlotProps = {
    ...componentsProps,
    ...slotProps
  };
  const externalForwardedProps = {
    slots: backwardCompatibleSlots,
    slotProps: backwardCompatibleSlotProps
  };
  const [RootSlot, rootProps] = useSlot("root", {
    elementType: BackdropRoot,
    externalForwardedProps,
    className: clsx(classes.root, className),
    ownerState
  });
  const [TransitionSlot, transitionProps] = useSlot("transition", {
    elementType: Fade,
    externalForwardedProps,
    ownerState
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionSlot, {
    in: open,
    timeout: transitionDuration,
    ...other,
    ...transitionProps,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(RootSlot, {
      "aria-hidden": true,
      ...rootProps,
      classes,
      ref: ref2,
      children
    })
  });
});
function getContainer(container) {
  return typeof container === "function" ? container() : container;
}
function getHasTransition(children) {
  return children ? children.props.hasOwnProperty("in") : false;
}
const noop = () => {
};
const manager = new ModalManager();
function useModal(parameters) {
  const {
    container,
    disableEscapeKeyDown = false,
    disableScrollLock = false,
    closeAfterTransition = false,
    onTransitionEnter,
    onTransitionExited,
    children,
    onClose,
    open,
    rootRef
  } = parameters;
  const modal = React.useRef({});
  const mountNodeRef = React.useRef(null);
  const modalRef = React.useRef(null);
  const handleRef = useForkRef$1(modalRef, rootRef);
  const [exited, setExited] = React.useState(!open);
  const hasTransition = getHasTransition(children);
  let ariaHiddenProp = true;
  if (parameters["aria-hidden"] === "false" || parameters["aria-hidden"] === false) {
    ariaHiddenProp = false;
  }
  const getDoc = () => ownerDocument(mountNodeRef.current);
  const getModal = () => {
    modal.current.modalRef = modalRef.current;
    modal.current.mount = mountNodeRef.current;
    return modal.current;
  };
  const handleMounted = () => {
    manager.mount(getModal(), {
      disableScrollLock
    });
    if (modalRef.current) {
      modalRef.current.scrollTop = 0;
    }
  };
  const handleOpen = useEventCallback(() => {
    const resolvedContainer = getContainer(container) || getDoc().body;
    manager.add(getModal(), resolvedContainer);
    if (modalRef.current) {
      handleMounted();
    }
  });
  const isTopModal = () => manager.isTopModal(getModal());
  const handlePortalRef = useEventCallback((node2) => {
    mountNodeRef.current = node2;
    if (!node2) {
      return;
    }
    if (open && isTopModal()) {
      handleMounted();
    } else if (modalRef.current) {
      ariaHidden(modalRef.current, ariaHiddenProp);
    }
  });
  const handleClose = React.useCallback(() => {
    manager.remove(getModal(), ariaHiddenProp);
  }, [ariaHiddenProp]);
  React.useEffect(() => {
    return () => {
      handleClose();
    };
  }, [handleClose]);
  React.useEffect(() => {
    if (open) {
      handleOpen();
    } else if (!hasTransition || !closeAfterTransition) {
      handleClose();
    }
  }, [open, handleClose, hasTransition, closeAfterTransition, handleOpen]);
  const createHandleKeyDown = (otherHandlers) => (event) => {
    var _a2;
    (_a2 = otherHandlers.onKeyDown) == null ? void 0 : _a2.call(otherHandlers, event);
    if (event.key !== "Escape" || event.which === 229 || // Wait until IME is settled.
    !isTopModal()) {
      return;
    }
    if (!disableEscapeKeyDown) {
      event.stopPropagation();
      if (onClose) {
        onClose(event, "escapeKeyDown");
      }
    }
  };
  const createHandleBackdropClick = (otherHandlers) => (event) => {
    var _a2;
    (_a2 = otherHandlers.onClick) == null ? void 0 : _a2.call(otherHandlers, event);
    if (event.target !== event.currentTarget) {
      return;
    }
    if (onClose) {
      onClose(event, "backdropClick");
    }
  };
  const getRootProps = (otherHandlers = {}) => {
    const propsEventHandlers = extractEventHandlers$1(parameters);
    delete propsEventHandlers.onTransitionEnter;
    delete propsEventHandlers.onTransitionExited;
    const externalEventHandlers = {
      ...propsEventHandlers,
      ...otherHandlers
    };
    return {
      /*
       * Marking an element with the role presentation indicates to assistive technology
       * that this element should be ignored; it exists to support the web application and
       * is not meant for humans to interact with directly.
       * https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/no-static-element-interactions.md
       */
      role: "presentation",
      ...externalEventHandlers,
      onKeyDown: createHandleKeyDown(externalEventHandlers),
      ref: handleRef
    };
  };
  const getBackdropProps = (otherHandlers = {}) => {
    const externalEventHandlers = otherHandlers;
    return {
      "aria-hidden": true,
      ...externalEventHandlers,
      onClick: createHandleBackdropClick(externalEventHandlers),
      open
    };
  };
  const getTransitionProps2 = () => {
    const handleEnter = () => {
      setExited(false);
      if (onTransitionEnter) {
        onTransitionEnter();
      }
    };
    const handleExited = () => {
      setExited(true);
      if (onTransitionExited) {
        onTransitionExited();
      }
      if (closeAfterTransition) {
        handleClose();
      }
    };
    return {
      onEnter: createChainedFunction(handleEnter, (children == null ? void 0 : children.props.onEnter) ?? noop),
      onExited: createChainedFunction(handleExited, (children == null ? void 0 : children.props.onExited) ?? noop)
    };
  };
  return {
    getRootProps,
    getBackdropProps,
    getTransitionProps: getTransitionProps2,
    rootRef: handleRef,
    portalRef: handlePortalRef,
    isTopModal,
    exited,
    hasTransition
  };
}
function getModalUtilityClass(slot) {
  return generateUtilityClass("MuiModal", slot);
}
generateUtilityClasses("MuiModal", ["root", "hidden", "backdrop"]);
const useUtilityClasses$d = (ownerState) => {
  const {
    open,
    exited,
    classes
  } = ownerState;
  const slots2 = {
    root: ["root", !open && exited && "hidden"],
    backdrop: ["backdrop"]
  };
  return composeClasses(slots2, getModalUtilityClass, classes);
};
const ModalRoot = styled("div", {
  name: "MuiModal",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, !ownerState.open && ownerState.exited && styles2.hidden];
  }
})(memoTheme(({
  theme
}) => ({
  position: "fixed",
  zIndex: (theme.vars || theme).zIndex.modal,
  right: 0,
  bottom: 0,
  top: 0,
  left: 0,
  variants: [{
    props: ({
      ownerState
    }) => !ownerState.open && ownerState.exited,
    style: {
      visibility: "hidden"
    }
  }]
})));
const ModalBackdrop = styled(Backdrop, {
  name: "MuiModal",
  slot: "Backdrop",
  overridesResolver: (props, styles2) => {
    return styles2.backdrop;
  }
})({
  zIndex: -1
});
const Modal = /* @__PURE__ */ React.forwardRef(function Modal2(inProps, ref2) {
  const props = useDefaultProps({
    name: "MuiModal",
    props: inProps
  });
  const {
    BackdropComponent = ModalBackdrop,
    BackdropProps,
    classes: classesProp,
    className,
    closeAfterTransition = false,
    children,
    container,
    component,
    components = {},
    componentsProps = {},
    disableAutoFocus = false,
    disableEnforceFocus = false,
    disableEscapeKeyDown = false,
    disablePortal = false,
    disableRestoreFocus = false,
    disableScrollLock = false,
    hideBackdrop = false,
    keepMounted = false,
    onBackdropClick,
    onClose,
    onTransitionEnter,
    onTransitionExited,
    open,
    slotProps = {},
    slots: slots2 = {},
    // eslint-disable-next-line https://esm.sh/react/prop-types
    theme,
    ...other
  } = props;
  const propsWithDefaults = {
    ...props,
    closeAfterTransition,
    disableAutoFocus,
    disableEnforceFocus,
    disableEscapeKeyDown,
    disablePortal,
    disableRestoreFocus,
    disableScrollLock,
    hideBackdrop,
    keepMounted
  };
  const {
    getRootProps,
    getBackdropProps,
    getTransitionProps: getTransitionProps2,
    portalRef,
    isTopModal,
    exited,
    hasTransition
  } = useModal({
    ...propsWithDefaults,
    rootRef: ref2
  });
  const ownerState = {
    ...propsWithDefaults,
    exited
  };
  const classes = useUtilityClasses$d(ownerState);
  const childProps = {};
  if (children.props.tabIndex === void 0) {
    childProps.tabIndex = "-1";
  }
  if (hasTransition) {
    const {
      onEnter,
      onExited
    } = getTransitionProps2();
    childProps.onEnter = onEnter;
    childProps.onExited = onExited;
  }
  const externalForwardedProps = {
    ...other,
    slots: {
      root: components.Root,
      backdrop: components.Backdrop,
      ...slots2
    },
    slotProps: {
      ...componentsProps,
      ...slotProps
    }
  };
  const [RootSlot, rootProps] = useSlot("root", {
    elementType: ModalRoot,
    externalForwardedProps,
    getSlotProps: getRootProps,
    additionalProps: {
      ref: ref2,
      as: component
    },
    ownerState,
    className: clsx(className, classes == null ? void 0 : classes.root, !ownerState.open && ownerState.exited && (classes == null ? void 0 : classes.hidden))
  });
  const [BackdropSlot, backdropProps] = useSlot("backdrop", {
    elementType: BackdropComponent,
    externalForwardedProps,
    additionalProps: BackdropProps,
    getSlotProps: (otherHandlers) => {
      return getBackdropProps({
        ...otherHandlers,
        onClick: (event) => {
          if (onBackdropClick) {
            onBackdropClick(event);
          }
          if (otherHandlers == null ? void 0 : otherHandlers.onClick) {
            otherHandlers.onClick(event);
          }
        }
      });
    },
    className: clsx(BackdropProps == null ? void 0 : BackdropProps.className, classes == null ? void 0 : classes.backdrop),
    ownerState
  });
  const backdropRef = useForkRef$1(BackdropProps == null ? void 0 : BackdropProps.ref, backdropProps.ref);
  if (!keepMounted && !open && (!hasTransition || exited)) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, {
    ref: portalRef,
    container,
    disablePortal,
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, {
      ...rootProps,
      children: [!hideBackdrop && BackdropComponent ? /* @__PURE__ */ jsxRuntimeExports.jsx(BackdropSlot, {
        ...backdropProps,
        ref: backdropRef
      }) : null, /* @__PURE__ */ jsxRuntimeExports.jsx(FocusTrap, {
        disableEnforceFocus,
        disableAutoFocus,
        disableRestoreFocus,
        isEnabled: isTopModal,
        open,
        children: /* @__PURE__ */ React.cloneElement(children, childProps)
      })]
    })
  });
});
function getPaperUtilityClass(slot) {
  return generateUtilityClass("MuiPaper", slot);
}
generateUtilityClasses("MuiPaper", ["root", "rounded", "outlined", "elevation", "elevation0", "elevation1", "elevation2", "elevation3", "elevation4", "elevation5", "elevation6", "elevation7", "elevation8", "elevation9", "elevation10", "elevation11", "elevation12", "elevation13", "elevation14", "elevation15", "elevation16", "elevation17", "elevation18", "elevation19", "elevation20", "elevation21", "elevation22", "elevation23", "elevation24"]);
const useUtilityClasses$c = (ownerState) => {
  const {
    square,
    elevation,
    variant,
    classes
  } = ownerState;
  const slots2 = {
    root: ["root", variant, !square && "rounded", variant === "elevation" && `elevation${elevation}`]
  };
  return composeClasses(slots2, getPaperUtilityClass, classes);
};
const PaperRoot = styled("div", {
  name: "MuiPaper",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], !ownerState.square && styles2.rounded, ownerState.variant === "elevation" && styles2[`elevation${ownerState.elevation}`]];
  }
})(memoTheme(({
  theme
}) => ({
  backgroundColor: (theme.vars || theme).palette.background.paper,
  color: (theme.vars || theme).palette.text.primary,
  transition: theme.transitions.create("box-shadow"),
  variants: [{
    props: ({
      ownerState
    }) => !ownerState.square,
    style: {
      borderRadius: theme.shape.borderRadius
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      border: `1px solid ${(theme.vars || theme).palette.divider}`
    }
  }, {
    props: {
      variant: "elevation"
    },
    style: {
      boxShadow: "var(--Paper-shadow)",
      backgroundImage: "var(--Paper-overlay)"
    }
  }]
})));
const Paper = /* @__PURE__ */ React.forwardRef(function Paper2(inProps, ref2) {
  var _a2;
  const props = useDefaultProps({
    props: inProps,
    name: "MuiPaper"
  });
  const theme = useTheme();
  const {
    className,
    component = "div",
    elevation = 1,
    square = false,
    variant = "elevation",
    ...other
  } = props;
  const ownerState = {
    ...props,
    component,
    elevation,
    square,
    variant
  };
  const classes = useUtilityClasses$c(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PaperRoot, {
    as: component,
    ownerState,
    className: clsx(classes.root, className),
    ref: ref2,
    ...other,
    style: {
      ...variant === "elevation" && {
        "--Paper-shadow": (theme.vars || theme).shadows[elevation],
        ...theme.vars && {
          "--Paper-overlay": (_a2 = theme.vars.overlays) == null ? void 0 : _a2[elevation]
        },
        ...!theme.vars && theme.palette.mode === "dark" && {
          "--Paper-overlay": `linear-gradient(${alpha("#fff", getOverlayAlpha(elevation))}, ${alpha("#fff", getOverlayAlpha(elevation))})`
        }
      },
      ...other.style
    }
  });
});
function getPopoverUtilityClass(slot) {
  return generateUtilityClass("MuiPopover", slot);
}
generateUtilityClasses("MuiPopover", ["root", "paper"]);
function getOffsetTop(rect, vertical) {
  let offset = 0;
  if (typeof vertical === "number") {
    offset = vertical;
  } else if (vertical === "center") {
    offset = rect.height / 2;
  } else if (vertical === "bottom") {
    offset = rect.height;
  }
  return offset;
}
function getOffsetLeft(rect, horizontal) {
  let offset = 0;
  if (typeof horizontal === "number") {
    offset = horizontal;
  } else if (horizontal === "center") {
    offset = rect.width / 2;
  } else if (horizontal === "right") {
    offset = rect.width;
  }
  return offset;
}
function getTransformOriginValue(transformOrigin) {
  return [transformOrigin.horizontal, transformOrigin.vertical].map((n) => typeof n === "number" ? `${n}px` : n).join(" ");
}
function resolveAnchorEl(anchorEl) {
  return typeof anchorEl === "function" ? anchorEl() : anchorEl;
}
const useUtilityClasses$b = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots2 = {
    root: ["root"],
    paper: ["paper"]
  };
  return composeClasses(slots2, getPopoverUtilityClass, classes);
};
const PopoverRoot = styled(Modal, {
  name: "MuiPopover",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({});
const PopoverPaper = styled(Paper, {
  name: "MuiPopover",
  slot: "Paper",
  overridesResolver: (props, styles2) => styles2.paper
})({
  position: "absolute",
  overflowY: "auto",
  overflowX: "hidden",
  // So we see the popover when it's empty.
  // It's most likely on issue on userland.
  minWidth: 16,
  minHeight: 16,
  maxWidth: "calc(100% - 32px)",
  maxHeight: "calc(100% - 32px)",
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
});
const Popover = /* @__PURE__ */ React.forwardRef(function Popover2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiPopover"
  });
  const {
    action,
    anchorEl,
    anchorOrigin = {
      vertical: "top",
      horizontal: "left"
    },
    anchorPosition,
    anchorReference = "anchorEl",
    children,
    className,
    container: containerProp,
    elevation = 8,
    marginThreshold = 16,
    open,
    PaperProps: PaperPropsProp = {},
    slots: slots2 = {},
    slotProps = {},
    transformOrigin = {
      vertical: "top",
      horizontal: "left"
    },
    TransitionComponent = Grow,
    transitionDuration: transitionDurationProp = "auto",
    TransitionProps: {
      onEntering,
      ...TransitionProps
    } = {},
    disableScrollLock = false,
    ...other
  } = props;
  const externalPaperSlotProps = (slotProps == null ? void 0 : slotProps.paper) ?? PaperPropsProp;
  const paperRef = React.useRef();
  const ownerState = {
    ...props,
    anchorOrigin,
    anchorReference,
    elevation,
    marginThreshold,
    externalPaperSlotProps,
    transformOrigin,
    TransitionComponent,
    transitionDuration: transitionDurationProp,
    TransitionProps
  };
  const classes = useUtilityClasses$b(ownerState);
  const getAnchorOffset = React.useCallback(() => {
    if (anchorReference === "anchorPosition") {
      return anchorPosition;
    }
    const resolvedAnchorEl = resolveAnchorEl(anchorEl);
    const anchorElement = resolvedAnchorEl && resolvedAnchorEl.nodeType === 1 ? resolvedAnchorEl : ownerDocument(paperRef.current).body;
    const anchorRect = anchorElement.getBoundingClientRect();
    return {
      top: anchorRect.top + getOffsetTop(anchorRect, anchorOrigin.vertical),
      left: anchorRect.left + getOffsetLeft(anchorRect, anchorOrigin.horizontal)
    };
  }, [anchorEl, anchorOrigin.horizontal, anchorOrigin.vertical, anchorPosition, anchorReference]);
  const getTransformOrigin = React.useCallback((elemRect) => {
    return {
      vertical: getOffsetTop(elemRect, transformOrigin.vertical),
      horizontal: getOffsetLeft(elemRect, transformOrigin.horizontal)
    };
  }, [transformOrigin.horizontal, transformOrigin.vertical]);
  const getPositioningStyle = React.useCallback((element) => {
    const elemRect = {
      width: element.offsetWidth,
      height: element.offsetHeight
    };
    const elemTransformOrigin = getTransformOrigin(elemRect);
    if (anchorReference === "none") {
      return {
        top: null,
        left: null,
        transformOrigin: getTransformOriginValue(elemTransformOrigin)
      };
    }
    const anchorOffset = getAnchorOffset();
    let top = anchorOffset.top - elemTransformOrigin.vertical;
    let left = anchorOffset.left - elemTransformOrigin.horizontal;
    const bottom = top + elemRect.height;
    const right = left + elemRect.width;
    const containerWindow = ownerWindow(resolveAnchorEl(anchorEl));
    const heightThreshold = containerWindow.innerHeight - marginThreshold;
    const widthThreshold = containerWindow.innerWidth - marginThreshold;
    if (marginThreshold !== null && top < marginThreshold) {
      const diff = top - marginThreshold;
      top -= diff;
      elemTransformOrigin.vertical += diff;
    } else if (marginThreshold !== null && bottom > heightThreshold) {
      const diff = bottom - heightThreshold;
      top -= diff;
      elemTransformOrigin.vertical += diff;
    }
    if (marginThreshold !== null && left < marginThreshold) {
      const diff = left - marginThreshold;
      left -= diff;
      elemTransformOrigin.horizontal += diff;
    } else if (right > widthThreshold) {
      const diff = right - widthThreshold;
      left -= diff;
      elemTransformOrigin.horizontal += diff;
    }
    return {
      top: `${Math.round(top)}px`,
      left: `${Math.round(left)}px`,
      transformOrigin: getTransformOriginValue(elemTransformOrigin)
    };
  }, [anchorEl, anchorReference, getAnchorOffset, getTransformOrigin, marginThreshold]);
  const [isPositioned, setIsPositioned] = React.useState(open);
  const setPositioningStyles = React.useCallback(() => {
    const element = paperRef.current;
    if (!element) {
      return;
    }
    const positioning = getPositioningStyle(element);
    if (positioning.top !== null) {
      element.style.setProperty("top", positioning.top);
    }
    if (positioning.left !== null) {
      element.style.left = positioning.left;
    }
    element.style.transformOrigin = positioning.transformOrigin;
    setIsPositioned(true);
  }, [getPositioningStyle]);
  React.useEffect(() => {
    if (disableScrollLock) {
      window.addEventListener("scroll", setPositioningStyles);
    }
    return () => window.removeEventListener("scroll", setPositioningStyles);
  }, [anchorEl, disableScrollLock, setPositioningStyles]);
  const handleEntering = (element, isAppearing) => {
    if (onEntering) {
      onEntering(element, isAppearing);
    }
    setPositioningStyles();
  };
  const handleExited = () => {
    setIsPositioned(false);
  };
  React.useEffect(() => {
    if (open) {
      setPositioningStyles();
    }
  });
  React.useImperativeHandle(action, () => open ? {
    updatePosition: () => {
      setPositioningStyles();
    }
  } : null, [open, setPositioningStyles]);
  React.useEffect(() => {
    if (!open) {
      return void 0;
    }
    const handleResize = debounce(() => {
      setPositioningStyles();
    });
    const containerWindow = ownerWindow(anchorEl);
    containerWindow.addEventListener("resize", handleResize);
    return () => {
      handleResize.clear();
      containerWindow.removeEventListener("resize", handleResize);
    };
  }, [anchorEl, open, setPositioningStyles]);
  let transitionDuration = transitionDurationProp;
  if (transitionDurationProp === "auto" && !TransitionComponent.muiSupportAuto) {
    transitionDuration = void 0;
  }
  const container = containerProp || (anchorEl ? ownerDocument(resolveAnchorEl(anchorEl)).body : void 0);
  const externalForwardedProps = {
    slots: slots2,
    slotProps: {
      ...slotProps,
      paper: externalPaperSlotProps
    }
  };
  const [PaperSlot, paperProps] = useSlot("paper", {
    elementType: PopoverPaper,
    externalForwardedProps,
    additionalProps: {
      elevation,
      className: clsx(classes.paper, externalPaperSlotProps == null ? void 0 : externalPaperSlotProps.className),
      style: isPositioned ? externalPaperSlotProps.style : {
        ...externalPaperSlotProps.style,
        opacity: 0
      }
    },
    ownerState
  });
  const [RootSlot, {
    slotProps: rootSlotPropsProp,
    ...rootProps
  }] = useSlot("root", {
    elementType: PopoverRoot,
    externalForwardedProps,
    additionalProps: {
      slotProps: {
        backdrop: {
          invisible: true
        }
      },
      container,
      open
    },
    ownerState,
    className: clsx(classes.root, className)
  });
  const handlePaperRef = useForkRef$1(paperRef, paperProps.ref);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RootSlot, {
    ...rootProps,
    ...!isHostComponent$1(RootSlot) && {
      slotProps: rootSlotPropsProp,
      disableScrollLock
    },
    ...other,
    ref: ref2,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, {
      appear: true,
      in: open,
      onEntering: handleEntering,
      onExited: handleExited,
      timeout: transitionDuration,
      ...TransitionProps,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(PaperSlot, {
        ...paperProps,
        ref: handlePaperRef,
        children
      })
    })
  });
});
function getMenuUtilityClass(slot) {
  return generateUtilityClass("MuiMenu", slot);
}
generateUtilityClasses("MuiMenu", ["root", "paper", "list"]);
const RTL_ORIGIN = {
  vertical: "top",
  horizontal: "right"
};
const LTR_ORIGIN = {
  vertical: "top",
  horizontal: "left"
};
const useUtilityClasses$a = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots2 = {
    root: ["root"],
    paper: ["paper"],
    list: ["list"]
  };
  return composeClasses(slots2, getMenuUtilityClass, classes);
};
const MenuRoot = styled(Popover, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiMenu",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({});
const MenuPaper = styled(PopoverPaper, {
  name: "MuiMenu",
  slot: "Paper",
  overridesResolver: (props, styles2) => styles2.paper
})({
  // specZ: The maximum height of a simple menu should be one or more rows less than the view
  // height. This ensures a tappable area outside of the simple menu with which to dismiss
  // the menu.
  maxHeight: "calc(100% - 96px)",
  // Add iOS momentum scrolling for iOS < 13.0
  WebkitOverflowScrolling: "touch"
});
const MenuMenuList = styled(MenuList, {
  name: "MuiMenu",
  slot: "List",
  overridesResolver: (props, styles2) => styles2.list
})({
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
});
const Menu = /* @__PURE__ */ React.forwardRef(function Menu2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiMenu"
  });
  const {
    autoFocus = true,
    children,
    className,
    disableAutoFocusItem = false,
    MenuListProps = {},
    onClose,
    open,
    PaperProps = {},
    PopoverClasses,
    transitionDuration = "auto",
    TransitionProps: {
      onEntering,
      ...TransitionProps
    } = {},
    variant = "selectedMenu",
    slots: slots2 = {},
    slotProps = {},
    ...other
  } = props;
  const isRtl = useRtl();
  const ownerState = {
    ...props,
    autoFocus,
    disableAutoFocusItem,
    MenuListProps,
    onEntering,
    PaperProps,
    transitionDuration,
    TransitionProps,
    variant
  };
  const classes = useUtilityClasses$a(ownerState);
  const autoFocusItem = autoFocus && !disableAutoFocusItem && open;
  const menuListActionsRef = React.useRef(null);
  const handleEntering = (element, isAppearing) => {
    if (menuListActionsRef.current) {
      menuListActionsRef.current.adjustStyleForScrollbar(element, {
        direction: isRtl ? "rtl" : "ltr"
      });
    }
    if (onEntering) {
      onEntering(element, isAppearing);
    }
  };
  const handleListKeyDown = (event) => {
    if (event.key === "Tab") {
      event.preventDefault();
      if (onClose) {
        onClose(event, "tabKeyDown");
      }
    }
  };
  let activeItemIndex = -1;
  React.Children.map(children, (child, index) => {
    if (!/* @__PURE__ */ React.isValidElement(child)) {
      return;
    }
    if (!child.props.disabled) {
      if (variant === "selectedMenu" && child.props.selected) {
        activeItemIndex = index;
      } else if (activeItemIndex === -1) {
        activeItemIndex = index;
      }
    }
  });
  const PaperSlot = slots2.paper ?? MenuPaper;
  const paperExternalSlotProps = slotProps.paper ?? PaperProps;
  const rootSlotProps = useSlotProps$1({
    elementType: slots2.root,
    externalSlotProps: slotProps.root,
    ownerState,
    className: [classes.root, className]
  });
  const paperSlotProps = useSlotProps$1({
    elementType: PaperSlot,
    externalSlotProps: paperExternalSlotProps,
    ownerState,
    className: classes.paper
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuRoot, {
    onClose,
    anchorOrigin: {
      vertical: "bottom",
      horizontal: isRtl ? "right" : "left"
    },
    transformOrigin: isRtl ? RTL_ORIGIN : LTR_ORIGIN,
    slots: {
      paper: PaperSlot,
      root: slots2.root
    },
    slotProps: {
      root: rootSlotProps,
      paper: paperSlotProps
    },
    open,
    ref: ref2,
    transitionDuration,
    TransitionProps: {
      onEntering: handleEntering,
      ...TransitionProps
    },
    ownerState,
    ...other,
    classes: PopoverClasses,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuMenuList, {
      onKeyDown: handleListKeyDown,
      actions: menuListActionsRef,
      autoFocus: autoFocus && (activeItemIndex === -1 || disableAutoFocusItem),
      autoFocusItem,
      variant,
      ...MenuListProps,
      className: clsx(classes.list, MenuListProps.className),
      children
    })
  });
});
class LazyRipple {
  constructor() {
    __publicField(this, "mountEffect", () => {
      if (this.shouldMount && !this.didMount) {
        if (this.ref.current !== null) {
          this.didMount = true;
          this.mounted.resolve();
        }
      }
    });
    this.ref = {
      current: null
    };
    this.mounted = null;
    this.didMount = false;
    this.shouldMount = false;
    this.setShouldMount = null;
  }
  /** React ref to the ripple instance */
  /** If the ripple component should be mounted */
  /** Promise that resolves when the ripple component is mounted */
  /** If the ripple component has been mounted */
  /** React state hook setter */
  static create() {
    return new LazyRipple();
  }
  static use() {
    const ripple = useLazyRef(LazyRipple.create).current;
    const [shouldMount, setShouldMount] = React.useState(false);
    ripple.shouldMount = shouldMount;
    ripple.setShouldMount = setShouldMount;
    React.useEffect(ripple.mountEffect, [shouldMount]);
    return ripple;
  }
  mount() {
    if (!this.mounted) {
      this.mounted = createControlledPromise();
      this.shouldMount = true;
      this.setShouldMount(this.shouldMount);
    }
    return this.mounted;
  }
  /* Ripple API */
  start(...args) {
    this.mount().then(() => {
      var _a2;
      return (_a2 = this.ref.current) == null ? void 0 : _a2.start(...args);
    });
  }
  stop(...args) {
    this.mount().then(() => {
      var _a2;
      return (_a2 = this.ref.current) == null ? void 0 : _a2.stop(...args);
    });
  }
  pulsate(...args) {
    this.mount().then(() => {
      var _a2;
      return (_a2 = this.ref.current) == null ? void 0 : _a2.pulsate(...args);
    });
  }
}
function useLazyRipple() {
  return LazyRipple.use();
}
function createControlledPromise() {
  let resolve;
  let reject;
  const p2 = new Promise((resolveFn, rejectFn) => {
    resolve = resolveFn;
    reject = rejectFn;
  });
  p2.resolve = resolve;
  p2.reject = reject;
  return p2;
}
function Ripple(props) {
  const {
    className,
    classes,
    pulsate = false,
    rippleX,
    rippleY,
    rippleSize,
    in: inProp,
    onExited,
    timeout
  } = props;
  const [leaving, setLeaving] = React.useState(false);
  const rippleClassName = clsx(className, classes.ripple, classes.rippleVisible, pulsate && classes.ripplePulsate);
  const rippleStyles = {
    width: rippleSize,
    height: rippleSize,
    top: -(rippleSize / 2) + rippleY,
    left: -(rippleSize / 2) + rippleX
  };
  const childClassName = clsx(classes.child, leaving && classes.childLeaving, pulsate && classes.childPulsate);
  if (!inProp && !leaving) {
    setLeaving(true);
  }
  React.useEffect(() => {
    if (!inProp && onExited != null) {
      const timeoutId = setTimeout(onExited, timeout);
      return () => {
        clearTimeout(timeoutId);
      };
    }
    return void 0;
  }, [onExited, inProp, timeout]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
    className: rippleClassName,
    style: rippleStyles,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
      className: childClassName
    })
  });
}
const touchRippleClasses = generateUtilityClasses("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]);
const DURATION = 550;
const DELAY_RIPPLE = 80;
const enterKeyframe = keyframes`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`;
const exitKeyframe = keyframes`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`;
const pulsateKeyframe = keyframes`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`;
const TouchRippleRoot = styled("span", {
  name: "MuiTouchRipple",
  slot: "Root"
})({
  overflow: "hidden",
  pointerEvents: "none",
  position: "absolute",
  zIndex: 0,
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  borderRadius: "inherit"
});
const TouchRippleRipple = styled(Ripple, {
  name: "MuiTouchRipple",
  slot: "Ripple"
})`
  opacity: 0;
  position: absolute;

  &.${touchRippleClasses.rippleVisible} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${enterKeyframe};
    animation-duration: ${DURATION}ms;
    animation-timing-function: ${({
  theme
}) => theme.transitions.easing.easeInOut};
  }

  &.${touchRippleClasses.ripplePulsate} {
    animation-duration: ${({
  theme
}) => theme.transitions.duration.shorter}ms;
  }

  & .${touchRippleClasses.child} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${touchRippleClasses.childLeaving} {
    opacity: 0;
    animation-name: ${exitKeyframe};
    animation-duration: ${DURATION}ms;
    animation-timing-function: ${({
  theme
}) => theme.transitions.easing.easeInOut};
  }

  & .${touchRippleClasses.childPulsate} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${pulsateKeyframe};
    animation-duration: 2500ms;
    animation-timing-function: ${({
  theme
}) => theme.transitions.easing.easeInOut};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`;
const TouchRipple = /* @__PURE__ */ React.forwardRef(function TouchRipple2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTouchRipple"
  });
  const {
    center: centerProp = false,
    classes = {},
    className,
    ...other
  } = props;
  const [ripples, setRipples] = React.useState([]);
  const nextKey = React.useRef(0);
  const rippleCallback = React.useRef(null);
  React.useEffect(() => {
    if (rippleCallback.current) {
      rippleCallback.current();
      rippleCallback.current = null;
    }
  }, [ripples]);
  const ignoringMouseDown = React.useRef(false);
  const startTimer = useTimeout();
  const startTimerCommit = React.useRef(null);
  const container = React.useRef(null);
  const startCommit = React.useCallback((params) => {
    const {
      pulsate: pulsate2,
      rippleX,
      rippleY,
      rippleSize,
      cb
    } = params;
    setRipples((oldRipples) => [...oldRipples, /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRippleRipple, {
      classes: {
        ripple: clsx(classes.ripple, touchRippleClasses.ripple),
        rippleVisible: clsx(classes.rippleVisible, touchRippleClasses.rippleVisible),
        ripplePulsate: clsx(classes.ripplePulsate, touchRippleClasses.ripplePulsate),
        child: clsx(classes.child, touchRippleClasses.child),
        childLeaving: clsx(classes.childLeaving, touchRippleClasses.childLeaving),
        childPulsate: clsx(classes.childPulsate, touchRippleClasses.childPulsate)
      },
      timeout: DURATION,
      pulsate: pulsate2,
      rippleX,
      rippleY,
      rippleSize
    }, nextKey.current)]);
    nextKey.current += 1;
    rippleCallback.current = cb;
  }, [classes]);
  const start = React.useCallback((event = {}, options = {}, cb = () => {
  }) => {
    const {
      pulsate: pulsate2 = false,
      center = centerProp || options.pulsate,
      fakeElement = false
      // For test purposes
    } = options;
    if ((event == null ? void 0 : event.type) === "mousedown" && ignoringMouseDown.current) {
      ignoringMouseDown.current = false;
      return;
    }
    if ((event == null ? void 0 : event.type) === "touchstart") {
      ignoringMouseDown.current = true;
    }
    const element = fakeElement ? null : container.current;
    const rect = element ? element.getBoundingClientRect() : {
      width: 0,
      height: 0,
      left: 0,
      top: 0
    };
    let rippleX;
    let rippleY;
    let rippleSize;
    if (center || event === void 0 || event.clientX === 0 && event.clientY === 0 || !event.clientX && !event.touches) {
      rippleX = Math.round(rect.width / 2);
      rippleY = Math.round(rect.height / 2);
    } else {
      const {
        clientX,
        clientY
      } = event.touches && event.touches.length > 0 ? event.touches[0] : event;
      rippleX = Math.round(clientX - rect.left);
      rippleY = Math.round(clientY - rect.top);
    }
    if (center) {
      rippleSize = Math.sqrt((2 * rect.width ** 2 + rect.height ** 2) / 3);
      if (rippleSize % 2 === 0) {
        rippleSize += 1;
      }
    } else {
      const sizeX = Math.max(Math.abs((element ? element.clientWidth : 0) - rippleX), rippleX) * 2 + 2;
      const sizeY = Math.max(Math.abs((element ? element.clientHeight : 0) - rippleY), rippleY) * 2 + 2;
      rippleSize = Math.sqrt(sizeX ** 2 + sizeY ** 2);
    }
    if (event == null ? void 0 : event.touches) {
      if (startTimerCommit.current === null) {
        startTimerCommit.current = () => {
          startCommit({
            pulsate: pulsate2,
            rippleX,
            rippleY,
            rippleSize,
            cb
          });
        };
        startTimer.start(DELAY_RIPPLE, () => {
          if (startTimerCommit.current) {
            startTimerCommit.current();
            startTimerCommit.current = null;
          }
        });
      }
    } else {
      startCommit({
        pulsate: pulsate2,
        rippleX,
        rippleY,
        rippleSize,
        cb
      });
    }
  }, [centerProp, startCommit, startTimer]);
  const pulsate = React.useCallback(() => {
    start({}, {
      pulsate: true
    });
  }, [start]);
  const stop = React.useCallback((event, cb) => {
    startTimer.clear();
    if ((event == null ? void 0 : event.type) === "touchend" && startTimerCommit.current) {
      startTimerCommit.current();
      startTimerCommit.current = null;
      startTimer.start(0, () => {
        stop(event, cb);
      });
      return;
    }
    startTimerCommit.current = null;
    setRipples((oldRipples) => {
      if (oldRipples.length > 0) {
        return oldRipples.slice(1);
      }
      return oldRipples;
    });
    rippleCallback.current = cb;
  }, [startTimer]);
  React.useImperativeHandle(ref2, () => ({
    pulsate,
    start,
    stop
  }), [pulsate, start, stop]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRippleRoot, {
    className: clsx(touchRippleClasses.root, classes.root, className),
    ref: container,
    ...other,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionGroup$1, {
      component: null,
      exit: true,
      children: ripples
    })
  });
});
function getButtonBaseUtilityClass(slot) {
  return generateUtilityClass("MuiButtonBase", slot);
}
const buttonBaseClasses = generateUtilityClasses("MuiButtonBase", ["root", "disabled", "focusVisible"]);
const useUtilityClasses$9 = (ownerState) => {
  const {
    disabled,
    focusVisible,
    focusVisibleClassName,
    classes
  } = ownerState;
  const slots2 = {
    root: ["root", disabled && "disabled", focusVisible && "focusVisible"]
  };
  const composedClasses = composeClasses(slots2, getButtonBaseUtilityClass, classes);
  if (focusVisible && focusVisibleClassName) {
    composedClasses.root += ` ${focusVisibleClassName}`;
  }
  return composedClasses;
};
const ButtonBaseRoot = styled("button", {
  name: "MuiButtonBase",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  position: "relative",
  boxSizing: "border-box",
  WebkitTapHighlightColor: "transparent",
  backgroundColor: "transparent",
  // Reset default value
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  border: 0,
  margin: 0,
  // Remove the margin in Safari
  borderRadius: 0,
  padding: 0,
  // Remove the padding in Firefox
  cursor: "pointer",
  userSelect: "none",
  verticalAlign: "middle",
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // Reset
  textDecoration: "none",
  // So we take precedent over the style of a native <a /> element.
  color: "inherit",
  "&::-moz-focus-inner": {
    borderStyle: "none"
    // Remove Firefox dotted outline.
  },
  [`&.${buttonBaseClasses.disabled}`]: {
    pointerEvents: "none",
    // Disable link interactions
    cursor: "default"
  },
  "@media print": {
    colorAdjust: "exact"
  }
});
const ButtonBase = /* @__PURE__ */ React.forwardRef(function ButtonBase2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiButtonBase"
  });
  const {
    action,
    centerRipple = false,
    children,
    className,
    component = "button",
    disabled = false,
    disableRipple = false,
    disableTouchRipple = false,
    focusRipple = false,
    focusVisibleClassName,
    LinkComponent = "a",
    onBlur,
    onClick,
    onContextMenu,
    onDragLeave,
    onFocus,
    onFocusVisible,
    onKeyDown,
    onKeyUp,
    onMouseDown,
    onMouseLeave,
    onMouseUp,
    onTouchEnd,
    onTouchMove,
    onTouchStart,
    tabIndex = 0,
    TouchRippleProps,
    touchRippleRef,
    type,
    ...other
  } = props;
  const buttonRef = React.useRef(null);
  const ripple = useLazyRipple();
  const handleRippleRef = useForkRef$1(ripple.ref, touchRippleRef);
  const [focusVisible, setFocusVisible] = React.useState(false);
  if (disabled && focusVisible) {
    setFocusVisible(false);
  }
  React.useImperativeHandle(action, () => ({
    focusVisible: () => {
      setFocusVisible(true);
      buttonRef.current.focus();
    }
  }), []);
  const enableTouchRipple = ripple.shouldMount && !disableRipple && !disabled;
  React.useEffect(() => {
    if (focusVisible && focusRipple && !disableRipple) {
      ripple.pulsate();
    }
  }, [disableRipple, focusRipple, focusVisible, ripple]);
  const handleMouseDown = useRippleHandler(ripple, "start", onMouseDown, disableTouchRipple);
  const handleContextMenu = useRippleHandler(ripple, "stop", onContextMenu, disableTouchRipple);
  const handleDragLeave = useRippleHandler(ripple, "stop", onDragLeave, disableTouchRipple);
  const handleMouseUp = useRippleHandler(ripple, "stop", onMouseUp, disableTouchRipple);
  const handleMouseLeave = useRippleHandler(ripple, "stop", (event) => {
    if (focusVisible) {
      event.preventDefault();
    }
    if (onMouseLeave) {
      onMouseLeave(event);
    }
  }, disableTouchRipple);
  const handleTouchStart = useRippleHandler(ripple, "start", onTouchStart, disableTouchRipple);
  const handleTouchEnd = useRippleHandler(ripple, "stop", onTouchEnd, disableTouchRipple);
  const handleTouchMove = useRippleHandler(ripple, "stop", onTouchMove, disableTouchRipple);
  const handleBlur = useRippleHandler(ripple, "stop", (event) => {
    if (!isFocusVisible(event.target)) {
      setFocusVisible(false);
    }
    if (onBlur) {
      onBlur(event);
    }
  }, false);
  const handleFocus = useEventCallback((event) => {
    if (!buttonRef.current) {
      buttonRef.current = event.currentTarget;
    }
    if (isFocusVisible(event.target)) {
      setFocusVisible(true);
      if (onFocusVisible) {
        onFocusVisible(event);
      }
    }
    if (onFocus) {
      onFocus(event);
    }
  });
  const isNonNativeButton = () => {
    const button = buttonRef.current;
    return component && component !== "button" && !(button.tagName === "A" && button.href);
  };
  const handleKeyDown = useEventCallback((event) => {
    if (focusRipple && !event.repeat && focusVisible && event.key === " ") {
      ripple.stop(event, () => {
        ripple.start(event);
      });
    }
    if (event.target === event.currentTarget && isNonNativeButton() && event.key === " ") {
      event.preventDefault();
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
    if (event.target === event.currentTarget && isNonNativeButton() && event.key === "Enter" && !disabled) {
      event.preventDefault();
      if (onClick) {
        onClick(event);
      }
    }
  });
  const handleKeyUp = useEventCallback((event) => {
    if (focusRipple && event.key === " " && focusVisible && !event.defaultPrevented) {
      ripple.stop(event, () => {
        ripple.pulsate(event);
      });
    }
    if (onKeyUp) {
      onKeyUp(event);
    }
    if (onClick && event.target === event.currentTarget && isNonNativeButton() && event.key === " " && !event.defaultPrevented) {
      onClick(event);
    }
  });
  let ComponentProp = component;
  if (ComponentProp === "button" && (other.href || other.to)) {
    ComponentProp = LinkComponent;
  }
  const buttonProps = {};
  if (ComponentProp === "button") {
    buttonProps.type = type === void 0 ? "button" : type;
    buttonProps.disabled = disabled;
  } else {
    if (!other.href && !other.to) {
      buttonProps.role = "button";
    }
    if (disabled) {
      buttonProps["aria-disabled"] = disabled;
    }
  }
  const handleRef = useForkRef$1(ref2, buttonRef);
  const ownerState = {
    ...props,
    centerRipple,
    component,
    disabled,
    disableRipple,
    disableTouchRipple,
    focusRipple,
    tabIndex,
    focusVisible
  };
  const classes = useUtilityClasses$9(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ButtonBaseRoot, {
    as: ComponentProp,
    className: clsx(classes.root, className),
    ownerState,
    onBlur: handleBlur,
    onClick,
    onContextMenu: handleContextMenu,
    onFocus: handleFocus,
    onKeyDown: handleKeyDown,
    onKeyUp: handleKeyUp,
    onMouseDown: handleMouseDown,
    onMouseLeave: handleMouseLeave,
    onMouseUp: handleMouseUp,
    onDragLeave: handleDragLeave,
    onTouchEnd: handleTouchEnd,
    onTouchMove: handleTouchMove,
    onTouchStart: handleTouchStart,
    ref: handleRef,
    tabIndex: disabled ? -1 : tabIndex,
    type,
    ...buttonProps,
    ...other,
    children: [children, enableTouchRipple ? /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRipple, {
      ref: handleRippleRef,
      center: centerRipple,
      ...TouchRippleProps
    }) : null]
  });
});
function useRippleHandler(ripple, rippleAction, eventCallback, skipRippleAction = false) {
  return useEventCallback((event) => {
    if (eventCallback) {
      eventCallback(event);
    }
    if (!skipRippleAction) {
      ripple[rippleAction](event);
    }
    return true;
  });
}
function getDividerUtilityClass(slot) {
  return generateUtilityClass("MuiDivider", slot);
}
const dividerClasses = generateUtilityClasses("MuiDivider", ["root", "absolute", "fullWidth", "inset", "middle", "flexItem", "light", "vertical", "withChildren", "withChildrenVertical", "textAlignRight", "textAlignLeft", "wrapper", "wrapperVertical"]);
const useUtilityClasses$8 = (ownerState) => {
  const {
    absolute,
    children,
    classes,
    flexItem,
    light: light2,
    orientation,
    textAlign,
    variant
  } = ownerState;
  const slots2 = {
    root: ["root", absolute && "absolute", variant, light2 && "light", orientation === "vertical" && "vertical", flexItem && "flexItem", children && "withChildren", children && orientation === "vertical" && "withChildrenVertical", textAlign === "right" && orientation !== "vertical" && "textAlignRight", textAlign === "left" && orientation !== "vertical" && "textAlignLeft"],
    wrapper: ["wrapper", orientation === "vertical" && "wrapperVertical"]
  };
  return composeClasses(slots2, getDividerUtilityClass, classes);
};
const DividerRoot = styled("div", {
  name: "MuiDivider",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.absolute && styles2.absolute, styles2[ownerState.variant], ownerState.light && styles2.light, ownerState.orientation === "vertical" && styles2.vertical, ownerState.flexItem && styles2.flexItem, ownerState.children && styles2.withChildren, ownerState.children && ownerState.orientation === "vertical" && styles2.withChildrenVertical, ownerState.textAlign === "right" && ownerState.orientation !== "vertical" && styles2.textAlignRight, ownerState.textAlign === "left" && ownerState.orientation !== "vertical" && styles2.textAlignLeft];
  }
})(memoTheme(({
  theme
}) => ({
  margin: 0,
  // Reset browser default style.
  flexShrink: 0,
  borderWidth: 0,
  borderStyle: "solid",
  borderColor: (theme.vars || theme).palette.divider,
  borderBottomWidth: "thin",
  variants: [{
    props: {
      absolute: true
    },
    style: {
      position: "absolute",
      bottom: 0,
      left: 0,
      width: "100%"
    }
  }, {
    props: {
      light: true
    },
    style: {
      borderColor: theme.vars ? `rgba(${theme.vars.palette.dividerChannel} / 0.08)` : alpha(theme.palette.divider, 0.08)
    }
  }, {
    props: {
      variant: "inset"
    },
    style: {
      marginLeft: 72
    }
  }, {
    props: {
      variant: "middle",
      orientation: "horizontal"
    },
    style: {
      marginLeft: theme.spacing(2),
      marginRight: theme.spacing(2)
    }
  }, {
    props: {
      variant: "middle",
      orientation: "vertical"
    },
    style: {
      marginTop: theme.spacing(1),
      marginBottom: theme.spacing(1)
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      height: "100%",
      borderBottomWidth: 0,
      borderRightWidth: "thin"
    }
  }, {
    props: {
      flexItem: true
    },
    style: {
      alignSelf: "stretch",
      height: "auto"
    }
  }, {
    props: ({
      ownerState
    }) => !!ownerState.children,
    style: {
      display: "flex",
      textAlign: "center",
      border: 0,
      borderTopStyle: "solid",
      borderLeftStyle: "solid",
      "&::before, &::after": {
        content: '""',
        alignSelf: "center"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.children && ownerState.orientation !== "vertical",
    style: {
      "&::before, &::after": {
        width: "100%",
        borderTop: `thin solid ${(theme.vars || theme).palette.divider}`,
        borderTopStyle: "inherit"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.orientation === "vertical" && ownerState.children,
    style: {
      flexDirection: "column",
      "&::before, &::after": {
        height: "100%",
        borderLeft: `thin solid ${(theme.vars || theme).palette.divider}`,
        borderLeftStyle: "inherit"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.textAlign === "right" && ownerState.orientation !== "vertical",
    style: {
      "&::before": {
        width: "90%"
      },
      "&::after": {
        width: "10%"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.textAlign === "left" && ownerState.orientation !== "vertical",
    style: {
      "&::before": {
        width: "10%"
      },
      "&::after": {
        width: "90%"
      }
    }
  }]
})));
const DividerWrapper = styled("span", {
  name: "MuiDivider",
  slot: "Wrapper",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.wrapper, ownerState.orientation === "vertical" && styles2.wrapperVertical];
  }
})(memoTheme(({
  theme
}) => ({
  display: "inline-block",
  paddingLeft: `calc(${theme.spacing(1)} * 1.2)`,
  paddingRight: `calc(${theme.spacing(1)} * 1.2)`,
  whiteSpace: "nowrap",
  variants: [{
    props: {
      orientation: "vertical"
    },
    style: {
      paddingTop: `calc(${theme.spacing(1)} * 1.2)`,
      paddingBottom: `calc(${theme.spacing(1)} * 1.2)`
    }
  }]
})));
const Divider = /* @__PURE__ */ React.forwardRef(function Divider2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiDivider"
  });
  const {
    absolute = false,
    children,
    className,
    orientation = "horizontal",
    component = children || orientation === "vertical" ? "div" : "hr",
    flexItem = false,
    light: light2 = false,
    role = component !== "hr" ? "separator" : void 0,
    textAlign = "center",
    variant = "fullWidth",
    ...other
  } = props;
  const ownerState = {
    ...props,
    absolute,
    component,
    flexItem,
    light: light2,
    orientation,
    role,
    textAlign,
    variant
  };
  const classes = useUtilityClasses$8(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DividerRoot, {
    as: component,
    className: clsx(classes.root, className),
    role,
    ref: ref2,
    ownerState,
    "aria-orientation": role === "separator" && (component !== "hr" || orientation === "vertical") ? orientation : void 0,
    ...other,
    children: children ? /* @__PURE__ */ jsxRuntimeExports.jsx(DividerWrapper, {
      className: classes.wrapper,
      ownerState,
      children
    }) : null
  });
});
if (Divider) {
  Divider.muiSkipListHighlight = true;
}
const listItemIconClasses = generateUtilityClasses("MuiListItemIcon", ["root", "alignItemsFlexStart"]);
function hasCorrectMainProperty(obj) {
  return typeof obj.main === "string";
}
function checkSimplePaletteColorValues(obj, additionalPropertiesToCheck = []) {
  if (!hasCorrectMainProperty(obj)) {
    return false;
  }
  for (const value of additionalPropertiesToCheck) {
    if (!obj.hasOwnProperty(value) || typeof obj[value] !== "string") {
      return false;
    }
  }
  return true;
}
function createSimplePaletteValueFilter(additionalPropertiesToCheck = []) {
  return ([, value]) => value && checkSimplePaletteColorValues(value, additionalPropertiesToCheck);
}
const listItemTextClasses = generateUtilityClasses("MuiListItemText", ["root", "multiline", "dense", "inset", "primary", "secondary"]);
function getMenuItemUtilityClass(slot) {
  return generateUtilityClass("MuiMenuItem", slot);
}
const menuItemClasses = generateUtilityClasses("MuiMenuItem", ["root", "focusVisible", "dense", "disabled", "divider", "gutters", "selected"]);
const overridesResolver = (props, styles2) => {
  const {
    ownerState
  } = props;
  return [styles2.root, ownerState.dense && styles2.dense, ownerState.divider && styles2.divider, !ownerState.disableGutters && styles2.gutters];
};
const useUtilityClasses$7 = (ownerState) => {
  const {
    disabled,
    dense,
    divider,
    disableGutters,
    selected,
    classes
  } = ownerState;
  const slots2 = {
    root: ["root", dense && "dense", disabled && "disabled", !disableGutters && "gutters", divider && "divider", selected && "selected"]
  };
  const composedClasses = composeClasses(slots2, getMenuItemUtilityClass, classes);
  return {
    ...classes,
    ...composedClasses
  };
};
const MenuItemRoot = styled(ButtonBase, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiMenuItem",
  slot: "Root",
  overridesResolver
})(memoTheme(({
  theme
}) => ({
  ...theme.typography.body1,
  display: "flex",
  justifyContent: "flex-start",
  alignItems: "center",
  position: "relative",
  textDecoration: "none",
  minHeight: 48,
  paddingTop: 6,
  paddingBottom: 6,
  boxSizing: "border-box",
  whiteSpace: "nowrap",
  "&:hover": {
    textDecoration: "none",
    backgroundColor: (theme.vars || theme).palette.action.hover,
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  },
  [`&.${menuItemClasses.selected}`]: {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity),
    [`&.${menuItemClasses.focusVisible}`]: {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)
    }
  },
  [`&.${menuItemClasses.selected}:hover`]: {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.hoverOpacity}))` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity),
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity)
    }
  },
  [`&.${menuItemClasses.focusVisible}`]: {
    backgroundColor: (theme.vars || theme).palette.action.focus
  },
  [`&.${menuItemClasses.disabled}`]: {
    opacity: (theme.vars || theme).palette.action.disabledOpacity
  },
  [`& + .${dividerClasses.root}`]: {
    marginTop: theme.spacing(1),
    marginBottom: theme.spacing(1)
  },
  [`& + .${dividerClasses.inset}`]: {
    marginLeft: 52
  },
  [`& .${listItemTextClasses.root}`]: {
    marginTop: 0,
    marginBottom: 0
  },
  [`& .${listItemTextClasses.inset}`]: {
    paddingLeft: 36
  },
  [`& .${listItemIconClasses.root}`]: {
    minWidth: 36
  },
  variants: [{
    props: ({
      ownerState
    }) => !ownerState.disableGutters,
    style: {
      paddingLeft: 16,
      paddingRight: 16
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.divider,
    style: {
      borderBottom: `1px solid ${(theme.vars || theme).palette.divider}`,
      backgroundClip: "padding-box"
    }
  }, {
    props: ({
      ownerState
    }) => !ownerState.dense,
    style: {
      [theme.breakpoints.up("sm")]: {
        minHeight: "auto"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.dense,
    style: {
      minHeight: 32,
      // https://m2.material.io/components/menus#specs > Dense
      paddingTop: 4,
      paddingBottom: 4,
      ...theme.typography.body2,
      [`& .${listItemIconClasses.root} svg`]: {
        fontSize: "1.25rem"
      }
    }
  }]
})));
const MenuItem = /* @__PURE__ */ React.forwardRef(function MenuItem2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiMenuItem"
  });
  const {
    autoFocus = false,
    component = "li",
    dense = false,
    divider = false,
    disableGutters = false,
    focusVisibleClassName,
    role = "menuitem",
    tabIndex: tabIndexProp,
    className,
    ...other
  } = props;
  const context = React.useContext(ListContext);
  const childContext = React.useMemo(() => ({
    dense: dense || context.dense || false,
    disableGutters
  }), [context.dense, dense, disableGutters]);
  const menuItemRef = React.useRef(null);
  useEnhancedEffect(() => {
    if (autoFocus) {
      if (menuItemRef.current) {
        menuItemRef.current.focus();
      }
    }
  }, [autoFocus]);
  const ownerState = {
    ...props,
    dense: childContext.dense,
    divider,
    disableGutters
  };
  const classes = useUtilityClasses$7(props);
  const handleRef = useForkRef$1(menuItemRef, ref2);
  let tabIndex;
  if (!props.disabled) {
    tabIndex = tabIndexProp !== void 0 ? tabIndexProp : -1;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext.Provider, {
    value: childContext,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItemRoot, {
      ref: handleRef,
      role,
      tabIndex,
      component,
      focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),
      className: clsx(classes.root, className),
      ...other,
      ownerState,
      classes
    })
  });
});
function Menus({ items, position: position2, data, onClose }) {
  const isPositionByEl = position2 instanceof HTMLElement;
  const handleClick = (next2) => (ev) => {
    ev.preventDefault();
    onClose == null ? void 0 : onClose();
    next2 == null ? void 0 : next2(data);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Menu,
    {
      open: true,
      className: "rcw-menus",
      anchorReference: isPositionByEl ? "anchorEl" : "anchorPosition",
      anchorEl: isPositionByEl ? position2 : void 0,
      anchorPosition: isPositionByEl ? void 0 : { left: position2 == null ? void 0 : position2.x, top: position2 == null ? void 0 : position2.y },
      elevation: 1,
      onClose,
      children: items.map((item, i) => {
        if (item == "divider") {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(Divider, { sx: { my: 0.5 } }, i);
        }
        const { icon, label, onClick } = item;
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(MenuItem, { onClick: handleClick(onClick), children: [
          icon && /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: icon }),
          label
        ] }, i);
      })
    }
  );
}
const initialState$4 = {
  showChat: false,
  disabledInput: false,
  messageLoader: false
};
const state$5 = proxy(initialState$4);
function toggleChat() {
  state$5.showChat = !state$5.showChat;
}
function addToggleChatListener(f) {
  return subscribe(state$5, (changes) => {
    for (const [event, path, value] of changes) {
      if (event === "set" && path.includes("showChat")) {
        f(value);
      }
    }
  });
}
function toggleInputDisabled() {
  state$5.disabledInput = !state$5.disabledInput;
}
function toggleMsgLoader() {
  state$5.messageLoader = !state$5.messageLoader;
}
const initialState$3 = {
  quickButtons: []
};
const state$4 = proxy(initialState$3);
function setQuickButtons(buttons) {
  state$4.quickButtons = buttons.map((button) => createQuickButton(button));
}
var lodash$1 = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
var lodash = lodash$1.exports;
var hasRequiredLodash;
function requireLodash() {
  if (hasRequiredLodash) return lodash$1.exports;
  hasRequiredLodash = 1;
  (function(module, exports) {
    (function() {
      var undefined$1;
      var VERSION = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['’]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        // Latin-1 Supplement block.
        "À": "A",
        "Á": "A",
        "Â": "A",
        "Ã": "A",
        "Ä": "A",
        "Å": "A",
        "à": "a",
        "á": "a",
        "â": "a",
        "ã": "a",
        "ä": "a",
        "å": "a",
        "Ç": "C",
        "ç": "c",
        "Ð": "D",
        "ð": "d",
        "È": "E",
        "É": "E",
        "Ê": "E",
        "Ë": "E",
        "è": "e",
        "é": "e",
        "ê": "e",
        "ë": "e",
        "Ì": "I",
        "Í": "I",
        "Î": "I",
        "Ï": "I",
        "ì": "i",
        "í": "i",
        "î": "i",
        "ï": "i",
        "Ñ": "N",
        "ñ": "n",
        "Ò": "O",
        "Ó": "O",
        "Ô": "O",
        "Õ": "O",
        "Ö": "O",
        "Ø": "O",
        "ò": "o",
        "ó": "o",
        "ô": "o",
        "õ": "o",
        "ö": "o",
        "ø": "o",
        "Ù": "U",
        "Ú": "U",
        "Û": "U",
        "Ü": "U",
        "ù": "u",
        "ú": "u",
        "û": "u",
        "ü": "u",
        "Ý": "Y",
        "ý": "y",
        "ÿ": "y",
        "Æ": "Ae",
        "æ": "ae",
        "Þ": "Th",
        "þ": "th",
        "ß": "ss",
        // Latin Extended-A block.
        "Ā": "A",
        "Ă": "A",
        "Ą": "A",
        "ā": "a",
        "ă": "a",
        "ą": "a",
        "Ć": "C",
        "Ĉ": "C",
        "Ċ": "C",
        "Č": "C",
        "ć": "c",
        "ĉ": "c",
        "ċ": "c",
        "č": "c",
        "Ď": "D",
        "Đ": "D",
        "ď": "d",
        "đ": "d",
        "Ē": "E",
        "Ĕ": "E",
        "Ė": "E",
        "Ę": "E",
        "Ě": "E",
        "ē": "e",
        "ĕ": "e",
        "ė": "e",
        "ę": "e",
        "ě": "e",
        "Ĝ": "G",
        "Ğ": "G",
        "Ġ": "G",
        "Ģ": "G",
        "ĝ": "g",
        "ğ": "g",
        "ġ": "g",
        "ģ": "g",
        "Ĥ": "H",
        "Ħ": "H",
        "ĥ": "h",
        "ħ": "h",
        "Ĩ": "I",
        "Ī": "I",
        "Ĭ": "I",
        "Į": "I",
        "İ": "I",
        "ĩ": "i",
        "ī": "i",
        "ĭ": "i",
        "į": "i",
        "ı": "i",
        "Ĵ": "J",
        "ĵ": "j",
        "Ķ": "K",
        "ķ": "k",
        "ĸ": "k",
        "Ĺ": "L",
        "Ļ": "L",
        "Ľ": "L",
        "Ŀ": "L",
        "Ł": "L",
        "ĺ": "l",
        "ļ": "l",
        "ľ": "l",
        "ŀ": "l",
        "ł": "l",
        "Ń": "N",
        "Ņ": "N",
        "Ň": "N",
        "Ŋ": "N",
        "ń": "n",
        "ņ": "n",
        "ň": "n",
        "ŋ": "n",
        "Ō": "O",
        "Ŏ": "O",
        "Ő": "O",
        "ō": "o",
        "ŏ": "o",
        "ő": "o",
        "Ŕ": "R",
        "Ŗ": "R",
        "Ř": "R",
        "ŕ": "r",
        "ŗ": "r",
        "ř": "r",
        "Ś": "S",
        "Ŝ": "S",
        "Ş": "S",
        "Š": "S",
        "ś": "s",
        "ŝ": "s",
        "ş": "s",
        "š": "s",
        "Ţ": "T",
        "Ť": "T",
        "Ŧ": "T",
        "ţ": "t",
        "ť": "t",
        "ŧ": "t",
        "Ũ": "U",
        "Ū": "U",
        "Ŭ": "U",
        "Ů": "U",
        "Ű": "U",
        "Ų": "U",
        "ũ": "u",
        "ū": "u",
        "ŭ": "u",
        "ů": "u",
        "ű": "u",
        "ų": "u",
        "Ŵ": "W",
        "ŵ": "w",
        "Ŷ": "Y",
        "ŷ": "y",
        "Ÿ": "Y",
        "Ź": "Z",
        "Ż": "Z",
        "Ž": "Z",
        "ź": "z",
        "ż": "z",
        "ž": "z",
        "Ĳ": "IJ",
        "ĳ": "ij",
        "Œ": "Oe",
        "œ": "oe",
        "ŉ": "'n",
        "ſ": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = exports && !exports.nodeType && exports;
      var freeModule = freeExports && true && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1, length2 = array == null ? 0 : array.length;
        while (++index < length2) {
          var value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function arrayEach(array, iteratee) {
        var index = -1, length2 = array == null ? 0 : array.length;
        while (++index < length2) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEachRight(array, iteratee) {
        var length2 = array == null ? 0 : array.length;
        while (length2--) {
          if (iteratee(array[length2], length2, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEvery(array, predicate) {
        var index = -1, length2 = array == null ? 0 : array.length;
        while (++index < length2) {
          if (!predicate(array[index], index, array)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array, predicate) {
        var index = -1, length2 = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length2) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array, value) {
        var length2 = array == null ? 0 : array.length;
        return !!length2 && baseIndexOf(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        var index = -1, length2 = array == null ? 0 : array.length;
        while (++index < length2) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array, iteratee) {
        var index = -1, length2 = array == null ? 0 : array.length, result = Array(length2);
        while (++index < length2) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      function arrayPush(array, values2) {
        var index = -1, length2 = values2.length, offset = array.length;
        while (++index < length2) {
          array[offset + index] = values2[index];
        }
        return array;
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length2 = array == null ? 0 : array.length;
        if (initAccum && length2) {
          accumulator = array[++index];
        }
        while (++index < length2) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length2 = array == null ? 0 : array.length;
        if (initAccum && length2) {
          accumulator = array[--length2];
        }
        while (length2--) {
          accumulator = iteratee(accumulator, array[length2], length2, array);
        }
        return accumulator;
      }
      function arraySome(array, predicate) {
        var index = -1, length2 = array == null ? 0 : array.length;
        while (++index < length2) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string) {
        return string.split("");
      }
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length2 = array.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length2) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1, length2 = array.length;
        while (++index < length2) {
          if (comparator(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array, iteratee) {
        var length2 = array == null ? 0 : array.length;
        return length2 ? baseSum(array, iteratee) / length2 : NAN;
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined$1 : object[key];
        };
      }
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined$1 : object[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array, comparer) {
        var length2 = array.length;
        array.sort(comparer);
        while (length2--) {
          array[length2] = array[length2].value;
        }
        return array;
      }
      function baseSum(array, iteratee) {
        var result, index = -1, length2 = array.length;
        while (++index < length2) {
          var current = iteratee(array[index]);
          if (current !== undefined$1) {
            result = result === undefined$1 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1, length2 = strSymbols.length;
        while (++index < length2 && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function countHolders(array, placeholder) {
        var length2 = array.length, result = 0;
        while (length2--) {
          if (array[length2] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue2(object, key) {
        return object == null ? undefined$1 : object[key];
      }
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }
      function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray(map2) {
        var index = -1, result = Array(map2.size);
        map2.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function overArg(func, transform) {
        return function(arg2) {
          return func(transform(arg2));
        };
      }
      function replaceHolders(array, placeholder) {
        var index = -1, length2 = array.length, resIndex = 0, result = [];
        while (++index < length2) {
          var value = array[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }
      function setToArray(set2) {
        var index = -1, result = Array(set2.size);
        set2.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      function setToPairs(set2) {
        var index = -1, result = Array(set2.size);
        set2.forEach(function(value) {
          result[++index] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1, length2 = array.length;
        while (++index < length2) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array, value, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array[index] === value) {
            return index;
          }
        }
        return index;
      }
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      function trimmedEndIndex(string) {
        var index = string.length;
        while (index-- && reWhitespace.test(string.charAt(index))) {
        }
        return index;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root : _2.defaults(root.Object(), context, _2.pick(root, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root._;
        var reIsNative = RegExp2(
          "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer2 = moduleExports ? context.Buffer : undefined$1, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined$1, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined$1, symIterator = Symbol2 ? Symbol2.iterator : undefined$1, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined$1;
        var defineProperty = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined$1, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap2 && new WeakMap2();
        var realNames = {};
        var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined$1, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1, symbolToString = symbolProto ? symbolProto.toString : undefined$1;
        function lodash2(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = /* @__PURE__ */ function() {
          function object() {
          }
          return function(proto) {
            if (!isObject2(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result2 = new object();
            object.prototype = undefined$1;
            return result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined$1;
        }
        lodash2.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "escape": reEscape,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "evaluate": reEvaluate,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "interpolate": reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          "variable": "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          "imports": {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            "_": lodash2
          }
        };
        lodash2.prototype = baseLodash.prototype;
        lodash2.prototype.constructor = lodash2;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length2 = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length2, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length2 && takeCount == length2) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length2-- && resIndex < takeCount) {
              index += dir;
              var iterIndex = -1, value = array[index];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index = -1, length2 = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length2) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED ? undefined$1 : result2;
          }
          return hasOwnProperty.call(data, key) ? data[key] : undefined$1;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined$1 : hasOwnProperty.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined$1 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1, length2 = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length2) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          return index < 0 ? undefined$1 : data[index][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1, length2 = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length2) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size2 = data.size;
          data.set(key, value);
          this.size += data.size == size2 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values3) {
          var index = -1, length2 = values3 == null ? 0 : values3.length;
          this.__data__ = new MapCache();
          while (++index < length2) {
            this.add(values3[index]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__, result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length2 = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex(key, length2)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array) {
          var length2 = array.length;
          return length2 ? array[baseRandom(0, length2 - 1)] : undefined$1;
        }
        function arraySampleSize(array, n) {
          return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }
        function assignMergeValue(object, key, value) {
          if (value !== undefined$1 && !eq(object[key], value) || value === undefined$1 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined$1 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assocIndexOf(array, key) {
          var length2 = array.length;
          while (length2--) {
            if (eq(array[length2][0], key)) {
              return length2;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object[key] = value;
          }
        }
        function baseAt(object, paths) {
          var index = -1, length2 = paths.length, result2 = Array2(length2), skip = object == null;
          while (++index < length2) {
            result2[index] = skip ? undefined$1 : get(object, paths[index]);
          }
          return result2;
        }
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined$1) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined$1) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result2 !== undefined$1) {
            return result2;
          }
          if (!isObject2(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
          var props = isArr ? undefined$1 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        function baseConformsTo(object, source, props) {
          var length2 = props.length;
          if (object == null) {
            return !length2;
          }
          object = Object2(object);
          while (length2--) {
            var key = props[length2], predicate = source[key], value = object[key];
            if (value === undefined$1 && !(key in object) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined$1, args);
          }, wait);
        }
        function baseDifference(array, values3, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, isCommon = true, length2 = array.length, result2 = [], valuesLength = values3.length;
          if (!length2) {
            return result2;
          }
          if (iteratee2) {
            values3 = arrayMap(values3, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values3.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values3 = new SetCache(values3);
          }
          outer:
            while (++index < length2) {
              var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values3[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes2(values3, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index, collection2) {
            result2 = !!predicate(value, index, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array, iteratee2, comparator) {
          var index = -1, length2 = array.length;
          while (++index < length2) {
            var value = array[index], current = iteratee2(value);
            if (current != null && (computed === undefined$1 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array, value, start, end) {
          var length2 = array.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length2 ? 0 : length2 + start;
          }
          end = end === undefined$1 || end > length2 ? length2 : toInteger(end);
          if (end < 0) {
            end += length2;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array[start++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index, collection2) {
            if (predicate(value, index, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array, depth, predicate, isStrict, result2) {
          var index = -1, length2 = array.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index < length2) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction2(object[key]);
          });
        }
        function baseGet(object, path) {
          path = castPath(path, object);
          var index = 0, length2 = path.length;
          while (object != null && index < length2) {
            object = object[toKey(path[index++])];
          }
          return index && index == length2 ? object : undefined$1;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined$1 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty.call(object, key);
        }
        function baseHasIn(object, key) {
          return object != null && key in Object2(object);
        }
        function baseInRange(number, start, end) {
          return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length2 = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee2) {
              array = arrayMap(array, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length2 >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined$1;
          }
          array = arrays[0];
          var index = -1, seen = caches[0];
          outer:
            while (++index < length2 && result2.length < maxLength) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function(value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2);
          });
          return accumulator;
        }
        function baseInvoke(object, path, args) {
          path = castPath(path, object);
          object = parent(object, path);
          var func = object == null ? object : object[toKey(last(path))];
          return func == null ? undefined$1 : apply(func, object, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index = matchData.length, length2 = index, noCustomizer = !customizer;
          if (object == null) {
            return !length2;
          }
          object = Object2(object);
          while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index < length2) {
            data = matchData[index];
            var key = data[0], objValue = object[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined$1 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result2 === undefined$1 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject2(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == "object") {
            return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result2 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty.call(object, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object) {
          if (!isObject2(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object), result2 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object) {
            var objValue = get(object, path);
            return objValue === undefined$1 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject2(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined$1;
              if (newValue === undefined$1) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined$1;
          var isCommon = newValue === undefined$1;
          if (isCommon) {
            var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject2(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject2(objValue) || isFunction2(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        function baseNth(array, n) {
          var length2 = array.length;
          if (!length2) {
            return;
          }
          n += n < 0 ? length2 : 0;
          return isIndex(n, length2) ? array[n] : undefined$1;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity];
          }
          var index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index, "value": value };
          });
          return baseSortBy(result2, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path) {
            return hasIn(object, path);
          });
        }
        function basePickBy(object, paths, predicate) {
          var index = -1, length2 = paths.length, result2 = {};
          while (++index < length2) {
            var path = paths[index], value = baseGet(object, path);
            if (predicate(value, path)) {
              baseSet(result2, castPath(path, object), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path) {
          return function(object) {
            return baseGet(object, path);
          };
        }
        function basePullAll(array, values3, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length2 = values3.length, seen = array;
          if (array === values3) {
            values3 = copyArray(values3);
          }
          if (iteratee2) {
            seen = arrayMap(array, baseUnary(iteratee2));
          }
          while (++index < length2) {
            var fromIndex = 0, value = values3[index], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function basePullAt(array, indexes) {
          var length2 = array ? indexes.length : 0, lastIndex = length2 - 1;
          while (length2--) {
            var index = indexes[length2];
            if (length2 == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex(index)) {
                splice.call(array, index, 1);
              } else {
                baseUnset(array, index);
              }
            }
          }
          return array;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
          var index = -1, length2 = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length2);
          while (length2--) {
            result2[fromRight ? length2 : ++index] = start;
            start += step;
          }
          return result2;
        }
        function baseRepeat(string, n) {
          var result2 = "";
          if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n % 2) {
              result2 += string;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string += string;
            }
          } while (n);
          return result2;
        }
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity), func + "");
        }
        function baseSample(collection) {
          return arraySample(values2(collection));
        }
        function baseSampleSize(collection, n) {
          var array = values2(collection);
          return shuffleSelf(array, baseClamp(n, 0, array.length));
        }
        function baseSet(object, path, value, customizer) {
          if (!isObject2(object)) {
            return object;
          }
          path = castPath(path, object);
          var index = -1, length2 = path.length, lastIndex = length2 - 1, nested = object;
          while (nested != null && ++index < length2) {
            var key = toKey(path[index]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
              if (newValue === undefined$1) {
                newValue = isObject2(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        var baseSetToString = !defineProperty ? identity : function(func, string) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values2(collection));
        }
        function baseSlice(array, start, end) {
          var index = -1, length2 = array.length;
          if (start < 0) {
            start = -start > length2 ? 0 : length2 + start;
          }
          end = end > length2 ? length2 : end;
          if (end < 0) {
            end += length2;
          }
          length2 = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result2 = Array2(length2);
          while (++index < length2) {
            result2[index] = array[index + start];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index, collection2) {
            result2 = predicate(value, index, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0, high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0, high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined$1;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined$1, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee2) {
          var index = -1, length2 = array.length, resIndex = 0, result2 = [];
          while (++index < length2) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            if (!index || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, length2 = array.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length2 >= LARGE_ARRAY_SIZE) {
            var set3 = iteratee2 ? null : createSet(array);
            if (set3) {
              return setToArray(set3);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index < length2) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset(object, path) {
          path = castPath(path, object);
          object = parent(object, path);
          return object == null || delete object[toKey(last(path))];
        }
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length2 = array.length, index = fromRight ? length2 : -1;
          while ((fromRight ? index-- : ++index < length2) && predicate(array[index], index, array)) {
          }
          return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length2) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length2 : index);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length2 = arrays.length;
          if (length2 < 2) {
            return length2 ? baseUniq(arrays[0]) : [];
          }
          var index = -1, result2 = Array2(length2);
          while (++index < length2) {
            var array = arrays[index], othIndex = -1;
            while (++othIndex < length2) {
              if (othIndex != index) {
                result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values3, assignFunc) {
          var index = -1, length2 = props.length, valsLength = values3.length, result2 = {};
          while (++index < length2) {
            var value = index < valsLength ? values3[index] : undefined$1;
            assignFunc(result2, props[index], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity;
        }
        function castPath(value, object) {
          if (isArray(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString(value));
        }
        var castRest = baseRest;
        function castSlice(array, start, end) {
          var length2 = array.length;
          end = end === undefined$1 ? length2 : end;
          return !start && end >= length2 ? array : baseSlice(array, start, end);
        }
        var clearTimeout2 = ctxClearTimeout || function(id) {
          return root.clearTimeout(id);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length2 = buffer.length, result2 = allocUnsafe ? allocUnsafe(length2) : new buffer.constructor(length2);
          buffer.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined$1, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined$1, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length2 = objCriteria.length, ordersLength = orders.length;
          while (++index < length2) {
            var result2 = compareAscending(objCriteria[index], othCriteria[index]);
            if (result2) {
              if (index >= ordersLength) {
                return result2;
              }
              var order = orders[index];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array) {
          var index = -1, length2 = source.length;
          array || (array = Array2(length2));
          while (++index < length2) {
            array[index] = source[index];
          }
          return array;
        }
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index = -1, length2 = props.length;
          while (++index < length2) {
            var key = props[index];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined$1;
            if (newValue === undefined$1) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index = -1, length2 = sources.length, customizer = length2 > 1 ? sources[length2 - 1] : undefined$1, guard = length2 > 2 ? sources[2] : undefined$1;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length2--, customizer) : undefined$1;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length2 < 3 ? undefined$1 : customizer;
              length2 = 1;
            }
            object = Object2(object);
            while (++index < length2) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length2 = collection.length, index = fromRight ? length2 : -1, iterable = Object2(collection);
            while (fromRight ? index-- : ++index < length2) {
              if (iteratee2(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index = -1, iterable = Object2(object), props = keysFunc(object), length2 = props.length;
            while (length2--) {
              var key = props[fromRight ? length2 : ++index];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper2() {
            var fn = this && this !== root && this instanceof wrapper2 ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper2;
        }
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString(string);
            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined$1;
            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject2(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper2() {
            var length2 = arguments.length, args = Array2(length2), index = length2, placeholder = getHolder(wrapper2);
            while (index--) {
              args[index] = arguments[index];
            }
            var holders = length2 < 3 && args[0] !== placeholder && args[length2 - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length2 -= holders.length;
            if (length2 < arity) {
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper2.placeholder,
                undefined$1,
                args,
                holders,
                undefined$1,
                undefined$1,
                arity - length2
              );
            }
            var fn = this && this !== root && this instanceof wrapper2 ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper2;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined$1;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length2 = funcs.length, index = length2, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper2 && getFuncName(func) == "wrapper") {
                var wrapper2 = new LodashWrapper([], true);
              }
            }
            index = wrapper2 ? index : length2;
            while (++index < length2) {
              func = funcs[index];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined$1;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper2 = wrapper2[getFuncName(data[0])].apply(wrapper2, data[3]);
              } else {
                wrapper2 = func.length == 1 && isLaziable(func) ? wrapper2[funcName]() : wrapper2.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper2 && args.length == 1 && isArray(value)) {
                return wrapper2.plant(value).value();
              }
              var index2 = 0, result2 = length2 ? funcs[index2].apply(this, args) : value;
              while (++index2 < length2) {
                result2 = funcs[index2].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$1 : createCtor(func);
          function wrapper2() {
            var length2 = arguments.length, args = Array2(length2), index = length2;
            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper2), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length2 -= holdersCount;
            if (isCurried && length2 < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper2.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length2
              );
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length2 = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length2 > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length2) {
              args.length = ary2;
            }
            if (this && this !== root && this instanceof wrapper2) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper2;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined$1 && other === undefined$1) {
              return defaultValue;
            }
            if (value !== undefined$1) {
              result2 = value;
            }
            if (other !== undefined$1) {
              if (result2 === undefined$1) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length2, chars) {
          chars = chars === undefined$1 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length2) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length2 / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length2).join("") : result2.slice(0, length2);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper2() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper2 ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper2;
        }
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
              end = step = undefined$1;
            }
            start = toFinite(start);
            if (end === undefined$1) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined$1 ? start < end ? 1 : -1 : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$1, newHoldersRight = isCurry ? undefined$1 : holders, newPartials = isCurry ? partials : undefined$1, newPartialsRight = isCurry ? undefined$1 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined$1, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number, precision) {
            number = toNumber(number);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number)) {
              var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop2 : function(values3) {
          return new Set2(values3);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length2 = partials ? partials.length : 0;
          if (!length2) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined$1;
          }
          ary2 = ary2 === undefined$1 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined$1 ? arity : toInteger(arity);
          length2 -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined$1;
          }
          var data = isBindKey ? undefined$1 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined$1 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length2, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined$1, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined$1 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject2(objValue) && isObject2(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject2(value) ? undefined$1 : value;
        }
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined$1;
          stack.set(array, other);
          stack.set(other, array);
          while (++index < arrLength) {
            var arrValue = array[index], othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined$1) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined$1 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined$1, flatten), func + "");
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop2 : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array = realNames[result2], length2 = hasOwnProperty.call(realNames, result2) ? array.length : 0;
          while (length2--) {
            var data = array[length2], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object = hasOwnProperty.call(lodash2, "placeholder") ? lodash2 : func;
          return object.placeholder;
        }
        function getIteratee() {
          var result2 = lodash2.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map3, key) {
          var data = map3.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object) {
          var result2 = keys(object), length2 = result2.length;
          while (length2--) {
            var key = result2[length2], value = object[key];
            result2[length2] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object, key) {
          var value = getValue2(object, key);
          return baseIsNative(value) ? value : undefined$1;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined$1;
            var unmasked = true;
          } catch (e) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result2 = [];
          while (object) {
            arrayPush(result2, getSymbols(object));
            object = getPrototype(object);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
          getTag = function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined$1, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start, end, transforms) {
          var index = -1, length2 = transforms.length;
          while (++index < length2) {
            var data = transforms[index], size2 = data.size;
            switch (data.type) {
              case "drop":
                start += size2;
                break;
              case "dropRight":
                end -= size2;
                break;
              case "take":
                end = nativeMin(end, start + size2);
                break;
              case "takeRight":
                start = nativeMax(start, end - size2);
                break;
            }
          }
          return { "start": start, "end": end };
        }
        function getWrapDetails(source) {
          var match3 = source.match(reWrapDetails);
          return match3 ? match3[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);
          var index = -1, length2 = path.length, result2 = false;
          while (++index < length2) {
            var key = toKey(path[index]);
            if (!(result2 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result2 || ++index != length2) {
            return result2;
          }
          length2 = object == null ? 0 : object.length;
          return !!length2 && isLength(length2) && isIndex(key, length2) && (isArray(object) || isArguments(object));
        }
        function initCloneArray(array) {
          var length2 = array.length, result2 = new array.constructor(length2);
          if (length2 && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
            result2.index = array.index;
            result2.input = array.input;
          }
          return result2;
        }
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function insertWrapDetails(source, details) {
          var length2 = details.length;
          if (!length2) {
            return source;
          }
          var lastIndex = length2 - 1;
          details[lastIndex] = (length2 > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length2 > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length2) {
          var type = typeof value;
          length2 = length2 == null ? MAX_SAFE_INTEGER : length2;
          return !!length2 && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
        }
        function isIterateeCall(value, index, object) {
          if (!isObject2(object)) {
            return false;
          }
          var type = typeof index;
          if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
            return eq(object[index], value);
          }
          return false;
        }
        function isKey(value, object) {
          if (isArray(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
        }
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash2[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction2 : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject2(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined$1 || key in Object2(object));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize2(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result2.cache;
          return result2;
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn(object) {
          var result2 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start, transform2) {
          start = nativeMax(start === undefined$1 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index = -1, length2 = nativeMax(args.length - start, 0), array = Array2(length2);
            while (++index < length2) {
              array[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array2(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform2(array);
            return apply(func, this, otherArgs);
          };
        }
        function parent(object, path) {
          return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }
        function reorder(array, indexes) {
          var arrLength = array.length, length2 = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
          while (length2--) {
            var index = indexes[length2];
            array[length2] = isIndex(index, arrLength) ? oldArray[index] : undefined$1;
          }
          return array;
        }
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait) {
          return root.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper2, reference2, bitmask) {
          var source = reference2 + "";
          return setToString(wrapper2, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined$1, arguments);
          };
        }
        function shuffleSelf(array, size2) {
          var index = -1, length2 = array.length, lastIndex = length2 - 1;
          size2 = size2 === undefined$1 ? length2 : size2;
          while (++index < size2) {
            var rand = baseRandom(index, lastIndex), value = array[rand];
            array[rand] = array[index];
            array[index] = value;
          }
          array.length = size2;
          return array;
        }
        var stringToPath = memoizeCapped(function(string) {
          var result2 = [];
          if (string.charCodeAt(0) === 46) {
            result2.push("");
          }
          string.replace(rePropName, function(match3, number, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match3);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper2) {
          if (wrapper2 instanceof LazyWrapper) {
            return wrapper2.clone();
          }
          var result2 = new LodashWrapper(wrapper2.__wrapped__, wrapper2.__chain__);
          result2.__actions__ = copyArray(wrapper2.__actions__);
          result2.__index__ = wrapper2.__index__;
          result2.__values__ = wrapper2.__values__;
          return result2;
        }
        function chunk(array, size2, guard) {
          if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined$1) {
            size2 = 1;
          } else {
            size2 = nativeMax(toInteger(size2), 0);
          }
          var length2 = array == null ? 0 : array.length;
          if (!length2 || size2 < 1) {
            return [];
          }
          var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length2 / size2));
          while (index < length2) {
            result2[resIndex++] = baseSlice(array, index, index += size2);
          }
          return result2;
        }
        function compact(array) {
          var index = -1, length2 = array == null ? 0 : array.length, resIndex = 0, result2 = [];
          while (++index < length2) {
            var value = array[index];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat() {
          var length2 = arguments.length;
          if (!length2) {
            return [];
          }
          var args = Array2(length2 - 1), array = arguments[0], index = length2;
          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array, values3) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values3, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array, values3) {
          var iteratee2 = last(values3);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined$1;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values3, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array, values3) {
          var comparator = last(values3);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined$1;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values3, 1, isArrayLikeObject, true), undefined$1, comparator) : [];
        });
        function drop(array, n, guard) {
          var length2 = array == null ? 0 : array.length;
          if (!length2) {
            return [];
          }
          n = guard || n === undefined$1 ? 1 : toInteger(n);
          return baseSlice(array, n < 0 ? 0 : n, length2);
        }
        function dropRight(array, n, guard) {
          var length2 = array == null ? 0 : array.length;
          if (!length2) {
            return [];
          }
          n = guard || n === undefined$1 ? 1 : toInteger(n);
          n = length2 - n;
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        function fill(array, value, start, end) {
          var length2 = array == null ? 0 : array.length;
          if (!length2) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
            start = 0;
            end = length2;
          }
          return baseFill(array, value, start, end);
        }
        function findIndex2(array, predicate, fromIndex) {
          var length2 = array == null ? 0 : array.length;
          if (!length2) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length2 + index, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index);
        }
        function findLastIndex(array, predicate, fromIndex) {
          var length2 = array == null ? 0 : array.length;
          if (!length2) {
            return -1;
          }
          var index = length2 - 1;
          if (fromIndex !== undefined$1) {
            index = toInteger(fromIndex);
            index = fromIndex < 0 ? nativeMax(length2 + index, 0) : nativeMin(index, length2 - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index, true);
        }
        function flatten(array) {
          var length2 = array == null ? 0 : array.length;
          return length2 ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
          var length2 = array == null ? 0 : array.length;
          return length2 ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
          var length2 = array == null ? 0 : array.length;
          if (!length2) {
            return [];
          }
          depth = depth === undefined$1 ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }
        function fromPairs(pairs) {
          var index = -1, length2 = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index < length2) {
            var pair = pairs[index];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array) {
          return array && array.length ? array[0] : undefined$1;
        }
        function indexOf(array, value, fromIndex) {
          var length2 = array == null ? 0 : array.length;
          if (!length2) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length2 + index, 0);
          }
          return baseIndexOf(array, value, index);
        }
        function initial(array) {
          var length2 = array == null ? 0 : array.length;
          return length2 ? baseSlice(array, 0, -1) : [];
        }
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined$1;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined$1;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$1, comparator) : [];
        });
        function join(array, separator) {
          return array == null ? "" : nativeJoin.call(array, separator);
        }
        function last(array) {
          var length2 = array == null ? 0 : array.length;
          return length2 ? array[length2 - 1] : undefined$1;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length2 = array == null ? 0 : array.length;
          if (!length2) {
            return -1;
          }
          var index = length2;
          if (fromIndex !== undefined$1) {
            index = toInteger(fromIndex);
            index = index < 0 ? nativeMax(length2 + index, 0) : nativeMin(index, length2 - 1);
          }
          return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
        }
        function nth(array, n) {
          return array && array.length ? baseNth(array, toInteger(n)) : undefined$1;
        }
        var pull = baseRest(pullAll);
        function pullAll(array, values3) {
          return array && array.length && values3 && values3.length ? basePullAll(array, values3) : array;
        }
        function pullAllBy(array, values3, iteratee2) {
          return array && array.length && values3 && values3.length ? basePullAll(array, values3, getIteratee(iteratee2, 2)) : array;
        }
        function pullAllWith(array, values3, comparator) {
          return array && array.length && values3 && values3.length ? basePullAll(array, values3, undefined$1, comparator) : array;
        }
        var pullAt = flatRest(function(array, indexes) {
          var length2 = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
          basePullAt(array, arrayMap(indexes, function(index) {
            return isIndex(index, length2) ? +index : index;
          }).sort(compareAscending));
          return result2;
        });
        function remove(array, predicate) {
          var result2 = [];
          if (!(array && array.length)) {
            return result2;
          }
          var index = -1, indexes = [], length2 = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index < length2) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result2.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result2;
        }
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        function slice2(array, start, end) {
          var length2 = array == null ? 0 : array.length;
          if (!length2) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
            start = 0;
            end = length2;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined$1 ? length2 : toInteger(end);
          }
          return baseSlice(array, start, end);
        }
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array, value) {
          var length2 = array == null ? 0 : array.length;
          if (length2) {
            var index = baseSortedIndex(array, value);
            if (index < length2 && eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array, value) {
          var length2 = array == null ? 0 : array.length;
          if (length2) {
            var index = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array) {
          var length2 = array == null ? 0 : array.length;
          return length2 ? baseSlice(array, 1, length2) : [];
        }
        function take(array, n, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n = guard || n === undefined$1 ? 1 : toInteger(n);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
          var length2 = array == null ? 0 : array.length;
          if (!length2) {
            return [];
          }
          n = guard || n === undefined$1 ? 1 : toInteger(n);
          n = length2 - n;
          return baseSlice(array, n < 0 ? 0 : n, length2);
        }
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined$1;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined$1;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$1, comparator);
        });
        function uniq(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee2) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined$1;
          return array && array.length ? baseUniq(array, undefined$1, comparator) : [];
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length2 = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length2 = nativeMax(group.length, length2);
              return true;
            }
          });
          return baseTimes(length2, function(index) {
            return arrayMap(array, baseProperty(index));
          });
        }
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return [];
          }
          var result2 = unzip(array);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply(iteratee2, undefined$1, group);
          });
        }
        var without = baseRest(function(array, values3) {
          return isArrayLikeObject(array) ? baseDifference(array, values3) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined$1;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined$1;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values3) {
          return baseZipObject(props || [], values3 || [], assignValue);
        }
        function zipObjectDeep(props, values3) {
          return baseZipObject(props || [], values3 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length2 = arrays.length, iteratee2 = length2 > 1 ? arrays[length2 - 1] : undefined$1;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$1;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash2(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length2 = paths.length, start = length2 ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
            return baseAt(object, paths);
          };
          if (length2 > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length2 ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined$1
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length2 && !array.length) {
              array.push(undefined$1);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined$1) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined$1 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone2 = wrapperClone(parent2);
            clone2.__index__ = 0;
            clone2.__values__ = undefined$1;
            if (result2) {
              previous.__wrapped__ = clone2;
            } else {
              result2 = clone2;
            }
            var previous = clone2;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined$1
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined$1;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find = createFind(findIndex2);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map2(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map2(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined$1 ? 1 : toInteger(depth);
          return baseFlatten(map2(collection, iteratee2), depth);
        }
        function forEach(collection, iteratee2) {
          var func = isArray(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values2(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length2 = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length2 + fromIndex, 0);
          }
          return isString2(collection) ? fromIndex <= length2 && collection.indexOf(value, fromIndex) > -1 : !!length2 && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path, args) {
          var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map2(collection, iteratee2) {
          var func = isArray(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined$1 : orders;
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n === undefined$1) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          var func = isArray(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }
        function shuffle(collection) {
          var func = isArray(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString2(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined$1;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length2 = iteratees.length;
          if (length2 > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length2 > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now = ctxNow || function() {
          return root.Date.now();
        };
        function after(n, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          n = guard ? undefined$1 : n;
          n = func && n == null ? func.length : n;
          return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n);
        }
        function before(n, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined$1;
            }
            return result2;
          };
        }
        var bind = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined$1 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined$1 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce2(func, wait, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject2(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined$1;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined$1 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined$1;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined$1;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined$1) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined$1;
          }
          function flush() {
            return timerId === undefined$1 ? result2 : trailingEdge(now());
          }
          function debounced() {
            var time = now(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined$1) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined$1) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize2(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache.set(key, result2) || cache;
            return result2;
          };
          memoized.cache = new (memoize2.Cache || MapCache)();
          return memoized;
        }
        memoize2.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index = -1, length2 = nativeMin(args.length, funcsLength);
            while (++index < length2) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func, this, args);
          });
        });
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
        });
        function rest(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined$1 ? start : toInteger(start);
          return baseRest(func, start);
        }
        function spread(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array = args[start], otherArgs = castSlice(args, 0, start);
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle(func, wait, options) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject2(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce2(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value, wrapper2) {
          return partial(castFunction(wrapper2), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray(value) ? value : [value];
        }
        function clone(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(/* @__PURE__ */ function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction2(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        var isDate2 = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject2(value);
        }
        function isEmpty2(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          var result2 = customizer ? customizer(value, other) : undefined$1;
          return result2 === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject2(value);
        }
        function isFinite(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction2(value) {
          if (!isObject2(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject2(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN2(value) {
          return isNumber2(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber2(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject2(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp2 = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString2(value) {
          return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined(value) {
          return value === undefined$1;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString2(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values2;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject2(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject2(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign2 = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create(prototype, properties2) {
          var result2 = baseCreate(prototype);
          return properties2 == null ? result2 : baseAssign(result2, properties2);
        }
        var defaults2 = baseRest(function(object, sources) {
          object = Object2(object);
          var index = -1;
          var length2 = sources.length;
          var guard = length2 > 2 ? sources[2] : undefined$1;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length2 = 1;
          }
          while (++index < length2) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];
              if (value === undefined$1 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined$1, customDefaultsMerge);
          return apply(mergeWith, undefined$1, args);
        });
        function findKey2(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn2(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get(object, path, defaultValue) {
          var result2 = object == null ? undefined$1 : baseGet(object, path);
          return result2 === undefined$1 ? defaultValue : result2;
        }
        function has2(object, path) {
          return object != null && hasPath(object, path, baseHas);
        }
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }
        var invert = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant(identity));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, iteratee2(value, key, object2), value);
          });
          return result2;
        }
        function mapValues(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, key, iteratee2(value, key, object2));
          });
          return result2;
        }
        var merge2 = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object, getAllKeysIn(object), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length2 = paths.length;
          while (length2--) {
            baseUnset(result2, paths[length2]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }
        var pick = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }
        function result(object, path, defaultValue) {
          path = castPath(path, object);
          var index = -1, length2 = path.length;
          if (!length2) {
            length2 = 1;
            object = undefined$1;
          }
          while (++index < length2) {
            var value = object == null ? undefined$1 : object[toKey(path[index])];
            if (value === undefined$1) {
              index = length2;
              value = defaultValue;
            }
            object = isFunction2(value) ? value.call(object) : value;
          }
          return object;
        }
        function set2(object, path, value) {
          return object == null ? object : baseSet(object, path, value);
        }
        function setWith(object, path, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return object == null ? object : baseSet(object, path, value, customizer);
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform(object, iteratee2, accumulator) {
          var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject2(object)) {
              accumulator = isFunction2(Ctor) ? baseCreate(getPrototype(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
            return iteratee2(accumulator, value, index, object2);
          });
          return accumulator;
        }
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path);
        }
        function update(object, path, updater) {
          return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }
        function updateWith(object, path, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }
        function values2(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp2(number, lower, upper) {
          if (upper === undefined$1) {
            upper = lower;
            lower = undefined$1;
          }
          if (upper !== undefined$1) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined$1) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number), lower, upper);
        }
        function inRange(number, start, end) {
          start = toFinite(start);
          if (end === undefined$1) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number = toNumber(number);
          return baseInRange(number, start, end);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined$1;
          }
          if (floating === undefined$1) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined$1;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined$1;
            }
          }
          if (lower === undefined$1 && upper === undefined$1) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined$1) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function(result2, word, index) {
          word = word.toLowerCase();
          return result2 + (index ? capitalize2(word) : word);
        });
        function capitalize2(string) {
          return upperFirst(toString(string).toLowerCase());
        }
        function deburr(string) {
          string = toString(string);
          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string, target, position2) {
          string = toString(string);
          target = baseToString(target);
          var length2 = string.length;
          position2 = position2 === undefined$1 ? length2 : baseClamp(toInteger(position2), 0, length2);
          var end = position2;
          position2 -= target.length;
          return position2 >= 0 && string.slice(position2, end) == target;
        }
        function escape2(string) {
          string = toString(string);
          return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = toString(string);
          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        var kebabCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string, length2, chars) {
          string = toString(string);
          length2 = toInteger(length2);
          var strLength = length2 ? stringSize(string) : 0;
          if (!length2 || strLength >= length2) {
            return string;
          }
          var mid = (length2 - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string, length2, chars) {
          string = toString(string);
          length2 = toInteger(length2);
          var strLength = length2 ? stringSize(string) : 0;
          return length2 && strLength < length2 ? string + createPadding(length2 - strLength, chars) : string;
        }
        function padStart(string, length2, chars) {
          string = toString(string);
          length2 = toInteger(length2);
          var strLength = length2 ? stringSize(string) : 0;
          return length2 && strLength < length2 ? createPadding(length2 - strLength, chars) + string : string;
        }
        function parseInt2(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string, n, guard) {
          if (guard ? isIterateeCall(string, n, guard) : n === undefined$1) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          return baseRepeat(toString(string), n);
        }
        function replace2() {
          var args = arguments, string = toString(args[0]);
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "_" : "") + word.toLowerCase();
        });
        function split(string, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined$1;
          }
          limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString(string);
          if (string && (typeof separator == "string" || separator != null && !isRegExp2(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + upperFirst(word);
        });
        function startsWith(string, target, position2) {
          string = toString(string);
          position2 = position2 == null ? 0 : baseClamp(toInteger(position2), 0, string.length);
          target = baseToString(target);
          return string.slice(position2, position2 + target.length) == target;
        }
        function template(string, options, guard) {
          var settings = lodash2.templateSettings;
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined$1;
          }
          string = toString(string);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string.replace(reDelimiters, function(match3, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match3.length;
            return match3;
          });
          source += "';\n";
          var variable = hasOwnProperty.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined$1, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString(value).toLowerCase();
        }
        function toUpper(value) {
          return toString(value).toUpperCase();
        }
        function trim2(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined$1)) {
            return baseTrim(string);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined$1)) {
            return string.slice(0, trimmedEndIndex(string) + 1);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined$1)) {
            return string.replace(reTrimStart, "");
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        function truncate(string, options) {
          var length2 = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject2(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length2 = "length" in options ? toInteger(options.length) : length2;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string = toString(string);
          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length2 >= strLength) {
            return string;
          }
          var end = length2 - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
          if (separator === undefined$1) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp2(separator)) {
            if (string.slice(end).search(separator)) {
              var match3, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match3 = separator.exec(substring)) {
                var newEnd = match3.index;
              }
              result2 = result2.slice(0, newEnd === undefined$1 ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index = result2.lastIndexOf(separator);
            if (index > -1) {
              result2 = result2.slice(0, index);
            }
          }
          return result2 + omission;
        }
        function unescape2(string) {
          string = toString(string);
          return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        var upperCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string, pattern, guard) {
          string = toString(string);
          pattern = guard ? undefined$1 : pattern;
          if (pattern === undefined$1) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined$1, args);
          } catch (e) {
            return isError(e) ? e : new Error2(e);
          }
        });
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind(object[key], object));
          });
          return object;
        });
        function cond(pairs) {
          var length2 = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length2 ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index = -1;
            while (++index < length2) {
              var pair = pairs[index];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path, args) {
          return function(object) {
            return baseInvoke(object, path, args);
          };
        });
        var methodOf = baseRest(function(object, args) {
          return function(path) {
            return baseInvoke(object, path, args);
          };
        });
        function mixin(object, source, options) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject2(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain2 = !(isObject2(options) && "chain" in options) || !!options.chain, isFunc = isFunction2(object);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({ "func": func, "args": arguments, "thisArg": object });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
        function noop2() {
        }
        function nthArg(n) {
          n = toInteger(n);
          return baseRest(function(args) {
            return baseNth(args, n);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function propertyOf(object) {
          return function(path) {
            return object == null ? undefined$1 : baseGet(object, path);
          };
        }
        var range = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n, iteratee2) {
          n = toInteger(n);
          if (n < 1 || n > MAX_SAFE_INTEGER) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH, length2 = nativeMin(n, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length2, iteratee2);
          while (++index < n) {
            iteratee2(index);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
        }
        function uniqueId(prefix2) {
          var id = ++idCounter;
          return toString(prefix2) + id;
        }
        var add2 = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor2 = createRound("floor");
        function max(array) {
          return array && array.length ? baseExtremum(array, identity, baseGt) : undefined$1;
        }
        function maxBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined$1;
        }
        function mean(array) {
          return baseMean(array, identity);
        }
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        function min(array) {
          return array && array.length ? baseExtremum(array, identity, baseLt) : undefined$1;
        }
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined$1;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round2 = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array) {
          return array && array.length ? baseSum(array, identity) : 0;
        }
        function sumBy(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        lodash2.after = after;
        lodash2.ary = ary;
        lodash2.assign = assign2;
        lodash2.assignIn = assignIn;
        lodash2.assignInWith = assignInWith;
        lodash2.assignWith = assignWith;
        lodash2.at = at;
        lodash2.before = before;
        lodash2.bind = bind;
        lodash2.bindAll = bindAll;
        lodash2.bindKey = bindKey;
        lodash2.castArray = castArray;
        lodash2.chain = chain;
        lodash2.chunk = chunk;
        lodash2.compact = compact;
        lodash2.concat = concat;
        lodash2.cond = cond;
        lodash2.conforms = conforms;
        lodash2.constant = constant;
        lodash2.countBy = countBy;
        lodash2.create = create;
        lodash2.curry = curry;
        lodash2.curryRight = curryRight;
        lodash2.debounce = debounce2;
        lodash2.defaults = defaults2;
        lodash2.defaultsDeep = defaultsDeep;
        lodash2.defer = defer;
        lodash2.delay = delay;
        lodash2.difference = difference;
        lodash2.differenceBy = differenceBy;
        lodash2.differenceWith = differenceWith;
        lodash2.drop = drop;
        lodash2.dropRight = dropRight;
        lodash2.dropRightWhile = dropRightWhile;
        lodash2.dropWhile = dropWhile;
        lodash2.fill = fill;
        lodash2.filter = filter;
        lodash2.flatMap = flatMap;
        lodash2.flatMapDeep = flatMapDeep;
        lodash2.flatMapDepth = flatMapDepth;
        lodash2.flatten = flatten;
        lodash2.flattenDeep = flattenDeep;
        lodash2.flattenDepth = flattenDepth;
        lodash2.flip = flip;
        lodash2.flow = flow;
        lodash2.flowRight = flowRight;
        lodash2.fromPairs = fromPairs;
        lodash2.functions = functions;
        lodash2.functionsIn = functionsIn;
        lodash2.groupBy = groupBy;
        lodash2.initial = initial;
        lodash2.intersection = intersection;
        lodash2.intersectionBy = intersectionBy;
        lodash2.intersectionWith = intersectionWith;
        lodash2.invert = invert;
        lodash2.invertBy = invertBy;
        lodash2.invokeMap = invokeMap;
        lodash2.iteratee = iteratee;
        lodash2.keyBy = keyBy;
        lodash2.keys = keys;
        lodash2.keysIn = keysIn;
        lodash2.map = map2;
        lodash2.mapKeys = mapKeys;
        lodash2.mapValues = mapValues;
        lodash2.matches = matches;
        lodash2.matchesProperty = matchesProperty;
        lodash2.memoize = memoize2;
        lodash2.merge = merge2;
        lodash2.mergeWith = mergeWith;
        lodash2.method = method;
        lodash2.methodOf = methodOf;
        lodash2.mixin = mixin;
        lodash2.negate = negate;
        lodash2.nthArg = nthArg;
        lodash2.omit = omit;
        lodash2.omitBy = omitBy;
        lodash2.once = once;
        lodash2.orderBy = orderBy;
        lodash2.over = over;
        lodash2.overArgs = overArgs;
        lodash2.overEvery = overEvery;
        lodash2.overSome = overSome;
        lodash2.partial = partial;
        lodash2.partialRight = partialRight;
        lodash2.partition = partition;
        lodash2.pick = pick;
        lodash2.pickBy = pickBy;
        lodash2.property = property;
        lodash2.propertyOf = propertyOf;
        lodash2.pull = pull;
        lodash2.pullAll = pullAll;
        lodash2.pullAllBy = pullAllBy;
        lodash2.pullAllWith = pullAllWith;
        lodash2.pullAt = pullAt;
        lodash2.range = range;
        lodash2.rangeRight = rangeRight;
        lodash2.rearg = rearg;
        lodash2.reject = reject;
        lodash2.remove = remove;
        lodash2.rest = rest;
        lodash2.reverse = reverse;
        lodash2.sampleSize = sampleSize;
        lodash2.set = set2;
        lodash2.setWith = setWith;
        lodash2.shuffle = shuffle;
        lodash2.slice = slice2;
        lodash2.sortBy = sortBy;
        lodash2.sortedUniq = sortedUniq;
        lodash2.sortedUniqBy = sortedUniqBy;
        lodash2.split = split;
        lodash2.spread = spread;
        lodash2.tail = tail;
        lodash2.take = take;
        lodash2.takeRight = takeRight;
        lodash2.takeRightWhile = takeRightWhile;
        lodash2.takeWhile = takeWhile;
        lodash2.tap = tap;
        lodash2.throttle = throttle;
        lodash2.thru = thru;
        lodash2.toArray = toArray;
        lodash2.toPairs = toPairs;
        lodash2.toPairsIn = toPairsIn;
        lodash2.toPath = toPath;
        lodash2.toPlainObject = toPlainObject;
        lodash2.transform = transform;
        lodash2.unary = unary;
        lodash2.union = union;
        lodash2.unionBy = unionBy;
        lodash2.unionWith = unionWith;
        lodash2.uniq = uniq;
        lodash2.uniqBy = uniqBy;
        lodash2.uniqWith = uniqWith;
        lodash2.unset = unset;
        lodash2.unzip = unzip;
        lodash2.unzipWith = unzipWith;
        lodash2.update = update;
        lodash2.updateWith = updateWith;
        lodash2.values = values2;
        lodash2.valuesIn = valuesIn;
        lodash2.without = without;
        lodash2.words = words;
        lodash2.wrap = wrap;
        lodash2.xor = xor;
        lodash2.xorBy = xorBy;
        lodash2.xorWith = xorWith;
        lodash2.zip = zip;
        lodash2.zipObject = zipObject;
        lodash2.zipObjectDeep = zipObjectDeep;
        lodash2.zipWith = zipWith;
        lodash2.entries = toPairs;
        lodash2.entriesIn = toPairsIn;
        lodash2.extend = assignIn;
        lodash2.extendWith = assignInWith;
        mixin(lodash2, lodash2);
        lodash2.add = add2;
        lodash2.attempt = attempt;
        lodash2.camelCase = camelCase;
        lodash2.capitalize = capitalize2;
        lodash2.ceil = ceil;
        lodash2.clamp = clamp2;
        lodash2.clone = clone;
        lodash2.cloneDeep = cloneDeep;
        lodash2.cloneDeepWith = cloneDeepWith;
        lodash2.cloneWith = cloneWith;
        lodash2.conformsTo = conformsTo;
        lodash2.deburr = deburr;
        lodash2.defaultTo = defaultTo;
        lodash2.divide = divide;
        lodash2.endsWith = endsWith;
        lodash2.eq = eq;
        lodash2.escape = escape2;
        lodash2.escapeRegExp = escapeRegExp;
        lodash2.every = every;
        lodash2.find = find;
        lodash2.findIndex = findIndex2;
        lodash2.findKey = findKey2;
        lodash2.findLast = findLast;
        lodash2.findLastIndex = findLastIndex;
        lodash2.findLastKey = findLastKey;
        lodash2.floor = floor2;
        lodash2.forEach = forEach;
        lodash2.forEachRight = forEachRight;
        lodash2.forIn = forIn2;
        lodash2.forInRight = forInRight;
        lodash2.forOwn = forOwn;
        lodash2.forOwnRight = forOwnRight;
        lodash2.get = get;
        lodash2.gt = gt;
        lodash2.gte = gte;
        lodash2.has = has2;
        lodash2.hasIn = hasIn;
        lodash2.head = head;
        lodash2.identity = identity;
        lodash2.includes = includes;
        lodash2.indexOf = indexOf;
        lodash2.inRange = inRange;
        lodash2.invoke = invoke;
        lodash2.isArguments = isArguments;
        lodash2.isArray = isArray;
        lodash2.isArrayBuffer = isArrayBuffer;
        lodash2.isArrayLike = isArrayLike;
        lodash2.isArrayLikeObject = isArrayLikeObject;
        lodash2.isBoolean = isBoolean;
        lodash2.isBuffer = isBuffer;
        lodash2.isDate = isDate2;
        lodash2.isElement = isElement;
        lodash2.isEmpty = isEmpty2;
        lodash2.isEqual = isEqual;
        lodash2.isEqualWith = isEqualWith;
        lodash2.isError = isError;
        lodash2.isFinite = isFinite;
        lodash2.isFunction = isFunction2;
        lodash2.isInteger = isInteger;
        lodash2.isLength = isLength;
        lodash2.isMap = isMap;
        lodash2.isMatch = isMatch;
        lodash2.isMatchWith = isMatchWith;
        lodash2.isNaN = isNaN2;
        lodash2.isNative = isNative;
        lodash2.isNil = isNil;
        lodash2.isNull = isNull;
        lodash2.isNumber = isNumber2;
        lodash2.isObject = isObject2;
        lodash2.isObjectLike = isObjectLike;
        lodash2.isPlainObject = isPlainObject2;
        lodash2.isRegExp = isRegExp2;
        lodash2.isSafeInteger = isSafeInteger;
        lodash2.isSet = isSet;
        lodash2.isString = isString2;
        lodash2.isSymbol = isSymbol;
        lodash2.isTypedArray = isTypedArray;
        lodash2.isUndefined = isUndefined;
        lodash2.isWeakMap = isWeakMap;
        lodash2.isWeakSet = isWeakSet;
        lodash2.join = join;
        lodash2.kebabCase = kebabCase;
        lodash2.last = last;
        lodash2.lastIndexOf = lastIndexOf;
        lodash2.lowerCase = lowerCase;
        lodash2.lowerFirst = lowerFirst;
        lodash2.lt = lt;
        lodash2.lte = lte;
        lodash2.max = max;
        lodash2.maxBy = maxBy;
        lodash2.mean = mean;
        lodash2.meanBy = meanBy;
        lodash2.min = min;
        lodash2.minBy = minBy;
        lodash2.stubArray = stubArray;
        lodash2.stubFalse = stubFalse;
        lodash2.stubObject = stubObject;
        lodash2.stubString = stubString;
        lodash2.stubTrue = stubTrue;
        lodash2.multiply = multiply;
        lodash2.nth = nth;
        lodash2.noConflict = noConflict;
        lodash2.noop = noop2;
        lodash2.now = now;
        lodash2.pad = pad;
        lodash2.padEnd = padEnd;
        lodash2.padStart = padStart;
        lodash2.parseInt = parseInt2;
        lodash2.random = random;
        lodash2.reduce = reduce;
        lodash2.reduceRight = reduceRight;
        lodash2.repeat = repeat;
        lodash2.replace = replace2;
        lodash2.result = result;
        lodash2.round = round2;
        lodash2.runInContext = runInContext2;
        lodash2.sample = sample;
        lodash2.size = size;
        lodash2.snakeCase = snakeCase;
        lodash2.some = some;
        lodash2.sortedIndex = sortedIndex;
        lodash2.sortedIndexBy = sortedIndexBy;
        lodash2.sortedIndexOf = sortedIndexOf;
        lodash2.sortedLastIndex = sortedLastIndex;
        lodash2.sortedLastIndexBy = sortedLastIndexBy;
        lodash2.sortedLastIndexOf = sortedLastIndexOf;
        lodash2.startCase = startCase;
        lodash2.startsWith = startsWith;
        lodash2.subtract = subtract;
        lodash2.sum = sum;
        lodash2.sumBy = sumBy;
        lodash2.template = template;
        lodash2.times = times;
        lodash2.toFinite = toFinite;
        lodash2.toInteger = toInteger;
        lodash2.toLength = toLength;
        lodash2.toLower = toLower;
        lodash2.toNumber = toNumber;
        lodash2.toSafeInteger = toSafeInteger;
        lodash2.toString = toString;
        lodash2.toUpper = toUpper;
        lodash2.trim = trim2;
        lodash2.trimEnd = trimEnd;
        lodash2.trimStart = trimStart;
        lodash2.truncate = truncate;
        lodash2.unescape = unescape2;
        lodash2.uniqueId = uniqueId;
        lodash2.upperCase = upperCase;
        lodash2.upperFirst = upperFirst;
        lodash2.each = forEach;
        lodash2.eachRight = forEachRight;
        lodash2.first = head;
        mixin(lodash2, function() {
          var source = {};
          baseForOwn(lodash2, function(func, methodName) {
            if (!hasOwnProperty.call(lodash2.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), { "chain": false });
        lodash2.VERSION = VERSION;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash2[methodName].placeholder = lodash2;
        });
        arrayEach(["drop", "take"], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            n = n === undefined$1 ? 1 : nativeMax(toInteger(n), 0);
            var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
          var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index) {
          var takeName = "take" + (index ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index) {
          var dropName = "drop" + (index ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
          if (typeof path == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result2 = this;
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start < 0) {
            result2 = result2.takeRight(-start);
          } else if (start) {
            result2 = result2.drop(start);
          }
          if (end !== undefined$1) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash2.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
            var interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash2, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined$1 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash2.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash2[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined$1
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash2.prototype.at = wrapperAt;
        lodash2.prototype.chain = wrapperChain;
        lodash2.prototype.commit = wrapperCommit;
        lodash2.prototype.next = wrapperNext;
        lodash2.prototype.plant = wrapperPlant;
        lodash2.prototype.reverse = wrapperReverse;
        lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue;
        lodash2.prototype.first = lodash2.prototype.head;
        if (symIterator) {
          lodash2.prototype[symIterator] = wrapperToIterator;
        }
        return lodash2;
      };
      var _2 = runInContext();
      if (typeof undefined$1 == "function" && typeof undefined$1.amd == "object" && undefined$1.amd) {
        root._ = _2;
        undefined$1(function() {
          return _2;
        });
      } else if (freeModule) {
        (freeModule.exports = _2)._ = _2;
        freeExports._ = _2;
      } else {
        root._ = _2;
      }
    }).call(lodash);
  })(lodash$1, lodash$1.exports);
  return lodash$1.exports;
}
var lodashExports = requireLodash();
const initialState$2 = {
  showPopup: false,
  styles: {},
  component: null
};
const state$3 = proxy(initialState$2);
function hidePopup() {
  lodashExports.assign(state$3, initialState$2);
}
function showPopup(component, styles2) {
  state$3.component = ref$1(component);
  if (styles2) {
    state$3.styles = styles2;
  }
  state$3.showPopup = true;
}
const initialState$1 = {
  showSuggestion: false,
  right: {},
  bottom: {}
};
const state$2 = proxy(initialState$1);
function hideSuggestions() {
  lodashExports.assign(state$2, initialState$1);
}
function showSuggestions(right, bottom) {
  state$2.right = right;
  state$2.bottom = bottom;
  state$2.showSuggestion = true;
}
const initialState = {
  show: null,
  close: null
};
const state$1 = proxy(initialState);
function setNotification({ show, close: close2 }) {
  state$1.show = show;
  state$1.close = close2;
}
function closeNotification(key) {
  if (!state$1.close) {
    return;
  }
  return state$1.close(key);
}
function showNotification(message2, options) {
  if (!state$1.show) {
    return null;
  }
  return state$1.show(message2, options);
}
const state = proxy({ behavior: state$5, messages: state$6, quickButtons: state$4, preview: state$7, popup: state$3, suggestions: state$2, notification: state$1 });
const useSelector = (selector) => selector(useSnapshot(state));
function isWidgetOpened() {
  return state.behavior.showChat;
}
const replyIcon = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20512%20512'%3e%3c!--!Font%20Awesome%20Free%206.7.2%20by%20@fontawesome%20-%20https://fontawesome.com%20License%20-%20https://fontawesome.com/license/free%20Copyright%202025%20Fonticons,%20Inc.--%3e%3cpath%20d='M205%2034.8c11.5%205.1%2019%2016.6%2019%2029.2l0%2064%20112%200c97.2%200%20176%2078.8%20176%20176c0%20113.3-81.5%20163.9-100.2%20174.1c-2.5%201.4-5.3%201.9-8.1%201.9c-10.9%200-19.7-8.9-19.7-19.7c0-7.5%204.3-14.4%209.8-19.5c9.4-8.8%2022.2-26.4%2022.2-56.7c0-53-43-96-96-96l-96%200%200%2064c0%2012.6-7.4%2024.1-19%2029.2s-25%203-34.4-5.4l-160-144C3.9%20225.7%200%20217.1%200%20208s3.9-17.7%2010.6-23.8l160-144c9.4-8.5%2022.9-10.6%2034.4-5.4z'/%3e%3c/svg%3e";
const faceSmileIcon = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20512%20512'%3e%3c!--!Font%20Awesome%20Free%206.7.2%20by%20@fontawesome%20-%20https://fontawesome.com%20License%20-%20https://fontawesome.com/license/free%20Copyright%202025%20Fonticons,%20Inc.--%3e%3cpath%20d='M464%20256A208%20208%200%201%200%2048%20256a208%20208%200%201%200%20416%200zM0%20256a256%20256%200%201%201%20512%200A256%20256%200%201%201%200%20256zm177.6%2062.1C192.8%20334.5%20218.8%20352%20256%20352s63.2-17.5%2078.4-33.9c9-9.7%2024.2-10.4%2033.9-1.4s10.4%2024.2%201.4%2033.9c-22%2023.8-60%2049.4-113.6%2049.4s-91.7-25.5-113.6-49.4c-9-9.7-8.4-24.9%201.4-33.9s24.9-8.4%2033.9%201.4zM144.4%20208a32%2032%200%201%201%2064%200%2032%2032%200%201%201%20-64%200zm192-32a32%2032%200%201%201%200%2064%2032%2032%200%201%201%200-64z'/%3e%3c/svg%3e";
const MenuId$1 = "message-context";
function ContextMenu({ reply, reaction }) {
  const contextMenu = useSelector(({ messages }) => messages == null ? void 0 : messages.contextMenu);
  const items = useMemo(() => {
    const items2 = [];
    if (reply) {
      items2.push({
        icon: replyIcon,
        label: "Reply",
        onClick: ({ message: message2 }) => setReplyMessage(message2)
      });
    }
    if (reaction) {
      items2.push({
        icon: faceSmileIcon,
        label: "Feeling"
      });
    }
    return items2;
  }, [reply, reaction]);
  if (!contextMenu || contextMenu.id != MenuId$1) {
    return;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Menus, { items, position: contextMenu.position, data: contextMenu.data, onClose: () => setContextMenu(null) });
}
function asArray(v2) {
  return [].concat(v2);
}
function isPsuedoSelector(selector) {
  return selector.startsWith(":");
}
function isStyleCondition(selector) {
  return isString(selector) && (selector === "*" || selector.length > 1 && ":>~.+*".includes(selector.slice(0, 1)) || isImmediatePostcondition(selector));
}
function isValidProperty(property, value) {
  return (isString(value) || typeof value === "number") && !isCssVariables(property) && !isPsuedoSelector(property) && !isMediaQuery(property);
}
function isMediaQuery(selector) {
  return selector.startsWith("@media");
}
function isDirectClass(selector) {
  return selector === ".";
}
function isCssVariables(selector) {
  return selector === "--";
}
function isString(value) {
  return value + "" === value;
}
function isImmediatePostcondition(value) {
  return isString(value) && (value.startsWith("&") || isPsuedoSelector(value));
}
function joinTruthy(arr, delimiter2 = "") {
  return arr.filter(Boolean).join(delimiter2);
}
function stableHash(prefix2, seed) {
  let hash2 = 0;
  if (seed.length === 0)
    return hash2.toString();
  for (let i = 0; i < seed.length; i++) {
    const char2 = seed.charCodeAt(i);
    hash2 = (hash2 << 5) - hash2 + char2;
    hash2 = hash2 & hash2;
  }
  return `${prefix2 ?? "cl"}_${hash2.toString(36)}`;
}
function handlePropertyValue(property, value) {
  if (property === "content") {
    return `"${value}"`;
  }
  return value;
}
function camelCaseToDash(str) {
  return str.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}
function joinedProperty(property, value) {
  return `${property}:${value}`;
}
function toClass(str) {
  return str ? `.${str}` : "";
}
function appendString(base2, line2) {
  return base2 ? `${base2}
${line2}` : line2;
}
var Rule = class _Rule {
  constructor(sheet, property, value, selector) {
    this.sheet = sheet;
    this.property = property;
    this.value = value;
    this.selector = selector;
    this.property = property;
    this.value = value;
    this.joined = joinedProperty(property, value);
    const joinedConditions = this.selector.preconditions.concat(
      this.selector.postconditions
    );
    this.hash = this.selector.hasConditions ? this.selector.scopeClassName : stableHash(this.sheet.name, this.joined);
    this.key = joinTruthy([this.joined, joinedConditions, this.hash]);
  }
  toString() {
    let selectors = mergeSelectors(this.selector.preconditions, {
      right: this.hash
    });
    selectors = mergeSelectors(this.selector.postconditions, {
      left: selectors
    });
    return `${selectors} {${_Rule.genRule(this.property, this.value)}}`;
  }
  static genRule(property, value) {
    const transformedProperty = camelCaseToDash(property);
    return joinedProperty(
      transformedProperty,
      handlePropertyValue(property, value)
    ) + ";";
  }
};
function mergeSelectors(selectors, { left = "", right = "" } = {}) {
  const output = selectors.reduce((selectors2, current) => {
    if (isPsuedoSelector(current)) {
      return selectors2 + current;
    }
    if (isImmediatePostcondition(current)) {
      return selectors2 + current.slice(1);
    }
    return joinTruthy([selectors2, current], " ");
  }, left);
  return joinTruthy([output, toClass(right)], " ");
}
var Selector = class _Selector {
  constructor(sheet, scopeName = null, {
    preconditions,
    postconditions
  } = {}) {
    this.sheet = sheet;
    this.preconditions = [];
    this.scopeClassName = null;
    this.scopeName = null;
    this.postconditions = [];
    this.preconditions = preconditions ? asArray(preconditions) : [];
    this.postconditions = postconditions ? asArray(postconditions) : [];
    this.setScope(scopeName);
  }
  setScope(scopeName) {
    if (!scopeName) {
      return this;
    }
    if (!this.scopeClassName) {
      this.scopeName = scopeName;
      this.scopeClassName = stableHash(
        this.sheet.name,
        // adding the count guarantees uniqueness across style.create calls
        scopeName + this.sheet.count
      );
    }
    return this;
  }
  get hasConditions() {
    return this.preconditions.length > 0 || this.postconditions.length > 0;
  }
  addScope(scopeName) {
    return new _Selector(this.sheet, scopeName, {
      preconditions: this.preconditions,
      postconditions: this.postconditions
    });
  }
  addPrecondition(precondition) {
    return new _Selector(this.sheet, this.scopeClassName, {
      postconditions: this.postconditions,
      preconditions: this.preconditions.concat(precondition)
    });
  }
  addPostcondition(postcondition) {
    return new _Selector(this.sheet, this.scopeClassName, {
      preconditions: this.preconditions,
      postconditions: this.postconditions.concat(postcondition)
    });
  }
  createRule(property, value) {
    return new Rule(this.sheet, property, value, this);
  }
};
var Sheet = class {
  constructor(name, rootNode) {
    this.name = name;
    this.rootNode = rootNode;
    this.storedStyles = {};
    this.storedClasses = {};
    this.style = "";
    this.count = 0;
    this.id = `flairup-${name}`;
    this.styleTag = this.createStyleTag();
  }
  getStyle() {
    return this.style;
  }
  append(css2) {
    this.style = appendString(this.style, css2);
  }
  apply() {
    this.count++;
    if (!this.styleTag) {
      return;
    }
    this.styleTag.innerHTML = this.style;
  }
  isApplied() {
    return !!this.styleTag;
  }
  createStyleTag() {
    if (typeof document === "undefined" || this.isApplied() || // Explicitly disallow mounting to the DOM
    this.rootNode === null) {
      return this.styleTag;
    }
    const styleTag = document.createElement("style");
    styleTag.type = "text/css";
    styleTag.id = this.id;
    (this.rootNode ?? document.head).appendChild(styleTag);
    return styleTag;
  }
  addRule(rule) {
    const storedClass = this.storedClasses[rule.key];
    if (isString(storedClass)) {
      return storedClass;
    }
    this.storedClasses[rule.key] = rule.hash;
    this.storedStyles[rule.hash] = [rule.property, rule.value];
    this.append(rule.toString());
    return rule.hash;
  }
};
function forIn(obj, fn) {
  for (const key in obj) {
    fn(key.trim(), obj[key]);
  }
}
function cx(...args) {
  const classes = args.reduce((classes2, arg2) => {
    if (arg2 instanceof Set) {
      classes2.push(...arg2);
    } else if (typeof arg2 === "string") {
      classes2.push(arg2);
    } else if (Array.isArray(arg2)) {
      classes2.push(cx(...arg2));
    } else if (typeof arg2 === "object") {
      Object.entries(arg2).forEach(([key, value]) => {
        if (value) {
          classes2.push(key);
        }
      });
    }
    return classes2;
  }, []);
  return joinTruthy(classes, " ").trim();
}
function createSheet(name, rootNode) {
  const sheet = new Sheet(name, rootNode);
  return {
    create,
    getStyle: sheet.getStyle.bind(sheet),
    isApplied: sheet.isApplied.bind(sheet)
  };
  function create(styles2) {
    const scopedStyles = {};
    iteratePreconditions(sheet, styles2, new Selector(sheet)).forEach(
      ([scopeName, styles22, selector]) => {
        iterateStyles(sheet, styles22, selector).forEach(
          (className) => {
            addScopedStyle(scopeName, className);
          }
        );
      }
    );
    sheet.apply();
    return scopedStyles;
    function addScopedStyle(name2, className) {
      scopedStyles[name2] = scopedStyles[name2] ?? /* @__PURE__ */ new Set();
      scopedStyles[name2].add(className);
    }
  }
}
function iteratePreconditions(sheet, styles2, selector) {
  const output = [];
  forIn(styles2, (key, value) => {
    if (isStyleCondition(key)) {
      return iteratePreconditions(
        sheet,
        value,
        selector.addPrecondition(key)
      ).forEach((item) => output.push(item));
    }
    output.push([key, styles2[key], selector.addScope(key)]);
  });
  return output;
}
function iterateStyles(sheet, styles2, selector) {
  const output = /* @__PURE__ */ new Set();
  forIn(styles2, (property, value) => {
    let res = [];
    if (isStyleCondition(property)) {
      res = iterateStyles(
        sheet,
        value,
        selector.addPostcondition(property)
      );
    } else if (isDirectClass(property)) {
      res = asArray(value);
    } else if (isMediaQuery(property)) {
      res = handleMediaQuery(sheet, value, property, selector);
    } else if (isCssVariables(property)) {
      res = cssVariablesBlock(sheet, value, selector);
    } else if (isValidProperty(property, value)) {
      const rule = selector.createRule(property, value);
      sheet.addRule(rule);
      output.add(rule.hash);
    }
    return addEachClass(res, output);
  });
  return output;
}
function addEachClass(list2, to) {
  list2.forEach((className) => to.add(className));
  return to;
}
function cssVariablesBlock(sheet, styles2, selector) {
  const classes = /* @__PURE__ */ new Set();
  const chunkRows = [];
  forIn(styles2, (property, value) => {
    if (isValidProperty(property, value)) {
      chunkRows.push(Rule.genRule(property, value));
      return;
    }
    const res = iterateStyles(sheet, value ?? {}, selector);
    addEachClass(res, classes);
  });
  if (!selector.scopeClassName) {
    return classes;
  }
  if (chunkRows.length) {
    const output = chunkRows.join(" ");
    sheet.append(
      `${mergeSelectors(selector.preconditions, {
        right: selector.scopeClassName
      })} {${output}}`
    );
  }
  classes.add(selector.scopeClassName);
  return classes;
}
function handleMediaQuery(sheet, styles2, mediaQuery, selector) {
  sheet.append(mediaQuery + " {");
  const output = iterateStyles(sheet, styles2, selector);
  sheet.append("}");
  return output;
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p2) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf(o, p2);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike) {
    if (it) o = it;
    var i = 0;
    return function() {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var ClassNames;
(function(ClassNames2) {
  ClassNames2["hiddenOnSearch"] = "epr-hidden-on-search";
  ClassNames2["searchActive"] = "epr-search-active";
  ClassNames2["hidden"] = "epr-hidden";
  ClassNames2["visible"] = "epr-visible";
  ClassNames2["active"] = "epr-active";
  ClassNames2["emoji"] = "epr-emoji";
  ClassNames2["category"] = "epr-emoji-category";
  ClassNames2["label"] = "epr-emoji-category-label";
  ClassNames2["categoryContent"] = "epr-emoji-category-content";
  ClassNames2["emojiHasVariations"] = "epr-emoji-has-variations";
  ClassNames2["scrollBody"] = "epr-body";
  ClassNames2["emojiList"] = "epr-emoji-list";
  ClassNames2["external"] = "__EmojiPicker__";
  ClassNames2["emojiPicker"] = "EmojiPickerReact";
  ClassNames2["open"] = "epr-open";
  ClassNames2["vertical"] = "epr-vertical";
  ClassNames2["horizontal"] = "epr-horizontal";
  ClassNames2["variationPicker"] = "epr-emoji-variation-picker";
  ClassNames2["darkTheme"] = "epr-dark-theme";
  ClassNames2["autoTheme"] = "epr-auto-theme";
})(ClassNames || (ClassNames = {}));
function asSelectors() {
  for (var _len = arguments.length, classNames = new Array(_len), _key = 0; _key < _len; _key++) {
    classNames[_key] = arguments[_key];
  }
  return classNames.map(function(c) {
    return "." + c;
  }).join("");
}
var stylesheet = /* @__PURE__ */ createSheet("epr", null);
var hidden = {
  display: "none",
  opacity: "0",
  pointerEvents: "none",
  visibility: "hidden",
  overflow: "hidden"
};
var commonStyles = /* @__PURE__ */ stylesheet.create({
  hidden: /* @__PURE__ */ _extends({
    ".": ClassNames.hidden
  }, hidden)
});
var PickerStyleTag = /* @__PURE__ */ memo(function PickerStyleTag2() {
  return createElement("style", {
    suppressHydrationWarning: true,
    dangerouslySetInnerHTML: {
      __html: stylesheet.getStyle()
    }
  });
});
var commonInteractionStyles = /* @__PURE__ */ stylesheet.create({
  ".epr-main": {
    ":has(input:not(:placeholder-shown))": {
      categoryBtn: {
        ":hover": {
          opacity: "1",
          backgroundPositionY: "var(--epr-category-navigation-button-size)"
        }
      },
      hiddenOnSearch: /* @__PURE__ */ _extends({
        ".": ClassNames.hiddenOnSearch
      }, hidden)
    },
    ":has(input(:placeholder-shown))": {
      visibleOnSearchOnly: hidden
    }
  },
  hiddenOnReactions: {
    transition: "all 0.5s ease-in-out"
  },
  ".epr-reactions": {
    hiddenOnReactions: {
      height: "0px",
      width: "0px",
      opacity: "0",
      pointerEvents: "none",
      overflow: "hidden"
    }
  },
  ".EmojiPickerReact:not(.epr-search-active)": {
    categoryBtn: {
      ":hover": {
        opacity: "1",
        backgroundPositionY: "var(--epr-category-navigation-button-size)"
      },
      "&.epr-active": {
        opacity: "1",
        backgroundPositionY: "var(--epr-category-navigation-button-size)"
      }
    },
    visibleOnSearchOnly: /* @__PURE__ */ _extends({
      ".": "epr-visible-on-search-only"
    }, hidden)
  }
});
function darkMode(key, value) {
  var _eprDarkTheme, _eprAutoTheme;
  return {
    ".epr-dark-theme": (_eprDarkTheme = {}, _eprDarkTheme[key] = value, _eprDarkTheme),
    ".epr-auto-theme": (_eprAutoTheme = {}, _eprAutoTheme[key] = {
      "@media (prefers-color-scheme: dark)": value
    }, _eprAutoTheme)
  };
}
function compareConfig(prev2, next2) {
  var _prev$customEmojis, _next$customEmojis;
  var prevCustomEmojis = (_prev$customEmojis = prev2.customEmojis) != null ? _prev$customEmojis : [];
  var nextCustomEmojis = (_next$customEmojis = next2.customEmojis) != null ? _next$customEmojis : [];
  return prev2.open === next2.open && prev2.emojiVersion === next2.emojiVersion && prev2.reactionsDefaultOpen === next2.reactionsDefaultOpen && prev2.searchPlaceHolder === next2.searchPlaceHolder && prev2.searchPlaceholder === next2.searchPlaceholder && prev2.defaultSkinTone === next2.defaultSkinTone && prev2.skinTonesDisabled === next2.skinTonesDisabled && prev2.autoFocusSearch === next2.autoFocusSearch && prev2.emojiStyle === next2.emojiStyle && prev2.theme === next2.theme && prev2.suggestedEmojisMode === next2.suggestedEmojisMode && prev2.lazyLoadEmojis === next2.lazyLoadEmojis && prev2.className === next2.className && prev2.height === next2.height && prev2.width === next2.width && prev2.style === next2.style && prev2.searchDisabled === next2.searchDisabled && prev2.skinTonePickerLocation === next2.skinTonePickerLocation && prevCustomEmojis.length === nextCustomEmojis.length;
}
var DEFAULT_REACTIONS = [
  "1f44d",
  "2764-fe0f",
  "1f603",
  "1f622",
  "1f64f",
  "1f44e",
  "1f621"
  // 😡
];
var SuggestionMode;
(function(SuggestionMode2) {
  SuggestionMode2["RECENT"] = "recent";
  SuggestionMode2["FREQUENT"] = "frequent";
})(SuggestionMode || (SuggestionMode = {}));
var EmojiStyle;
(function(EmojiStyle2) {
  EmojiStyle2["NATIVE"] = "native";
  EmojiStyle2["APPLE"] = "apple";
  EmojiStyle2["TWITTER"] = "twitter";
  EmojiStyle2["GOOGLE"] = "google";
  EmojiStyle2["FACEBOOK"] = "facebook";
})(EmojiStyle || (EmojiStyle = {}));
var Theme;
(function(Theme2) {
  Theme2["DARK"] = "dark";
  Theme2["LIGHT"] = "light";
  Theme2["AUTO"] = "auto";
})(Theme || (Theme = {}));
var SkinTones;
(function(SkinTones2) {
  SkinTones2["NEUTRAL"] = "neutral";
  SkinTones2["LIGHT"] = "1f3fb";
  SkinTones2["MEDIUM_LIGHT"] = "1f3fc";
  SkinTones2["MEDIUM"] = "1f3fd";
  SkinTones2["MEDIUM_DARK"] = "1f3fe";
  SkinTones2["DARK"] = "1f3ff";
})(SkinTones || (SkinTones = {}));
var Categories;
(function(Categories2) {
  Categories2["SUGGESTED"] = "suggested";
  Categories2["CUSTOM"] = "custom";
  Categories2["SMILEYS_PEOPLE"] = "smileys_people";
  Categories2["ANIMALS_NATURE"] = "animals_nature";
  Categories2["FOOD_DRINK"] = "food_drink";
  Categories2["TRAVEL_PLACES"] = "travel_places";
  Categories2["ACTIVITIES"] = "activities";
  Categories2["OBJECTS"] = "objects";
  Categories2["SYMBOLS"] = "symbols";
  Categories2["FLAGS"] = "flags";
})(Categories || (Categories = {}));
var SkinTonePickerLocation;
(function(SkinTonePickerLocation2) {
  SkinTonePickerLocation2["SEARCH"] = "SEARCH";
  SkinTonePickerLocation2["PREVIEW"] = "PREVIEW";
})(SkinTonePickerLocation || (SkinTonePickerLocation = {}));
var _configByCategory;
var categoriesOrdered = [Categories.SUGGESTED, Categories.CUSTOM, Categories.SMILEYS_PEOPLE, Categories.ANIMALS_NATURE, Categories.FOOD_DRINK, Categories.TRAVEL_PLACES, Categories.ACTIVITIES, Categories.OBJECTS, Categories.SYMBOLS, Categories.FLAGS];
var SuggestedRecent = {
  name: "Recently Used",
  category: Categories.SUGGESTED
};
var configByCategory = (_configByCategory = {}, _configByCategory[Categories.SUGGESTED] = {
  category: Categories.SUGGESTED,
  name: "Frequently Used"
}, _configByCategory[Categories.CUSTOM] = {
  category: Categories.CUSTOM,
  name: "Custom Emojis"
}, _configByCategory[Categories.SMILEYS_PEOPLE] = {
  category: Categories.SMILEYS_PEOPLE,
  name: "Smileys & People"
}, _configByCategory[Categories.ANIMALS_NATURE] = {
  category: Categories.ANIMALS_NATURE,
  name: "Animals & Nature"
}, _configByCategory[Categories.FOOD_DRINK] = {
  category: Categories.FOOD_DRINK,
  name: "Food & Drink"
}, _configByCategory[Categories.TRAVEL_PLACES] = {
  category: Categories.TRAVEL_PLACES,
  name: "Travel & Places"
}, _configByCategory[Categories.ACTIVITIES] = {
  category: Categories.ACTIVITIES,
  name: "Activities"
}, _configByCategory[Categories.OBJECTS] = {
  category: Categories.OBJECTS,
  name: "Objects"
}, _configByCategory[Categories.SYMBOLS] = {
  category: Categories.SYMBOLS,
  name: "Symbols"
}, _configByCategory[Categories.FLAGS] = {
  category: Categories.FLAGS,
  name: "Flags"
}, _configByCategory);
function baseCategoriesConfig(modifiers) {
  return categoriesOrdered.map(function(category) {
    return _extends({}, configByCategory[category], modifiers && modifiers[category] && modifiers[category]);
  });
}
function categoryFromCategoryConfig(category) {
  return category.category;
}
function categoryNameFromCategoryConfig(category) {
  return category.name;
}
function mergeCategoriesConfig(userCategoriesConfig, modifiers) {
  var _userCategoriesConfig;
  if (userCategoriesConfig === void 0) {
    userCategoriesConfig = [];
  }
  if (modifiers === void 0) {
    modifiers = {};
  }
  var extra = {};
  if (modifiers.suggestionMode === SuggestionMode.RECENT) {
    extra[Categories.SUGGESTED] = SuggestedRecent;
  }
  var base2 = baseCategoriesConfig(extra);
  if (!((_userCategoriesConfig = userCategoriesConfig) != null && _userCategoriesConfig.length)) {
    return base2;
  }
  return userCategoriesConfig.map(function(category) {
    if (typeof category === "string") {
      return getBaseConfigByCategory(category, extra[category]);
    }
    return _extends({}, getBaseConfigByCategory(category.category, extra[category.category]), category);
  });
}
function getBaseConfigByCategory(category, modifier) {
  if (modifier === void 0) {
    modifier = {};
  }
  return Object.assign(configByCategory[category], modifier);
}
var CDN_URL_APPLE = "https://cdn.jsdelivr.net/npm/emoji-datasource-apple/img/apple/64/";
var CDN_URL_FACEBOOK = "https://cdn.jsdelivr.net/npm/emoji-datasource-facebook/img/facebook/64/";
var CDN_URL_TWITTER = "https://cdn.jsdelivr.net/npm/emoji-datasource-twitter/img/twitter/64/";
var CDN_URL_GOOGLE = "https://cdn.jsdelivr.net/npm/emoji-datasource-google/img/google/64/";
function cdnUrl(emojiStyle) {
  switch (emojiStyle) {
    case EmojiStyle.TWITTER:
      return CDN_URL_TWITTER;
    case EmojiStyle.GOOGLE:
      return CDN_URL_GOOGLE;
    case EmojiStyle.FACEBOOK:
      return CDN_URL_FACEBOOK;
    case EmojiStyle.APPLE:
    default:
      return CDN_URL_APPLE;
  }
}
var custom = [];
var smileys_people = [
  {
    n: [
      "grinning",
      "grinning face"
    ],
    u: "1f600",
    a: "1.0"
  },
  {
    n: [
      "smiley",
      "smiling face with open mouth"
    ],
    u: "1f603",
    a: "0.6"
  },
  {
    n: [
      "smile",
      "smiling face with open mouth and smiling eyes"
    ],
    u: "1f604",
    a: "0.6"
  },
  {
    n: [
      "grin",
      "grinning face with smiling eyes"
    ],
    u: "1f601",
    a: "0.6"
  },
  {
    n: [
      "laughing",
      "satisfied",
      "smiling face with open mouth and tightly-closed eyes"
    ],
    u: "1f606",
    a: "0.6"
  },
  {
    n: [
      "sweat smile",
      "smiling face with open mouth and cold sweat"
    ],
    u: "1f605",
    a: "0.6"
  },
  {
    n: [
      "rolling on the floor laughing"
    ],
    u: "1f923",
    a: "3.0"
  },
  {
    n: [
      "joy",
      "face with tears of joy"
    ],
    u: "1f602",
    a: "0.6"
  },
  {
    n: [
      "slightly smiling face"
    ],
    u: "1f642",
    a: "1.0"
  },
  {
    n: [
      "upside-down face",
      "upside down face"
    ],
    u: "1f643",
    a: "1.0"
  },
  {
    n: [
      "melting face"
    ],
    u: "1fae0",
    a: "14.0"
  },
  {
    n: [
      "wink",
      "winking face"
    ],
    u: "1f609",
    a: "0.6"
  },
  {
    n: [
      "blush",
      "smiling face with smiling eyes"
    ],
    u: "1f60a",
    a: "0.6"
  },
  {
    n: [
      "innocent",
      "smiling face with halo"
    ],
    u: "1f607",
    a: "1.0"
  },
  {
    n: [
      "smiling face with 3 hearts",
      "smiling face with smiling eyes and three hearts"
    ],
    u: "1f970",
    a: "11.0"
  },
  {
    n: [
      "heart eyes",
      "smiling face with heart-shaped eyes"
    ],
    u: "1f60d",
    a: "0.6"
  },
  {
    n: [
      "star-struck",
      "grinning face with star eyes"
    ],
    u: "1f929",
    a: "5.0"
  },
  {
    n: [
      "kissing heart",
      "face throwing a kiss"
    ],
    u: "1f618",
    a: "0.6"
  },
  {
    n: [
      "kissing",
      "kissing face"
    ],
    u: "1f617",
    a: "1.0"
  },
  {
    n: [
      "relaxed",
      "white smiling face"
    ],
    u: "263a-fe0f",
    a: "0.6"
  },
  {
    n: [
      "kissing closed eyes",
      "kissing face with closed eyes"
    ],
    u: "1f61a",
    a: "0.6"
  },
  {
    n: [
      "kissing smiling eyes",
      "kissing face with smiling eyes"
    ],
    u: "1f619",
    a: "1.0"
  },
  {
    n: [
      "smiling face with tear"
    ],
    u: "1f972",
    a: "13.0"
  },
  {
    n: [
      "yum",
      "face savouring delicious food"
    ],
    u: "1f60b",
    a: "0.6"
  },
  {
    n: [
      "stuck out tongue",
      "face with stuck-out tongue"
    ],
    u: "1f61b",
    a: "1.0"
  },
  {
    n: [
      "stuck out tongue winking eye",
      "face with stuck-out tongue and winking eye"
    ],
    u: "1f61c",
    a: "0.6"
  },
  {
    n: [
      "zany face",
      "grinning face with one large and one small eye"
    ],
    u: "1f92a",
    a: "5.0"
  },
  {
    n: [
      "stuck out tongue closed eyes",
      "face with stuck-out tongue and tightly-closed eyes"
    ],
    u: "1f61d",
    a: "0.6"
  },
  {
    n: [
      "money-mouth face",
      "money mouth face"
    ],
    u: "1f911",
    a: "1.0"
  },
  {
    n: [
      "hugging face"
    ],
    u: "1f917",
    a: "1.0"
  },
  {
    n: [
      "face with hand over mouth",
      "smiling face with smiling eyes and hand covering mouth"
    ],
    u: "1f92d",
    a: "5.0"
  },
  {
    n: [
      "face with open eyes and hand over mouth"
    ],
    u: "1fae2",
    a: "14.0"
  },
  {
    n: [
      "face with peeking eye"
    ],
    u: "1fae3",
    a: "14.0"
  },
  {
    n: [
      "shushing face",
      "face with finger covering closed lips"
    ],
    u: "1f92b",
    a: "5.0"
  },
  {
    n: [
      "thinking face"
    ],
    u: "1f914",
    a: "1.0"
  },
  {
    n: [
      "saluting face"
    ],
    u: "1fae1",
    a: "14.0"
  },
  {
    n: [
      "zipper-mouth face",
      "zipper mouth face"
    ],
    u: "1f910",
    a: "1.0"
  },
  {
    n: [
      "face with raised eyebrow",
      "face with one eyebrow raised"
    ],
    u: "1f928",
    a: "5.0"
  },
  {
    n: [
      "neutral face"
    ],
    u: "1f610",
    a: "0.7"
  },
  {
    n: [
      "expressionless",
      "expressionless face"
    ],
    u: "1f611",
    a: "1.0"
  },
  {
    n: [
      "no mouth",
      "face without mouth"
    ],
    u: "1f636",
    a: "1.0"
  },
  {
    n: [
      "dotted line face"
    ],
    u: "1fae5",
    a: "14.0"
  },
  {
    n: [
      "face in clouds"
    ],
    u: "1f636-200d-1f32b-fe0f",
    a: "13.1"
  },
  {
    n: [
      "smirk",
      "smirking face"
    ],
    u: "1f60f",
    a: "0.6"
  },
  {
    n: [
      "unamused",
      "unamused face"
    ],
    u: "1f612",
    a: "0.6"
  },
  {
    n: [
      "face with rolling eyes"
    ],
    u: "1f644",
    a: "1.0"
  },
  {
    n: [
      "grimacing",
      "grimacing face"
    ],
    u: "1f62c",
    a: "1.0"
  },
  {
    n: [
      "face exhaling"
    ],
    u: "1f62e-200d-1f4a8",
    a: "13.1"
  },
  {
    n: [
      "lying face"
    ],
    u: "1f925",
    a: "3.0"
  },
  {
    n: [
      "relieved",
      "relieved face"
    ],
    u: "1f60c",
    a: "0.6"
  },
  {
    n: [
      "pensive",
      "pensive face"
    ],
    u: "1f614",
    a: "0.6"
  },
  {
    n: [
      "sleepy",
      "sleepy face"
    ],
    u: "1f62a",
    a: "0.6"
  },
  {
    n: [
      "drooling face"
    ],
    u: "1f924",
    a: "3.0"
  },
  {
    n: [
      "sleeping",
      "sleeping face"
    ],
    u: "1f634",
    a: "1.0"
  },
  {
    n: [
      "mask",
      "face with medical mask"
    ],
    u: "1f637",
    a: "0.6"
  },
  {
    n: [
      "face with thermometer"
    ],
    u: "1f912",
    a: "1.0"
  },
  {
    n: [
      "face with head-bandage",
      "face with head bandage"
    ],
    u: "1f915",
    a: "1.0"
  },
  {
    n: [
      "nauseated face"
    ],
    u: "1f922",
    a: "3.0"
  },
  {
    n: [
      "face vomiting",
      "face with open mouth vomiting"
    ],
    u: "1f92e",
    a: "5.0"
  },
  {
    n: [
      "sneezing face"
    ],
    u: "1f927",
    a: "3.0"
  },
  {
    n: [
      "hot face",
      "overheated face"
    ],
    u: "1f975",
    a: "11.0"
  },
  {
    n: [
      "cold face",
      "freezing face"
    ],
    u: "1f976",
    a: "11.0"
  },
  {
    n: [
      "woozy face",
      "face with uneven eyes and wavy mouth"
    ],
    u: "1f974",
    a: "11.0"
  },
  {
    n: [
      "dizzy face"
    ],
    u: "1f635",
    a: "0.6"
  },
  {
    n: [
      "face with spiral eyes"
    ],
    u: "1f635-200d-1f4ab",
    a: "13.1"
  },
  {
    n: [
      "exploding head",
      "shocked face with exploding head"
    ],
    u: "1f92f",
    a: "5.0"
  },
  {
    n: [
      "face with cowboy hat"
    ],
    u: "1f920",
    a: "3.0"
  },
  {
    n: [
      "partying face",
      "face with party horn and party hat"
    ],
    u: "1f973",
    a: "11.0"
  },
  {
    n: [
      "disguised face"
    ],
    u: "1f978",
    a: "13.0"
  },
  {
    n: [
      "sunglasses",
      "smiling face with sunglasses"
    ],
    u: "1f60e",
    a: "1.0"
  },
  {
    n: [
      "nerd face"
    ],
    u: "1f913",
    a: "1.0"
  },
  {
    n: [
      "face with monocle"
    ],
    u: "1f9d0",
    a: "5.0"
  },
  {
    n: [
      "confused",
      "confused face"
    ],
    u: "1f615",
    a: "1.0"
  },
  {
    n: [
      "face with diagonal mouth"
    ],
    u: "1fae4",
    a: "14.0"
  },
  {
    n: [
      "worried",
      "worried face"
    ],
    u: "1f61f",
    a: "1.0"
  },
  {
    n: [
      "slightly frowning face"
    ],
    u: "1f641",
    a: "1.0"
  },
  {
    n: [
      "frowning face",
      "white frowning face"
    ],
    u: "2639-fe0f",
    a: "0.7"
  },
  {
    n: [
      "open mouth",
      "face with open mouth"
    ],
    u: "1f62e",
    a: "1.0"
  },
  {
    n: [
      "hushed",
      "hushed face"
    ],
    u: "1f62f",
    a: "1.0"
  },
  {
    n: [
      "astonished",
      "astonished face"
    ],
    u: "1f632",
    a: "0.6"
  },
  {
    n: [
      "flushed",
      "flushed face"
    ],
    u: "1f633",
    a: "0.6"
  },
  {
    n: [
      "pleading face",
      "face with pleading eyes"
    ],
    u: "1f97a",
    a: "11.0"
  },
  {
    n: [
      "face holding back tears"
    ],
    u: "1f979",
    a: "14.0"
  },
  {
    n: [
      "frowning",
      "frowning face with open mouth"
    ],
    u: "1f626",
    a: "1.0"
  },
  {
    n: [
      "anguished",
      "anguished face"
    ],
    u: "1f627",
    a: "1.0"
  },
  {
    n: [
      "fearful",
      "fearful face"
    ],
    u: "1f628",
    a: "0.6"
  },
  {
    n: [
      "cold sweat",
      "face with open mouth and cold sweat"
    ],
    u: "1f630",
    a: "0.6"
  },
  {
    n: [
      "disappointed relieved",
      "disappointed but relieved face"
    ],
    u: "1f625",
    a: "0.6"
  },
  {
    n: [
      "cry",
      "crying face"
    ],
    u: "1f622",
    a: "0.6"
  },
  {
    n: [
      "sob",
      "loudly crying face"
    ],
    u: "1f62d",
    a: "0.6"
  },
  {
    n: [
      "scream",
      "face screaming in fear"
    ],
    u: "1f631",
    a: "0.6"
  },
  {
    n: [
      "confounded",
      "confounded face"
    ],
    u: "1f616",
    a: "0.6"
  },
  {
    n: [
      "persevere",
      "persevering face"
    ],
    u: "1f623",
    a: "0.6"
  },
  {
    n: [
      "disappointed",
      "disappointed face"
    ],
    u: "1f61e",
    a: "0.6"
  },
  {
    n: [
      "sweat",
      "face with cold sweat"
    ],
    u: "1f613",
    a: "0.6"
  },
  {
    n: [
      "weary",
      "weary face"
    ],
    u: "1f629",
    a: "0.6"
  },
  {
    n: [
      "tired face"
    ],
    u: "1f62b",
    a: "0.6"
  },
  {
    n: [
      "yawning face"
    ],
    u: "1f971",
    a: "12.0"
  },
  {
    n: [
      "triumph",
      "face with look of triumph"
    ],
    u: "1f624",
    a: "0.6"
  },
  {
    n: [
      "rage",
      "pouting face"
    ],
    u: "1f621",
    a: "0.6"
  },
  {
    n: [
      "angry",
      "angry face"
    ],
    u: "1f620",
    a: "0.6"
  },
  {
    n: [
      "face with symbols on mouth",
      "serious face with symbols covering mouth"
    ],
    u: "1f92c",
    a: "5.0"
  },
  {
    n: [
      "smiling imp",
      "smiling face with horns"
    ],
    u: "1f608",
    a: "1.0"
  },
  {
    n: [
      "imp"
    ],
    u: "1f47f",
    a: "0.6"
  },
  {
    n: [
      "skull"
    ],
    u: "1f480",
    a: "0.6"
  },
  {
    n: [
      "skull and crossbones"
    ],
    u: "2620-fe0f",
    a: "1.0"
  },
  {
    n: [
      "poop",
      "shit",
      "hankey",
      "pile of poo"
    ],
    u: "1f4a9",
    a: "0.6"
  },
  {
    n: [
      "clown face"
    ],
    u: "1f921",
    a: "3.0"
  },
  {
    n: [
      "japanese ogre"
    ],
    u: "1f479",
    a: "0.6"
  },
  {
    n: [
      "japanese goblin"
    ],
    u: "1f47a",
    a: "0.6"
  },
  {
    n: [
      "ghost"
    ],
    u: "1f47b",
    a: "0.6"
  },
  {
    n: [
      "alien",
      "extraterrestrial alien"
    ],
    u: "1f47d",
    a: "0.6"
  },
  {
    n: [
      "alien monster",
      "space invader"
    ],
    u: "1f47e",
    a: "0.6"
  },
  {
    n: [
      "robot face"
    ],
    u: "1f916",
    a: "1.0"
  },
  {
    n: [
      "smiley cat",
      "smiling cat face with open mouth"
    ],
    u: "1f63a",
    a: "0.6"
  },
  {
    n: [
      "smile cat",
      "grinning cat face with smiling eyes"
    ],
    u: "1f638",
    a: "0.6"
  },
  {
    n: [
      "joy cat",
      "cat face with tears of joy"
    ],
    u: "1f639",
    a: "0.6"
  },
  {
    n: [
      "heart eyes cat",
      "smiling cat face with heart-shaped eyes"
    ],
    u: "1f63b",
    a: "0.6"
  },
  {
    n: [
      "smirk cat",
      "cat face with wry smile"
    ],
    u: "1f63c",
    a: "0.6"
  },
  {
    n: [
      "kissing cat",
      "kissing cat face with closed eyes"
    ],
    u: "1f63d",
    a: "0.6"
  },
  {
    n: [
      "scream cat",
      "weary cat face"
    ],
    u: "1f640",
    a: "0.6"
  },
  {
    n: [
      "crying cat face"
    ],
    u: "1f63f",
    a: "0.6"
  },
  {
    n: [
      "pouting cat",
      "pouting cat face"
    ],
    u: "1f63e",
    a: "0.6"
  },
  {
    n: [
      "see no evil",
      "see-no-evil monkey"
    ],
    u: "1f648",
    a: "0.6"
  },
  {
    n: [
      "hear no evil",
      "hear-no-evil monkey"
    ],
    u: "1f649",
    a: "0.6"
  },
  {
    n: [
      "speak no evil",
      "speak-no-evil monkey"
    ],
    u: "1f64a",
    a: "0.6"
  },
  {
    n: [
      "kiss",
      "kiss mark"
    ],
    u: "1f48b",
    a: "0.6"
  },
  {
    n: [
      "love letter"
    ],
    u: "1f48c",
    a: "0.6"
  },
  {
    n: [
      "cupid",
      "heart with arrow"
    ],
    u: "1f498",
    a: "0.6"
  },
  {
    n: [
      "gift heart",
      "heart with ribbon"
    ],
    u: "1f49d",
    a: "0.6"
  },
  {
    n: [
      "sparkling heart"
    ],
    u: "1f496",
    a: "0.6"
  },
  {
    n: [
      "heartpulse",
      "growing heart"
    ],
    u: "1f497",
    a: "0.6"
  },
  {
    n: [
      "heartbeat",
      "beating heart"
    ],
    u: "1f493",
    a: "0.6"
  },
  {
    n: [
      "revolving hearts"
    ],
    u: "1f49e",
    a: "0.6"
  },
  {
    n: [
      "two hearts"
    ],
    u: "1f495",
    a: "0.6"
  },
  {
    n: [
      "heart decoration"
    ],
    u: "1f49f",
    a: "0.6"
  },
  {
    n: [
      "heart exclamation",
      "heavy heart exclamation mark ornament"
    ],
    u: "2763-fe0f",
    a: "1.0"
  },
  {
    n: [
      "broken heart"
    ],
    u: "1f494",
    a: "0.6"
  },
  {
    n: [
      "heart on fire"
    ],
    u: "2764-fe0f-200d-1f525",
    a: "13.1"
  },
  {
    n: [
      "mending heart"
    ],
    u: "2764-fe0f-200d-1fa79",
    a: "13.1"
  },
  {
    n: [
      "heart",
      "heavy black heart"
    ],
    u: "2764-fe0f",
    a: "0.6"
  },
  {
    n: [
      "orange heart"
    ],
    u: "1f9e1",
    a: "5.0"
  },
  {
    n: [
      "yellow heart"
    ],
    u: "1f49b",
    a: "0.6"
  },
  {
    n: [
      "green heart"
    ],
    u: "1f49a",
    a: "0.6"
  },
  {
    n: [
      "blue heart"
    ],
    u: "1f499",
    a: "0.6"
  },
  {
    n: [
      "purple heart"
    ],
    u: "1f49c",
    a: "0.6"
  },
  {
    n: [
      "brown heart"
    ],
    u: "1f90e",
    a: "12.0"
  },
  {
    n: [
      "black heart"
    ],
    u: "1f5a4",
    a: "3.0"
  },
  {
    n: [
      "white heart"
    ],
    u: "1f90d",
    a: "12.0"
  },
  {
    n: [
      "100",
      "hundred points symbol"
    ],
    u: "1f4af",
    a: "0.6"
  },
  {
    n: [
      "anger",
      "anger symbol"
    ],
    u: "1f4a2",
    a: "0.6"
  },
  {
    n: [
      "boom",
      "collision",
      "collision symbol"
    ],
    u: "1f4a5",
    a: "0.6"
  },
  {
    n: [
      "dizzy",
      "dizzy symbol"
    ],
    u: "1f4ab",
    a: "0.6"
  },
  {
    n: [
      "sweat drops",
      "splashing sweat symbol"
    ],
    u: "1f4a6",
    a: "0.6"
  },
  {
    n: [
      "dash",
      "dash symbol"
    ],
    u: "1f4a8",
    a: "0.6"
  },
  {
    n: [
      "hole"
    ],
    u: "1f573-fe0f",
    a: "0.7"
  },
  {
    n: [
      "bomb"
    ],
    u: "1f4a3",
    a: "0.6"
  },
  {
    n: [
      "speech balloon"
    ],
    u: "1f4ac",
    a: "0.6"
  },
  {
    n: [
      "eye in speech bubble",
      "eye-in-speech-bubble"
    ],
    u: "1f441-fe0f-200d-1f5e8-fe0f",
    a: "2.0"
  },
  {
    n: [
      "left speech bubble"
    ],
    u: "1f5e8-fe0f",
    a: "2.0"
  },
  {
    n: [
      "right anger bubble"
    ],
    u: "1f5ef-fe0f",
    a: "0.7"
  },
  {
    n: [
      "thought balloon"
    ],
    u: "1f4ad",
    a: "1.0"
  },
  {
    n: [
      "zzz",
      "sleeping symbol"
    ],
    u: "1f4a4",
    a: "0.6"
  },
  {
    n: [
      "wave",
      "waving hand sign"
    ],
    u: "1f44b",
    v: [
      "1f44b-1f3fb",
      "1f44b-1f3fc",
      "1f44b-1f3fd",
      "1f44b-1f3fe",
      "1f44b-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "raised back of hand"
    ],
    u: "1f91a",
    v: [
      "1f91a-1f3fb",
      "1f91a-1f3fc",
      "1f91a-1f3fd",
      "1f91a-1f3fe",
      "1f91a-1f3ff"
    ],
    a: "3.0"
  },
  {
    n: [
      "hand with fingers splayed",
      "raised hand with fingers splayed"
    ],
    u: "1f590-fe0f",
    v: [
      "1f590-1f3fb",
      "1f590-1f3fc",
      "1f590-1f3fd",
      "1f590-1f3fe",
      "1f590-1f3ff"
    ],
    a: "0.7"
  },
  {
    n: [
      "hand",
      "raised hand"
    ],
    u: "270b",
    v: [
      "270b-1f3fb",
      "270b-1f3fc",
      "270b-1f3fd",
      "270b-1f3fe",
      "270b-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "spock-hand",
      "raised hand with part between middle and ring fingers"
    ],
    u: "1f596",
    v: [
      "1f596-1f3fb",
      "1f596-1f3fc",
      "1f596-1f3fd",
      "1f596-1f3fe",
      "1f596-1f3ff"
    ],
    a: "1.0"
  },
  {
    n: [
      "rightwards hand"
    ],
    u: "1faf1",
    v: [
      "1faf1-1f3fb",
      "1faf1-1f3fc",
      "1faf1-1f3fd",
      "1faf1-1f3fe",
      "1faf1-1f3ff"
    ],
    a: "14.0"
  },
  {
    n: [
      "leftwards hand"
    ],
    u: "1faf2",
    v: [
      "1faf2-1f3fb",
      "1faf2-1f3fc",
      "1faf2-1f3fd",
      "1faf2-1f3fe",
      "1faf2-1f3ff"
    ],
    a: "14.0"
  },
  {
    n: [
      "palm down hand"
    ],
    u: "1faf3",
    v: [
      "1faf3-1f3fb",
      "1faf3-1f3fc",
      "1faf3-1f3fd",
      "1faf3-1f3fe",
      "1faf3-1f3ff"
    ],
    a: "14.0"
  },
  {
    n: [
      "palm up hand"
    ],
    u: "1faf4",
    v: [
      "1faf4-1f3fb",
      "1faf4-1f3fc",
      "1faf4-1f3fd",
      "1faf4-1f3fe",
      "1faf4-1f3ff"
    ],
    a: "14.0"
  },
  {
    n: [
      "ok hand",
      "ok hand sign"
    ],
    u: "1f44c",
    v: [
      "1f44c-1f3fb",
      "1f44c-1f3fc",
      "1f44c-1f3fd",
      "1f44c-1f3fe",
      "1f44c-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "pinched fingers"
    ],
    u: "1f90c",
    v: [
      "1f90c-1f3fb",
      "1f90c-1f3fc",
      "1f90c-1f3fd",
      "1f90c-1f3fe",
      "1f90c-1f3ff"
    ],
    a: "13.0"
  },
  {
    n: [
      "pinching hand"
    ],
    u: "1f90f",
    v: [
      "1f90f-1f3fb",
      "1f90f-1f3fc",
      "1f90f-1f3fd",
      "1f90f-1f3fe",
      "1f90f-1f3ff"
    ],
    a: "12.0"
  },
  {
    n: [
      "v",
      "victory hand"
    ],
    u: "270c-fe0f",
    v: [
      "270c-1f3fb",
      "270c-1f3fc",
      "270c-1f3fd",
      "270c-1f3fe",
      "270c-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "crossed fingers",
      "hand with index and middle fingers crossed"
    ],
    u: "1f91e",
    v: [
      "1f91e-1f3fb",
      "1f91e-1f3fc",
      "1f91e-1f3fd",
      "1f91e-1f3fe",
      "1f91e-1f3ff"
    ],
    a: "3.0"
  },
  {
    n: [
      "hand with index finger and thumb crossed"
    ],
    u: "1faf0",
    v: [
      "1faf0-1f3fb",
      "1faf0-1f3fc",
      "1faf0-1f3fd",
      "1faf0-1f3fe",
      "1faf0-1f3ff"
    ],
    a: "14.0"
  },
  {
    n: [
      "i love you hand sign"
    ],
    u: "1f91f",
    v: [
      "1f91f-1f3fb",
      "1f91f-1f3fc",
      "1f91f-1f3fd",
      "1f91f-1f3fe",
      "1f91f-1f3ff"
    ],
    a: "5.0"
  },
  {
    n: [
      "the horns",
      "sign of the horns"
    ],
    u: "1f918",
    v: [
      "1f918-1f3fb",
      "1f918-1f3fc",
      "1f918-1f3fd",
      "1f918-1f3fe",
      "1f918-1f3ff"
    ],
    a: "1.0"
  },
  {
    n: [
      "call me hand"
    ],
    u: "1f919",
    v: [
      "1f919-1f3fb",
      "1f919-1f3fc",
      "1f919-1f3fd",
      "1f919-1f3fe",
      "1f919-1f3ff"
    ],
    a: "3.0"
  },
  {
    n: [
      "point left",
      "white left pointing backhand index"
    ],
    u: "1f448",
    v: [
      "1f448-1f3fb",
      "1f448-1f3fc",
      "1f448-1f3fd",
      "1f448-1f3fe",
      "1f448-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "point right",
      "white right pointing backhand index"
    ],
    u: "1f449",
    v: [
      "1f449-1f3fb",
      "1f449-1f3fc",
      "1f449-1f3fd",
      "1f449-1f3fe",
      "1f449-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "point up 2",
      "white up pointing backhand index"
    ],
    u: "1f446",
    v: [
      "1f446-1f3fb",
      "1f446-1f3fc",
      "1f446-1f3fd",
      "1f446-1f3fe",
      "1f446-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "middle finger",
      "reversed hand with middle finger extended"
    ],
    u: "1f595",
    v: [
      "1f595-1f3fb",
      "1f595-1f3fc",
      "1f595-1f3fd",
      "1f595-1f3fe",
      "1f595-1f3ff"
    ],
    a: "1.0"
  },
  {
    n: [
      "point down",
      "white down pointing backhand index"
    ],
    u: "1f447",
    v: [
      "1f447-1f3fb",
      "1f447-1f3fc",
      "1f447-1f3fd",
      "1f447-1f3fe",
      "1f447-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "point up",
      "white up pointing index"
    ],
    u: "261d-fe0f",
    v: [
      "261d-1f3fb",
      "261d-1f3fc",
      "261d-1f3fd",
      "261d-1f3fe",
      "261d-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "index pointing at the viewer"
    ],
    u: "1faf5",
    v: [
      "1faf5-1f3fb",
      "1faf5-1f3fc",
      "1faf5-1f3fd",
      "1faf5-1f3fe",
      "1faf5-1f3ff"
    ],
    a: "14.0"
  },
  {
    n: [
      "+1",
      "thumbsup",
      "thumbs up sign"
    ],
    u: "1f44d",
    v: [
      "1f44d-1f3fb",
      "1f44d-1f3fc",
      "1f44d-1f3fd",
      "1f44d-1f3fe",
      "1f44d-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "-1",
      "thumbsdown",
      "thumbs down sign"
    ],
    u: "1f44e",
    v: [
      "1f44e-1f3fb",
      "1f44e-1f3fc",
      "1f44e-1f3fd",
      "1f44e-1f3fe",
      "1f44e-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "fist",
      "raised fist"
    ],
    u: "270a",
    v: [
      "270a-1f3fb",
      "270a-1f3fc",
      "270a-1f3fd",
      "270a-1f3fe",
      "270a-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "punch",
      "facepunch",
      "fisted hand sign"
    ],
    u: "1f44a",
    v: [
      "1f44a-1f3fb",
      "1f44a-1f3fc",
      "1f44a-1f3fd",
      "1f44a-1f3fe",
      "1f44a-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "left-facing fist"
    ],
    u: "1f91b",
    v: [
      "1f91b-1f3fb",
      "1f91b-1f3fc",
      "1f91b-1f3fd",
      "1f91b-1f3fe",
      "1f91b-1f3ff"
    ],
    a: "3.0"
  },
  {
    n: [
      "right-facing fist"
    ],
    u: "1f91c",
    v: [
      "1f91c-1f3fb",
      "1f91c-1f3fc",
      "1f91c-1f3fd",
      "1f91c-1f3fe",
      "1f91c-1f3ff"
    ],
    a: "3.0"
  },
  {
    n: [
      "clap",
      "clapping hands sign"
    ],
    u: "1f44f",
    v: [
      "1f44f-1f3fb",
      "1f44f-1f3fc",
      "1f44f-1f3fd",
      "1f44f-1f3fe",
      "1f44f-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "raised hands",
      "person raising both hands in celebration"
    ],
    u: "1f64c",
    v: [
      "1f64c-1f3fb",
      "1f64c-1f3fc",
      "1f64c-1f3fd",
      "1f64c-1f3fe",
      "1f64c-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "heart hands"
    ],
    u: "1faf6",
    v: [
      "1faf6-1f3fb",
      "1faf6-1f3fc",
      "1faf6-1f3fd",
      "1faf6-1f3fe",
      "1faf6-1f3ff"
    ],
    a: "14.0"
  },
  {
    n: [
      "open hands",
      "open hands sign"
    ],
    u: "1f450",
    v: [
      "1f450-1f3fb",
      "1f450-1f3fc",
      "1f450-1f3fd",
      "1f450-1f3fe",
      "1f450-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "palms up together"
    ],
    u: "1f932",
    v: [
      "1f932-1f3fb",
      "1f932-1f3fc",
      "1f932-1f3fd",
      "1f932-1f3fe",
      "1f932-1f3ff"
    ],
    a: "5.0"
  },
  {
    n: [
      "handshake"
    ],
    u: "1f91d",
    v: [
      "1f91d-1f3fb",
      "1f91d-1f3fc",
      "1f91d-1f3fd",
      "1f91d-1f3fe",
      "1f91d-1f3ff",
      "1faf1-1f3fb-200d-1faf2-1f3fc",
      "1faf1-1f3fb-200d-1faf2-1f3fd",
      "1faf1-1f3fb-200d-1faf2-1f3fe",
      "1faf1-1f3fb-200d-1faf2-1f3ff",
      "1faf1-1f3fc-200d-1faf2-1f3fb",
      "1faf1-1f3fc-200d-1faf2-1f3fd",
      "1faf1-1f3fc-200d-1faf2-1f3fe",
      "1faf1-1f3fc-200d-1faf2-1f3ff",
      "1faf1-1f3fd-200d-1faf2-1f3fb",
      "1faf1-1f3fd-200d-1faf2-1f3fc",
      "1faf1-1f3fd-200d-1faf2-1f3fe",
      "1faf1-1f3fd-200d-1faf2-1f3ff",
      "1faf1-1f3fe-200d-1faf2-1f3fb",
      "1faf1-1f3fe-200d-1faf2-1f3fc",
      "1faf1-1f3fe-200d-1faf2-1f3fd",
      "1faf1-1f3fe-200d-1faf2-1f3ff",
      "1faf1-1f3ff-200d-1faf2-1f3fb",
      "1faf1-1f3ff-200d-1faf2-1f3fc",
      "1faf1-1f3ff-200d-1faf2-1f3fd",
      "1faf1-1f3ff-200d-1faf2-1f3fe"
    ],
    a: "3.0"
  },
  {
    n: [
      "pray",
      "person with folded hands"
    ],
    u: "1f64f",
    v: [
      "1f64f-1f3fb",
      "1f64f-1f3fc",
      "1f64f-1f3fd",
      "1f64f-1f3fe",
      "1f64f-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "writing hand"
    ],
    u: "270d-fe0f",
    v: [
      "270d-1f3fb",
      "270d-1f3fc",
      "270d-1f3fd",
      "270d-1f3fe",
      "270d-1f3ff"
    ],
    a: "0.7"
  },
  {
    n: [
      "nail care",
      "nail polish"
    ],
    u: "1f485",
    v: [
      "1f485-1f3fb",
      "1f485-1f3fc",
      "1f485-1f3fd",
      "1f485-1f3fe",
      "1f485-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "selfie"
    ],
    u: "1f933",
    v: [
      "1f933-1f3fb",
      "1f933-1f3fc",
      "1f933-1f3fd",
      "1f933-1f3fe",
      "1f933-1f3ff"
    ],
    a: "3.0"
  },
  {
    n: [
      "muscle",
      "flexed biceps"
    ],
    u: "1f4aa",
    v: [
      "1f4aa-1f3fb",
      "1f4aa-1f3fc",
      "1f4aa-1f3fd",
      "1f4aa-1f3fe",
      "1f4aa-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "mechanical arm"
    ],
    u: "1f9be",
    a: "12.0"
  },
  {
    n: [
      "mechanical leg"
    ],
    u: "1f9bf",
    a: "12.0"
  },
  {
    n: [
      "leg"
    ],
    u: "1f9b5",
    v: [
      "1f9b5-1f3fb",
      "1f9b5-1f3fc",
      "1f9b5-1f3fd",
      "1f9b5-1f3fe",
      "1f9b5-1f3ff"
    ],
    a: "11.0"
  },
  {
    n: [
      "foot"
    ],
    u: "1f9b6",
    v: [
      "1f9b6-1f3fb",
      "1f9b6-1f3fc",
      "1f9b6-1f3fd",
      "1f9b6-1f3fe",
      "1f9b6-1f3ff"
    ],
    a: "11.0"
  },
  {
    n: [
      "ear"
    ],
    u: "1f442",
    v: [
      "1f442-1f3fb",
      "1f442-1f3fc",
      "1f442-1f3fd",
      "1f442-1f3fe",
      "1f442-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "ear with hearing aid"
    ],
    u: "1f9bb",
    v: [
      "1f9bb-1f3fb",
      "1f9bb-1f3fc",
      "1f9bb-1f3fd",
      "1f9bb-1f3fe",
      "1f9bb-1f3ff"
    ],
    a: "12.0"
  },
  {
    n: [
      "nose"
    ],
    u: "1f443",
    v: [
      "1f443-1f3fb",
      "1f443-1f3fc",
      "1f443-1f3fd",
      "1f443-1f3fe",
      "1f443-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "brain"
    ],
    u: "1f9e0",
    a: "5.0"
  },
  {
    n: [
      "anatomical heart"
    ],
    u: "1fac0",
    a: "13.0"
  },
  {
    n: [
      "lungs"
    ],
    u: "1fac1",
    a: "13.0"
  },
  {
    n: [
      "tooth"
    ],
    u: "1f9b7",
    a: "11.0"
  },
  {
    n: [
      "bone"
    ],
    u: "1f9b4",
    a: "11.0"
  },
  {
    n: [
      "eyes"
    ],
    u: "1f440",
    a: "0.6"
  },
  {
    n: [
      "eye"
    ],
    u: "1f441-fe0f",
    a: "0.7"
  },
  {
    n: [
      "tongue"
    ],
    u: "1f445",
    a: "0.6"
  },
  {
    n: [
      "lips",
      "mouth"
    ],
    u: "1f444",
    a: "0.6"
  },
  {
    n: [
      "biting lip"
    ],
    u: "1fae6",
    a: "14.0"
  },
  {
    n: [
      "baby"
    ],
    u: "1f476",
    v: [
      "1f476-1f3fb",
      "1f476-1f3fc",
      "1f476-1f3fd",
      "1f476-1f3fe",
      "1f476-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "child"
    ],
    u: "1f9d2",
    v: [
      "1f9d2-1f3fb",
      "1f9d2-1f3fc",
      "1f9d2-1f3fd",
      "1f9d2-1f3fe",
      "1f9d2-1f3ff"
    ],
    a: "5.0"
  },
  {
    n: [
      "boy"
    ],
    u: "1f466",
    v: [
      "1f466-1f3fb",
      "1f466-1f3fc",
      "1f466-1f3fd",
      "1f466-1f3fe",
      "1f466-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "girl"
    ],
    u: "1f467",
    v: [
      "1f467-1f3fb",
      "1f467-1f3fc",
      "1f467-1f3fd",
      "1f467-1f3fe",
      "1f467-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "adult"
    ],
    u: "1f9d1",
    v: [
      "1f9d1-1f3fb",
      "1f9d1-1f3fc",
      "1f9d1-1f3fd",
      "1f9d1-1f3fe",
      "1f9d1-1f3ff"
    ],
    a: "5.0"
  },
  {
    n: [
      "person with blond hair"
    ],
    u: "1f471",
    v: [
      "1f471-1f3fb",
      "1f471-1f3fc",
      "1f471-1f3fd",
      "1f471-1f3fe",
      "1f471-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "man"
    ],
    u: "1f468",
    v: [
      "1f468-1f3fb",
      "1f468-1f3fc",
      "1f468-1f3fd",
      "1f468-1f3fe",
      "1f468-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "bearded person"
    ],
    u: "1f9d4",
    v: [
      "1f9d4-1f3fb",
      "1f9d4-1f3fc",
      "1f9d4-1f3fd",
      "1f9d4-1f3fe",
      "1f9d4-1f3ff"
    ],
    a: "5.0"
  },
  {
    n: [
      "man: beard",
      "man with beard"
    ],
    u: "1f9d4-200d-2642-fe0f",
    v: [
      "1f9d4-1f3fb-200d-2642-fe0f",
      "1f9d4-1f3fc-200d-2642-fe0f",
      "1f9d4-1f3fd-200d-2642-fe0f",
      "1f9d4-1f3fe-200d-2642-fe0f",
      "1f9d4-1f3ff-200d-2642-fe0f"
    ],
    a: "13.1"
  },
  {
    n: [
      "woman: beard",
      "woman with beard"
    ],
    u: "1f9d4-200d-2640-fe0f",
    v: [
      "1f9d4-1f3fb-200d-2640-fe0f",
      "1f9d4-1f3fc-200d-2640-fe0f",
      "1f9d4-1f3fd-200d-2640-fe0f",
      "1f9d4-1f3fe-200d-2640-fe0f",
      "1f9d4-1f3ff-200d-2640-fe0f"
    ],
    a: "13.1"
  },
  {
    n: [
      "man: red hair",
      "red haired man"
    ],
    u: "1f468-200d-1f9b0",
    v: [
      "1f468-1f3fb-200d-1f9b0",
      "1f468-1f3fc-200d-1f9b0",
      "1f468-1f3fd-200d-1f9b0",
      "1f468-1f3fe-200d-1f9b0",
      "1f468-1f3ff-200d-1f9b0"
    ],
    a: "11.0"
  },
  {
    n: [
      "man: curly hair",
      "curly haired man"
    ],
    u: "1f468-200d-1f9b1",
    v: [
      "1f468-1f3fb-200d-1f9b1",
      "1f468-1f3fc-200d-1f9b1",
      "1f468-1f3fd-200d-1f9b1",
      "1f468-1f3fe-200d-1f9b1",
      "1f468-1f3ff-200d-1f9b1"
    ],
    a: "11.0"
  },
  {
    n: [
      "man: white hair",
      "white haired man"
    ],
    u: "1f468-200d-1f9b3",
    v: [
      "1f468-1f3fb-200d-1f9b3",
      "1f468-1f3fc-200d-1f9b3",
      "1f468-1f3fd-200d-1f9b3",
      "1f468-1f3fe-200d-1f9b3",
      "1f468-1f3ff-200d-1f9b3"
    ],
    a: "11.0"
  },
  {
    n: [
      "bald man",
      "man: bald"
    ],
    u: "1f468-200d-1f9b2",
    v: [
      "1f468-1f3fb-200d-1f9b2",
      "1f468-1f3fc-200d-1f9b2",
      "1f468-1f3fd-200d-1f9b2",
      "1f468-1f3fe-200d-1f9b2",
      "1f468-1f3ff-200d-1f9b2"
    ],
    a: "11.0"
  },
  {
    n: [
      "woman"
    ],
    u: "1f469",
    v: [
      "1f469-1f3fb",
      "1f469-1f3fc",
      "1f469-1f3fd",
      "1f469-1f3fe",
      "1f469-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "woman: red hair",
      "red haired woman"
    ],
    u: "1f469-200d-1f9b0",
    v: [
      "1f469-1f3fb-200d-1f9b0",
      "1f469-1f3fc-200d-1f9b0",
      "1f469-1f3fd-200d-1f9b0",
      "1f469-1f3fe-200d-1f9b0",
      "1f469-1f3ff-200d-1f9b0"
    ],
    a: "11.0"
  },
  {
    n: [
      "person: red hair",
      "red haired person"
    ],
    u: "1f9d1-200d-1f9b0",
    v: [
      "1f9d1-1f3fb-200d-1f9b0",
      "1f9d1-1f3fc-200d-1f9b0",
      "1f9d1-1f3fd-200d-1f9b0",
      "1f9d1-1f3fe-200d-1f9b0",
      "1f9d1-1f3ff-200d-1f9b0"
    ],
    a: "12.1"
  },
  {
    n: [
      "woman: curly hair",
      "curly haired woman"
    ],
    u: "1f469-200d-1f9b1",
    v: [
      "1f469-1f3fb-200d-1f9b1",
      "1f469-1f3fc-200d-1f9b1",
      "1f469-1f3fd-200d-1f9b1",
      "1f469-1f3fe-200d-1f9b1",
      "1f469-1f3ff-200d-1f9b1"
    ],
    a: "11.0"
  },
  {
    n: [
      "person: curly hair",
      "curly haired person"
    ],
    u: "1f9d1-200d-1f9b1",
    v: [
      "1f9d1-1f3fb-200d-1f9b1",
      "1f9d1-1f3fc-200d-1f9b1",
      "1f9d1-1f3fd-200d-1f9b1",
      "1f9d1-1f3fe-200d-1f9b1",
      "1f9d1-1f3ff-200d-1f9b1"
    ],
    a: "12.1"
  },
  {
    n: [
      "woman: white hair",
      "white haired woman"
    ],
    u: "1f469-200d-1f9b3",
    v: [
      "1f469-1f3fb-200d-1f9b3",
      "1f469-1f3fc-200d-1f9b3",
      "1f469-1f3fd-200d-1f9b3",
      "1f469-1f3fe-200d-1f9b3",
      "1f469-1f3ff-200d-1f9b3"
    ],
    a: "11.0"
  },
  {
    n: [
      "person: white hair",
      "white haired person"
    ],
    u: "1f9d1-200d-1f9b3",
    v: [
      "1f9d1-1f3fb-200d-1f9b3",
      "1f9d1-1f3fc-200d-1f9b3",
      "1f9d1-1f3fd-200d-1f9b3",
      "1f9d1-1f3fe-200d-1f9b3",
      "1f9d1-1f3ff-200d-1f9b3"
    ],
    a: "12.1"
  },
  {
    n: [
      "bald woman",
      "woman: bald"
    ],
    u: "1f469-200d-1f9b2",
    v: [
      "1f469-1f3fb-200d-1f9b2",
      "1f469-1f3fc-200d-1f9b2",
      "1f469-1f3fd-200d-1f9b2",
      "1f469-1f3fe-200d-1f9b2",
      "1f469-1f3ff-200d-1f9b2"
    ],
    a: "11.0"
  },
  {
    n: [
      "bald person",
      "person: bald"
    ],
    u: "1f9d1-200d-1f9b2",
    v: [
      "1f9d1-1f3fb-200d-1f9b2",
      "1f9d1-1f3fc-200d-1f9b2",
      "1f9d1-1f3fd-200d-1f9b2",
      "1f9d1-1f3fe-200d-1f9b2",
      "1f9d1-1f3ff-200d-1f9b2"
    ],
    a: "12.1"
  },
  {
    n: [
      "woman: blond hair",
      "blond-haired-woman"
    ],
    u: "1f471-200d-2640-fe0f",
    v: [
      "1f471-1f3fb-200d-2640-fe0f",
      "1f471-1f3fc-200d-2640-fe0f",
      "1f471-1f3fd-200d-2640-fe0f",
      "1f471-1f3fe-200d-2640-fe0f",
      "1f471-1f3ff-200d-2640-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "man: blond hair",
      "blond-haired-man"
    ],
    u: "1f471-200d-2642-fe0f",
    v: [
      "1f471-1f3fb-200d-2642-fe0f",
      "1f471-1f3fc-200d-2642-fe0f",
      "1f471-1f3fd-200d-2642-fe0f",
      "1f471-1f3fe-200d-2642-fe0f",
      "1f471-1f3ff-200d-2642-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "older adult"
    ],
    u: "1f9d3",
    v: [
      "1f9d3-1f3fb",
      "1f9d3-1f3fc",
      "1f9d3-1f3fd",
      "1f9d3-1f3fe",
      "1f9d3-1f3ff"
    ],
    a: "5.0"
  },
  {
    n: [
      "older man"
    ],
    u: "1f474",
    v: [
      "1f474-1f3fb",
      "1f474-1f3fc",
      "1f474-1f3fd",
      "1f474-1f3fe",
      "1f474-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "older woman"
    ],
    u: "1f475",
    v: [
      "1f475-1f3fb",
      "1f475-1f3fc",
      "1f475-1f3fd",
      "1f475-1f3fe",
      "1f475-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "person frowning"
    ],
    u: "1f64d",
    v: [
      "1f64d-1f3fb",
      "1f64d-1f3fc",
      "1f64d-1f3fd",
      "1f64d-1f3fe",
      "1f64d-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "man frowning",
      "man-frowning"
    ],
    u: "1f64d-200d-2642-fe0f",
    v: [
      "1f64d-1f3fb-200d-2642-fe0f",
      "1f64d-1f3fc-200d-2642-fe0f",
      "1f64d-1f3fd-200d-2642-fe0f",
      "1f64d-1f3fe-200d-2642-fe0f",
      "1f64d-1f3ff-200d-2642-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "woman frowning",
      "woman-frowning"
    ],
    u: "1f64d-200d-2640-fe0f",
    v: [
      "1f64d-1f3fb-200d-2640-fe0f",
      "1f64d-1f3fc-200d-2640-fe0f",
      "1f64d-1f3fd-200d-2640-fe0f",
      "1f64d-1f3fe-200d-2640-fe0f",
      "1f64d-1f3ff-200d-2640-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "person with pouting face"
    ],
    u: "1f64e",
    v: [
      "1f64e-1f3fb",
      "1f64e-1f3fc",
      "1f64e-1f3fd",
      "1f64e-1f3fe",
      "1f64e-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "man pouting",
      "man-pouting"
    ],
    u: "1f64e-200d-2642-fe0f",
    v: [
      "1f64e-1f3fb-200d-2642-fe0f",
      "1f64e-1f3fc-200d-2642-fe0f",
      "1f64e-1f3fd-200d-2642-fe0f",
      "1f64e-1f3fe-200d-2642-fe0f",
      "1f64e-1f3ff-200d-2642-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "woman pouting",
      "woman-pouting"
    ],
    u: "1f64e-200d-2640-fe0f",
    v: [
      "1f64e-1f3fb-200d-2640-fe0f",
      "1f64e-1f3fc-200d-2640-fe0f",
      "1f64e-1f3fd-200d-2640-fe0f",
      "1f64e-1f3fe-200d-2640-fe0f",
      "1f64e-1f3ff-200d-2640-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "no good",
      "face with no good gesture"
    ],
    u: "1f645",
    v: [
      "1f645-1f3fb",
      "1f645-1f3fc",
      "1f645-1f3fd",
      "1f645-1f3fe",
      "1f645-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "man gesturing no",
      "man-gesturing-no"
    ],
    u: "1f645-200d-2642-fe0f",
    v: [
      "1f645-1f3fb-200d-2642-fe0f",
      "1f645-1f3fc-200d-2642-fe0f",
      "1f645-1f3fd-200d-2642-fe0f",
      "1f645-1f3fe-200d-2642-fe0f",
      "1f645-1f3ff-200d-2642-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "woman gesturing no",
      "woman-gesturing-no"
    ],
    u: "1f645-200d-2640-fe0f",
    v: [
      "1f645-1f3fb-200d-2640-fe0f",
      "1f645-1f3fc-200d-2640-fe0f",
      "1f645-1f3fd-200d-2640-fe0f",
      "1f645-1f3fe-200d-2640-fe0f",
      "1f645-1f3ff-200d-2640-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "ok woman",
      "face with ok gesture"
    ],
    u: "1f646",
    v: [
      "1f646-1f3fb",
      "1f646-1f3fc",
      "1f646-1f3fd",
      "1f646-1f3fe",
      "1f646-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "man gesturing ok",
      "man-gesturing-ok"
    ],
    u: "1f646-200d-2642-fe0f",
    v: [
      "1f646-1f3fb-200d-2642-fe0f",
      "1f646-1f3fc-200d-2642-fe0f",
      "1f646-1f3fd-200d-2642-fe0f",
      "1f646-1f3fe-200d-2642-fe0f",
      "1f646-1f3ff-200d-2642-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "woman gesturing ok",
      "woman-gesturing-ok"
    ],
    u: "1f646-200d-2640-fe0f",
    v: [
      "1f646-1f3fb-200d-2640-fe0f",
      "1f646-1f3fc-200d-2640-fe0f",
      "1f646-1f3fd-200d-2640-fe0f",
      "1f646-1f3fe-200d-2640-fe0f",
      "1f646-1f3ff-200d-2640-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "information desk person"
    ],
    u: "1f481",
    v: [
      "1f481-1f3fb",
      "1f481-1f3fc",
      "1f481-1f3fd",
      "1f481-1f3fe",
      "1f481-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "man tipping hand",
      "man-tipping-hand"
    ],
    u: "1f481-200d-2642-fe0f",
    v: [
      "1f481-1f3fb-200d-2642-fe0f",
      "1f481-1f3fc-200d-2642-fe0f",
      "1f481-1f3fd-200d-2642-fe0f",
      "1f481-1f3fe-200d-2642-fe0f",
      "1f481-1f3ff-200d-2642-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "woman tipping hand",
      "woman-tipping-hand"
    ],
    u: "1f481-200d-2640-fe0f",
    v: [
      "1f481-1f3fb-200d-2640-fe0f",
      "1f481-1f3fc-200d-2640-fe0f",
      "1f481-1f3fd-200d-2640-fe0f",
      "1f481-1f3fe-200d-2640-fe0f",
      "1f481-1f3ff-200d-2640-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "raising hand",
      "happy person raising one hand"
    ],
    u: "1f64b",
    v: [
      "1f64b-1f3fb",
      "1f64b-1f3fc",
      "1f64b-1f3fd",
      "1f64b-1f3fe",
      "1f64b-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "man raising hand",
      "man-raising-hand"
    ],
    u: "1f64b-200d-2642-fe0f",
    v: [
      "1f64b-1f3fb-200d-2642-fe0f",
      "1f64b-1f3fc-200d-2642-fe0f",
      "1f64b-1f3fd-200d-2642-fe0f",
      "1f64b-1f3fe-200d-2642-fe0f",
      "1f64b-1f3ff-200d-2642-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "woman raising hand",
      "woman-raising-hand"
    ],
    u: "1f64b-200d-2640-fe0f",
    v: [
      "1f64b-1f3fb-200d-2640-fe0f",
      "1f64b-1f3fc-200d-2640-fe0f",
      "1f64b-1f3fd-200d-2640-fe0f",
      "1f64b-1f3fe-200d-2640-fe0f",
      "1f64b-1f3ff-200d-2640-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "deaf person"
    ],
    u: "1f9cf",
    v: [
      "1f9cf-1f3fb",
      "1f9cf-1f3fc",
      "1f9cf-1f3fd",
      "1f9cf-1f3fe",
      "1f9cf-1f3ff"
    ],
    a: "12.0"
  },
  {
    n: [
      "deaf man"
    ],
    u: "1f9cf-200d-2642-fe0f",
    v: [
      "1f9cf-1f3fb-200d-2642-fe0f",
      "1f9cf-1f3fc-200d-2642-fe0f",
      "1f9cf-1f3fd-200d-2642-fe0f",
      "1f9cf-1f3fe-200d-2642-fe0f",
      "1f9cf-1f3ff-200d-2642-fe0f"
    ],
    a: "12.0"
  },
  {
    n: [
      "deaf woman"
    ],
    u: "1f9cf-200d-2640-fe0f",
    v: [
      "1f9cf-1f3fb-200d-2640-fe0f",
      "1f9cf-1f3fc-200d-2640-fe0f",
      "1f9cf-1f3fd-200d-2640-fe0f",
      "1f9cf-1f3fe-200d-2640-fe0f",
      "1f9cf-1f3ff-200d-2640-fe0f"
    ],
    a: "12.0"
  },
  {
    n: [
      "bow",
      "person bowing deeply"
    ],
    u: "1f647",
    v: [
      "1f647-1f3fb",
      "1f647-1f3fc",
      "1f647-1f3fd",
      "1f647-1f3fe",
      "1f647-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "man bowing",
      "man-bowing"
    ],
    u: "1f647-200d-2642-fe0f",
    v: [
      "1f647-1f3fb-200d-2642-fe0f",
      "1f647-1f3fc-200d-2642-fe0f",
      "1f647-1f3fd-200d-2642-fe0f",
      "1f647-1f3fe-200d-2642-fe0f",
      "1f647-1f3ff-200d-2642-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "woman bowing",
      "woman-bowing"
    ],
    u: "1f647-200d-2640-fe0f",
    v: [
      "1f647-1f3fb-200d-2640-fe0f",
      "1f647-1f3fc-200d-2640-fe0f",
      "1f647-1f3fd-200d-2640-fe0f",
      "1f647-1f3fe-200d-2640-fe0f",
      "1f647-1f3ff-200d-2640-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "face palm"
    ],
    u: "1f926",
    v: [
      "1f926-1f3fb",
      "1f926-1f3fc",
      "1f926-1f3fd",
      "1f926-1f3fe",
      "1f926-1f3ff"
    ],
    a: "3.0"
  },
  {
    n: [
      "man facepalming",
      "man-facepalming"
    ],
    u: "1f926-200d-2642-fe0f",
    v: [
      "1f926-1f3fb-200d-2642-fe0f",
      "1f926-1f3fc-200d-2642-fe0f",
      "1f926-1f3fd-200d-2642-fe0f",
      "1f926-1f3fe-200d-2642-fe0f",
      "1f926-1f3ff-200d-2642-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "woman facepalming",
      "woman-facepalming"
    ],
    u: "1f926-200d-2640-fe0f",
    v: [
      "1f926-1f3fb-200d-2640-fe0f",
      "1f926-1f3fc-200d-2640-fe0f",
      "1f926-1f3fd-200d-2640-fe0f",
      "1f926-1f3fe-200d-2640-fe0f",
      "1f926-1f3ff-200d-2640-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "shrug"
    ],
    u: "1f937",
    v: [
      "1f937-1f3fb",
      "1f937-1f3fc",
      "1f937-1f3fd",
      "1f937-1f3fe",
      "1f937-1f3ff"
    ],
    a: "3.0"
  },
  {
    n: [
      "man shrugging",
      "man-shrugging"
    ],
    u: "1f937-200d-2642-fe0f",
    v: [
      "1f937-1f3fb-200d-2642-fe0f",
      "1f937-1f3fc-200d-2642-fe0f",
      "1f937-1f3fd-200d-2642-fe0f",
      "1f937-1f3fe-200d-2642-fe0f",
      "1f937-1f3ff-200d-2642-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "woman shrugging",
      "woman-shrugging"
    ],
    u: "1f937-200d-2640-fe0f",
    v: [
      "1f937-1f3fb-200d-2640-fe0f",
      "1f937-1f3fc-200d-2640-fe0f",
      "1f937-1f3fd-200d-2640-fe0f",
      "1f937-1f3fe-200d-2640-fe0f",
      "1f937-1f3ff-200d-2640-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "health worker"
    ],
    u: "1f9d1-200d-2695-fe0f",
    v: [
      "1f9d1-1f3fb-200d-2695-fe0f",
      "1f9d1-1f3fc-200d-2695-fe0f",
      "1f9d1-1f3fd-200d-2695-fe0f",
      "1f9d1-1f3fe-200d-2695-fe0f",
      "1f9d1-1f3ff-200d-2695-fe0f"
    ],
    a: "12.1"
  },
  {
    n: [
      "male-doctor",
      "man health worker"
    ],
    u: "1f468-200d-2695-fe0f",
    v: [
      "1f468-1f3fb-200d-2695-fe0f",
      "1f468-1f3fc-200d-2695-fe0f",
      "1f468-1f3fd-200d-2695-fe0f",
      "1f468-1f3fe-200d-2695-fe0f",
      "1f468-1f3ff-200d-2695-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "female-doctor",
      "woman health worker"
    ],
    u: "1f469-200d-2695-fe0f",
    v: [
      "1f469-1f3fb-200d-2695-fe0f",
      "1f469-1f3fc-200d-2695-fe0f",
      "1f469-1f3fd-200d-2695-fe0f",
      "1f469-1f3fe-200d-2695-fe0f",
      "1f469-1f3ff-200d-2695-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "student"
    ],
    u: "1f9d1-200d-1f393",
    v: [
      "1f9d1-1f3fb-200d-1f393",
      "1f9d1-1f3fc-200d-1f393",
      "1f9d1-1f3fd-200d-1f393",
      "1f9d1-1f3fe-200d-1f393",
      "1f9d1-1f3ff-200d-1f393"
    ],
    a: "12.1"
  },
  {
    n: [
      "man student",
      "male-student"
    ],
    u: "1f468-200d-1f393",
    v: [
      "1f468-1f3fb-200d-1f393",
      "1f468-1f3fc-200d-1f393",
      "1f468-1f3fd-200d-1f393",
      "1f468-1f3fe-200d-1f393",
      "1f468-1f3ff-200d-1f393"
    ],
    a: "4.0"
  },
  {
    n: [
      "woman student",
      "female-student"
    ],
    u: "1f469-200d-1f393",
    v: [
      "1f469-1f3fb-200d-1f393",
      "1f469-1f3fc-200d-1f393",
      "1f469-1f3fd-200d-1f393",
      "1f469-1f3fe-200d-1f393",
      "1f469-1f3ff-200d-1f393"
    ],
    a: "4.0"
  },
  {
    n: [
      "teacher"
    ],
    u: "1f9d1-200d-1f3eb",
    v: [
      "1f9d1-1f3fb-200d-1f3eb",
      "1f9d1-1f3fc-200d-1f3eb",
      "1f9d1-1f3fd-200d-1f3eb",
      "1f9d1-1f3fe-200d-1f3eb",
      "1f9d1-1f3ff-200d-1f3eb"
    ],
    a: "12.1"
  },
  {
    n: [
      "man teacher",
      "male-teacher"
    ],
    u: "1f468-200d-1f3eb",
    v: [
      "1f468-1f3fb-200d-1f3eb",
      "1f468-1f3fc-200d-1f3eb",
      "1f468-1f3fd-200d-1f3eb",
      "1f468-1f3fe-200d-1f3eb",
      "1f468-1f3ff-200d-1f3eb"
    ],
    a: "4.0"
  },
  {
    n: [
      "woman teacher",
      "female-teacher"
    ],
    u: "1f469-200d-1f3eb",
    v: [
      "1f469-1f3fb-200d-1f3eb",
      "1f469-1f3fc-200d-1f3eb",
      "1f469-1f3fd-200d-1f3eb",
      "1f469-1f3fe-200d-1f3eb",
      "1f469-1f3ff-200d-1f3eb"
    ],
    a: "4.0"
  },
  {
    n: [
      "judge"
    ],
    u: "1f9d1-200d-2696-fe0f",
    v: [
      "1f9d1-1f3fb-200d-2696-fe0f",
      "1f9d1-1f3fc-200d-2696-fe0f",
      "1f9d1-1f3fd-200d-2696-fe0f",
      "1f9d1-1f3fe-200d-2696-fe0f",
      "1f9d1-1f3ff-200d-2696-fe0f"
    ],
    a: "12.1"
  },
  {
    n: [
      "man judge",
      "male-judge"
    ],
    u: "1f468-200d-2696-fe0f",
    v: [
      "1f468-1f3fb-200d-2696-fe0f",
      "1f468-1f3fc-200d-2696-fe0f",
      "1f468-1f3fd-200d-2696-fe0f",
      "1f468-1f3fe-200d-2696-fe0f",
      "1f468-1f3ff-200d-2696-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "woman judge",
      "female-judge"
    ],
    u: "1f469-200d-2696-fe0f",
    v: [
      "1f469-1f3fb-200d-2696-fe0f",
      "1f469-1f3fc-200d-2696-fe0f",
      "1f469-1f3fd-200d-2696-fe0f",
      "1f469-1f3fe-200d-2696-fe0f",
      "1f469-1f3ff-200d-2696-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "farmer"
    ],
    u: "1f9d1-200d-1f33e",
    v: [
      "1f9d1-1f3fb-200d-1f33e",
      "1f9d1-1f3fc-200d-1f33e",
      "1f9d1-1f3fd-200d-1f33e",
      "1f9d1-1f3fe-200d-1f33e",
      "1f9d1-1f3ff-200d-1f33e"
    ],
    a: "12.1"
  },
  {
    n: [
      "man farmer",
      "male-farmer"
    ],
    u: "1f468-200d-1f33e",
    v: [
      "1f468-1f3fb-200d-1f33e",
      "1f468-1f3fc-200d-1f33e",
      "1f468-1f3fd-200d-1f33e",
      "1f468-1f3fe-200d-1f33e",
      "1f468-1f3ff-200d-1f33e"
    ],
    a: "4.0"
  },
  {
    n: [
      "woman farmer",
      "female-farmer"
    ],
    u: "1f469-200d-1f33e",
    v: [
      "1f469-1f3fb-200d-1f33e",
      "1f469-1f3fc-200d-1f33e",
      "1f469-1f3fd-200d-1f33e",
      "1f469-1f3fe-200d-1f33e",
      "1f469-1f3ff-200d-1f33e"
    ],
    a: "4.0"
  },
  {
    n: [
      "cook"
    ],
    u: "1f9d1-200d-1f373",
    v: [
      "1f9d1-1f3fb-200d-1f373",
      "1f9d1-1f3fc-200d-1f373",
      "1f9d1-1f3fd-200d-1f373",
      "1f9d1-1f3fe-200d-1f373",
      "1f9d1-1f3ff-200d-1f373"
    ],
    a: "12.1"
  },
  {
    n: [
      "man cook",
      "male-cook"
    ],
    u: "1f468-200d-1f373",
    v: [
      "1f468-1f3fb-200d-1f373",
      "1f468-1f3fc-200d-1f373",
      "1f468-1f3fd-200d-1f373",
      "1f468-1f3fe-200d-1f373",
      "1f468-1f3ff-200d-1f373"
    ],
    a: "4.0"
  },
  {
    n: [
      "woman cook",
      "female-cook"
    ],
    u: "1f469-200d-1f373",
    v: [
      "1f469-1f3fb-200d-1f373",
      "1f469-1f3fc-200d-1f373",
      "1f469-1f3fd-200d-1f373",
      "1f469-1f3fe-200d-1f373",
      "1f469-1f3ff-200d-1f373"
    ],
    a: "4.0"
  },
  {
    n: [
      "mechanic"
    ],
    u: "1f9d1-200d-1f527",
    v: [
      "1f9d1-1f3fb-200d-1f527",
      "1f9d1-1f3fc-200d-1f527",
      "1f9d1-1f3fd-200d-1f527",
      "1f9d1-1f3fe-200d-1f527",
      "1f9d1-1f3ff-200d-1f527"
    ],
    a: "12.1"
  },
  {
    n: [
      "man mechanic",
      "male-mechanic"
    ],
    u: "1f468-200d-1f527",
    v: [
      "1f468-1f3fb-200d-1f527",
      "1f468-1f3fc-200d-1f527",
      "1f468-1f3fd-200d-1f527",
      "1f468-1f3fe-200d-1f527",
      "1f468-1f3ff-200d-1f527"
    ],
    a: "4.0"
  },
  {
    n: [
      "woman mechanic",
      "female-mechanic"
    ],
    u: "1f469-200d-1f527",
    v: [
      "1f469-1f3fb-200d-1f527",
      "1f469-1f3fc-200d-1f527",
      "1f469-1f3fd-200d-1f527",
      "1f469-1f3fe-200d-1f527",
      "1f469-1f3ff-200d-1f527"
    ],
    a: "4.0"
  },
  {
    n: [
      "factory worker"
    ],
    u: "1f9d1-200d-1f3ed",
    v: [
      "1f9d1-1f3fb-200d-1f3ed",
      "1f9d1-1f3fc-200d-1f3ed",
      "1f9d1-1f3fd-200d-1f3ed",
      "1f9d1-1f3fe-200d-1f3ed",
      "1f9d1-1f3ff-200d-1f3ed"
    ],
    a: "12.1"
  },
  {
    n: [
      "man factory worker",
      "male-factory-worker"
    ],
    u: "1f468-200d-1f3ed",
    v: [
      "1f468-1f3fb-200d-1f3ed",
      "1f468-1f3fc-200d-1f3ed",
      "1f468-1f3fd-200d-1f3ed",
      "1f468-1f3fe-200d-1f3ed",
      "1f468-1f3ff-200d-1f3ed"
    ],
    a: "4.0"
  },
  {
    n: [
      "woman factory worker",
      "female-factory-worker"
    ],
    u: "1f469-200d-1f3ed",
    v: [
      "1f469-1f3fb-200d-1f3ed",
      "1f469-1f3fc-200d-1f3ed",
      "1f469-1f3fd-200d-1f3ed",
      "1f469-1f3fe-200d-1f3ed",
      "1f469-1f3ff-200d-1f3ed"
    ],
    a: "4.0"
  },
  {
    n: [
      "office worker"
    ],
    u: "1f9d1-200d-1f4bc",
    v: [
      "1f9d1-1f3fb-200d-1f4bc",
      "1f9d1-1f3fc-200d-1f4bc",
      "1f9d1-1f3fd-200d-1f4bc",
      "1f9d1-1f3fe-200d-1f4bc",
      "1f9d1-1f3ff-200d-1f4bc"
    ],
    a: "12.1"
  },
  {
    n: [
      "man office worker",
      "male-office-worker"
    ],
    u: "1f468-200d-1f4bc",
    v: [
      "1f468-1f3fb-200d-1f4bc",
      "1f468-1f3fc-200d-1f4bc",
      "1f468-1f3fd-200d-1f4bc",
      "1f468-1f3fe-200d-1f4bc",
      "1f468-1f3ff-200d-1f4bc"
    ],
    a: "4.0"
  },
  {
    n: [
      "woman office worker",
      "female-office-worker"
    ],
    u: "1f469-200d-1f4bc",
    v: [
      "1f469-1f3fb-200d-1f4bc",
      "1f469-1f3fc-200d-1f4bc",
      "1f469-1f3fd-200d-1f4bc",
      "1f469-1f3fe-200d-1f4bc",
      "1f469-1f3ff-200d-1f4bc"
    ],
    a: "4.0"
  },
  {
    n: [
      "scientist"
    ],
    u: "1f9d1-200d-1f52c",
    v: [
      "1f9d1-1f3fb-200d-1f52c",
      "1f9d1-1f3fc-200d-1f52c",
      "1f9d1-1f3fd-200d-1f52c",
      "1f9d1-1f3fe-200d-1f52c",
      "1f9d1-1f3ff-200d-1f52c"
    ],
    a: "12.1"
  },
  {
    n: [
      "man scientist",
      "male-scientist"
    ],
    u: "1f468-200d-1f52c",
    v: [
      "1f468-1f3fb-200d-1f52c",
      "1f468-1f3fc-200d-1f52c",
      "1f468-1f3fd-200d-1f52c",
      "1f468-1f3fe-200d-1f52c",
      "1f468-1f3ff-200d-1f52c"
    ],
    a: "4.0"
  },
  {
    n: [
      "woman scientist",
      "female-scientist"
    ],
    u: "1f469-200d-1f52c",
    v: [
      "1f469-1f3fb-200d-1f52c",
      "1f469-1f3fc-200d-1f52c",
      "1f469-1f3fd-200d-1f52c",
      "1f469-1f3fe-200d-1f52c",
      "1f469-1f3ff-200d-1f52c"
    ],
    a: "4.0"
  },
  {
    n: [
      "technologist"
    ],
    u: "1f9d1-200d-1f4bb",
    v: [
      "1f9d1-1f3fb-200d-1f4bb",
      "1f9d1-1f3fc-200d-1f4bb",
      "1f9d1-1f3fd-200d-1f4bb",
      "1f9d1-1f3fe-200d-1f4bb",
      "1f9d1-1f3ff-200d-1f4bb"
    ],
    a: "12.1"
  },
  {
    n: [
      "man technologist",
      "male-technologist"
    ],
    u: "1f468-200d-1f4bb",
    v: [
      "1f468-1f3fb-200d-1f4bb",
      "1f468-1f3fc-200d-1f4bb",
      "1f468-1f3fd-200d-1f4bb",
      "1f468-1f3fe-200d-1f4bb",
      "1f468-1f3ff-200d-1f4bb"
    ],
    a: "4.0"
  },
  {
    n: [
      "woman technologist",
      "female-technologist"
    ],
    u: "1f469-200d-1f4bb",
    v: [
      "1f469-1f3fb-200d-1f4bb",
      "1f469-1f3fc-200d-1f4bb",
      "1f469-1f3fd-200d-1f4bb",
      "1f469-1f3fe-200d-1f4bb",
      "1f469-1f3ff-200d-1f4bb"
    ],
    a: "4.0"
  },
  {
    n: [
      "singer"
    ],
    u: "1f9d1-200d-1f3a4",
    v: [
      "1f9d1-1f3fb-200d-1f3a4",
      "1f9d1-1f3fc-200d-1f3a4",
      "1f9d1-1f3fd-200d-1f3a4",
      "1f9d1-1f3fe-200d-1f3a4",
      "1f9d1-1f3ff-200d-1f3a4"
    ],
    a: "12.1"
  },
  {
    n: [
      "man singer",
      "male-singer"
    ],
    u: "1f468-200d-1f3a4",
    v: [
      "1f468-1f3fb-200d-1f3a4",
      "1f468-1f3fc-200d-1f3a4",
      "1f468-1f3fd-200d-1f3a4",
      "1f468-1f3fe-200d-1f3a4",
      "1f468-1f3ff-200d-1f3a4"
    ],
    a: "4.0"
  },
  {
    n: [
      "woman singer",
      "female-singer"
    ],
    u: "1f469-200d-1f3a4",
    v: [
      "1f469-1f3fb-200d-1f3a4",
      "1f469-1f3fc-200d-1f3a4",
      "1f469-1f3fd-200d-1f3a4",
      "1f469-1f3fe-200d-1f3a4",
      "1f469-1f3ff-200d-1f3a4"
    ],
    a: "4.0"
  },
  {
    n: [
      "artist"
    ],
    u: "1f9d1-200d-1f3a8",
    v: [
      "1f9d1-1f3fb-200d-1f3a8",
      "1f9d1-1f3fc-200d-1f3a8",
      "1f9d1-1f3fd-200d-1f3a8",
      "1f9d1-1f3fe-200d-1f3a8",
      "1f9d1-1f3ff-200d-1f3a8"
    ],
    a: "12.1"
  },
  {
    n: [
      "man artist",
      "male-artist"
    ],
    u: "1f468-200d-1f3a8",
    v: [
      "1f468-1f3fb-200d-1f3a8",
      "1f468-1f3fc-200d-1f3a8",
      "1f468-1f3fd-200d-1f3a8",
      "1f468-1f3fe-200d-1f3a8",
      "1f468-1f3ff-200d-1f3a8"
    ],
    a: "4.0"
  },
  {
    n: [
      "woman artist",
      "female-artist"
    ],
    u: "1f469-200d-1f3a8",
    v: [
      "1f469-1f3fb-200d-1f3a8",
      "1f469-1f3fc-200d-1f3a8",
      "1f469-1f3fd-200d-1f3a8",
      "1f469-1f3fe-200d-1f3a8",
      "1f469-1f3ff-200d-1f3a8"
    ],
    a: "4.0"
  },
  {
    n: [
      "pilot"
    ],
    u: "1f9d1-200d-2708-fe0f",
    v: [
      "1f9d1-1f3fb-200d-2708-fe0f",
      "1f9d1-1f3fc-200d-2708-fe0f",
      "1f9d1-1f3fd-200d-2708-fe0f",
      "1f9d1-1f3fe-200d-2708-fe0f",
      "1f9d1-1f3ff-200d-2708-fe0f"
    ],
    a: "12.1"
  },
  {
    n: [
      "man pilot",
      "male-pilot"
    ],
    u: "1f468-200d-2708-fe0f",
    v: [
      "1f468-1f3fb-200d-2708-fe0f",
      "1f468-1f3fc-200d-2708-fe0f",
      "1f468-1f3fd-200d-2708-fe0f",
      "1f468-1f3fe-200d-2708-fe0f",
      "1f468-1f3ff-200d-2708-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "woman pilot",
      "female-pilot"
    ],
    u: "1f469-200d-2708-fe0f",
    v: [
      "1f469-1f3fb-200d-2708-fe0f",
      "1f469-1f3fc-200d-2708-fe0f",
      "1f469-1f3fd-200d-2708-fe0f",
      "1f469-1f3fe-200d-2708-fe0f",
      "1f469-1f3ff-200d-2708-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "astronaut"
    ],
    u: "1f9d1-200d-1f680",
    v: [
      "1f9d1-1f3fb-200d-1f680",
      "1f9d1-1f3fc-200d-1f680",
      "1f9d1-1f3fd-200d-1f680",
      "1f9d1-1f3fe-200d-1f680",
      "1f9d1-1f3ff-200d-1f680"
    ],
    a: "12.1"
  },
  {
    n: [
      "man astronaut",
      "male-astronaut"
    ],
    u: "1f468-200d-1f680",
    v: [
      "1f468-1f3fb-200d-1f680",
      "1f468-1f3fc-200d-1f680",
      "1f468-1f3fd-200d-1f680",
      "1f468-1f3fe-200d-1f680",
      "1f468-1f3ff-200d-1f680"
    ],
    a: "4.0"
  },
  {
    n: [
      "woman astronaut",
      "female-astronaut"
    ],
    u: "1f469-200d-1f680",
    v: [
      "1f469-1f3fb-200d-1f680",
      "1f469-1f3fc-200d-1f680",
      "1f469-1f3fd-200d-1f680",
      "1f469-1f3fe-200d-1f680",
      "1f469-1f3ff-200d-1f680"
    ],
    a: "4.0"
  },
  {
    n: [
      "firefighter"
    ],
    u: "1f9d1-200d-1f692",
    v: [
      "1f9d1-1f3fb-200d-1f692",
      "1f9d1-1f3fc-200d-1f692",
      "1f9d1-1f3fd-200d-1f692",
      "1f9d1-1f3fe-200d-1f692",
      "1f9d1-1f3ff-200d-1f692"
    ],
    a: "12.1"
  },
  {
    n: [
      "man firefighter",
      "male-firefighter"
    ],
    u: "1f468-200d-1f692",
    v: [
      "1f468-1f3fb-200d-1f692",
      "1f468-1f3fc-200d-1f692",
      "1f468-1f3fd-200d-1f692",
      "1f468-1f3fe-200d-1f692",
      "1f468-1f3ff-200d-1f692"
    ],
    a: "4.0"
  },
  {
    n: [
      "woman firefighter",
      "female-firefighter"
    ],
    u: "1f469-200d-1f692",
    v: [
      "1f469-1f3fb-200d-1f692",
      "1f469-1f3fc-200d-1f692",
      "1f469-1f3fd-200d-1f692",
      "1f469-1f3fe-200d-1f692",
      "1f469-1f3ff-200d-1f692"
    ],
    a: "4.0"
  },
  {
    n: [
      "cop",
      "police officer"
    ],
    u: "1f46e",
    v: [
      "1f46e-1f3fb",
      "1f46e-1f3fc",
      "1f46e-1f3fd",
      "1f46e-1f3fe",
      "1f46e-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "man police officer",
      "male-police-officer"
    ],
    u: "1f46e-200d-2642-fe0f",
    v: [
      "1f46e-1f3fb-200d-2642-fe0f",
      "1f46e-1f3fc-200d-2642-fe0f",
      "1f46e-1f3fd-200d-2642-fe0f",
      "1f46e-1f3fe-200d-2642-fe0f",
      "1f46e-1f3ff-200d-2642-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "woman police officer",
      "female-police-officer"
    ],
    u: "1f46e-200d-2640-fe0f",
    v: [
      "1f46e-1f3fb-200d-2640-fe0f",
      "1f46e-1f3fc-200d-2640-fe0f",
      "1f46e-1f3fd-200d-2640-fe0f",
      "1f46e-1f3fe-200d-2640-fe0f",
      "1f46e-1f3ff-200d-2640-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "detective",
      "sleuth or spy"
    ],
    u: "1f575-fe0f",
    v: [
      "1f575-1f3fb",
      "1f575-1f3fc",
      "1f575-1f3fd",
      "1f575-1f3fe",
      "1f575-1f3ff"
    ],
    a: "0.7"
  },
  {
    n: [
      "man detective",
      "male-detective"
    ],
    u: "1f575-fe0f-200d-2642-fe0f",
    v: [
      "1f575-1f3fb-200d-2642-fe0f",
      "1f575-1f3fc-200d-2642-fe0f",
      "1f575-1f3fd-200d-2642-fe0f",
      "1f575-1f3fe-200d-2642-fe0f",
      "1f575-1f3ff-200d-2642-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "woman detective",
      "female-detective"
    ],
    u: "1f575-fe0f-200d-2640-fe0f",
    v: [
      "1f575-1f3fb-200d-2640-fe0f",
      "1f575-1f3fc-200d-2640-fe0f",
      "1f575-1f3fd-200d-2640-fe0f",
      "1f575-1f3fe-200d-2640-fe0f",
      "1f575-1f3ff-200d-2640-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "guardsman"
    ],
    u: "1f482",
    v: [
      "1f482-1f3fb",
      "1f482-1f3fc",
      "1f482-1f3fd",
      "1f482-1f3fe",
      "1f482-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "man guard",
      "male-guard"
    ],
    u: "1f482-200d-2642-fe0f",
    v: [
      "1f482-1f3fb-200d-2642-fe0f",
      "1f482-1f3fc-200d-2642-fe0f",
      "1f482-1f3fd-200d-2642-fe0f",
      "1f482-1f3fe-200d-2642-fe0f",
      "1f482-1f3ff-200d-2642-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "woman guard",
      "female-guard"
    ],
    u: "1f482-200d-2640-fe0f",
    v: [
      "1f482-1f3fb-200d-2640-fe0f",
      "1f482-1f3fc-200d-2640-fe0f",
      "1f482-1f3fd-200d-2640-fe0f",
      "1f482-1f3fe-200d-2640-fe0f",
      "1f482-1f3ff-200d-2640-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "ninja"
    ],
    u: "1f977",
    v: [
      "1f977-1f3fb",
      "1f977-1f3fc",
      "1f977-1f3fd",
      "1f977-1f3fe",
      "1f977-1f3ff"
    ],
    a: "13.0"
  },
  {
    n: [
      "construction worker"
    ],
    u: "1f477",
    v: [
      "1f477-1f3fb",
      "1f477-1f3fc",
      "1f477-1f3fd",
      "1f477-1f3fe",
      "1f477-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "man construction worker",
      "male-construction-worker"
    ],
    u: "1f477-200d-2642-fe0f",
    v: [
      "1f477-1f3fb-200d-2642-fe0f",
      "1f477-1f3fc-200d-2642-fe0f",
      "1f477-1f3fd-200d-2642-fe0f",
      "1f477-1f3fe-200d-2642-fe0f",
      "1f477-1f3ff-200d-2642-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "woman construction worker",
      "female-construction-worker"
    ],
    u: "1f477-200d-2640-fe0f",
    v: [
      "1f477-1f3fb-200d-2640-fe0f",
      "1f477-1f3fc-200d-2640-fe0f",
      "1f477-1f3fd-200d-2640-fe0f",
      "1f477-1f3fe-200d-2640-fe0f",
      "1f477-1f3ff-200d-2640-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "person with crown"
    ],
    u: "1fac5",
    v: [
      "1fac5-1f3fb",
      "1fac5-1f3fc",
      "1fac5-1f3fd",
      "1fac5-1f3fe",
      "1fac5-1f3ff"
    ],
    a: "14.0"
  },
  {
    n: [
      "prince"
    ],
    u: "1f934",
    v: [
      "1f934-1f3fb",
      "1f934-1f3fc",
      "1f934-1f3fd",
      "1f934-1f3fe",
      "1f934-1f3ff"
    ],
    a: "3.0"
  },
  {
    n: [
      "princess"
    ],
    u: "1f478",
    v: [
      "1f478-1f3fb",
      "1f478-1f3fc",
      "1f478-1f3fd",
      "1f478-1f3fe",
      "1f478-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "man with turban"
    ],
    u: "1f473",
    v: [
      "1f473-1f3fb",
      "1f473-1f3fc",
      "1f473-1f3fd",
      "1f473-1f3fe",
      "1f473-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "man wearing turban",
      "man-wearing-turban"
    ],
    u: "1f473-200d-2642-fe0f",
    v: [
      "1f473-1f3fb-200d-2642-fe0f",
      "1f473-1f3fc-200d-2642-fe0f",
      "1f473-1f3fd-200d-2642-fe0f",
      "1f473-1f3fe-200d-2642-fe0f",
      "1f473-1f3ff-200d-2642-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "woman wearing turban",
      "woman-wearing-turban"
    ],
    u: "1f473-200d-2640-fe0f",
    v: [
      "1f473-1f3fb-200d-2640-fe0f",
      "1f473-1f3fc-200d-2640-fe0f",
      "1f473-1f3fd-200d-2640-fe0f",
      "1f473-1f3fe-200d-2640-fe0f",
      "1f473-1f3ff-200d-2640-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "man with gua pi mao"
    ],
    u: "1f472",
    v: [
      "1f472-1f3fb",
      "1f472-1f3fc",
      "1f472-1f3fd",
      "1f472-1f3fe",
      "1f472-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "person with headscarf"
    ],
    u: "1f9d5",
    v: [
      "1f9d5-1f3fb",
      "1f9d5-1f3fc",
      "1f9d5-1f3fd",
      "1f9d5-1f3fe",
      "1f9d5-1f3ff"
    ],
    a: "5.0"
  },
  {
    n: [
      "man in tuxedo",
      "person in tuxedo"
    ],
    u: "1f935",
    v: [
      "1f935-1f3fb",
      "1f935-1f3fc",
      "1f935-1f3fd",
      "1f935-1f3fe",
      "1f935-1f3ff"
    ],
    a: "3.0"
  },
  {
    n: [
      "man in tuxedo"
    ],
    u: "1f935-200d-2642-fe0f",
    v: [
      "1f935-1f3fb-200d-2642-fe0f",
      "1f935-1f3fc-200d-2642-fe0f",
      "1f935-1f3fd-200d-2642-fe0f",
      "1f935-1f3fe-200d-2642-fe0f",
      "1f935-1f3ff-200d-2642-fe0f"
    ],
    a: "13.0"
  },
  {
    n: [
      "woman in tuxedo"
    ],
    u: "1f935-200d-2640-fe0f",
    v: [
      "1f935-1f3fb-200d-2640-fe0f",
      "1f935-1f3fc-200d-2640-fe0f",
      "1f935-1f3fd-200d-2640-fe0f",
      "1f935-1f3fe-200d-2640-fe0f",
      "1f935-1f3ff-200d-2640-fe0f"
    ],
    a: "13.0"
  },
  {
    n: [
      "bride with veil"
    ],
    u: "1f470",
    v: [
      "1f470-1f3fb",
      "1f470-1f3fc",
      "1f470-1f3fd",
      "1f470-1f3fe",
      "1f470-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "man with veil"
    ],
    u: "1f470-200d-2642-fe0f",
    v: [
      "1f470-1f3fb-200d-2642-fe0f",
      "1f470-1f3fc-200d-2642-fe0f",
      "1f470-1f3fd-200d-2642-fe0f",
      "1f470-1f3fe-200d-2642-fe0f",
      "1f470-1f3ff-200d-2642-fe0f"
    ],
    a: "13.0"
  },
  {
    n: [
      "woman with veil"
    ],
    u: "1f470-200d-2640-fe0f",
    v: [
      "1f470-1f3fb-200d-2640-fe0f",
      "1f470-1f3fc-200d-2640-fe0f",
      "1f470-1f3fd-200d-2640-fe0f",
      "1f470-1f3fe-200d-2640-fe0f",
      "1f470-1f3ff-200d-2640-fe0f"
    ],
    a: "13.0"
  },
  {
    n: [
      "pregnant woman"
    ],
    u: "1f930",
    v: [
      "1f930-1f3fb",
      "1f930-1f3fc",
      "1f930-1f3fd",
      "1f930-1f3fe",
      "1f930-1f3ff"
    ],
    a: "3.0"
  },
  {
    n: [
      "pregnant man"
    ],
    u: "1fac3",
    v: [
      "1fac3-1f3fb",
      "1fac3-1f3fc",
      "1fac3-1f3fd",
      "1fac3-1f3fe",
      "1fac3-1f3ff"
    ],
    a: "14.0"
  },
  {
    n: [
      "pregnant person"
    ],
    u: "1fac4",
    v: [
      "1fac4-1f3fb",
      "1fac4-1f3fc",
      "1fac4-1f3fd",
      "1fac4-1f3fe",
      "1fac4-1f3ff"
    ],
    a: "14.0"
  },
  {
    n: [
      "breast-feeding"
    ],
    u: "1f931",
    v: [
      "1f931-1f3fb",
      "1f931-1f3fc",
      "1f931-1f3fd",
      "1f931-1f3fe",
      "1f931-1f3ff"
    ],
    a: "5.0"
  },
  {
    n: [
      "woman feeding baby"
    ],
    u: "1f469-200d-1f37c",
    v: [
      "1f469-1f3fb-200d-1f37c",
      "1f469-1f3fc-200d-1f37c",
      "1f469-1f3fd-200d-1f37c",
      "1f469-1f3fe-200d-1f37c",
      "1f469-1f3ff-200d-1f37c"
    ],
    a: "13.0"
  },
  {
    n: [
      "man feeding baby"
    ],
    u: "1f468-200d-1f37c",
    v: [
      "1f468-1f3fb-200d-1f37c",
      "1f468-1f3fc-200d-1f37c",
      "1f468-1f3fd-200d-1f37c",
      "1f468-1f3fe-200d-1f37c",
      "1f468-1f3ff-200d-1f37c"
    ],
    a: "13.0"
  },
  {
    n: [
      "person feeding baby"
    ],
    u: "1f9d1-200d-1f37c",
    v: [
      "1f9d1-1f3fb-200d-1f37c",
      "1f9d1-1f3fc-200d-1f37c",
      "1f9d1-1f3fd-200d-1f37c",
      "1f9d1-1f3fe-200d-1f37c",
      "1f9d1-1f3ff-200d-1f37c"
    ],
    a: "13.0"
  },
  {
    n: [
      "angel",
      "baby angel"
    ],
    u: "1f47c",
    v: [
      "1f47c-1f3fb",
      "1f47c-1f3fc",
      "1f47c-1f3fd",
      "1f47c-1f3fe",
      "1f47c-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "santa",
      "father christmas"
    ],
    u: "1f385",
    v: [
      "1f385-1f3fb",
      "1f385-1f3fc",
      "1f385-1f3fd",
      "1f385-1f3fe",
      "1f385-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "mrs claus",
      "mother christmas"
    ],
    u: "1f936",
    v: [
      "1f936-1f3fb",
      "1f936-1f3fc",
      "1f936-1f3fd",
      "1f936-1f3fe",
      "1f936-1f3ff"
    ],
    a: "3.0"
  },
  {
    n: [
      "mx claus"
    ],
    u: "1f9d1-200d-1f384",
    v: [
      "1f9d1-1f3fb-200d-1f384",
      "1f9d1-1f3fc-200d-1f384",
      "1f9d1-1f3fd-200d-1f384",
      "1f9d1-1f3fe-200d-1f384",
      "1f9d1-1f3ff-200d-1f384"
    ],
    a: "13.0"
  },
  {
    n: [
      "superhero"
    ],
    u: "1f9b8",
    v: [
      "1f9b8-1f3fb",
      "1f9b8-1f3fc",
      "1f9b8-1f3fd",
      "1f9b8-1f3fe",
      "1f9b8-1f3ff"
    ],
    a: "11.0"
  },
  {
    n: [
      "man superhero",
      "male superhero"
    ],
    u: "1f9b8-200d-2642-fe0f",
    v: [
      "1f9b8-1f3fb-200d-2642-fe0f",
      "1f9b8-1f3fc-200d-2642-fe0f",
      "1f9b8-1f3fd-200d-2642-fe0f",
      "1f9b8-1f3fe-200d-2642-fe0f",
      "1f9b8-1f3ff-200d-2642-fe0f"
    ],
    a: "11.0"
  },
  {
    n: [
      "woman superhero",
      "female superhero"
    ],
    u: "1f9b8-200d-2640-fe0f",
    v: [
      "1f9b8-1f3fb-200d-2640-fe0f",
      "1f9b8-1f3fc-200d-2640-fe0f",
      "1f9b8-1f3fd-200d-2640-fe0f",
      "1f9b8-1f3fe-200d-2640-fe0f",
      "1f9b8-1f3ff-200d-2640-fe0f"
    ],
    a: "11.0"
  },
  {
    n: [
      "supervillain"
    ],
    u: "1f9b9",
    v: [
      "1f9b9-1f3fb",
      "1f9b9-1f3fc",
      "1f9b9-1f3fd",
      "1f9b9-1f3fe",
      "1f9b9-1f3ff"
    ],
    a: "11.0"
  },
  {
    n: [
      "man supervillain",
      "male supervillain"
    ],
    u: "1f9b9-200d-2642-fe0f",
    v: [
      "1f9b9-1f3fb-200d-2642-fe0f",
      "1f9b9-1f3fc-200d-2642-fe0f",
      "1f9b9-1f3fd-200d-2642-fe0f",
      "1f9b9-1f3fe-200d-2642-fe0f",
      "1f9b9-1f3ff-200d-2642-fe0f"
    ],
    a: "11.0"
  },
  {
    n: [
      "woman supervillain",
      "female supervillain"
    ],
    u: "1f9b9-200d-2640-fe0f",
    v: [
      "1f9b9-1f3fb-200d-2640-fe0f",
      "1f9b9-1f3fc-200d-2640-fe0f",
      "1f9b9-1f3fd-200d-2640-fe0f",
      "1f9b9-1f3fe-200d-2640-fe0f",
      "1f9b9-1f3ff-200d-2640-fe0f"
    ],
    a: "11.0"
  },
  {
    n: [
      "mage"
    ],
    u: "1f9d9",
    v: [
      "1f9d9-1f3fb",
      "1f9d9-1f3fc",
      "1f9d9-1f3fd",
      "1f9d9-1f3fe",
      "1f9d9-1f3ff"
    ],
    a: "5.0"
  },
  {
    n: [
      "man mage",
      "male mage"
    ],
    u: "1f9d9-200d-2642-fe0f",
    v: [
      "1f9d9-1f3fb-200d-2642-fe0f",
      "1f9d9-1f3fc-200d-2642-fe0f",
      "1f9d9-1f3fd-200d-2642-fe0f",
      "1f9d9-1f3fe-200d-2642-fe0f",
      "1f9d9-1f3ff-200d-2642-fe0f"
    ],
    a: "5.0"
  },
  {
    n: [
      "woman mage",
      "female mage"
    ],
    u: "1f9d9-200d-2640-fe0f",
    v: [
      "1f9d9-1f3fb-200d-2640-fe0f",
      "1f9d9-1f3fc-200d-2640-fe0f",
      "1f9d9-1f3fd-200d-2640-fe0f",
      "1f9d9-1f3fe-200d-2640-fe0f",
      "1f9d9-1f3ff-200d-2640-fe0f"
    ],
    a: "5.0"
  },
  {
    n: [
      "fairy"
    ],
    u: "1f9da",
    v: [
      "1f9da-1f3fb",
      "1f9da-1f3fc",
      "1f9da-1f3fd",
      "1f9da-1f3fe",
      "1f9da-1f3ff"
    ],
    a: "5.0"
  },
  {
    n: [
      "man fairy",
      "male fairy"
    ],
    u: "1f9da-200d-2642-fe0f",
    v: [
      "1f9da-1f3fb-200d-2642-fe0f",
      "1f9da-1f3fc-200d-2642-fe0f",
      "1f9da-1f3fd-200d-2642-fe0f",
      "1f9da-1f3fe-200d-2642-fe0f",
      "1f9da-1f3ff-200d-2642-fe0f"
    ],
    a: "5.0"
  },
  {
    n: [
      "woman fairy",
      "female fairy"
    ],
    u: "1f9da-200d-2640-fe0f",
    v: [
      "1f9da-1f3fb-200d-2640-fe0f",
      "1f9da-1f3fc-200d-2640-fe0f",
      "1f9da-1f3fd-200d-2640-fe0f",
      "1f9da-1f3fe-200d-2640-fe0f",
      "1f9da-1f3ff-200d-2640-fe0f"
    ],
    a: "5.0"
  },
  {
    n: [
      "vampire"
    ],
    u: "1f9db",
    v: [
      "1f9db-1f3fb",
      "1f9db-1f3fc",
      "1f9db-1f3fd",
      "1f9db-1f3fe",
      "1f9db-1f3ff"
    ],
    a: "5.0"
  },
  {
    n: [
      "man vampire",
      "male vampire"
    ],
    u: "1f9db-200d-2642-fe0f",
    v: [
      "1f9db-1f3fb-200d-2642-fe0f",
      "1f9db-1f3fc-200d-2642-fe0f",
      "1f9db-1f3fd-200d-2642-fe0f",
      "1f9db-1f3fe-200d-2642-fe0f",
      "1f9db-1f3ff-200d-2642-fe0f"
    ],
    a: "5.0"
  },
  {
    n: [
      "woman vampire",
      "female vampire"
    ],
    u: "1f9db-200d-2640-fe0f",
    v: [
      "1f9db-1f3fb-200d-2640-fe0f",
      "1f9db-1f3fc-200d-2640-fe0f",
      "1f9db-1f3fd-200d-2640-fe0f",
      "1f9db-1f3fe-200d-2640-fe0f",
      "1f9db-1f3ff-200d-2640-fe0f"
    ],
    a: "5.0"
  },
  {
    n: [
      "merperson"
    ],
    u: "1f9dc",
    v: [
      "1f9dc-1f3fb",
      "1f9dc-1f3fc",
      "1f9dc-1f3fd",
      "1f9dc-1f3fe",
      "1f9dc-1f3ff"
    ],
    a: "5.0"
  },
  {
    n: [
      "merman"
    ],
    u: "1f9dc-200d-2642-fe0f",
    v: [
      "1f9dc-1f3fb-200d-2642-fe0f",
      "1f9dc-1f3fc-200d-2642-fe0f",
      "1f9dc-1f3fd-200d-2642-fe0f",
      "1f9dc-1f3fe-200d-2642-fe0f",
      "1f9dc-1f3ff-200d-2642-fe0f"
    ],
    a: "5.0"
  },
  {
    n: [
      "mermaid"
    ],
    u: "1f9dc-200d-2640-fe0f",
    v: [
      "1f9dc-1f3fb-200d-2640-fe0f",
      "1f9dc-1f3fc-200d-2640-fe0f",
      "1f9dc-1f3fd-200d-2640-fe0f",
      "1f9dc-1f3fe-200d-2640-fe0f",
      "1f9dc-1f3ff-200d-2640-fe0f"
    ],
    a: "5.0"
  },
  {
    n: [
      "elf"
    ],
    u: "1f9dd",
    v: [
      "1f9dd-1f3fb",
      "1f9dd-1f3fc",
      "1f9dd-1f3fd",
      "1f9dd-1f3fe",
      "1f9dd-1f3ff"
    ],
    a: "5.0"
  },
  {
    n: [
      "man elf",
      "male elf"
    ],
    u: "1f9dd-200d-2642-fe0f",
    v: [
      "1f9dd-1f3fb-200d-2642-fe0f",
      "1f9dd-1f3fc-200d-2642-fe0f",
      "1f9dd-1f3fd-200d-2642-fe0f",
      "1f9dd-1f3fe-200d-2642-fe0f",
      "1f9dd-1f3ff-200d-2642-fe0f"
    ],
    a: "5.0"
  },
  {
    n: [
      "woman elf",
      "female elf"
    ],
    u: "1f9dd-200d-2640-fe0f",
    v: [
      "1f9dd-1f3fb-200d-2640-fe0f",
      "1f9dd-1f3fc-200d-2640-fe0f",
      "1f9dd-1f3fd-200d-2640-fe0f",
      "1f9dd-1f3fe-200d-2640-fe0f",
      "1f9dd-1f3ff-200d-2640-fe0f"
    ],
    a: "5.0"
  },
  {
    n: [
      "genie"
    ],
    u: "1f9de",
    a: "5.0"
  },
  {
    n: [
      "man genie",
      "male genie"
    ],
    u: "1f9de-200d-2642-fe0f",
    a: "5.0"
  },
  {
    n: [
      "woman genie",
      "female genie"
    ],
    u: "1f9de-200d-2640-fe0f",
    a: "5.0"
  },
  {
    n: [
      "zombie"
    ],
    u: "1f9df",
    a: "5.0"
  },
  {
    n: [
      "man zombie",
      "male zombie"
    ],
    u: "1f9df-200d-2642-fe0f",
    a: "5.0"
  },
  {
    n: [
      "woman zombie",
      "female zombie"
    ],
    u: "1f9df-200d-2640-fe0f",
    a: "5.0"
  },
  {
    n: [
      "troll"
    ],
    u: "1f9cc",
    a: "14.0"
  },
  {
    n: [
      "massage",
      "face massage"
    ],
    u: "1f486",
    v: [
      "1f486-1f3fb",
      "1f486-1f3fc",
      "1f486-1f3fd",
      "1f486-1f3fe",
      "1f486-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "man getting massage",
      "man-getting-massage"
    ],
    u: "1f486-200d-2642-fe0f",
    v: [
      "1f486-1f3fb-200d-2642-fe0f",
      "1f486-1f3fc-200d-2642-fe0f",
      "1f486-1f3fd-200d-2642-fe0f",
      "1f486-1f3fe-200d-2642-fe0f",
      "1f486-1f3ff-200d-2642-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "woman getting massage",
      "woman-getting-massage"
    ],
    u: "1f486-200d-2640-fe0f",
    v: [
      "1f486-1f3fb-200d-2640-fe0f",
      "1f486-1f3fc-200d-2640-fe0f",
      "1f486-1f3fd-200d-2640-fe0f",
      "1f486-1f3fe-200d-2640-fe0f",
      "1f486-1f3ff-200d-2640-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "haircut"
    ],
    u: "1f487",
    v: [
      "1f487-1f3fb",
      "1f487-1f3fc",
      "1f487-1f3fd",
      "1f487-1f3fe",
      "1f487-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "man getting haircut",
      "man-getting-haircut"
    ],
    u: "1f487-200d-2642-fe0f",
    v: [
      "1f487-1f3fb-200d-2642-fe0f",
      "1f487-1f3fc-200d-2642-fe0f",
      "1f487-1f3fd-200d-2642-fe0f",
      "1f487-1f3fe-200d-2642-fe0f",
      "1f487-1f3ff-200d-2642-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "woman getting haircut",
      "woman-getting-haircut"
    ],
    u: "1f487-200d-2640-fe0f",
    v: [
      "1f487-1f3fb-200d-2640-fe0f",
      "1f487-1f3fc-200d-2640-fe0f",
      "1f487-1f3fd-200d-2640-fe0f",
      "1f487-1f3fe-200d-2640-fe0f",
      "1f487-1f3ff-200d-2640-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "walking",
      "pedestrian"
    ],
    u: "1f6b6",
    v: [
      "1f6b6-1f3fb",
      "1f6b6-1f3fc",
      "1f6b6-1f3fd",
      "1f6b6-1f3fe",
      "1f6b6-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "man walking",
      "man-walking"
    ],
    u: "1f6b6-200d-2642-fe0f",
    v: [
      "1f6b6-1f3fb-200d-2642-fe0f",
      "1f6b6-1f3fc-200d-2642-fe0f",
      "1f6b6-1f3fd-200d-2642-fe0f",
      "1f6b6-1f3fe-200d-2642-fe0f",
      "1f6b6-1f3ff-200d-2642-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "woman walking",
      "woman-walking"
    ],
    u: "1f6b6-200d-2640-fe0f",
    v: [
      "1f6b6-1f3fb-200d-2640-fe0f",
      "1f6b6-1f3fc-200d-2640-fe0f",
      "1f6b6-1f3fd-200d-2640-fe0f",
      "1f6b6-1f3fe-200d-2640-fe0f",
      "1f6b6-1f3ff-200d-2640-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "standing person"
    ],
    u: "1f9cd",
    v: [
      "1f9cd-1f3fb",
      "1f9cd-1f3fc",
      "1f9cd-1f3fd",
      "1f9cd-1f3fe",
      "1f9cd-1f3ff"
    ],
    a: "12.0"
  },
  {
    n: [
      "man standing"
    ],
    u: "1f9cd-200d-2642-fe0f",
    v: [
      "1f9cd-1f3fb-200d-2642-fe0f",
      "1f9cd-1f3fc-200d-2642-fe0f",
      "1f9cd-1f3fd-200d-2642-fe0f",
      "1f9cd-1f3fe-200d-2642-fe0f",
      "1f9cd-1f3ff-200d-2642-fe0f"
    ],
    a: "12.0"
  },
  {
    n: [
      "woman standing"
    ],
    u: "1f9cd-200d-2640-fe0f",
    v: [
      "1f9cd-1f3fb-200d-2640-fe0f",
      "1f9cd-1f3fc-200d-2640-fe0f",
      "1f9cd-1f3fd-200d-2640-fe0f",
      "1f9cd-1f3fe-200d-2640-fe0f",
      "1f9cd-1f3ff-200d-2640-fe0f"
    ],
    a: "12.0"
  },
  {
    n: [
      "kneeling person"
    ],
    u: "1f9ce",
    v: [
      "1f9ce-1f3fb",
      "1f9ce-1f3fc",
      "1f9ce-1f3fd",
      "1f9ce-1f3fe",
      "1f9ce-1f3ff"
    ],
    a: "12.0"
  },
  {
    n: [
      "man kneeling"
    ],
    u: "1f9ce-200d-2642-fe0f",
    v: [
      "1f9ce-1f3fb-200d-2642-fe0f",
      "1f9ce-1f3fc-200d-2642-fe0f",
      "1f9ce-1f3fd-200d-2642-fe0f",
      "1f9ce-1f3fe-200d-2642-fe0f",
      "1f9ce-1f3ff-200d-2642-fe0f"
    ],
    a: "12.0"
  },
  {
    n: [
      "woman kneeling"
    ],
    u: "1f9ce-200d-2640-fe0f",
    v: [
      "1f9ce-1f3fb-200d-2640-fe0f",
      "1f9ce-1f3fc-200d-2640-fe0f",
      "1f9ce-1f3fd-200d-2640-fe0f",
      "1f9ce-1f3fe-200d-2640-fe0f",
      "1f9ce-1f3ff-200d-2640-fe0f"
    ],
    a: "12.0"
  },
  {
    n: [
      "person with white cane",
      "person with probing cane"
    ],
    u: "1f9d1-200d-1f9af",
    v: [
      "1f9d1-1f3fb-200d-1f9af",
      "1f9d1-1f3fc-200d-1f9af",
      "1f9d1-1f3fd-200d-1f9af",
      "1f9d1-1f3fe-200d-1f9af",
      "1f9d1-1f3ff-200d-1f9af"
    ],
    a: "12.1"
  },
  {
    n: [
      "man with white cane",
      "man with probing cane"
    ],
    u: "1f468-200d-1f9af",
    v: [
      "1f468-1f3fb-200d-1f9af",
      "1f468-1f3fc-200d-1f9af",
      "1f468-1f3fd-200d-1f9af",
      "1f468-1f3fe-200d-1f9af",
      "1f468-1f3ff-200d-1f9af"
    ],
    a: "12.0"
  },
  {
    n: [
      "woman with white cane",
      "woman with probing cane"
    ],
    u: "1f469-200d-1f9af",
    v: [
      "1f469-1f3fb-200d-1f9af",
      "1f469-1f3fc-200d-1f9af",
      "1f469-1f3fd-200d-1f9af",
      "1f469-1f3fe-200d-1f9af",
      "1f469-1f3ff-200d-1f9af"
    ],
    a: "12.0"
  },
  {
    n: [
      "person in motorized wheelchair"
    ],
    u: "1f9d1-200d-1f9bc",
    v: [
      "1f9d1-1f3fb-200d-1f9bc",
      "1f9d1-1f3fc-200d-1f9bc",
      "1f9d1-1f3fd-200d-1f9bc",
      "1f9d1-1f3fe-200d-1f9bc",
      "1f9d1-1f3ff-200d-1f9bc"
    ],
    a: "12.1"
  },
  {
    n: [
      "man in motorized wheelchair"
    ],
    u: "1f468-200d-1f9bc",
    v: [
      "1f468-1f3fb-200d-1f9bc",
      "1f468-1f3fc-200d-1f9bc",
      "1f468-1f3fd-200d-1f9bc",
      "1f468-1f3fe-200d-1f9bc",
      "1f468-1f3ff-200d-1f9bc"
    ],
    a: "12.0"
  },
  {
    n: [
      "woman in motorized wheelchair"
    ],
    u: "1f469-200d-1f9bc",
    v: [
      "1f469-1f3fb-200d-1f9bc",
      "1f469-1f3fc-200d-1f9bc",
      "1f469-1f3fd-200d-1f9bc",
      "1f469-1f3fe-200d-1f9bc",
      "1f469-1f3ff-200d-1f9bc"
    ],
    a: "12.0"
  },
  {
    n: [
      "person in manual wheelchair"
    ],
    u: "1f9d1-200d-1f9bd",
    v: [
      "1f9d1-1f3fb-200d-1f9bd",
      "1f9d1-1f3fc-200d-1f9bd",
      "1f9d1-1f3fd-200d-1f9bd",
      "1f9d1-1f3fe-200d-1f9bd",
      "1f9d1-1f3ff-200d-1f9bd"
    ],
    a: "12.1"
  },
  {
    n: [
      "man in manual wheelchair"
    ],
    u: "1f468-200d-1f9bd",
    v: [
      "1f468-1f3fb-200d-1f9bd",
      "1f468-1f3fc-200d-1f9bd",
      "1f468-1f3fd-200d-1f9bd",
      "1f468-1f3fe-200d-1f9bd",
      "1f468-1f3ff-200d-1f9bd"
    ],
    a: "12.0"
  },
  {
    n: [
      "woman in manual wheelchair"
    ],
    u: "1f469-200d-1f9bd",
    v: [
      "1f469-1f3fb-200d-1f9bd",
      "1f469-1f3fc-200d-1f9bd",
      "1f469-1f3fd-200d-1f9bd",
      "1f469-1f3fe-200d-1f9bd",
      "1f469-1f3ff-200d-1f9bd"
    ],
    a: "12.0"
  },
  {
    n: [
      "runner",
      "running"
    ],
    u: "1f3c3",
    v: [
      "1f3c3-1f3fb",
      "1f3c3-1f3fc",
      "1f3c3-1f3fd",
      "1f3c3-1f3fe",
      "1f3c3-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "man running",
      "man-running"
    ],
    u: "1f3c3-200d-2642-fe0f",
    v: [
      "1f3c3-1f3fb-200d-2642-fe0f",
      "1f3c3-1f3fc-200d-2642-fe0f",
      "1f3c3-1f3fd-200d-2642-fe0f",
      "1f3c3-1f3fe-200d-2642-fe0f",
      "1f3c3-1f3ff-200d-2642-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "woman running",
      "woman-running"
    ],
    u: "1f3c3-200d-2640-fe0f",
    v: [
      "1f3c3-1f3fb-200d-2640-fe0f",
      "1f3c3-1f3fc-200d-2640-fe0f",
      "1f3c3-1f3fd-200d-2640-fe0f",
      "1f3c3-1f3fe-200d-2640-fe0f",
      "1f3c3-1f3ff-200d-2640-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "dancer"
    ],
    u: "1f483",
    v: [
      "1f483-1f3fb",
      "1f483-1f3fc",
      "1f483-1f3fd",
      "1f483-1f3fe",
      "1f483-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "man dancing"
    ],
    u: "1f57a",
    v: [
      "1f57a-1f3fb",
      "1f57a-1f3fc",
      "1f57a-1f3fd",
      "1f57a-1f3fe",
      "1f57a-1f3ff"
    ],
    a: "3.0"
  },
  {
    n: [
      "person in suit levitating",
      "man in business suit levitating"
    ],
    u: "1f574-fe0f",
    v: [
      "1f574-1f3fb",
      "1f574-1f3fc",
      "1f574-1f3fd",
      "1f574-1f3fe",
      "1f574-1f3ff"
    ],
    a: "0.7"
  },
  {
    n: [
      "dancers",
      "woman with bunny ears"
    ],
    u: "1f46f",
    a: "0.6"
  },
  {
    n: [
      "men with bunny ears",
      "men-with-bunny-ears-partying",
      "man-with-bunny-ears-partying"
    ],
    u: "1f46f-200d-2642-fe0f",
    a: "4.0"
  },
  {
    n: [
      "women with bunny ears",
      "women-with-bunny-ears-partying",
      "woman-with-bunny-ears-partying"
    ],
    u: "1f46f-200d-2640-fe0f",
    a: "4.0"
  },
  {
    n: [
      "person in steamy room"
    ],
    u: "1f9d6",
    v: [
      "1f9d6-1f3fb",
      "1f9d6-1f3fc",
      "1f9d6-1f3fd",
      "1f9d6-1f3fe",
      "1f9d6-1f3ff"
    ],
    a: "5.0"
  },
  {
    n: [
      "man in steamy room"
    ],
    u: "1f9d6-200d-2642-fe0f",
    v: [
      "1f9d6-1f3fb-200d-2642-fe0f",
      "1f9d6-1f3fc-200d-2642-fe0f",
      "1f9d6-1f3fd-200d-2642-fe0f",
      "1f9d6-1f3fe-200d-2642-fe0f",
      "1f9d6-1f3ff-200d-2642-fe0f"
    ],
    a: "5.0"
  },
  {
    n: [
      "woman in steamy room"
    ],
    u: "1f9d6-200d-2640-fe0f",
    v: [
      "1f9d6-1f3fb-200d-2640-fe0f",
      "1f9d6-1f3fc-200d-2640-fe0f",
      "1f9d6-1f3fd-200d-2640-fe0f",
      "1f9d6-1f3fe-200d-2640-fe0f",
      "1f9d6-1f3ff-200d-2640-fe0f"
    ],
    a: "5.0"
  },
  {
    n: [
      "person climbing"
    ],
    u: "1f9d7",
    v: [
      "1f9d7-1f3fb",
      "1f9d7-1f3fc",
      "1f9d7-1f3fd",
      "1f9d7-1f3fe",
      "1f9d7-1f3ff"
    ],
    a: "5.0"
  },
  {
    n: [
      "man climbing"
    ],
    u: "1f9d7-200d-2642-fe0f",
    v: [
      "1f9d7-1f3fb-200d-2642-fe0f",
      "1f9d7-1f3fc-200d-2642-fe0f",
      "1f9d7-1f3fd-200d-2642-fe0f",
      "1f9d7-1f3fe-200d-2642-fe0f",
      "1f9d7-1f3ff-200d-2642-fe0f"
    ],
    a: "5.0"
  },
  {
    n: [
      "woman climbing"
    ],
    u: "1f9d7-200d-2640-fe0f",
    v: [
      "1f9d7-1f3fb-200d-2640-fe0f",
      "1f9d7-1f3fc-200d-2640-fe0f",
      "1f9d7-1f3fd-200d-2640-fe0f",
      "1f9d7-1f3fe-200d-2640-fe0f",
      "1f9d7-1f3ff-200d-2640-fe0f"
    ],
    a: "5.0"
  },
  {
    n: [
      "fencer"
    ],
    u: "1f93a",
    a: "3.0"
  },
  {
    n: [
      "horse racing"
    ],
    u: "1f3c7",
    v: [
      "1f3c7-1f3fb",
      "1f3c7-1f3fc",
      "1f3c7-1f3fd",
      "1f3c7-1f3fe",
      "1f3c7-1f3ff"
    ],
    a: "1.0"
  },
  {
    n: [
      "skier"
    ],
    u: "26f7-fe0f",
    a: "0.7"
  },
  {
    n: [
      "snowboarder"
    ],
    u: "1f3c2",
    v: [
      "1f3c2-1f3fb",
      "1f3c2-1f3fc",
      "1f3c2-1f3fd",
      "1f3c2-1f3fe",
      "1f3c2-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "golfer",
      "person golfing"
    ],
    u: "1f3cc-fe0f",
    v: [
      "1f3cc-1f3fb",
      "1f3cc-1f3fc",
      "1f3cc-1f3fd",
      "1f3cc-1f3fe",
      "1f3cc-1f3ff"
    ],
    a: "0.7"
  },
  {
    n: [
      "man golfing",
      "man-golfing"
    ],
    u: "1f3cc-fe0f-200d-2642-fe0f",
    v: [
      "1f3cc-1f3fb-200d-2642-fe0f",
      "1f3cc-1f3fc-200d-2642-fe0f",
      "1f3cc-1f3fd-200d-2642-fe0f",
      "1f3cc-1f3fe-200d-2642-fe0f",
      "1f3cc-1f3ff-200d-2642-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "woman golfing",
      "woman-golfing"
    ],
    u: "1f3cc-fe0f-200d-2640-fe0f",
    v: [
      "1f3cc-1f3fb-200d-2640-fe0f",
      "1f3cc-1f3fc-200d-2640-fe0f",
      "1f3cc-1f3fd-200d-2640-fe0f",
      "1f3cc-1f3fe-200d-2640-fe0f",
      "1f3cc-1f3ff-200d-2640-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "surfer"
    ],
    u: "1f3c4",
    v: [
      "1f3c4-1f3fb",
      "1f3c4-1f3fc",
      "1f3c4-1f3fd",
      "1f3c4-1f3fe",
      "1f3c4-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "man surfing",
      "man-surfing"
    ],
    u: "1f3c4-200d-2642-fe0f",
    v: [
      "1f3c4-1f3fb-200d-2642-fe0f",
      "1f3c4-1f3fc-200d-2642-fe0f",
      "1f3c4-1f3fd-200d-2642-fe0f",
      "1f3c4-1f3fe-200d-2642-fe0f",
      "1f3c4-1f3ff-200d-2642-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "woman surfing",
      "woman-surfing"
    ],
    u: "1f3c4-200d-2640-fe0f",
    v: [
      "1f3c4-1f3fb-200d-2640-fe0f",
      "1f3c4-1f3fc-200d-2640-fe0f",
      "1f3c4-1f3fd-200d-2640-fe0f",
      "1f3c4-1f3fe-200d-2640-fe0f",
      "1f3c4-1f3ff-200d-2640-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "rowboat"
    ],
    u: "1f6a3",
    v: [
      "1f6a3-1f3fb",
      "1f6a3-1f3fc",
      "1f6a3-1f3fd",
      "1f6a3-1f3fe",
      "1f6a3-1f3ff"
    ],
    a: "1.0"
  },
  {
    n: [
      "man rowing boat",
      "man-rowing-boat"
    ],
    u: "1f6a3-200d-2642-fe0f",
    v: [
      "1f6a3-1f3fb-200d-2642-fe0f",
      "1f6a3-1f3fc-200d-2642-fe0f",
      "1f6a3-1f3fd-200d-2642-fe0f",
      "1f6a3-1f3fe-200d-2642-fe0f",
      "1f6a3-1f3ff-200d-2642-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "woman rowing boat",
      "woman-rowing-boat"
    ],
    u: "1f6a3-200d-2640-fe0f",
    v: [
      "1f6a3-1f3fb-200d-2640-fe0f",
      "1f6a3-1f3fc-200d-2640-fe0f",
      "1f6a3-1f3fd-200d-2640-fe0f",
      "1f6a3-1f3fe-200d-2640-fe0f",
      "1f6a3-1f3ff-200d-2640-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "swimmer"
    ],
    u: "1f3ca",
    v: [
      "1f3ca-1f3fb",
      "1f3ca-1f3fc",
      "1f3ca-1f3fd",
      "1f3ca-1f3fe",
      "1f3ca-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "man swimming",
      "man-swimming"
    ],
    u: "1f3ca-200d-2642-fe0f",
    v: [
      "1f3ca-1f3fb-200d-2642-fe0f",
      "1f3ca-1f3fc-200d-2642-fe0f",
      "1f3ca-1f3fd-200d-2642-fe0f",
      "1f3ca-1f3fe-200d-2642-fe0f",
      "1f3ca-1f3ff-200d-2642-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "woman swimming",
      "woman-swimming"
    ],
    u: "1f3ca-200d-2640-fe0f",
    v: [
      "1f3ca-1f3fb-200d-2640-fe0f",
      "1f3ca-1f3fc-200d-2640-fe0f",
      "1f3ca-1f3fd-200d-2640-fe0f",
      "1f3ca-1f3fe-200d-2640-fe0f",
      "1f3ca-1f3ff-200d-2640-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "person with ball",
      "person bouncing ball"
    ],
    u: "26f9-fe0f",
    v: [
      "26f9-1f3fb",
      "26f9-1f3fc",
      "26f9-1f3fd",
      "26f9-1f3fe",
      "26f9-1f3ff"
    ],
    a: "0.7"
  },
  {
    n: [
      "man bouncing ball",
      "man-bouncing-ball"
    ],
    u: "26f9-fe0f-200d-2642-fe0f",
    v: [
      "26f9-1f3fb-200d-2642-fe0f",
      "26f9-1f3fc-200d-2642-fe0f",
      "26f9-1f3fd-200d-2642-fe0f",
      "26f9-1f3fe-200d-2642-fe0f",
      "26f9-1f3ff-200d-2642-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "woman bouncing ball",
      "woman-bouncing-ball"
    ],
    u: "26f9-fe0f-200d-2640-fe0f",
    v: [
      "26f9-1f3fb-200d-2640-fe0f",
      "26f9-1f3fc-200d-2640-fe0f",
      "26f9-1f3fd-200d-2640-fe0f",
      "26f9-1f3fe-200d-2640-fe0f",
      "26f9-1f3ff-200d-2640-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "weight lifter",
      "person lifting weights"
    ],
    u: "1f3cb-fe0f",
    v: [
      "1f3cb-1f3fb",
      "1f3cb-1f3fc",
      "1f3cb-1f3fd",
      "1f3cb-1f3fe",
      "1f3cb-1f3ff"
    ],
    a: "0.7"
  },
  {
    n: [
      "man lifting weights",
      "man-lifting-weights"
    ],
    u: "1f3cb-fe0f-200d-2642-fe0f",
    v: [
      "1f3cb-1f3fb-200d-2642-fe0f",
      "1f3cb-1f3fc-200d-2642-fe0f",
      "1f3cb-1f3fd-200d-2642-fe0f",
      "1f3cb-1f3fe-200d-2642-fe0f",
      "1f3cb-1f3ff-200d-2642-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "woman lifting weights",
      "woman-lifting-weights"
    ],
    u: "1f3cb-fe0f-200d-2640-fe0f",
    v: [
      "1f3cb-1f3fb-200d-2640-fe0f",
      "1f3cb-1f3fc-200d-2640-fe0f",
      "1f3cb-1f3fd-200d-2640-fe0f",
      "1f3cb-1f3fe-200d-2640-fe0f",
      "1f3cb-1f3ff-200d-2640-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "bicyclist"
    ],
    u: "1f6b4",
    v: [
      "1f6b4-1f3fb",
      "1f6b4-1f3fc",
      "1f6b4-1f3fd",
      "1f6b4-1f3fe",
      "1f6b4-1f3ff"
    ],
    a: "1.0"
  },
  {
    n: [
      "man biking",
      "man-biking"
    ],
    u: "1f6b4-200d-2642-fe0f",
    v: [
      "1f6b4-1f3fb-200d-2642-fe0f",
      "1f6b4-1f3fc-200d-2642-fe0f",
      "1f6b4-1f3fd-200d-2642-fe0f",
      "1f6b4-1f3fe-200d-2642-fe0f",
      "1f6b4-1f3ff-200d-2642-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "woman biking",
      "woman-biking"
    ],
    u: "1f6b4-200d-2640-fe0f",
    v: [
      "1f6b4-1f3fb-200d-2640-fe0f",
      "1f6b4-1f3fc-200d-2640-fe0f",
      "1f6b4-1f3fd-200d-2640-fe0f",
      "1f6b4-1f3fe-200d-2640-fe0f",
      "1f6b4-1f3ff-200d-2640-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "mountain bicyclist"
    ],
    u: "1f6b5",
    v: [
      "1f6b5-1f3fb",
      "1f6b5-1f3fc",
      "1f6b5-1f3fd",
      "1f6b5-1f3fe",
      "1f6b5-1f3ff"
    ],
    a: "1.0"
  },
  {
    n: [
      "man mountain biking",
      "man-mountain-biking"
    ],
    u: "1f6b5-200d-2642-fe0f",
    v: [
      "1f6b5-1f3fb-200d-2642-fe0f",
      "1f6b5-1f3fc-200d-2642-fe0f",
      "1f6b5-1f3fd-200d-2642-fe0f",
      "1f6b5-1f3fe-200d-2642-fe0f",
      "1f6b5-1f3ff-200d-2642-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "woman mountain biking",
      "woman-mountain-biking"
    ],
    u: "1f6b5-200d-2640-fe0f",
    v: [
      "1f6b5-1f3fb-200d-2640-fe0f",
      "1f6b5-1f3fc-200d-2640-fe0f",
      "1f6b5-1f3fd-200d-2640-fe0f",
      "1f6b5-1f3fe-200d-2640-fe0f",
      "1f6b5-1f3ff-200d-2640-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "person doing cartwheel"
    ],
    u: "1f938",
    v: [
      "1f938-1f3fb",
      "1f938-1f3fc",
      "1f938-1f3fd",
      "1f938-1f3fe",
      "1f938-1f3ff"
    ],
    a: "3.0"
  },
  {
    n: [
      "man cartwheeling",
      "man-cartwheeling"
    ],
    u: "1f938-200d-2642-fe0f",
    v: [
      "1f938-1f3fb-200d-2642-fe0f",
      "1f938-1f3fc-200d-2642-fe0f",
      "1f938-1f3fd-200d-2642-fe0f",
      "1f938-1f3fe-200d-2642-fe0f",
      "1f938-1f3ff-200d-2642-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "woman cartwheeling",
      "woman-cartwheeling"
    ],
    u: "1f938-200d-2640-fe0f",
    v: [
      "1f938-1f3fb-200d-2640-fe0f",
      "1f938-1f3fc-200d-2640-fe0f",
      "1f938-1f3fd-200d-2640-fe0f",
      "1f938-1f3fe-200d-2640-fe0f",
      "1f938-1f3ff-200d-2640-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "wrestlers"
    ],
    u: "1f93c",
    a: "3.0"
  },
  {
    n: [
      "men wrestling",
      "man-wrestling"
    ],
    u: "1f93c-200d-2642-fe0f",
    a: "4.0"
  },
  {
    n: [
      "women wrestling",
      "woman-wrestling"
    ],
    u: "1f93c-200d-2640-fe0f",
    a: "4.0"
  },
  {
    n: [
      "water polo"
    ],
    u: "1f93d",
    v: [
      "1f93d-1f3fb",
      "1f93d-1f3fc",
      "1f93d-1f3fd",
      "1f93d-1f3fe",
      "1f93d-1f3ff"
    ],
    a: "3.0"
  },
  {
    n: [
      "man playing water polo",
      "man-playing-water-polo"
    ],
    u: "1f93d-200d-2642-fe0f",
    v: [
      "1f93d-1f3fb-200d-2642-fe0f",
      "1f93d-1f3fc-200d-2642-fe0f",
      "1f93d-1f3fd-200d-2642-fe0f",
      "1f93d-1f3fe-200d-2642-fe0f",
      "1f93d-1f3ff-200d-2642-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "woman playing water polo",
      "woman-playing-water-polo"
    ],
    u: "1f93d-200d-2640-fe0f",
    v: [
      "1f93d-1f3fb-200d-2640-fe0f",
      "1f93d-1f3fc-200d-2640-fe0f",
      "1f93d-1f3fd-200d-2640-fe0f",
      "1f93d-1f3fe-200d-2640-fe0f",
      "1f93d-1f3ff-200d-2640-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "handball"
    ],
    u: "1f93e",
    v: [
      "1f93e-1f3fb",
      "1f93e-1f3fc",
      "1f93e-1f3fd",
      "1f93e-1f3fe",
      "1f93e-1f3ff"
    ],
    a: "3.0"
  },
  {
    n: [
      "man playing handball",
      "man-playing-handball"
    ],
    u: "1f93e-200d-2642-fe0f",
    v: [
      "1f93e-1f3fb-200d-2642-fe0f",
      "1f93e-1f3fc-200d-2642-fe0f",
      "1f93e-1f3fd-200d-2642-fe0f",
      "1f93e-1f3fe-200d-2642-fe0f",
      "1f93e-1f3ff-200d-2642-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "woman playing handball",
      "woman-playing-handball"
    ],
    u: "1f93e-200d-2640-fe0f",
    v: [
      "1f93e-1f3fb-200d-2640-fe0f",
      "1f93e-1f3fc-200d-2640-fe0f",
      "1f93e-1f3fd-200d-2640-fe0f",
      "1f93e-1f3fe-200d-2640-fe0f",
      "1f93e-1f3ff-200d-2640-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "juggling"
    ],
    u: "1f939",
    v: [
      "1f939-1f3fb",
      "1f939-1f3fc",
      "1f939-1f3fd",
      "1f939-1f3fe",
      "1f939-1f3ff"
    ],
    a: "3.0"
  },
  {
    n: [
      "man juggling",
      "man-juggling"
    ],
    u: "1f939-200d-2642-fe0f",
    v: [
      "1f939-1f3fb-200d-2642-fe0f",
      "1f939-1f3fc-200d-2642-fe0f",
      "1f939-1f3fd-200d-2642-fe0f",
      "1f939-1f3fe-200d-2642-fe0f",
      "1f939-1f3ff-200d-2642-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "woman juggling",
      "woman-juggling"
    ],
    u: "1f939-200d-2640-fe0f",
    v: [
      "1f939-1f3fb-200d-2640-fe0f",
      "1f939-1f3fc-200d-2640-fe0f",
      "1f939-1f3fd-200d-2640-fe0f",
      "1f939-1f3fe-200d-2640-fe0f",
      "1f939-1f3ff-200d-2640-fe0f"
    ],
    a: "4.0"
  },
  {
    n: [
      "person in lotus position"
    ],
    u: "1f9d8",
    v: [
      "1f9d8-1f3fb",
      "1f9d8-1f3fc",
      "1f9d8-1f3fd",
      "1f9d8-1f3fe",
      "1f9d8-1f3ff"
    ],
    a: "5.0"
  },
  {
    n: [
      "man in lotus position"
    ],
    u: "1f9d8-200d-2642-fe0f",
    v: [
      "1f9d8-1f3fb-200d-2642-fe0f",
      "1f9d8-1f3fc-200d-2642-fe0f",
      "1f9d8-1f3fd-200d-2642-fe0f",
      "1f9d8-1f3fe-200d-2642-fe0f",
      "1f9d8-1f3ff-200d-2642-fe0f"
    ],
    a: "5.0"
  },
  {
    n: [
      "woman in lotus position"
    ],
    u: "1f9d8-200d-2640-fe0f",
    v: [
      "1f9d8-1f3fb-200d-2640-fe0f",
      "1f9d8-1f3fc-200d-2640-fe0f",
      "1f9d8-1f3fd-200d-2640-fe0f",
      "1f9d8-1f3fe-200d-2640-fe0f",
      "1f9d8-1f3ff-200d-2640-fe0f"
    ],
    a: "5.0"
  },
  {
    n: [
      "bath"
    ],
    u: "1f6c0",
    v: [
      "1f6c0-1f3fb",
      "1f6c0-1f3fc",
      "1f6c0-1f3fd",
      "1f6c0-1f3fe",
      "1f6c0-1f3ff"
    ],
    a: "0.6"
  },
  {
    n: [
      "sleeping accommodation"
    ],
    u: "1f6cc",
    v: [
      "1f6cc-1f3fb",
      "1f6cc-1f3fc",
      "1f6cc-1f3fd",
      "1f6cc-1f3fe",
      "1f6cc-1f3ff"
    ],
    a: "1.0"
  },
  {
    n: [
      "people holding hands"
    ],
    u: "1f9d1-200d-1f91d-200d-1f9d1",
    v: [
      "1f9d1-1f3fb-200d-1f91d-200d-1f9d1-1f3fb",
      "1f9d1-1f3fb-200d-1f91d-200d-1f9d1-1f3fc",
      "1f9d1-1f3fb-200d-1f91d-200d-1f9d1-1f3fd",
      "1f9d1-1f3fb-200d-1f91d-200d-1f9d1-1f3fe",
      "1f9d1-1f3fb-200d-1f91d-200d-1f9d1-1f3ff",
      "1f9d1-1f3fc-200d-1f91d-200d-1f9d1-1f3fb",
      "1f9d1-1f3fc-200d-1f91d-200d-1f9d1-1f3fc",
      "1f9d1-1f3fc-200d-1f91d-200d-1f9d1-1f3fd",
      "1f9d1-1f3fc-200d-1f91d-200d-1f9d1-1f3fe",
      "1f9d1-1f3fc-200d-1f91d-200d-1f9d1-1f3ff",
      "1f9d1-1f3fd-200d-1f91d-200d-1f9d1-1f3fb",
      "1f9d1-1f3fd-200d-1f91d-200d-1f9d1-1f3fc",
      "1f9d1-1f3fd-200d-1f91d-200d-1f9d1-1f3fd",
      "1f9d1-1f3fd-200d-1f91d-200d-1f9d1-1f3fe",
      "1f9d1-1f3fd-200d-1f91d-200d-1f9d1-1f3ff",
      "1f9d1-1f3fe-200d-1f91d-200d-1f9d1-1f3fb",
      "1f9d1-1f3fe-200d-1f91d-200d-1f9d1-1f3fc",
      "1f9d1-1f3fe-200d-1f91d-200d-1f9d1-1f3fd",
      "1f9d1-1f3fe-200d-1f91d-200d-1f9d1-1f3fe",
      "1f9d1-1f3fe-200d-1f91d-200d-1f9d1-1f3ff",
      "1f9d1-1f3ff-200d-1f91d-200d-1f9d1-1f3fb",
      "1f9d1-1f3ff-200d-1f91d-200d-1f9d1-1f3fc",
      "1f9d1-1f3ff-200d-1f91d-200d-1f9d1-1f3fd",
      "1f9d1-1f3ff-200d-1f91d-200d-1f9d1-1f3fe",
      "1f9d1-1f3ff-200d-1f91d-200d-1f9d1-1f3ff"
    ],
    a: "12.0"
  },
  {
    n: [
      "women holding hands",
      "two women holding hands"
    ],
    u: "1f46d",
    v: [
      "1f46d-1f3fb",
      "1f46d-1f3fc",
      "1f46d-1f3fd",
      "1f46d-1f3fe",
      "1f46d-1f3ff",
      "1f469-1f3fb-200d-1f91d-200d-1f469-1f3fc",
      "1f469-1f3fb-200d-1f91d-200d-1f469-1f3fd",
      "1f469-1f3fb-200d-1f91d-200d-1f469-1f3fe",
      "1f469-1f3fb-200d-1f91d-200d-1f469-1f3ff",
      "1f469-1f3fc-200d-1f91d-200d-1f469-1f3fb",
      "1f469-1f3fc-200d-1f91d-200d-1f469-1f3fd",
      "1f469-1f3fc-200d-1f91d-200d-1f469-1f3fe",
      "1f469-1f3fc-200d-1f91d-200d-1f469-1f3ff",
      "1f469-1f3fd-200d-1f91d-200d-1f469-1f3fb",
      "1f469-1f3fd-200d-1f91d-200d-1f469-1f3fc",
      "1f469-1f3fd-200d-1f91d-200d-1f469-1f3fe",
      "1f469-1f3fd-200d-1f91d-200d-1f469-1f3ff",
      "1f469-1f3fe-200d-1f91d-200d-1f469-1f3fb",
      "1f469-1f3fe-200d-1f91d-200d-1f469-1f3fc",
      "1f469-1f3fe-200d-1f91d-200d-1f469-1f3fd",
      "1f469-1f3fe-200d-1f91d-200d-1f469-1f3ff",
      "1f469-1f3ff-200d-1f91d-200d-1f469-1f3fb",
      "1f469-1f3ff-200d-1f91d-200d-1f469-1f3fc",
      "1f469-1f3ff-200d-1f91d-200d-1f469-1f3fd",
      "1f469-1f3ff-200d-1f91d-200d-1f469-1f3fe"
    ],
    a: "1.0"
  },
  {
    n: [
      "couple",
      "man and woman holding hands",
      "woman and man holding hands"
    ],
    u: "1f46b",
    v: [
      "1f46b-1f3fb",
      "1f46b-1f3fc",
      "1f46b-1f3fd",
      "1f46b-1f3fe",
      "1f46b-1f3ff",
      "1f469-1f3fb-200d-1f91d-200d-1f468-1f3fc",
      "1f469-1f3fb-200d-1f91d-200d-1f468-1f3fd",
      "1f469-1f3fb-200d-1f91d-200d-1f468-1f3fe",
      "1f469-1f3fb-200d-1f91d-200d-1f468-1f3ff",
      "1f469-1f3fc-200d-1f91d-200d-1f468-1f3fb",
      "1f469-1f3fc-200d-1f91d-200d-1f468-1f3fd",
      "1f469-1f3fc-200d-1f91d-200d-1f468-1f3fe",
      "1f469-1f3fc-200d-1f91d-200d-1f468-1f3ff",
      "1f469-1f3fd-200d-1f91d-200d-1f468-1f3fb",
      "1f469-1f3fd-200d-1f91d-200d-1f468-1f3fc",
      "1f469-1f3fd-200d-1f91d-200d-1f468-1f3fe",
      "1f469-1f3fd-200d-1f91d-200d-1f468-1f3ff",
      "1f469-1f3fe-200d-1f91d-200d-1f468-1f3fb",
      "1f469-1f3fe-200d-1f91d-200d-1f468-1f3fc",
      "1f469-1f3fe-200d-1f91d-200d-1f468-1f3fd",
      "1f469-1f3fe-200d-1f91d-200d-1f468-1f3ff",
      "1f469-1f3ff-200d-1f91d-200d-1f468-1f3fb",
      "1f469-1f3ff-200d-1f91d-200d-1f468-1f3fc",
      "1f469-1f3ff-200d-1f91d-200d-1f468-1f3fd",
      "1f469-1f3ff-200d-1f91d-200d-1f468-1f3fe"
    ],
    a: "0.6"
  },
  {
    n: [
      "men holding hands",
      "two men holding hands"
    ],
    u: "1f46c",
    v: [
      "1f46c-1f3fb",
      "1f46c-1f3fc",
      "1f46c-1f3fd",
      "1f46c-1f3fe",
      "1f46c-1f3ff",
      "1f468-1f3fb-200d-1f91d-200d-1f468-1f3fc",
      "1f468-1f3fb-200d-1f91d-200d-1f468-1f3fd",
      "1f468-1f3fb-200d-1f91d-200d-1f468-1f3fe",
      "1f468-1f3fb-200d-1f91d-200d-1f468-1f3ff",
      "1f468-1f3fc-200d-1f91d-200d-1f468-1f3fb",
      "1f468-1f3fc-200d-1f91d-200d-1f468-1f3fd",
      "1f468-1f3fc-200d-1f91d-200d-1f468-1f3fe",
      "1f468-1f3fc-200d-1f91d-200d-1f468-1f3ff",
      "1f468-1f3fd-200d-1f91d-200d-1f468-1f3fb",
      "1f468-1f3fd-200d-1f91d-200d-1f468-1f3fc",
      "1f468-1f3fd-200d-1f91d-200d-1f468-1f3fe",
      "1f468-1f3fd-200d-1f91d-200d-1f468-1f3ff",
      "1f468-1f3fe-200d-1f91d-200d-1f468-1f3fb",
      "1f468-1f3fe-200d-1f91d-200d-1f468-1f3fc",
      "1f468-1f3fe-200d-1f91d-200d-1f468-1f3fd",
      "1f468-1f3fe-200d-1f91d-200d-1f468-1f3ff",
      "1f468-1f3ff-200d-1f91d-200d-1f468-1f3fb",
      "1f468-1f3ff-200d-1f91d-200d-1f468-1f3fc",
      "1f468-1f3ff-200d-1f91d-200d-1f468-1f3fd",
      "1f468-1f3ff-200d-1f91d-200d-1f468-1f3fe"
    ],
    a: "1.0"
  },
  {
    n: [
      "kiss",
      "couplekiss"
    ],
    u: "1f48f",
    v: [
      "1f48f-1f3fb",
      "1f48f-1f3fc",
      "1f48f-1f3fd",
      "1f48f-1f3fe",
      "1f48f-1f3ff",
      "1f9d1-1f3fb-200d-2764-fe0f-200d-1f48b-200d-1f9d1-1f3fc",
      "1f9d1-1f3fb-200d-2764-fe0f-200d-1f48b-200d-1f9d1-1f3fd",
      "1f9d1-1f3fb-200d-2764-fe0f-200d-1f48b-200d-1f9d1-1f3fe",
      "1f9d1-1f3fb-200d-2764-fe0f-200d-1f48b-200d-1f9d1-1f3ff",
      "1f9d1-1f3fc-200d-2764-fe0f-200d-1f48b-200d-1f9d1-1f3fb",
      "1f9d1-1f3fc-200d-2764-fe0f-200d-1f48b-200d-1f9d1-1f3fd",
      "1f9d1-1f3fc-200d-2764-fe0f-200d-1f48b-200d-1f9d1-1f3fe",
      "1f9d1-1f3fc-200d-2764-fe0f-200d-1f48b-200d-1f9d1-1f3ff",
      "1f9d1-1f3fd-200d-2764-fe0f-200d-1f48b-200d-1f9d1-1f3fb",
      "1f9d1-1f3fd-200d-2764-fe0f-200d-1f48b-200d-1f9d1-1f3fc",
      "1f9d1-1f3fd-200d-2764-fe0f-200d-1f48b-200d-1f9d1-1f3fe",
      "1f9d1-1f3fd-200d-2764-fe0f-200d-1f48b-200d-1f9d1-1f3ff",
      "1f9d1-1f3fe-200d-2764-fe0f-200d-1f48b-200d-1f9d1-1f3fb",
      "1f9d1-1f3fe-200d-2764-fe0f-200d-1f48b-200d-1f9d1-1f3fc",
      "1f9d1-1f3fe-200d-2764-fe0f-200d-1f48b-200d-1f9d1-1f3fd",
      "1f9d1-1f3fe-200d-2764-fe0f-200d-1f48b-200d-1f9d1-1f3ff",
      "1f9d1-1f3ff-200d-2764-fe0f-200d-1f48b-200d-1f9d1-1f3fb",
      "1f9d1-1f3ff-200d-2764-fe0f-200d-1f48b-200d-1f9d1-1f3fc",
      "1f9d1-1f3ff-200d-2764-fe0f-200d-1f48b-200d-1f9d1-1f3fd",
      "1f9d1-1f3ff-200d-2764-fe0f-200d-1f48b-200d-1f9d1-1f3fe"
    ],
    a: "0.6"
  },
  {
    n: [
      "woman-kiss-man",
      "kiss: woman, man"
    ],
    u: "1f469-200d-2764-fe0f-200d-1f48b-200d-1f468",
    v: [
      "1f469-1f3fb-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fb",
      "1f469-1f3fb-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fc",
      "1f469-1f3fb-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fd",
      "1f469-1f3fb-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fe",
      "1f469-1f3fb-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3ff",
      "1f469-1f3fc-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fb",
      "1f469-1f3fc-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fc",
      "1f469-1f3fc-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fd",
      "1f469-1f3fc-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fe",
      "1f469-1f3fc-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3ff",
      "1f469-1f3fd-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fb",
      "1f469-1f3fd-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fc",
      "1f469-1f3fd-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fd",
      "1f469-1f3fd-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fe",
      "1f469-1f3fd-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3ff",
      "1f469-1f3fe-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fb",
      "1f469-1f3fe-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fc",
      "1f469-1f3fe-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fd",
      "1f469-1f3fe-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fe",
      "1f469-1f3fe-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3ff",
      "1f469-1f3ff-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fb",
      "1f469-1f3ff-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fc",
      "1f469-1f3ff-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fd",
      "1f469-1f3ff-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fe",
      "1f469-1f3ff-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3ff"
    ],
    a: "2.0"
  },
  {
    n: [
      "man-kiss-man",
      "kiss: man, man"
    ],
    u: "1f468-200d-2764-fe0f-200d-1f48b-200d-1f468",
    v: [
      "1f468-1f3fb-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fb",
      "1f468-1f3fb-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fc",
      "1f468-1f3fb-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fd",
      "1f468-1f3fb-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fe",
      "1f468-1f3fb-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3ff",
      "1f468-1f3fc-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fb",
      "1f468-1f3fc-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fc",
      "1f468-1f3fc-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fd",
      "1f468-1f3fc-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fe",
      "1f468-1f3fc-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3ff",
      "1f468-1f3fd-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fb",
      "1f468-1f3fd-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fc",
      "1f468-1f3fd-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fd",
      "1f468-1f3fd-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fe",
      "1f468-1f3fd-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3ff",
      "1f468-1f3fe-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fb",
      "1f468-1f3fe-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fc",
      "1f468-1f3fe-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fd",
      "1f468-1f3fe-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fe",
      "1f468-1f3fe-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3ff",
      "1f468-1f3ff-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fb",
      "1f468-1f3ff-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fc",
      "1f468-1f3ff-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fd",
      "1f468-1f3ff-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fe",
      "1f468-1f3ff-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3ff"
    ],
    a: "2.0"
  },
  {
    n: [
      "woman-kiss-woman",
      "kiss: woman, woman"
    ],
    u: "1f469-200d-2764-fe0f-200d-1f48b-200d-1f469",
    v: [
      "1f469-1f3fb-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3fb",
      "1f469-1f3fb-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3fc",
      "1f469-1f3fb-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3fd",
      "1f469-1f3fb-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3fe",
      "1f469-1f3fb-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3ff",
      "1f469-1f3fc-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3fb",
      "1f469-1f3fc-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3fc",
      "1f469-1f3fc-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3fd",
      "1f469-1f3fc-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3fe",
      "1f469-1f3fc-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3ff",
      "1f469-1f3fd-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3fb",
      "1f469-1f3fd-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3fc",
      "1f469-1f3fd-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3fd",
      "1f469-1f3fd-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3fe",
      "1f469-1f3fd-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3ff",
      "1f469-1f3fe-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3fb",
      "1f469-1f3fe-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3fc",
      "1f469-1f3fe-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3fd",
      "1f469-1f3fe-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3fe",
      "1f469-1f3fe-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3ff",
      "1f469-1f3ff-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3fb",
      "1f469-1f3ff-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3fc",
      "1f469-1f3ff-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3fd",
      "1f469-1f3ff-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3fe",
      "1f469-1f3ff-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3ff"
    ],
    a: "2.0"
  },
  {
    n: [
      "couple with heart"
    ],
    u: "1f491",
    v: [
      "1f491-1f3fb",
      "1f491-1f3fc",
      "1f491-1f3fd",
      "1f491-1f3fe",
      "1f491-1f3ff",
      "1f9d1-1f3fb-200d-2764-fe0f-200d-1f9d1-1f3fc",
      "1f9d1-1f3fb-200d-2764-fe0f-200d-1f9d1-1f3fd",
      "1f9d1-1f3fb-200d-2764-fe0f-200d-1f9d1-1f3fe",
      "1f9d1-1f3fb-200d-2764-fe0f-200d-1f9d1-1f3ff",
      "1f9d1-1f3fc-200d-2764-fe0f-200d-1f9d1-1f3fb",
      "1f9d1-1f3fc-200d-2764-fe0f-200d-1f9d1-1f3fd",
      "1f9d1-1f3fc-200d-2764-fe0f-200d-1f9d1-1f3fe",
      "1f9d1-1f3fc-200d-2764-fe0f-200d-1f9d1-1f3ff",
      "1f9d1-1f3fd-200d-2764-fe0f-200d-1f9d1-1f3fb",
      "1f9d1-1f3fd-200d-2764-fe0f-200d-1f9d1-1f3fc",
      "1f9d1-1f3fd-200d-2764-fe0f-200d-1f9d1-1f3fe",
      "1f9d1-1f3fd-200d-2764-fe0f-200d-1f9d1-1f3ff",
      "1f9d1-1f3fe-200d-2764-fe0f-200d-1f9d1-1f3fb",
      "1f9d1-1f3fe-200d-2764-fe0f-200d-1f9d1-1f3fc",
      "1f9d1-1f3fe-200d-2764-fe0f-200d-1f9d1-1f3fd",
      "1f9d1-1f3fe-200d-2764-fe0f-200d-1f9d1-1f3ff",
      "1f9d1-1f3ff-200d-2764-fe0f-200d-1f9d1-1f3fb",
      "1f9d1-1f3ff-200d-2764-fe0f-200d-1f9d1-1f3fc",
      "1f9d1-1f3ff-200d-2764-fe0f-200d-1f9d1-1f3fd",
      "1f9d1-1f3ff-200d-2764-fe0f-200d-1f9d1-1f3fe"
    ],
    a: "0.6"
  },
  {
    n: [
      "woman-heart-man",
      "couple with heart: woman, man"
    ],
    u: "1f469-200d-2764-fe0f-200d-1f468",
    v: [
      "1f469-1f3fb-200d-2764-fe0f-200d-1f468-1f3fb",
      "1f469-1f3fb-200d-2764-fe0f-200d-1f468-1f3fc",
      "1f469-1f3fb-200d-2764-fe0f-200d-1f468-1f3fd",
      "1f469-1f3fb-200d-2764-fe0f-200d-1f468-1f3fe",
      "1f469-1f3fb-200d-2764-fe0f-200d-1f468-1f3ff",
      "1f469-1f3fc-200d-2764-fe0f-200d-1f468-1f3fb",
      "1f469-1f3fc-200d-2764-fe0f-200d-1f468-1f3fc",
      "1f469-1f3fc-200d-2764-fe0f-200d-1f468-1f3fd",
      "1f469-1f3fc-200d-2764-fe0f-200d-1f468-1f3fe",
      "1f469-1f3fc-200d-2764-fe0f-200d-1f468-1f3ff",
      "1f469-1f3fd-200d-2764-fe0f-200d-1f468-1f3fb",
      "1f469-1f3fd-200d-2764-fe0f-200d-1f468-1f3fc",
      "1f469-1f3fd-200d-2764-fe0f-200d-1f468-1f3fd",
      "1f469-1f3fd-200d-2764-fe0f-200d-1f468-1f3fe",
      "1f469-1f3fd-200d-2764-fe0f-200d-1f468-1f3ff",
      "1f469-1f3fe-200d-2764-fe0f-200d-1f468-1f3fb",
      "1f469-1f3fe-200d-2764-fe0f-200d-1f468-1f3fc",
      "1f469-1f3fe-200d-2764-fe0f-200d-1f468-1f3fd",
      "1f469-1f3fe-200d-2764-fe0f-200d-1f468-1f3fe",
      "1f469-1f3fe-200d-2764-fe0f-200d-1f468-1f3ff",
      "1f469-1f3ff-200d-2764-fe0f-200d-1f468-1f3fb",
      "1f469-1f3ff-200d-2764-fe0f-200d-1f468-1f3fc",
      "1f469-1f3ff-200d-2764-fe0f-200d-1f468-1f3fd",
      "1f469-1f3ff-200d-2764-fe0f-200d-1f468-1f3fe",
      "1f469-1f3ff-200d-2764-fe0f-200d-1f468-1f3ff"
    ],
    a: "2.0"
  },
  {
    n: [
      "man-heart-man",
      "couple with heart: man, man"
    ],
    u: "1f468-200d-2764-fe0f-200d-1f468",
    v: [
      "1f468-1f3fb-200d-2764-fe0f-200d-1f468-1f3fb",
      "1f468-1f3fb-200d-2764-fe0f-200d-1f468-1f3fc",
      "1f468-1f3fb-200d-2764-fe0f-200d-1f468-1f3fd",
      "1f468-1f3fb-200d-2764-fe0f-200d-1f468-1f3fe",
      "1f468-1f3fb-200d-2764-fe0f-200d-1f468-1f3ff",
      "1f468-1f3fc-200d-2764-fe0f-200d-1f468-1f3fb",
      "1f468-1f3fc-200d-2764-fe0f-200d-1f468-1f3fc",
      "1f468-1f3fc-200d-2764-fe0f-200d-1f468-1f3fd",
      "1f468-1f3fc-200d-2764-fe0f-200d-1f468-1f3fe",
      "1f468-1f3fc-200d-2764-fe0f-200d-1f468-1f3ff",
      "1f468-1f3fd-200d-2764-fe0f-200d-1f468-1f3fb",
      "1f468-1f3fd-200d-2764-fe0f-200d-1f468-1f3fc",
      "1f468-1f3fd-200d-2764-fe0f-200d-1f468-1f3fd",
      "1f468-1f3fd-200d-2764-fe0f-200d-1f468-1f3fe",
      "1f468-1f3fd-200d-2764-fe0f-200d-1f468-1f3ff",
      "1f468-1f3fe-200d-2764-fe0f-200d-1f468-1f3fb",
      "1f468-1f3fe-200d-2764-fe0f-200d-1f468-1f3fc",
      "1f468-1f3fe-200d-2764-fe0f-200d-1f468-1f3fd",
      "1f468-1f3fe-200d-2764-fe0f-200d-1f468-1f3fe",
      "1f468-1f3fe-200d-2764-fe0f-200d-1f468-1f3ff",
      "1f468-1f3ff-200d-2764-fe0f-200d-1f468-1f3fb",
      "1f468-1f3ff-200d-2764-fe0f-200d-1f468-1f3fc",
      "1f468-1f3ff-200d-2764-fe0f-200d-1f468-1f3fd",
      "1f468-1f3ff-200d-2764-fe0f-200d-1f468-1f3fe",
      "1f468-1f3ff-200d-2764-fe0f-200d-1f468-1f3ff"
    ],
    a: "2.0"
  },
  {
    n: [
      "woman-heart-woman",
      "couple with heart: woman, woman"
    ],
    u: "1f469-200d-2764-fe0f-200d-1f469",
    v: [
      "1f469-1f3fb-200d-2764-fe0f-200d-1f469-1f3fb",
      "1f469-1f3fb-200d-2764-fe0f-200d-1f469-1f3fc",
      "1f469-1f3fb-200d-2764-fe0f-200d-1f469-1f3fd",
      "1f469-1f3fb-200d-2764-fe0f-200d-1f469-1f3fe",
      "1f469-1f3fb-200d-2764-fe0f-200d-1f469-1f3ff",
      "1f469-1f3fc-200d-2764-fe0f-200d-1f469-1f3fb",
      "1f469-1f3fc-200d-2764-fe0f-200d-1f469-1f3fc",
      "1f469-1f3fc-200d-2764-fe0f-200d-1f469-1f3fd",
      "1f469-1f3fc-200d-2764-fe0f-200d-1f469-1f3fe",
      "1f469-1f3fc-200d-2764-fe0f-200d-1f469-1f3ff",
      "1f469-1f3fd-200d-2764-fe0f-200d-1f469-1f3fb",
      "1f469-1f3fd-200d-2764-fe0f-200d-1f469-1f3fc",
      "1f469-1f3fd-200d-2764-fe0f-200d-1f469-1f3fd",
      "1f469-1f3fd-200d-2764-fe0f-200d-1f469-1f3fe",
      "1f469-1f3fd-200d-2764-fe0f-200d-1f469-1f3ff",
      "1f469-1f3fe-200d-2764-fe0f-200d-1f469-1f3fb",
      "1f469-1f3fe-200d-2764-fe0f-200d-1f469-1f3fc",
      "1f469-1f3fe-200d-2764-fe0f-200d-1f469-1f3fd",
      "1f469-1f3fe-200d-2764-fe0f-200d-1f469-1f3fe",
      "1f469-1f3fe-200d-2764-fe0f-200d-1f469-1f3ff",
      "1f469-1f3ff-200d-2764-fe0f-200d-1f469-1f3fb",
      "1f469-1f3ff-200d-2764-fe0f-200d-1f469-1f3fc",
      "1f469-1f3ff-200d-2764-fe0f-200d-1f469-1f3fd",
      "1f469-1f3ff-200d-2764-fe0f-200d-1f469-1f3fe",
      "1f469-1f3ff-200d-2764-fe0f-200d-1f469-1f3ff"
    ],
    a: "2.0"
  },
  {
    n: [
      "family"
    ],
    u: "1f46a",
    a: "0.6"
  },
  {
    n: [
      "man-woman-boy",
      "family: man, woman, boy"
    ],
    u: "1f468-200d-1f469-200d-1f466",
    a: "2.0"
  },
  {
    n: [
      "man-woman-girl",
      "family: man, woman, girl"
    ],
    u: "1f468-200d-1f469-200d-1f467",
    a: "2.0"
  },
  {
    n: [
      "man-woman-girl-boy",
      "family: man, woman, girl, boy"
    ],
    u: "1f468-200d-1f469-200d-1f467-200d-1f466",
    a: "2.0"
  },
  {
    n: [
      "man-woman-boy-boy",
      "family: man, woman, boy, boy"
    ],
    u: "1f468-200d-1f469-200d-1f466-200d-1f466",
    a: "2.0"
  },
  {
    n: [
      "man-woman-girl-girl",
      "family: man, woman, girl, girl"
    ],
    u: "1f468-200d-1f469-200d-1f467-200d-1f467",
    a: "2.0"
  },
  {
    n: [
      "man-man-boy",
      "family: man, man, boy"
    ],
    u: "1f468-200d-1f468-200d-1f466",
    a: "2.0"
  },
  {
    n: [
      "man-man-girl",
      "family: man, man, girl"
    ],
    u: "1f468-200d-1f468-200d-1f467",
    a: "2.0"
  },
  {
    n: [
      "man-man-girl-boy",
      "family: man, man, girl, boy"
    ],
    u: "1f468-200d-1f468-200d-1f467-200d-1f466",
    a: "2.0"
  },
  {
    n: [
      "man-man-boy-boy",
      "family: man, man, boy, boy"
    ],
    u: "1f468-200d-1f468-200d-1f466-200d-1f466",
    a: "2.0"
  },
  {
    n: [
      "man-man-girl-girl",
      "family: man, man, girl, girl"
    ],
    u: "1f468-200d-1f468-200d-1f467-200d-1f467",
    a: "2.0"
  },
  {
    n: [
      "woman-woman-boy",
      "family: woman, woman, boy"
    ],
    u: "1f469-200d-1f469-200d-1f466",
    a: "2.0"
  },
  {
    n: [
      "woman-woman-girl",
      "family: woman, woman, girl"
    ],
    u: "1f469-200d-1f469-200d-1f467",
    a: "2.0"
  },
  {
    n: [
      "woman-woman-girl-boy",
      "family: woman, woman, girl, boy"
    ],
    u: "1f469-200d-1f469-200d-1f467-200d-1f466",
    a: "2.0"
  },
  {
    n: [
      "woman-woman-boy-boy",
      "family: woman, woman, boy, boy"
    ],
    u: "1f469-200d-1f469-200d-1f466-200d-1f466",
    a: "2.0"
  },
  {
    n: [
      "woman-woman-girl-girl",
      "family: woman, woman, girl, girl"
    ],
    u: "1f469-200d-1f469-200d-1f467-200d-1f467",
    a: "2.0"
  },
  {
    n: [
      "man-boy",
      "family: man, boy"
    ],
    u: "1f468-200d-1f466",
    a: "4.0"
  },
  {
    n: [
      "man-boy-boy",
      "family: man, boy, boy"
    ],
    u: "1f468-200d-1f466-200d-1f466",
    a: "4.0"
  },
  {
    n: [
      "man-girl",
      "family: man, girl"
    ],
    u: "1f468-200d-1f467",
    a: "4.0"
  },
  {
    n: [
      "man-girl-boy",
      "family: man, girl, boy"
    ],
    u: "1f468-200d-1f467-200d-1f466",
    a: "4.0"
  },
  {
    n: [
      "man-girl-girl",
      "family: man, girl, girl"
    ],
    u: "1f468-200d-1f467-200d-1f467",
    a: "4.0"
  },
  {
    n: [
      "woman-boy",
      "family: woman, boy"
    ],
    u: "1f469-200d-1f466",
    a: "4.0"
  },
  {
    n: [
      "woman-boy-boy",
      "family: woman, boy, boy"
    ],
    u: "1f469-200d-1f466-200d-1f466",
    a: "4.0"
  },
  {
    n: [
      "woman-girl",
      "family: woman, girl"
    ],
    u: "1f469-200d-1f467",
    a: "4.0"
  },
  {
    n: [
      "woman-girl-boy",
      "family: woman, girl, boy"
    ],
    u: "1f469-200d-1f467-200d-1f466",
    a: "4.0"
  },
  {
    n: [
      "woman-girl-girl",
      "family: woman, girl, girl"
    ],
    u: "1f469-200d-1f467-200d-1f467",
    a: "4.0"
  },
  {
    n: [
      "speaking head",
      "speaking head in silhouette"
    ],
    u: "1f5e3-fe0f",
    a: "0.7"
  },
  {
    n: [
      "bust in silhouette"
    ],
    u: "1f464",
    a: "0.6"
  },
  {
    n: [
      "busts in silhouette"
    ],
    u: "1f465",
    a: "1.0"
  },
  {
    n: [
      "people hugging"
    ],
    u: "1fac2",
    a: "13.0"
  },
  {
    n: [
      "footprints"
    ],
    u: "1f463",
    a: "0.6"
  }
];
var animals_nature = [
  {
    n: [
      "monkey face"
    ],
    u: "1f435",
    a: "0.6"
  },
  {
    n: [
      "monkey"
    ],
    u: "1f412",
    a: "0.6"
  },
  {
    n: [
      "gorilla"
    ],
    u: "1f98d",
    a: "3.0"
  },
  {
    n: [
      "orangutan"
    ],
    u: "1f9a7",
    a: "12.0"
  },
  {
    n: [
      "dog",
      "dog face"
    ],
    u: "1f436",
    a: "0.6"
  },
  {
    n: [
      "dog",
      "dog2"
    ],
    u: "1f415",
    a: "0.7"
  },
  {
    n: [
      "guide dog"
    ],
    u: "1f9ae",
    a: "12.0"
  },
  {
    n: [
      "service dog"
    ],
    u: "1f415-200d-1f9ba",
    a: "12.0"
  },
  {
    n: [
      "poodle"
    ],
    u: "1f429",
    a: "0.6"
  },
  {
    n: [
      "wolf",
      "wolf face"
    ],
    u: "1f43a",
    a: "0.6"
  },
  {
    n: [
      "fox face"
    ],
    u: "1f98a",
    a: "3.0"
  },
  {
    n: [
      "raccoon"
    ],
    u: "1f99d",
    a: "11.0"
  },
  {
    n: [
      "cat",
      "cat face"
    ],
    u: "1f431",
    a: "0.6"
  },
  {
    n: [
      "cat",
      "cat2"
    ],
    u: "1f408",
    a: "0.7"
  },
  {
    n: [
      "black cat"
    ],
    u: "1f408-200d-2b1b",
    a: "13.0"
  },
  {
    n: [
      "lion face"
    ],
    u: "1f981",
    a: "1.0"
  },
  {
    n: [
      "tiger",
      "tiger face"
    ],
    u: "1f42f",
    a: "0.6"
  },
  {
    n: [
      "tiger",
      "tiger2"
    ],
    u: "1f405",
    a: "1.0"
  },
  {
    n: [
      "leopard"
    ],
    u: "1f406",
    a: "1.0"
  },
  {
    n: [
      "horse",
      "horse face"
    ],
    u: "1f434",
    a: "0.6"
  },
  {
    n: [
      "horse",
      "racehorse"
    ],
    u: "1f40e",
    a: "0.6"
  },
  {
    n: [
      "unicorn face"
    ],
    u: "1f984",
    a: "1.0"
  },
  {
    n: [
      "zebra face"
    ],
    u: "1f993",
    a: "5.0"
  },
  {
    n: [
      "deer"
    ],
    u: "1f98c",
    a: "3.0"
  },
  {
    n: [
      "bison"
    ],
    u: "1f9ac",
    a: "13.0"
  },
  {
    n: [
      "cow",
      "cow face"
    ],
    u: "1f42e",
    a: "0.6"
  },
  {
    n: [
      "ox"
    ],
    u: "1f402",
    a: "1.0"
  },
  {
    n: [
      "water buffalo"
    ],
    u: "1f403",
    a: "1.0"
  },
  {
    n: [
      "cow",
      "cow2"
    ],
    u: "1f404",
    a: "1.0"
  },
  {
    n: [
      "pig",
      "pig face"
    ],
    u: "1f437",
    a: "0.6"
  },
  {
    n: [
      "pig",
      "pig2"
    ],
    u: "1f416",
    a: "1.0"
  },
  {
    n: [
      "boar"
    ],
    u: "1f417",
    a: "0.6"
  },
  {
    n: [
      "pig nose"
    ],
    u: "1f43d",
    a: "0.6"
  },
  {
    n: [
      "ram"
    ],
    u: "1f40f",
    a: "1.0"
  },
  {
    n: [
      "sheep"
    ],
    u: "1f411",
    a: "0.6"
  },
  {
    n: [
      "goat"
    ],
    u: "1f410",
    a: "1.0"
  },
  {
    n: [
      "dromedary camel"
    ],
    u: "1f42a",
    a: "1.0"
  },
  {
    n: [
      "camel",
      "bactrian camel"
    ],
    u: "1f42b",
    a: "0.6"
  },
  {
    n: [
      "llama"
    ],
    u: "1f999",
    a: "11.0"
  },
  {
    n: [
      "giraffe face"
    ],
    u: "1f992",
    a: "5.0"
  },
  {
    n: [
      "elephant"
    ],
    u: "1f418",
    a: "0.6"
  },
  {
    n: [
      "mammoth"
    ],
    u: "1f9a3",
    a: "13.0"
  },
  {
    n: [
      "rhinoceros"
    ],
    u: "1f98f",
    a: "3.0"
  },
  {
    n: [
      "hippopotamus"
    ],
    u: "1f99b",
    a: "11.0"
  },
  {
    n: [
      "mouse",
      "mouse face"
    ],
    u: "1f42d",
    a: "0.6"
  },
  {
    n: [
      "mouse",
      "mouse2"
    ],
    u: "1f401",
    a: "1.0"
  },
  {
    n: [
      "rat"
    ],
    u: "1f400",
    a: "1.0"
  },
  {
    n: [
      "hamster",
      "hamster face"
    ],
    u: "1f439",
    a: "0.6"
  },
  {
    n: [
      "rabbit",
      "rabbit face"
    ],
    u: "1f430",
    a: "0.6"
  },
  {
    n: [
      "rabbit",
      "rabbit2"
    ],
    u: "1f407",
    a: "1.0"
  },
  {
    n: [
      "chipmunk"
    ],
    u: "1f43f-fe0f",
    a: "0.7"
  },
  {
    n: [
      "beaver"
    ],
    u: "1f9ab",
    a: "13.0"
  },
  {
    n: [
      "hedgehog"
    ],
    u: "1f994",
    a: "5.0"
  },
  {
    n: [
      "bat"
    ],
    u: "1f987",
    a: "3.0"
  },
  {
    n: [
      "bear",
      "bear face"
    ],
    u: "1f43b",
    a: "0.6"
  },
  {
    n: [
      "polar bear"
    ],
    u: "1f43b-200d-2744-fe0f",
    a: "13.0"
  },
  {
    n: [
      "koala"
    ],
    u: "1f428",
    a: "0.6"
  },
  {
    n: [
      "panda face"
    ],
    u: "1f43c",
    a: "0.6"
  },
  {
    n: [
      "sloth"
    ],
    u: "1f9a5",
    a: "12.0"
  },
  {
    n: [
      "otter"
    ],
    u: "1f9a6",
    a: "12.0"
  },
  {
    n: [
      "skunk"
    ],
    u: "1f9a8",
    a: "12.0"
  },
  {
    n: [
      "kangaroo"
    ],
    u: "1f998",
    a: "11.0"
  },
  {
    n: [
      "badger"
    ],
    u: "1f9a1",
    a: "11.0"
  },
  {
    n: [
      "feet",
      "paw prints"
    ],
    u: "1f43e",
    a: "0.6"
  },
  {
    n: [
      "turkey"
    ],
    u: "1f983",
    a: "1.0"
  },
  {
    n: [
      "chicken"
    ],
    u: "1f414",
    a: "0.6"
  },
  {
    n: [
      "rooster"
    ],
    u: "1f413",
    a: "1.0"
  },
  {
    n: [
      "hatching chick"
    ],
    u: "1f423",
    a: "0.6"
  },
  {
    n: [
      "baby chick"
    ],
    u: "1f424",
    a: "0.6"
  },
  {
    n: [
      "hatched chick",
      "front-facing baby chick"
    ],
    u: "1f425",
    a: "0.6"
  },
  {
    n: [
      "bird"
    ],
    u: "1f426",
    a: "0.6"
  },
  {
    n: [
      "penguin"
    ],
    u: "1f427",
    a: "0.6"
  },
  {
    n: [
      "dove",
      "dove of peace"
    ],
    u: "1f54a-fe0f",
    a: "0.7"
  },
  {
    n: [
      "eagle"
    ],
    u: "1f985",
    a: "3.0"
  },
  {
    n: [
      "duck"
    ],
    u: "1f986",
    a: "3.0"
  },
  {
    n: [
      "swan"
    ],
    u: "1f9a2",
    a: "11.0"
  },
  {
    n: [
      "owl"
    ],
    u: "1f989",
    a: "3.0"
  },
  {
    n: [
      "dodo"
    ],
    u: "1f9a4",
    a: "13.0"
  },
  {
    n: [
      "feather"
    ],
    u: "1fab6",
    a: "13.0"
  },
  {
    n: [
      "flamingo"
    ],
    u: "1f9a9",
    a: "12.0"
  },
  {
    n: [
      "peacock"
    ],
    u: "1f99a",
    a: "11.0"
  },
  {
    n: [
      "parrot"
    ],
    u: "1f99c",
    a: "11.0"
  },
  {
    n: [
      "frog",
      "frog face"
    ],
    u: "1f438",
    a: "0.6"
  },
  {
    n: [
      "crocodile"
    ],
    u: "1f40a",
    a: "1.0"
  },
  {
    n: [
      "turtle"
    ],
    u: "1f422",
    a: "0.6"
  },
  {
    n: [
      "lizard"
    ],
    u: "1f98e",
    a: "3.0"
  },
  {
    n: [
      "snake"
    ],
    u: "1f40d",
    a: "0.6"
  },
  {
    n: [
      "dragon face"
    ],
    u: "1f432",
    a: "0.6"
  },
  {
    n: [
      "dragon"
    ],
    u: "1f409",
    a: "1.0"
  },
  {
    n: [
      "sauropod"
    ],
    u: "1f995",
    a: "5.0"
  },
  {
    n: [
      "t-rex"
    ],
    u: "1f996",
    a: "5.0"
  },
  {
    n: [
      "whale",
      "spouting whale"
    ],
    u: "1f433",
    a: "0.6"
  },
  {
    n: [
      "whale",
      "whale2"
    ],
    u: "1f40b",
    a: "1.0"
  },
  {
    n: [
      "dolphin",
      "flipper"
    ],
    u: "1f42c",
    a: "0.6"
  },
  {
    n: [
      "seal"
    ],
    u: "1f9ad",
    a: "13.0"
  },
  {
    n: [
      "fish"
    ],
    u: "1f41f",
    a: "0.6"
  },
  {
    n: [
      "tropical fish"
    ],
    u: "1f420",
    a: "0.6"
  },
  {
    n: [
      "blowfish"
    ],
    u: "1f421",
    a: "0.6"
  },
  {
    n: [
      "shark"
    ],
    u: "1f988",
    a: "3.0"
  },
  {
    n: [
      "octopus"
    ],
    u: "1f419",
    a: "0.6"
  },
  {
    n: [
      "shell",
      "spiral shell"
    ],
    u: "1f41a",
    a: "0.6"
  },
  {
    n: [
      "coral"
    ],
    u: "1fab8",
    a: "14.0"
  },
  {
    n: [
      "snail"
    ],
    u: "1f40c",
    a: "0.6"
  },
  {
    n: [
      "butterfly"
    ],
    u: "1f98b",
    a: "3.0"
  },
  {
    n: [
      "bug"
    ],
    u: "1f41b",
    a: "0.6"
  },
  {
    n: [
      "ant"
    ],
    u: "1f41c",
    a: "0.6"
  },
  {
    n: [
      "bee",
      "honeybee"
    ],
    u: "1f41d",
    a: "0.6"
  },
  {
    n: [
      "beetle"
    ],
    u: "1fab2",
    a: "13.0"
  },
  {
    n: [
      "ladybug",
      "lady beetle"
    ],
    u: "1f41e",
    a: "0.6"
  },
  {
    n: [
      "cricket"
    ],
    u: "1f997",
    a: "5.0"
  },
  {
    n: [
      "cockroach"
    ],
    u: "1fab3",
    a: "13.0"
  },
  {
    n: [
      "spider"
    ],
    u: "1f577-fe0f",
    a: "0.7"
  },
  {
    n: [
      "spider web"
    ],
    u: "1f578-fe0f",
    a: "0.7"
  },
  {
    n: [
      "scorpion"
    ],
    u: "1f982",
    a: "1.0"
  },
  {
    n: [
      "mosquito"
    ],
    u: "1f99f",
    a: "11.0"
  },
  {
    n: [
      "fly"
    ],
    u: "1fab0",
    a: "13.0"
  },
  {
    n: [
      "worm"
    ],
    u: "1fab1",
    a: "13.0"
  },
  {
    n: [
      "microbe"
    ],
    u: "1f9a0",
    a: "11.0"
  },
  {
    n: [
      "bouquet"
    ],
    u: "1f490",
    a: "0.6"
  },
  {
    n: [
      "cherry blossom"
    ],
    u: "1f338",
    a: "0.6"
  },
  {
    n: [
      "white flower"
    ],
    u: "1f4ae",
    a: "0.6"
  },
  {
    n: [
      "lotus"
    ],
    u: "1fab7",
    a: "14.0"
  },
  {
    n: [
      "rosette"
    ],
    u: "1f3f5-fe0f",
    a: "0.7"
  },
  {
    n: [
      "rose"
    ],
    u: "1f339",
    a: "0.6"
  },
  {
    n: [
      "wilted flower"
    ],
    u: "1f940",
    a: "3.0"
  },
  {
    n: [
      "hibiscus"
    ],
    u: "1f33a",
    a: "0.6"
  },
  {
    n: [
      "sunflower"
    ],
    u: "1f33b",
    a: "0.6"
  },
  {
    n: [
      "blossom"
    ],
    u: "1f33c",
    a: "0.6"
  },
  {
    n: [
      "tulip"
    ],
    u: "1f337",
    a: "0.6"
  },
  {
    n: [
      "seedling"
    ],
    u: "1f331",
    a: "0.6"
  },
  {
    n: [
      "potted plant"
    ],
    u: "1fab4",
    a: "13.0"
  },
  {
    n: [
      "evergreen tree"
    ],
    u: "1f332",
    a: "1.0"
  },
  {
    n: [
      "deciduous tree"
    ],
    u: "1f333",
    a: "1.0"
  },
  {
    n: [
      "palm tree"
    ],
    u: "1f334",
    a: "0.6"
  },
  {
    n: [
      "cactus"
    ],
    u: "1f335",
    a: "0.6"
  },
  {
    n: [
      "ear of rice"
    ],
    u: "1f33e",
    a: "0.6"
  },
  {
    n: [
      "herb"
    ],
    u: "1f33f",
    a: "0.6"
  },
  {
    n: [
      "shamrock"
    ],
    u: "2618-fe0f",
    a: "1.0"
  },
  {
    n: [
      "four leaf clover"
    ],
    u: "1f340",
    a: "0.6"
  },
  {
    n: [
      "maple leaf"
    ],
    u: "1f341",
    a: "0.6"
  },
  {
    n: [
      "fallen leaf"
    ],
    u: "1f342",
    a: "0.6"
  },
  {
    n: [
      "leaves",
      "leaf fluttering in wind"
    ],
    u: "1f343",
    a: "0.6"
  },
  {
    n: [
      "empty nest"
    ],
    u: "1fab9",
    a: "14.0"
  },
  {
    n: [
      "nest with eggs"
    ],
    u: "1faba",
    a: "14.0"
  }
];
var food_drink = [
  {
    n: [
      "grapes"
    ],
    u: "1f347",
    a: "0.6"
  },
  {
    n: [
      "melon"
    ],
    u: "1f348",
    a: "0.6"
  },
  {
    n: [
      "watermelon"
    ],
    u: "1f349",
    a: "0.6"
  },
  {
    n: [
      "tangerine"
    ],
    u: "1f34a",
    a: "0.6"
  },
  {
    n: [
      "lemon"
    ],
    u: "1f34b",
    a: "1.0"
  },
  {
    n: [
      "banana"
    ],
    u: "1f34c",
    a: "0.6"
  },
  {
    n: [
      "pineapple"
    ],
    u: "1f34d",
    a: "0.6"
  },
  {
    n: [
      "mango"
    ],
    u: "1f96d",
    a: "11.0"
  },
  {
    n: [
      "apple",
      "red apple"
    ],
    u: "1f34e",
    a: "0.6"
  },
  {
    n: [
      "green apple"
    ],
    u: "1f34f",
    a: "0.6"
  },
  {
    n: [
      "pear"
    ],
    u: "1f350",
    a: "1.0"
  },
  {
    n: [
      "peach"
    ],
    u: "1f351",
    a: "0.6"
  },
  {
    n: [
      "cherries"
    ],
    u: "1f352",
    a: "0.6"
  },
  {
    n: [
      "strawberry"
    ],
    u: "1f353",
    a: "0.6"
  },
  {
    n: [
      "blueberries"
    ],
    u: "1fad0",
    a: "13.0"
  },
  {
    n: [
      "kiwifruit"
    ],
    u: "1f95d",
    a: "3.0"
  },
  {
    n: [
      "tomato"
    ],
    u: "1f345",
    a: "0.6"
  },
  {
    n: [
      "olive"
    ],
    u: "1fad2",
    a: "13.0"
  },
  {
    n: [
      "coconut"
    ],
    u: "1f965",
    a: "5.0"
  },
  {
    n: [
      "avocado"
    ],
    u: "1f951",
    a: "3.0"
  },
  {
    n: [
      "eggplant",
      "aubergine"
    ],
    u: "1f346",
    a: "0.6"
  },
  {
    n: [
      "potato"
    ],
    u: "1f954",
    a: "3.0"
  },
  {
    n: [
      "carrot"
    ],
    u: "1f955",
    a: "3.0"
  },
  {
    n: [
      "corn",
      "ear of maize"
    ],
    u: "1f33d",
    a: "0.6"
  },
  {
    n: [
      "hot pepper"
    ],
    u: "1f336-fe0f",
    a: "0.7"
  },
  {
    n: [
      "bell pepper"
    ],
    u: "1fad1",
    a: "13.0"
  },
  {
    n: [
      "cucumber"
    ],
    u: "1f952",
    a: "3.0"
  },
  {
    n: [
      "leafy green"
    ],
    u: "1f96c",
    a: "11.0"
  },
  {
    n: [
      "broccoli"
    ],
    u: "1f966",
    a: "5.0"
  },
  {
    n: [
      "garlic"
    ],
    u: "1f9c4",
    a: "12.0"
  },
  {
    n: [
      "onion"
    ],
    u: "1f9c5",
    a: "12.0"
  },
  {
    n: [
      "mushroom"
    ],
    u: "1f344",
    a: "0.6"
  },
  {
    n: [
      "peanuts"
    ],
    u: "1f95c",
    a: "3.0"
  },
  {
    n: [
      "beans"
    ],
    u: "1fad8",
    a: "14.0"
  },
  {
    n: [
      "chestnut"
    ],
    u: "1f330",
    a: "0.6"
  },
  {
    n: [
      "bread"
    ],
    u: "1f35e",
    a: "0.6"
  },
  {
    n: [
      "croissant"
    ],
    u: "1f950",
    a: "3.0"
  },
  {
    n: [
      "baguette bread"
    ],
    u: "1f956",
    a: "3.0"
  },
  {
    n: [
      "flatbread"
    ],
    u: "1fad3",
    a: "13.0"
  },
  {
    n: [
      "pretzel"
    ],
    u: "1f968",
    a: "5.0"
  },
  {
    n: [
      "bagel"
    ],
    u: "1f96f",
    a: "11.0"
  },
  {
    n: [
      "pancakes"
    ],
    u: "1f95e",
    a: "3.0"
  },
  {
    n: [
      "waffle"
    ],
    u: "1f9c7",
    a: "12.0"
  },
  {
    n: [
      "cheese wedge"
    ],
    u: "1f9c0",
    a: "1.0"
  },
  {
    n: [
      "meat on bone"
    ],
    u: "1f356",
    a: "0.6"
  },
  {
    n: [
      "poultry leg"
    ],
    u: "1f357",
    a: "0.6"
  },
  {
    n: [
      "cut of meat"
    ],
    u: "1f969",
    a: "5.0"
  },
  {
    n: [
      "bacon"
    ],
    u: "1f953",
    a: "3.0"
  },
  {
    n: [
      "hamburger"
    ],
    u: "1f354",
    a: "0.6"
  },
  {
    n: [
      "fries",
      "french fries"
    ],
    u: "1f35f",
    a: "0.6"
  },
  {
    n: [
      "pizza",
      "slice of pizza"
    ],
    u: "1f355",
    a: "0.6"
  },
  {
    n: [
      "hotdog",
      "hot dog"
    ],
    u: "1f32d",
    a: "1.0"
  },
  {
    n: [
      "sandwich"
    ],
    u: "1f96a",
    a: "5.0"
  },
  {
    n: [
      "taco"
    ],
    u: "1f32e",
    a: "1.0"
  },
  {
    n: [
      "burrito"
    ],
    u: "1f32f",
    a: "1.0"
  },
  {
    n: [
      "tamale"
    ],
    u: "1fad4",
    a: "13.0"
  },
  {
    n: [
      "stuffed flatbread"
    ],
    u: "1f959",
    a: "3.0"
  },
  {
    n: [
      "falafel"
    ],
    u: "1f9c6",
    a: "12.0"
  },
  {
    n: [
      "egg"
    ],
    u: "1f95a",
    a: "3.0"
  },
  {
    n: [
      "cooking",
      "fried egg"
    ],
    u: "1f373",
    a: "0.6"
  },
  {
    n: [
      "shallow pan of food"
    ],
    u: "1f958",
    a: "3.0"
  },
  {
    n: [
      "stew",
      "pot of food"
    ],
    u: "1f372",
    a: "0.6"
  },
  {
    n: [
      "fondue"
    ],
    u: "1fad5",
    a: "13.0"
  },
  {
    n: [
      "bowl with spoon"
    ],
    u: "1f963",
    a: "5.0"
  },
  {
    n: [
      "green salad"
    ],
    u: "1f957",
    a: "3.0"
  },
  {
    n: [
      "popcorn"
    ],
    u: "1f37f",
    a: "1.0"
  },
  {
    n: [
      "butter"
    ],
    u: "1f9c8",
    a: "12.0"
  },
  {
    n: [
      "salt",
      "salt shaker"
    ],
    u: "1f9c2",
    a: "11.0"
  },
  {
    n: [
      "canned food"
    ],
    u: "1f96b",
    a: "5.0"
  },
  {
    n: [
      "bento",
      "bento box"
    ],
    u: "1f371",
    a: "0.6"
  },
  {
    n: [
      "rice cracker"
    ],
    u: "1f358",
    a: "0.6"
  },
  {
    n: [
      "rice ball"
    ],
    u: "1f359",
    a: "0.6"
  },
  {
    n: [
      "rice",
      "cooked rice"
    ],
    u: "1f35a",
    a: "0.6"
  },
  {
    n: [
      "curry",
      "curry and rice"
    ],
    u: "1f35b",
    a: "0.6"
  },
  {
    n: [
      "ramen",
      "steaming bowl"
    ],
    u: "1f35c",
    a: "0.6"
  },
  {
    n: [
      "spaghetti"
    ],
    u: "1f35d",
    a: "0.6"
  },
  {
    n: [
      "sweet potato",
      "roasted sweet potato"
    ],
    u: "1f360",
    a: "0.6"
  },
  {
    n: [
      "oden"
    ],
    u: "1f362",
    a: "0.6"
  },
  {
    n: [
      "sushi"
    ],
    u: "1f363",
    a: "0.6"
  },
  {
    n: [
      "fried shrimp"
    ],
    u: "1f364",
    a: "0.6"
  },
  {
    n: [
      "fish cake",
      "fish cake with swirl design"
    ],
    u: "1f365",
    a: "0.6"
  },
  {
    n: [
      "moon cake"
    ],
    u: "1f96e",
    a: "11.0"
  },
  {
    n: [
      "dango"
    ],
    u: "1f361",
    a: "0.6"
  },
  {
    n: [
      "dumpling"
    ],
    u: "1f95f",
    a: "5.0"
  },
  {
    n: [
      "fortune cookie"
    ],
    u: "1f960",
    a: "5.0"
  },
  {
    n: [
      "takeout box"
    ],
    u: "1f961",
    a: "5.0"
  },
  {
    n: [
      "crab"
    ],
    u: "1f980",
    a: "1.0"
  },
  {
    n: [
      "lobster"
    ],
    u: "1f99e",
    a: "11.0"
  },
  {
    n: [
      "shrimp"
    ],
    u: "1f990",
    a: "3.0"
  },
  {
    n: [
      "squid"
    ],
    u: "1f991",
    a: "3.0"
  },
  {
    n: [
      "oyster"
    ],
    u: "1f9aa",
    a: "12.0"
  },
  {
    n: [
      "icecream",
      "soft ice cream"
    ],
    u: "1f366",
    a: "0.6"
  },
  {
    n: [
      "shaved ice"
    ],
    u: "1f367",
    a: "0.6"
  },
  {
    n: [
      "ice cream"
    ],
    u: "1f368",
    a: "0.6"
  },
  {
    n: [
      "doughnut"
    ],
    u: "1f369",
    a: "0.6"
  },
  {
    n: [
      "cookie"
    ],
    u: "1f36a",
    a: "0.6"
  },
  {
    n: [
      "birthday",
      "birthday cake"
    ],
    u: "1f382",
    a: "0.6"
  },
  {
    n: [
      "cake",
      "shortcake"
    ],
    u: "1f370",
    a: "0.6"
  },
  {
    n: [
      "cupcake"
    ],
    u: "1f9c1",
    a: "11.0"
  },
  {
    n: [
      "pie"
    ],
    u: "1f967",
    a: "5.0"
  },
  {
    n: [
      "chocolate bar"
    ],
    u: "1f36b",
    a: "0.6"
  },
  {
    n: [
      "candy"
    ],
    u: "1f36c",
    a: "0.6"
  },
  {
    n: [
      "lollipop"
    ],
    u: "1f36d",
    a: "0.6"
  },
  {
    n: [
      "custard"
    ],
    u: "1f36e",
    a: "0.6"
  },
  {
    n: [
      "honey pot"
    ],
    u: "1f36f",
    a: "0.6"
  },
  {
    n: [
      "baby bottle"
    ],
    u: "1f37c",
    a: "1.0"
  },
  {
    n: [
      "glass of milk"
    ],
    u: "1f95b",
    a: "3.0"
  },
  {
    n: [
      "coffee",
      "hot beverage"
    ],
    u: "2615",
    a: "0.6"
  },
  {
    n: [
      "teapot"
    ],
    u: "1fad6",
    a: "13.0"
  },
  {
    n: [
      "tea",
      "teacup without handle"
    ],
    u: "1f375",
    a: "0.6"
  },
  {
    n: [
      "sake",
      "sake bottle and cup"
    ],
    u: "1f376",
    a: "0.6"
  },
  {
    n: [
      "champagne",
      "bottle with popping cork"
    ],
    u: "1f37e",
    a: "1.0"
  },
  {
    n: [
      "wine glass"
    ],
    u: "1f377",
    a: "0.6"
  },
  {
    n: [
      "cocktail",
      "cocktail glass"
    ],
    u: "1f378",
    a: "0.6"
  },
  {
    n: [
      "tropical drink"
    ],
    u: "1f379",
    a: "0.6"
  },
  {
    n: [
      "beer",
      "beer mug"
    ],
    u: "1f37a",
    a: "0.6"
  },
  {
    n: [
      "beers",
      "clinking beer mugs"
    ],
    u: "1f37b",
    a: "0.6"
  },
  {
    n: [
      "clinking glasses"
    ],
    u: "1f942",
    a: "3.0"
  },
  {
    n: [
      "tumbler glass"
    ],
    u: "1f943",
    a: "3.0"
  },
  {
    n: [
      "pouring liquid"
    ],
    u: "1fad7",
    a: "14.0"
  },
  {
    n: [
      "cup with straw"
    ],
    u: "1f964",
    a: "5.0"
  },
  {
    n: [
      "bubble tea"
    ],
    u: "1f9cb",
    a: "13.0"
  },
  {
    n: [
      "beverage box"
    ],
    u: "1f9c3",
    a: "12.0"
  },
  {
    n: [
      "mate drink"
    ],
    u: "1f9c9",
    a: "12.0"
  },
  {
    n: [
      "ice cube"
    ],
    u: "1f9ca",
    a: "12.0"
  },
  {
    n: [
      "chopsticks"
    ],
    u: "1f962",
    a: "5.0"
  },
  {
    n: [
      "knife fork plate",
      "fork and knife with plate"
    ],
    u: "1f37d-fe0f",
    a: "0.7"
  },
  {
    n: [
      "fork and knife"
    ],
    u: "1f374",
    a: "0.6"
  },
  {
    n: [
      "spoon"
    ],
    u: "1f944",
    a: "3.0"
  },
  {
    n: [
      "hocho",
      "knife"
    ],
    u: "1f52a",
    a: "0.6"
  },
  {
    n: [
      "jar"
    ],
    u: "1fad9",
    a: "14.0"
  },
  {
    n: [
      "amphora"
    ],
    u: "1f3fa",
    a: "1.0"
  }
];
var travel_places = [
  {
    n: [
      "earth africa",
      "earth globe europe-africa"
    ],
    u: "1f30d",
    a: "0.7"
  },
  {
    n: [
      "earth americas",
      "earth globe americas"
    ],
    u: "1f30e",
    a: "0.7"
  },
  {
    n: [
      "earth asia",
      "earth globe asia-australia"
    ],
    u: "1f30f",
    a: "0.6"
  },
  {
    n: [
      "globe with meridians"
    ],
    u: "1f310",
    a: "1.0"
  },
  {
    n: [
      "world map"
    ],
    u: "1f5fa-fe0f",
    a: "0.7"
  },
  {
    n: [
      "japan",
      "silhouette of japan"
    ],
    u: "1f5fe",
    a: "0.6"
  },
  {
    n: [
      "compass"
    ],
    u: "1f9ed",
    a: "11.0"
  },
  {
    n: [
      "snow-capped mountain",
      "snow capped mountain"
    ],
    u: "1f3d4-fe0f",
    a: "0.7"
  },
  {
    n: [
      "mountain"
    ],
    u: "26f0-fe0f",
    a: "0.7"
  },
  {
    n: [
      "volcano"
    ],
    u: "1f30b",
    a: "0.6"
  },
  {
    n: [
      "mount fuji"
    ],
    u: "1f5fb",
    a: "0.6"
  },
  {
    n: [
      "camping"
    ],
    u: "1f3d5-fe0f",
    a: "0.7"
  },
  {
    n: [
      "beach with umbrella"
    ],
    u: "1f3d6-fe0f",
    a: "0.7"
  },
  {
    n: [
      "desert"
    ],
    u: "1f3dc-fe0f",
    a: "0.7"
  },
  {
    n: [
      "desert island"
    ],
    u: "1f3dd-fe0f",
    a: "0.7"
  },
  {
    n: [
      "national park"
    ],
    u: "1f3de-fe0f",
    a: "0.7"
  },
  {
    n: [
      "stadium"
    ],
    u: "1f3df-fe0f",
    a: "0.7"
  },
  {
    n: [
      "classical building"
    ],
    u: "1f3db-fe0f",
    a: "0.7"
  },
  {
    n: [
      "building construction"
    ],
    u: "1f3d7-fe0f",
    a: "0.7"
  },
  {
    n: [
      "brick",
      "bricks"
    ],
    u: "1f9f1",
    a: "11.0"
  },
  {
    n: [
      "rock"
    ],
    u: "1faa8",
    a: "13.0"
  },
  {
    n: [
      "wood"
    ],
    u: "1fab5",
    a: "13.0"
  },
  {
    n: [
      "hut"
    ],
    u: "1f6d6",
    a: "13.0"
  },
  {
    n: [
      "houses",
      "house buildings"
    ],
    u: "1f3d8-fe0f",
    a: "0.7"
  },
  {
    n: [
      "derelict house",
      "derelict house building"
    ],
    u: "1f3da-fe0f",
    a: "0.7"
  },
  {
    n: [
      "house",
      "house building"
    ],
    u: "1f3e0",
    a: "0.6"
  },
  {
    n: [
      "house with garden"
    ],
    u: "1f3e1",
    a: "0.6"
  },
  {
    n: [
      "office",
      "office building"
    ],
    u: "1f3e2",
    a: "0.6"
  },
  {
    n: [
      "post office",
      "japanese post office"
    ],
    u: "1f3e3",
    a: "0.6"
  },
  {
    n: [
      "european post office"
    ],
    u: "1f3e4",
    a: "1.0"
  },
  {
    n: [
      "hospital"
    ],
    u: "1f3e5",
    a: "0.6"
  },
  {
    n: [
      "bank"
    ],
    u: "1f3e6",
    a: "0.6"
  },
  {
    n: [
      "hotel"
    ],
    u: "1f3e8",
    a: "0.6"
  },
  {
    n: [
      "love hotel"
    ],
    u: "1f3e9",
    a: "0.6"
  },
  {
    n: [
      "convenience store"
    ],
    u: "1f3ea",
    a: "0.6"
  },
  {
    n: [
      "school"
    ],
    u: "1f3eb",
    a: "0.6"
  },
  {
    n: [
      "department store"
    ],
    u: "1f3ec",
    a: "0.6"
  },
  {
    n: [
      "factory"
    ],
    u: "1f3ed",
    a: "0.6"
  },
  {
    n: [
      "japanese castle"
    ],
    u: "1f3ef",
    a: "0.6"
  },
  {
    n: [
      "european castle"
    ],
    u: "1f3f0",
    a: "0.6"
  },
  {
    n: [
      "wedding"
    ],
    u: "1f492",
    a: "0.6"
  },
  {
    n: [
      "tokyo tower"
    ],
    u: "1f5fc",
    a: "0.6"
  },
  {
    n: [
      "statue of liberty"
    ],
    u: "1f5fd",
    a: "0.6"
  },
  {
    n: [
      "church"
    ],
    u: "26ea",
    a: "0.6"
  },
  {
    n: [
      "mosque"
    ],
    u: "1f54c",
    a: "1.0"
  },
  {
    n: [
      "hindu temple"
    ],
    u: "1f6d5",
    a: "12.0"
  },
  {
    n: [
      "synagogue"
    ],
    u: "1f54d",
    a: "1.0"
  },
  {
    n: [
      "shinto shrine"
    ],
    u: "26e9-fe0f",
    a: "0.7"
  },
  {
    n: [
      "kaaba"
    ],
    u: "1f54b",
    a: "1.0"
  },
  {
    n: [
      "fountain"
    ],
    u: "26f2",
    a: "0.6"
  },
  {
    n: [
      "tent"
    ],
    u: "26fa",
    a: "0.6"
  },
  {
    n: [
      "foggy"
    ],
    u: "1f301",
    a: "0.6"
  },
  {
    n: [
      "night with stars"
    ],
    u: "1f303",
    a: "0.6"
  },
  {
    n: [
      "cityscape"
    ],
    u: "1f3d9-fe0f",
    a: "0.7"
  },
  {
    n: [
      "sunrise over mountains"
    ],
    u: "1f304",
    a: "0.6"
  },
  {
    n: [
      "sunrise"
    ],
    u: "1f305",
    a: "0.6"
  },
  {
    n: [
      "city sunset",
      "cityscape at dusk"
    ],
    u: "1f306",
    a: "0.6"
  },
  {
    n: [
      "city sunrise",
      "sunset over buildings"
    ],
    u: "1f307",
    a: "0.6"
  },
  {
    n: [
      "bridge at night"
    ],
    u: "1f309",
    a: "0.6"
  },
  {
    n: [
      "hotsprings",
      "hot springs"
    ],
    u: "2668-fe0f",
    a: "0.6"
  },
  {
    n: [
      "carousel horse"
    ],
    u: "1f3a0",
    a: "0.6"
  },
  {
    n: [
      "playground slide"
    ],
    u: "1f6dd",
    a: "14.0"
  },
  {
    n: [
      "ferris wheel"
    ],
    u: "1f3a1",
    a: "0.6"
  },
  {
    n: [
      "roller coaster"
    ],
    u: "1f3a2",
    a: "0.6"
  },
  {
    n: [
      "barber",
      "barber pole"
    ],
    u: "1f488",
    a: "0.6"
  },
  {
    n: [
      "circus tent"
    ],
    u: "1f3aa",
    a: "0.6"
  },
  {
    n: [
      "steam locomotive"
    ],
    u: "1f682",
    a: "1.0"
  },
  {
    n: [
      "railway car"
    ],
    u: "1f683",
    a: "0.6"
  },
  {
    n: [
      "high-speed train",
      "bullettrain side"
    ],
    u: "1f684",
    a: "0.6"
  },
  {
    n: [
      "bullettrain front",
      "high-speed train with bullet nose"
    ],
    u: "1f685",
    a: "0.6"
  },
  {
    n: [
      "train",
      "train2"
    ],
    u: "1f686",
    a: "1.0"
  },
  {
    n: [
      "metro"
    ],
    u: "1f687",
    a: "0.6"
  },
  {
    n: [
      "light rail"
    ],
    u: "1f688",
    a: "1.0"
  },
  {
    n: [
      "station"
    ],
    u: "1f689",
    a: "0.6"
  },
  {
    n: [
      "tram"
    ],
    u: "1f68a",
    a: "1.0"
  },
  {
    n: [
      "monorail"
    ],
    u: "1f69d",
    a: "1.0"
  },
  {
    n: [
      "mountain railway"
    ],
    u: "1f69e",
    a: "1.0"
  },
  {
    n: [
      "train",
      "tram car"
    ],
    u: "1f68b",
    a: "1.0"
  },
  {
    n: [
      "bus"
    ],
    u: "1f68c",
    a: "0.6"
  },
  {
    n: [
      "oncoming bus"
    ],
    u: "1f68d",
    a: "0.7"
  },
  {
    n: [
      "trolleybus"
    ],
    u: "1f68e",
    a: "1.0"
  },
  {
    n: [
      "minibus"
    ],
    u: "1f690",
    a: "1.0"
  },
  {
    n: [
      "ambulance"
    ],
    u: "1f691",
    a: "0.6"
  },
  {
    n: [
      "fire engine"
    ],
    u: "1f692",
    a: "0.6"
  },
  {
    n: [
      "police car"
    ],
    u: "1f693",
    a: "0.6"
  },
  {
    n: [
      "oncoming police car"
    ],
    u: "1f694",
    a: "0.7"
  },
  {
    n: [
      "taxi"
    ],
    u: "1f695",
    a: "0.6"
  },
  {
    n: [
      "oncoming taxi"
    ],
    u: "1f696",
    a: "1.0"
  },
  {
    n: [
      "car",
      "red car",
      "automobile"
    ],
    u: "1f697",
    a: "0.6"
  },
  {
    n: [
      "oncoming automobile"
    ],
    u: "1f698",
    a: "0.7"
  },
  {
    n: [
      "blue car",
      "recreational vehicle"
    ],
    u: "1f699",
    a: "0.6"
  },
  {
    n: [
      "pickup truck"
    ],
    u: "1f6fb",
    a: "13.0"
  },
  {
    n: [
      "truck",
      "delivery truck"
    ],
    u: "1f69a",
    a: "0.6"
  },
  {
    n: [
      "articulated lorry"
    ],
    u: "1f69b",
    a: "1.0"
  },
  {
    n: [
      "tractor"
    ],
    u: "1f69c",
    a: "1.0"
  },
  {
    n: [
      "racing car"
    ],
    u: "1f3ce-fe0f",
    a: "0.7"
  },
  {
    n: [
      "motorcycle",
      "racing motorcycle"
    ],
    u: "1f3cd-fe0f",
    a: "0.7"
  },
  {
    n: [
      "motor scooter"
    ],
    u: "1f6f5",
    a: "3.0"
  },
  {
    n: [
      "manual wheelchair"
    ],
    u: "1f9bd",
    a: "12.0"
  },
  {
    n: [
      "motorized wheelchair"
    ],
    u: "1f9bc",
    a: "12.0"
  },
  {
    n: [
      "auto rickshaw"
    ],
    u: "1f6fa",
    a: "12.0"
  },
  {
    n: [
      "bike",
      "bicycle"
    ],
    u: "1f6b2",
    a: "0.6"
  },
  {
    n: [
      "scooter"
    ],
    u: "1f6f4",
    a: "3.0"
  },
  {
    n: [
      "skateboard"
    ],
    u: "1f6f9",
    a: "11.0"
  },
  {
    n: [
      "roller skate"
    ],
    u: "1f6fc",
    a: "13.0"
  },
  {
    n: [
      "busstop",
      "bus stop"
    ],
    u: "1f68f",
    a: "0.6"
  },
  {
    n: [
      "motorway"
    ],
    u: "1f6e3-fe0f",
    a: "0.7"
  },
  {
    n: [
      "railway track"
    ],
    u: "1f6e4-fe0f",
    a: "0.7"
  },
  {
    n: [
      "oil drum"
    ],
    u: "1f6e2-fe0f",
    a: "0.7"
  },
  {
    n: [
      "fuelpump",
      "fuel pump"
    ],
    u: "26fd",
    a: "0.6"
  },
  {
    n: [
      "wheel"
    ],
    u: "1f6de",
    a: "14.0"
  },
  {
    n: [
      "rotating light",
      "police cars revolving light"
    ],
    u: "1f6a8",
    a: "0.6"
  },
  {
    n: [
      "traffic light",
      "horizontal traffic light"
    ],
    u: "1f6a5",
    a: "0.6"
  },
  {
    n: [
      "vertical traffic light"
    ],
    u: "1f6a6",
    a: "1.0"
  },
  {
    n: [
      "octagonal sign"
    ],
    u: "1f6d1",
    a: "3.0"
  },
  {
    n: [
      "construction",
      "construction sign"
    ],
    u: "1f6a7",
    a: "0.6"
  },
  {
    n: [
      "anchor"
    ],
    u: "2693",
    a: "0.6"
  },
  {
    n: [
      "ring buoy"
    ],
    u: "1f6df",
    a: "14.0"
  },
  {
    n: [
      "boat",
      "sailboat"
    ],
    u: "26f5",
    a: "0.6"
  },
  {
    n: [
      "canoe"
    ],
    u: "1f6f6",
    a: "3.0"
  },
  {
    n: [
      "speedboat"
    ],
    u: "1f6a4",
    a: "0.6"
  },
  {
    n: [
      "passenger ship"
    ],
    u: "1f6f3-fe0f",
    a: "0.7"
  },
  {
    n: [
      "ferry"
    ],
    u: "26f4-fe0f",
    a: "0.7"
  },
  {
    n: [
      "motor boat"
    ],
    u: "1f6e5-fe0f",
    a: "0.7"
  },
  {
    n: [
      "ship"
    ],
    u: "1f6a2",
    a: "0.6"
  },
  {
    n: [
      "airplane"
    ],
    u: "2708-fe0f",
    a: "0.6"
  },
  {
    n: [
      "small airplane"
    ],
    u: "1f6e9-fe0f",
    a: "0.7"
  },
  {
    n: [
      "airplane departure"
    ],
    u: "1f6eb",
    a: "1.0"
  },
  {
    n: [
      "airplane arriving"
    ],
    u: "1f6ec",
    a: "1.0"
  },
  {
    n: [
      "parachute"
    ],
    u: "1fa82",
    a: "12.0"
  },
  {
    n: [
      "seat"
    ],
    u: "1f4ba",
    a: "0.6"
  },
  {
    n: [
      "helicopter"
    ],
    u: "1f681",
    a: "1.0"
  },
  {
    n: [
      "suspension railway"
    ],
    u: "1f69f",
    a: "1.0"
  },
  {
    n: [
      "mountain cableway"
    ],
    u: "1f6a0",
    a: "1.0"
  },
  {
    n: [
      "aerial tramway"
    ],
    u: "1f6a1",
    a: "1.0"
  },
  {
    n: [
      "satellite"
    ],
    u: "1f6f0-fe0f",
    a: "0.7"
  },
  {
    n: [
      "rocket"
    ],
    u: "1f680",
    a: "0.6"
  },
  {
    n: [
      "flying saucer"
    ],
    u: "1f6f8",
    a: "5.0"
  },
  {
    n: [
      "bellhop bell"
    ],
    u: "1f6ce-fe0f",
    a: "0.7"
  },
  {
    n: [
      "luggage"
    ],
    u: "1f9f3",
    a: "11.0"
  },
  {
    n: [
      "hourglass"
    ],
    u: "231b",
    a: "0.6"
  },
  {
    n: [
      "hourglass flowing sand",
      "hourglass with flowing sand"
    ],
    u: "23f3",
    a: "0.6"
  },
  {
    n: [
      "watch"
    ],
    u: "231a",
    a: "0.6"
  },
  {
    n: [
      "alarm clock"
    ],
    u: "23f0",
    a: "0.6"
  },
  {
    n: [
      "stopwatch"
    ],
    u: "23f1-fe0f",
    a: "1.0"
  },
  {
    n: [
      "timer clock"
    ],
    u: "23f2-fe0f",
    a: "1.0"
  },
  {
    n: [
      "mantelpiece clock"
    ],
    u: "1f570-fe0f",
    a: "0.7"
  },
  {
    n: [
      "clock12",
      "clock face twelve oclock"
    ],
    u: "1f55b",
    a: "0.6"
  },
  {
    n: [
      "clock1230",
      "clock face twelve-thirty"
    ],
    u: "1f567",
    a: "0.7"
  },
  {
    n: [
      "clock1",
      "clock face one oclock"
    ],
    u: "1f550",
    a: "0.6"
  },
  {
    n: [
      "clock130",
      "clock face one-thirty"
    ],
    u: "1f55c",
    a: "0.7"
  },
  {
    n: [
      "clock2",
      "clock face two oclock"
    ],
    u: "1f551",
    a: "0.6"
  },
  {
    n: [
      "clock230",
      "clock face two-thirty"
    ],
    u: "1f55d",
    a: "0.7"
  },
  {
    n: [
      "clock3",
      "clock face three oclock"
    ],
    u: "1f552",
    a: "0.6"
  },
  {
    n: [
      "clock330",
      "clock face three-thirty"
    ],
    u: "1f55e",
    a: "0.7"
  },
  {
    n: [
      "clock4",
      "clock face four oclock"
    ],
    u: "1f553",
    a: "0.6"
  },
  {
    n: [
      "clock430",
      "clock face four-thirty"
    ],
    u: "1f55f",
    a: "0.7"
  },
  {
    n: [
      "clock5",
      "clock face five oclock"
    ],
    u: "1f554",
    a: "0.6"
  },
  {
    n: [
      "clock530",
      "clock face five-thirty"
    ],
    u: "1f560",
    a: "0.7"
  },
  {
    n: [
      "clock6",
      "clock face six oclock"
    ],
    u: "1f555",
    a: "0.6"
  },
  {
    n: [
      "clock630",
      "clock face six-thirty"
    ],
    u: "1f561",
    a: "0.7"
  },
  {
    n: [
      "clock7",
      "clock face seven oclock"
    ],
    u: "1f556",
    a: "0.6"
  },
  {
    n: [
      "clock730",
      "clock face seven-thirty"
    ],
    u: "1f562",
    a: "0.7"
  },
  {
    n: [
      "clock8",
      "clock face eight oclock"
    ],
    u: "1f557",
    a: "0.6"
  },
  {
    n: [
      "clock830",
      "clock face eight-thirty"
    ],
    u: "1f563",
    a: "0.7"
  },
  {
    n: [
      "clock9",
      "clock face nine oclock"
    ],
    u: "1f558",
    a: "0.6"
  },
  {
    n: [
      "clock930",
      "clock face nine-thirty"
    ],
    u: "1f564",
    a: "0.7"
  },
  {
    n: [
      "clock10",
      "clock face ten oclock"
    ],
    u: "1f559",
    a: "0.6"
  },
  {
    n: [
      "clock1030",
      "clock face ten-thirty"
    ],
    u: "1f565",
    a: "0.7"
  },
  {
    n: [
      "clock11",
      "clock face eleven oclock"
    ],
    u: "1f55a",
    a: "0.6"
  },
  {
    n: [
      "clock1130",
      "clock face eleven-thirty"
    ],
    u: "1f566",
    a: "0.7"
  },
  {
    n: [
      "new moon",
      "new moon symbol"
    ],
    u: "1f311",
    a: "0.6"
  },
  {
    n: [
      "waxing crescent moon",
      "waxing crescent moon symbol"
    ],
    u: "1f312",
    a: "1.0"
  },
  {
    n: [
      "first quarter moon",
      "first quarter moon symbol"
    ],
    u: "1f313",
    a: "0.6"
  },
  {
    n: [
      "moon",
      "waxing gibbous moon",
      "waxing gibbous moon symbol"
    ],
    u: "1f314",
    a: "0.6"
  },
  {
    n: [
      "full moon",
      "full moon symbol"
    ],
    u: "1f315",
    a: "0.6"
  },
  {
    n: [
      "waning gibbous moon",
      "waning gibbous moon symbol"
    ],
    u: "1f316",
    a: "1.0"
  },
  {
    n: [
      "last quarter moon",
      "last quarter moon symbol"
    ],
    u: "1f317",
    a: "1.0"
  },
  {
    n: [
      "waning crescent moon",
      "waning crescent moon symbol"
    ],
    u: "1f318",
    a: "1.0"
  },
  {
    n: [
      "crescent moon"
    ],
    u: "1f319",
    a: "0.6"
  },
  {
    n: [
      "new moon with face"
    ],
    u: "1f31a",
    a: "1.0"
  },
  {
    n: [
      "first quarter moon with face"
    ],
    u: "1f31b",
    a: "0.6"
  },
  {
    n: [
      "last quarter moon with face"
    ],
    u: "1f31c",
    a: "0.7"
  },
  {
    n: [
      "thermometer"
    ],
    u: "1f321-fe0f",
    a: "0.7"
  },
  {
    n: [
      "sunny",
      "black sun with rays"
    ],
    u: "2600-fe0f",
    a: "0.6"
  },
  {
    n: [
      "full moon with face"
    ],
    u: "1f31d",
    a: "1.0"
  },
  {
    n: [
      "sun with face"
    ],
    u: "1f31e",
    a: "1.0"
  },
  {
    n: [
      "ringed planet"
    ],
    u: "1fa90",
    a: "12.0"
  },
  {
    n: [
      "star",
      "white medium star"
    ],
    u: "2b50",
    a: "0.6"
  },
  {
    n: [
      "star2",
      "glowing star"
    ],
    u: "1f31f",
    a: "0.6"
  },
  {
    n: [
      "stars",
      "shooting star"
    ],
    u: "1f320",
    a: "0.6"
  },
  {
    n: [
      "milky way"
    ],
    u: "1f30c",
    a: "0.6"
  },
  {
    n: [
      "cloud"
    ],
    u: "2601-fe0f",
    a: "0.6"
  },
  {
    n: [
      "partly sunny",
      "sun behind cloud"
    ],
    u: "26c5",
    a: "0.6"
  },
  {
    n: [
      "thunder cloud and rain",
      "cloud with lightning and rain"
    ],
    u: "26c8-fe0f",
    a: "0.7"
  },
  {
    n: [
      "mostly sunny",
      "sun small cloud",
      "sun behind small cloud"
    ],
    u: "1f324-fe0f",
    a: "0.7"
  },
  {
    n: [
      "barely sunny",
      "sun behind cloud",
      "sun behind large cloud"
    ],
    u: "1f325-fe0f",
    a: "0.7"
  },
  {
    n: [
      "partly sunny rain",
      "sun behind rain cloud"
    ],
    u: "1f326-fe0f",
    a: "0.7"
  },
  {
    n: [
      "rain cloud",
      "cloud with rain"
    ],
    u: "1f327-fe0f",
    a: "0.7"
  },
  {
    n: [
      "snow cloud",
      "cloud with snow"
    ],
    u: "1f328-fe0f",
    a: "0.7"
  },
  {
    n: [
      "lightning",
      "lightning cloud",
      "cloud with lightning"
    ],
    u: "1f329-fe0f",
    a: "0.7"
  },
  {
    n: [
      "tornado",
      "tornado cloud"
    ],
    u: "1f32a-fe0f",
    a: "0.7"
  },
  {
    n: [
      "fog"
    ],
    u: "1f32b-fe0f",
    a: "0.7"
  },
  {
    n: [
      "wind face",
      "wind blowing face"
    ],
    u: "1f32c-fe0f",
    a: "0.7"
  },
  {
    n: [
      "cyclone"
    ],
    u: "1f300",
    a: "0.6"
  },
  {
    n: [
      "rainbow"
    ],
    u: "1f308",
    a: "0.6"
  },
  {
    n: [
      "closed umbrella"
    ],
    u: "1f302",
    a: "0.6"
  },
  {
    n: [
      "umbrella"
    ],
    u: "2602-fe0f",
    a: "0.7"
  },
  {
    n: [
      "umbrella with rain drops"
    ],
    u: "2614",
    a: "0.6"
  },
  {
    n: [
      "umbrella on ground"
    ],
    u: "26f1-fe0f",
    a: "0.7"
  },
  {
    n: [
      "zap",
      "high voltage sign"
    ],
    u: "26a1",
    a: "0.6"
  },
  {
    n: [
      "snowflake"
    ],
    u: "2744-fe0f",
    a: "0.6"
  },
  {
    n: [
      "snowman"
    ],
    u: "2603-fe0f",
    a: "0.7"
  },
  {
    n: [
      "snowman without snow"
    ],
    u: "26c4",
    a: "0.6"
  },
  {
    n: [
      "comet"
    ],
    u: "2604-fe0f",
    a: "1.0"
  },
  {
    n: [
      "fire"
    ],
    u: "1f525",
    a: "0.6"
  },
  {
    n: [
      "droplet"
    ],
    u: "1f4a7",
    a: "0.6"
  },
  {
    n: [
      "ocean",
      "water wave"
    ],
    u: "1f30a",
    a: "0.6"
  }
];
var activities = [
  {
    n: [
      "jack-o-lantern",
      "jack o lantern"
    ],
    u: "1f383",
    a: "0.6"
  },
  {
    n: [
      "christmas tree"
    ],
    u: "1f384",
    a: "0.6"
  },
  {
    n: [
      "fireworks"
    ],
    u: "1f386",
    a: "0.6"
  },
  {
    n: [
      "sparkler",
      "firework sparkler"
    ],
    u: "1f387",
    a: "0.6"
  },
  {
    n: [
      "firecracker"
    ],
    u: "1f9e8",
    a: "11.0"
  },
  {
    n: [
      "sparkles"
    ],
    u: "2728",
    a: "0.6"
  },
  {
    n: [
      "balloon"
    ],
    u: "1f388",
    a: "0.6"
  },
  {
    n: [
      "tada",
      "party popper"
    ],
    u: "1f389",
    a: "0.6"
  },
  {
    n: [
      "confetti ball"
    ],
    u: "1f38a",
    a: "0.6"
  },
  {
    n: [
      "tanabata tree"
    ],
    u: "1f38b",
    a: "0.6"
  },
  {
    n: [
      "bamboo",
      "pine decoration"
    ],
    u: "1f38d",
    a: "0.6"
  },
  {
    n: [
      "dolls",
      "japanese dolls"
    ],
    u: "1f38e",
    a: "0.6"
  },
  {
    n: [
      "flags",
      "carp streamer"
    ],
    u: "1f38f",
    a: "0.6"
  },
  {
    n: [
      "wind chime"
    ],
    u: "1f390",
    a: "0.6"
  },
  {
    n: [
      "rice scene",
      "moon viewing ceremony"
    ],
    u: "1f391",
    a: "0.6"
  },
  {
    n: [
      "red envelope",
      "red gift envelope"
    ],
    u: "1f9e7",
    a: "11.0"
  },
  {
    n: [
      "ribbon"
    ],
    u: "1f380",
    a: "0.6"
  },
  {
    n: [
      "gift",
      "wrapped present"
    ],
    u: "1f381",
    a: "0.6"
  },
  {
    n: [
      "reminder ribbon"
    ],
    u: "1f397-fe0f",
    a: "0.7"
  },
  {
    n: [
      "admission tickets"
    ],
    u: "1f39f-fe0f",
    a: "0.7"
  },
  {
    n: [
      "ticket"
    ],
    u: "1f3ab",
    a: "0.6"
  },
  {
    n: [
      "medal",
      "military medal"
    ],
    u: "1f396-fe0f",
    a: "0.7"
  },
  {
    n: [
      "trophy"
    ],
    u: "1f3c6",
    a: "0.6"
  },
  {
    n: [
      "sports medal"
    ],
    u: "1f3c5",
    a: "1.0"
  },
  {
    n: [
      "first place medal"
    ],
    u: "1f947",
    a: "3.0"
  },
  {
    n: [
      "second place medal"
    ],
    u: "1f948",
    a: "3.0"
  },
  {
    n: [
      "third place medal"
    ],
    u: "1f949",
    a: "3.0"
  },
  {
    n: [
      "soccer",
      "soccer ball"
    ],
    u: "26bd",
    a: "0.6"
  },
  {
    n: [
      "baseball"
    ],
    u: "26be",
    a: "0.6"
  },
  {
    n: [
      "softball"
    ],
    u: "1f94e",
    a: "11.0"
  },
  {
    n: [
      "basketball",
      "basketball and hoop"
    ],
    u: "1f3c0",
    a: "0.6"
  },
  {
    n: [
      "volleyball"
    ],
    u: "1f3d0",
    a: "1.0"
  },
  {
    n: [
      "football",
      "american football"
    ],
    u: "1f3c8",
    a: "0.6"
  },
  {
    n: [
      "rugby football"
    ],
    u: "1f3c9",
    a: "1.0"
  },
  {
    n: [
      "tennis",
      "tennis racquet and ball"
    ],
    u: "1f3be",
    a: "0.6"
  },
  {
    n: [
      "flying disc"
    ],
    u: "1f94f",
    a: "11.0"
  },
  {
    n: [
      "bowling"
    ],
    u: "1f3b3",
    a: "0.6"
  },
  {
    n: [
      "cricket bat and ball"
    ],
    u: "1f3cf",
    a: "1.0"
  },
  {
    n: [
      "field hockey stick and ball"
    ],
    u: "1f3d1",
    a: "1.0"
  },
  {
    n: [
      "ice hockey stick and puck"
    ],
    u: "1f3d2",
    a: "1.0"
  },
  {
    n: [
      "lacrosse",
      "lacrosse stick and ball"
    ],
    u: "1f94d",
    a: "11.0"
  },
  {
    n: [
      "table tennis paddle and ball"
    ],
    u: "1f3d3",
    a: "1.0"
  },
  {
    n: [
      "badminton racquet and shuttlecock"
    ],
    u: "1f3f8",
    a: "1.0"
  },
  {
    n: [
      "boxing glove"
    ],
    u: "1f94a",
    a: "3.0"
  },
  {
    n: [
      "martial arts uniform"
    ],
    u: "1f94b",
    a: "3.0"
  },
  {
    n: [
      "goal net"
    ],
    u: "1f945",
    a: "3.0"
  },
  {
    n: [
      "golf",
      "flag in hole"
    ],
    u: "26f3",
    a: "0.6"
  },
  {
    n: [
      "ice skate"
    ],
    u: "26f8-fe0f",
    a: "0.7"
  },
  {
    n: [
      "fishing pole and fish"
    ],
    u: "1f3a3",
    a: "0.6"
  },
  {
    n: [
      "diving mask"
    ],
    u: "1f93f",
    a: "12.0"
  },
  {
    n: [
      "running shirt with sash"
    ],
    u: "1f3bd",
    a: "0.6"
  },
  {
    n: [
      "ski",
      "ski and ski boot"
    ],
    u: "1f3bf",
    a: "0.6"
  },
  {
    n: [
      "sled"
    ],
    u: "1f6f7",
    a: "5.0"
  },
  {
    n: [
      "curling stone"
    ],
    u: "1f94c",
    a: "5.0"
  },
  {
    n: [
      "dart",
      "direct hit"
    ],
    u: "1f3af",
    a: "0.6"
  },
  {
    n: [
      "yo-yo"
    ],
    u: "1fa80",
    a: "12.0"
  },
  {
    n: [
      "kite"
    ],
    u: "1fa81",
    a: "12.0"
  },
  {
    n: [
      "8ball",
      "billiards"
    ],
    u: "1f3b1",
    a: "0.6"
  },
  {
    n: [
      "crystal ball"
    ],
    u: "1f52e",
    a: "0.6"
  },
  {
    n: [
      "magic wand"
    ],
    u: "1fa84",
    a: "13.0"
  },
  {
    n: [
      "nazar amulet"
    ],
    u: "1f9ff",
    a: "11.0"
  },
  {
    n: [
      "hamsa"
    ],
    u: "1faac",
    a: "14.0"
  },
  {
    n: [
      "video game"
    ],
    u: "1f3ae",
    a: "0.6"
  },
  {
    n: [
      "joystick"
    ],
    u: "1f579-fe0f",
    a: "0.7"
  },
  {
    n: [
      "slot machine"
    ],
    u: "1f3b0",
    a: "0.6"
  },
  {
    n: [
      "game die"
    ],
    u: "1f3b2",
    a: "0.6"
  },
  {
    n: [
      "jigsaw",
      "jigsaw puzzle piece"
    ],
    u: "1f9e9",
    a: "11.0"
  },
  {
    n: [
      "teddy bear"
    ],
    u: "1f9f8",
    a: "11.0"
  },
  {
    n: [
      "pinata"
    ],
    u: "1fa85",
    a: "13.0"
  },
  {
    n: [
      "mirror ball"
    ],
    u: "1faa9",
    a: "14.0"
  },
  {
    n: [
      "nesting dolls"
    ],
    u: "1fa86",
    a: "13.0"
  },
  {
    n: [
      "spades",
      "black spade suit"
    ],
    u: "2660-fe0f",
    a: "0.6"
  },
  {
    n: [
      "hearts",
      "black heart suit"
    ],
    u: "2665-fe0f",
    a: "0.6"
  },
  {
    n: [
      "diamonds",
      "black diamond suit"
    ],
    u: "2666-fe0f",
    a: "0.6"
  },
  {
    n: [
      "clubs",
      "black club suit"
    ],
    u: "2663-fe0f",
    a: "0.6"
  },
  {
    n: [
      "chess pawn"
    ],
    u: "265f-fe0f",
    a: "11.0"
  },
  {
    n: [
      "black joker",
      "playing card black joker"
    ],
    u: "1f0cf",
    a: "0.6"
  },
  {
    n: [
      "mahjong",
      "mahjong tile red dragon"
    ],
    u: "1f004",
    a: "0.6"
  },
  {
    n: [
      "flower playing cards"
    ],
    u: "1f3b4",
    a: "0.6"
  },
  {
    n: [
      "performing arts"
    ],
    u: "1f3ad",
    a: "0.6"
  },
  {
    n: [
      "framed picture",
      "frame with picture"
    ],
    u: "1f5bc-fe0f",
    a: "0.7"
  },
  {
    n: [
      "art",
      "artist palette"
    ],
    u: "1f3a8",
    a: "0.6"
  },
  {
    n: [
      "thread",
      "spool of thread"
    ],
    u: "1f9f5",
    a: "11.0"
  },
  {
    n: [
      "sewing needle"
    ],
    u: "1faa1",
    a: "13.0"
  },
  {
    n: [
      "yarn",
      "ball of yarn"
    ],
    u: "1f9f6",
    a: "11.0"
  },
  {
    n: [
      "knot"
    ],
    u: "1faa2",
    a: "13.0"
  }
];
var objects = [
  {
    n: [
      "eyeglasses"
    ],
    u: "1f453",
    a: "0.6"
  },
  {
    n: [
      "sunglasses",
      "dark sunglasses"
    ],
    u: "1f576-fe0f",
    a: "0.7"
  },
  {
    n: [
      "goggles"
    ],
    u: "1f97d",
    a: "11.0"
  },
  {
    n: [
      "lab coat"
    ],
    u: "1f97c",
    a: "11.0"
  },
  {
    n: [
      "safety vest"
    ],
    u: "1f9ba",
    a: "12.0"
  },
  {
    n: [
      "necktie"
    ],
    u: "1f454",
    a: "0.6"
  },
  {
    n: [
      "shirt",
      "tshirt",
      "t-shirt"
    ],
    u: "1f455",
    a: "0.6"
  },
  {
    n: [
      "jeans"
    ],
    u: "1f456",
    a: "0.6"
  },
  {
    n: [
      "scarf"
    ],
    u: "1f9e3",
    a: "5.0"
  },
  {
    n: [
      "gloves"
    ],
    u: "1f9e4",
    a: "5.0"
  },
  {
    n: [
      "coat"
    ],
    u: "1f9e5",
    a: "5.0"
  },
  {
    n: [
      "socks"
    ],
    u: "1f9e6",
    a: "5.0"
  },
  {
    n: [
      "dress"
    ],
    u: "1f457",
    a: "0.6"
  },
  {
    n: [
      "kimono"
    ],
    u: "1f458",
    a: "0.6"
  },
  {
    n: [
      "sari"
    ],
    u: "1f97b",
    a: "12.0"
  },
  {
    n: [
      "one-piece swimsuit"
    ],
    u: "1fa71",
    a: "12.0"
  },
  {
    n: [
      "briefs"
    ],
    u: "1fa72",
    a: "12.0"
  },
  {
    n: [
      "shorts"
    ],
    u: "1fa73",
    a: "12.0"
  },
  {
    n: [
      "bikini"
    ],
    u: "1f459",
    a: "0.6"
  },
  {
    n: [
      "womans clothes"
    ],
    u: "1f45a",
    a: "0.6"
  },
  {
    n: [
      "purse"
    ],
    u: "1f45b",
    a: "0.6"
  },
  {
    n: [
      "handbag"
    ],
    u: "1f45c",
    a: "0.6"
  },
  {
    n: [
      "pouch"
    ],
    u: "1f45d",
    a: "0.6"
  },
  {
    n: [
      "shopping bags"
    ],
    u: "1f6cd-fe0f",
    a: "0.7"
  },
  {
    n: [
      "school satchel"
    ],
    u: "1f392",
    a: "0.6"
  },
  {
    n: [
      "thong sandal"
    ],
    u: "1fa74",
    a: "13.0"
  },
  {
    n: [
      "shoe",
      "mans shoe"
    ],
    u: "1f45e",
    a: "0.6"
  },
  {
    n: [
      "athletic shoe"
    ],
    u: "1f45f",
    a: "0.6"
  },
  {
    n: [
      "hiking boot"
    ],
    u: "1f97e",
    a: "11.0"
  },
  {
    n: [
      "flat shoe",
      "womans flat shoe"
    ],
    u: "1f97f",
    a: "11.0"
  },
  {
    n: [
      "high heel",
      "high-heeled shoe"
    ],
    u: "1f460",
    a: "0.6"
  },
  {
    n: [
      "sandal",
      "womans sandal"
    ],
    u: "1f461",
    a: "0.6"
  },
  {
    n: [
      "ballet shoes"
    ],
    u: "1fa70",
    a: "12.0"
  },
  {
    n: [
      "boot",
      "womans boots"
    ],
    u: "1f462",
    a: "0.6"
  },
  {
    n: [
      "crown"
    ],
    u: "1f451",
    a: "0.6"
  },
  {
    n: [
      "womans hat"
    ],
    u: "1f452",
    a: "0.6"
  },
  {
    n: [
      "tophat",
      "top hat"
    ],
    u: "1f3a9",
    a: "0.6"
  },
  {
    n: [
      "mortar board",
      "graduation cap"
    ],
    u: "1f393",
    a: "0.6"
  },
  {
    n: [
      "billed cap"
    ],
    u: "1f9e2",
    a: "5.0"
  },
  {
    n: [
      "military helmet"
    ],
    u: "1fa96",
    a: "13.0"
  },
  {
    n: [
      "rescue worker’s helmet",
      "helmet with white cross"
    ],
    u: "26d1-fe0f",
    a: "0.7"
  },
  {
    n: [
      "prayer beads"
    ],
    u: "1f4ff",
    a: "1.0"
  },
  {
    n: [
      "lipstick"
    ],
    u: "1f484",
    a: "0.6"
  },
  {
    n: [
      "ring"
    ],
    u: "1f48d",
    a: "0.6"
  },
  {
    n: [
      "gem",
      "gem stone"
    ],
    u: "1f48e",
    a: "0.6"
  },
  {
    n: [
      "mute",
      "speaker with cancellation stroke"
    ],
    u: "1f507",
    a: "1.0"
  },
  {
    n: [
      "speaker"
    ],
    u: "1f508",
    a: "0.7"
  },
  {
    n: [
      "sound",
      "speaker with one sound wave"
    ],
    u: "1f509",
    a: "1.0"
  },
  {
    n: [
      "loud sound",
      "speaker with three sound waves"
    ],
    u: "1f50a",
    a: "0.6"
  },
  {
    n: [
      "loudspeaker",
      "public address loudspeaker"
    ],
    u: "1f4e2",
    a: "0.6"
  },
  {
    n: [
      "mega",
      "cheering megaphone"
    ],
    u: "1f4e3",
    a: "0.6"
  },
  {
    n: [
      "postal horn"
    ],
    u: "1f4ef",
    a: "1.0"
  },
  {
    n: [
      "bell"
    ],
    u: "1f514",
    a: "0.6"
  },
  {
    n: [
      "no bell",
      "bell with cancellation stroke"
    ],
    u: "1f515",
    a: "1.0"
  },
  {
    n: [
      "musical score"
    ],
    u: "1f3bc",
    a: "0.6"
  },
  {
    n: [
      "musical note"
    ],
    u: "1f3b5",
    a: "0.6"
  },
  {
    n: [
      "notes",
      "multiple musical notes"
    ],
    u: "1f3b6",
    a: "0.6"
  },
  {
    n: [
      "studio microphone"
    ],
    u: "1f399-fe0f",
    a: "0.7"
  },
  {
    n: [
      "level slider"
    ],
    u: "1f39a-fe0f",
    a: "0.7"
  },
  {
    n: [
      "control knobs"
    ],
    u: "1f39b-fe0f",
    a: "0.7"
  },
  {
    n: [
      "microphone"
    ],
    u: "1f3a4",
    a: "0.6"
  },
  {
    n: [
      "headphone",
      "headphones"
    ],
    u: "1f3a7",
    a: "0.6"
  },
  {
    n: [
      "radio"
    ],
    u: "1f4fb",
    a: "0.6"
  },
  {
    n: [
      "saxophone"
    ],
    u: "1f3b7",
    a: "0.6"
  },
  {
    n: [
      "accordion"
    ],
    u: "1fa97",
    a: "13.0"
  },
  {
    n: [
      "guitar"
    ],
    u: "1f3b8",
    a: "0.6"
  },
  {
    n: [
      "musical keyboard"
    ],
    u: "1f3b9",
    a: "0.6"
  },
  {
    n: [
      "trumpet"
    ],
    u: "1f3ba",
    a: "0.6"
  },
  {
    n: [
      "violin"
    ],
    u: "1f3bb",
    a: "0.6"
  },
  {
    n: [
      "banjo"
    ],
    u: "1fa95",
    a: "12.0"
  },
  {
    n: [
      "drum with drumsticks"
    ],
    u: "1f941",
    a: "3.0"
  },
  {
    n: [
      "long drum"
    ],
    u: "1fa98",
    a: "13.0"
  },
  {
    n: [
      "iphone",
      "mobile phone"
    ],
    u: "1f4f1",
    a: "0.6"
  },
  {
    n: [
      "calling",
      "mobile phone with rightwards arrow at left"
    ],
    u: "1f4f2",
    a: "0.6"
  },
  {
    n: [
      "phone",
      "telephone",
      "black telephone"
    ],
    u: "260e-fe0f",
    a: "0.6"
  },
  {
    n: [
      "telephone receiver"
    ],
    u: "1f4de",
    a: "0.6"
  },
  {
    n: [
      "pager"
    ],
    u: "1f4df",
    a: "0.6"
  },
  {
    n: [
      "fax",
      "fax machine"
    ],
    u: "1f4e0",
    a: "0.6"
  },
  {
    n: [
      "battery"
    ],
    u: "1f50b",
    a: "0.6"
  },
  {
    n: [
      "low battery"
    ],
    u: "1faab",
    a: "14.0"
  },
  {
    n: [
      "electric plug"
    ],
    u: "1f50c",
    a: "0.6"
  },
  {
    n: [
      "computer",
      "personal computer"
    ],
    u: "1f4bb",
    a: "0.6"
  },
  {
    n: [
      "desktop computer"
    ],
    u: "1f5a5-fe0f",
    a: "0.7"
  },
  {
    n: [
      "printer"
    ],
    u: "1f5a8-fe0f",
    a: "0.7"
  },
  {
    n: [
      "keyboard"
    ],
    u: "2328-fe0f",
    a: "1.0"
  },
  {
    n: [
      "computer mouse",
      "three button mouse"
    ],
    u: "1f5b1-fe0f",
    a: "0.7"
  },
  {
    n: [
      "trackball"
    ],
    u: "1f5b2-fe0f",
    a: "0.7"
  },
  {
    n: [
      "minidisc"
    ],
    u: "1f4bd",
    a: "0.6"
  },
  {
    n: [
      "floppy disk"
    ],
    u: "1f4be",
    a: "0.6"
  },
  {
    n: [
      "cd",
      "optical disc"
    ],
    u: "1f4bf",
    a: "0.6"
  },
  {
    n: [
      "dvd"
    ],
    u: "1f4c0",
    a: "0.6"
  },
  {
    n: [
      "abacus"
    ],
    u: "1f9ee",
    a: "11.0"
  },
  {
    n: [
      "movie camera"
    ],
    u: "1f3a5",
    a: "0.6"
  },
  {
    n: [
      "film frames"
    ],
    u: "1f39e-fe0f",
    a: "0.7"
  },
  {
    n: [
      "film projector"
    ],
    u: "1f4fd-fe0f",
    a: "0.7"
  },
  {
    n: [
      "clapper",
      "clapper board"
    ],
    u: "1f3ac",
    a: "0.6"
  },
  {
    n: [
      "tv",
      "television"
    ],
    u: "1f4fa",
    a: "0.6"
  },
  {
    n: [
      "camera"
    ],
    u: "1f4f7",
    a: "0.6"
  },
  {
    n: [
      "camera with flash"
    ],
    u: "1f4f8",
    a: "1.0"
  },
  {
    n: [
      "video camera"
    ],
    u: "1f4f9",
    a: "0.6"
  },
  {
    n: [
      "vhs",
      "videocassette"
    ],
    u: "1f4fc",
    a: "0.6"
  },
  {
    n: [
      "mag",
      "left-pointing magnifying glass"
    ],
    u: "1f50d",
    a: "0.6"
  },
  {
    n: [
      "mag right",
      "right-pointing magnifying glass"
    ],
    u: "1f50e",
    a: "0.6"
  },
  {
    n: [
      "candle"
    ],
    u: "1f56f-fe0f",
    a: "0.7"
  },
  {
    n: [
      "bulb",
      "electric light bulb"
    ],
    u: "1f4a1",
    a: "0.6"
  },
  {
    n: [
      "flashlight",
      "electric torch"
    ],
    u: "1f526",
    a: "0.6"
  },
  {
    n: [
      "lantern",
      "izakaya lantern"
    ],
    u: "1f3ee",
    a: "0.6"
  },
  {
    n: [
      "diya lamp"
    ],
    u: "1fa94",
    a: "12.0"
  },
  {
    n: [
      "notebook with decorative cover"
    ],
    u: "1f4d4",
    a: "0.6"
  },
  {
    n: [
      "closed book"
    ],
    u: "1f4d5",
    a: "0.6"
  },
  {
    n: [
      "book",
      "open book"
    ],
    u: "1f4d6",
    a: "0.6"
  },
  {
    n: [
      "green book"
    ],
    u: "1f4d7",
    a: "0.6"
  },
  {
    n: [
      "blue book"
    ],
    u: "1f4d8",
    a: "0.6"
  },
  {
    n: [
      "orange book"
    ],
    u: "1f4d9",
    a: "0.6"
  },
  {
    n: [
      "books"
    ],
    u: "1f4da",
    a: "0.6"
  },
  {
    n: [
      "notebook"
    ],
    u: "1f4d3",
    a: "0.6"
  },
  {
    n: [
      "ledger"
    ],
    u: "1f4d2",
    a: "0.6"
  },
  {
    n: [
      "page with curl"
    ],
    u: "1f4c3",
    a: "0.6"
  },
  {
    n: [
      "scroll"
    ],
    u: "1f4dc",
    a: "0.6"
  },
  {
    n: [
      "page facing up"
    ],
    u: "1f4c4",
    a: "0.6"
  },
  {
    n: [
      "newspaper"
    ],
    u: "1f4f0",
    a: "0.6"
  },
  {
    n: [
      "rolled-up newspaper",
      "rolled up newspaper"
    ],
    u: "1f5de-fe0f",
    a: "0.7"
  },
  {
    n: [
      "bookmark tabs"
    ],
    u: "1f4d1",
    a: "0.6"
  },
  {
    n: [
      "bookmark"
    ],
    u: "1f516",
    a: "0.6"
  },
  {
    n: [
      "label"
    ],
    u: "1f3f7-fe0f",
    a: "0.7"
  },
  {
    n: [
      "moneybag",
      "money bag"
    ],
    u: "1f4b0",
    a: "0.6"
  },
  {
    n: [
      "coin"
    ],
    u: "1fa99",
    a: "13.0"
  },
  {
    n: [
      "yen",
      "banknote with yen sign"
    ],
    u: "1f4b4",
    a: "0.6"
  },
  {
    n: [
      "dollar",
      "banknote with dollar sign"
    ],
    u: "1f4b5",
    a: "0.6"
  },
  {
    n: [
      "euro",
      "banknote with euro sign"
    ],
    u: "1f4b6",
    a: "1.0"
  },
  {
    n: [
      "pound",
      "banknote with pound sign"
    ],
    u: "1f4b7",
    a: "1.0"
  },
  {
    n: [
      "money with wings"
    ],
    u: "1f4b8",
    a: "0.6"
  },
  {
    n: [
      "credit card"
    ],
    u: "1f4b3",
    a: "0.6"
  },
  {
    n: [
      "receipt"
    ],
    u: "1f9fe",
    a: "11.0"
  },
  {
    n: [
      "chart",
      "chart with upwards trend and yen sign"
    ],
    u: "1f4b9",
    a: "0.6"
  },
  {
    n: [
      "email",
      "envelope"
    ],
    u: "2709-fe0f",
    a: "0.6"
  },
  {
    n: [
      "e-mail",
      "e-mail symbol"
    ],
    u: "1f4e7",
    a: "0.6"
  },
  {
    n: [
      "incoming envelope"
    ],
    u: "1f4e8",
    a: "0.6"
  },
  {
    n: [
      "envelope with arrow",
      "envelope with downwards arrow above"
    ],
    u: "1f4e9",
    a: "0.6"
  },
  {
    n: [
      "outbox tray"
    ],
    u: "1f4e4",
    a: "0.6"
  },
  {
    n: [
      "inbox tray"
    ],
    u: "1f4e5",
    a: "0.6"
  },
  {
    n: [
      "package"
    ],
    u: "1f4e6",
    a: "0.6"
  },
  {
    n: [
      "mailbox",
      "closed mailbox with raised flag"
    ],
    u: "1f4eb",
    a: "0.6"
  },
  {
    n: [
      "mailbox closed",
      "closed mailbox with lowered flag"
    ],
    u: "1f4ea",
    a: "0.6"
  },
  {
    n: [
      "mailbox with mail",
      "open mailbox with raised flag"
    ],
    u: "1f4ec",
    a: "0.7"
  },
  {
    n: [
      "mailbox with no mail",
      "open mailbox with lowered flag"
    ],
    u: "1f4ed",
    a: "0.7"
  },
  {
    n: [
      "postbox"
    ],
    u: "1f4ee",
    a: "0.6"
  },
  {
    n: [
      "ballot box with ballot"
    ],
    u: "1f5f3-fe0f",
    a: "0.7"
  },
  {
    n: [
      "pencil",
      "pencil2"
    ],
    u: "270f-fe0f",
    a: "0.6"
  },
  {
    n: [
      "black nib"
    ],
    u: "2712-fe0f",
    a: "0.6"
  },
  {
    n: [
      "fountain pen",
      "lower left fountain pen"
    ],
    u: "1f58b-fe0f",
    a: "0.7"
  },
  {
    n: [
      "pen",
      "lower left ballpoint pen"
    ],
    u: "1f58a-fe0f",
    a: "0.7"
  },
  {
    n: [
      "paintbrush",
      "lower left paintbrush"
    ],
    u: "1f58c-fe0f",
    a: "0.7"
  },
  {
    n: [
      "crayon",
      "lower left crayon"
    ],
    u: "1f58d-fe0f",
    a: "0.7"
  },
  {
    n: [
      "memo",
      "pencil"
    ],
    u: "1f4dd",
    a: "0.6"
  },
  {
    n: [
      "briefcase"
    ],
    u: "1f4bc",
    a: "0.6"
  },
  {
    n: [
      "file folder"
    ],
    u: "1f4c1",
    a: "0.6"
  },
  {
    n: [
      "open file folder"
    ],
    u: "1f4c2",
    a: "0.6"
  },
  {
    n: [
      "card index dividers"
    ],
    u: "1f5c2-fe0f",
    a: "0.7"
  },
  {
    n: [
      "date",
      "calendar"
    ],
    u: "1f4c5",
    a: "0.6"
  },
  {
    n: [
      "calendar",
      "tear-off calendar"
    ],
    u: "1f4c6",
    a: "0.6"
  },
  {
    n: [
      "spiral notepad",
      "spiral note pad"
    ],
    u: "1f5d2-fe0f",
    a: "0.7"
  },
  {
    n: [
      "spiral calendar",
      "spiral calendar pad"
    ],
    u: "1f5d3-fe0f",
    a: "0.7"
  },
  {
    n: [
      "card index"
    ],
    u: "1f4c7",
    a: "0.6"
  },
  {
    n: [
      "chart with upwards trend"
    ],
    u: "1f4c8",
    a: "0.6"
  },
  {
    n: [
      "chart with downwards trend"
    ],
    u: "1f4c9",
    a: "0.6"
  },
  {
    n: [
      "bar chart"
    ],
    u: "1f4ca",
    a: "0.6"
  },
  {
    n: [
      "clipboard"
    ],
    u: "1f4cb",
    a: "0.6"
  },
  {
    n: [
      "pushpin"
    ],
    u: "1f4cc",
    a: "0.6"
  },
  {
    n: [
      "round pushpin"
    ],
    u: "1f4cd",
    a: "0.6"
  },
  {
    n: [
      "paperclip"
    ],
    u: "1f4ce",
    a: "0.6"
  },
  {
    n: [
      "linked paperclips"
    ],
    u: "1f587-fe0f",
    a: "0.7"
  },
  {
    n: [
      "straight ruler"
    ],
    u: "1f4cf",
    a: "0.6"
  },
  {
    n: [
      "triangular ruler"
    ],
    u: "1f4d0",
    a: "0.6"
  },
  {
    n: [
      "scissors",
      "black scissors"
    ],
    u: "2702-fe0f",
    a: "0.6"
  },
  {
    n: [
      "card file box"
    ],
    u: "1f5c3-fe0f",
    a: "0.7"
  },
  {
    n: [
      "file cabinet"
    ],
    u: "1f5c4-fe0f",
    a: "0.7"
  },
  {
    n: [
      "wastebasket"
    ],
    u: "1f5d1-fe0f",
    a: "0.7"
  },
  {
    n: [
      "lock"
    ],
    u: "1f512",
    a: "0.6"
  },
  {
    n: [
      "unlock",
      "open lock"
    ],
    u: "1f513",
    a: "0.6"
  },
  {
    n: [
      "lock with ink pen"
    ],
    u: "1f50f",
    a: "0.6"
  },
  {
    n: [
      "closed lock with key"
    ],
    u: "1f510",
    a: "0.6"
  },
  {
    n: [
      "key"
    ],
    u: "1f511",
    a: "0.6"
  },
  {
    n: [
      "old key"
    ],
    u: "1f5dd-fe0f",
    a: "0.7"
  },
  {
    n: [
      "hammer"
    ],
    u: "1f528",
    a: "0.6"
  },
  {
    n: [
      "axe"
    ],
    u: "1fa93",
    a: "12.0"
  },
  {
    n: [
      "pick"
    ],
    u: "26cf-fe0f",
    a: "0.7"
  },
  {
    n: [
      "hammer and pick"
    ],
    u: "2692-fe0f",
    a: "1.0"
  },
  {
    n: [
      "hammer and wrench"
    ],
    u: "1f6e0-fe0f",
    a: "0.7"
  },
  {
    n: [
      "dagger",
      "dagger knife"
    ],
    u: "1f5e1-fe0f",
    a: "0.7"
  },
  {
    n: [
      "crossed swords"
    ],
    u: "2694-fe0f",
    a: "1.0"
  },
  {
    n: [
      "gun",
      "pistol"
    ],
    u: "1f52b",
    a: "0.6"
  },
  {
    n: [
      "boomerang"
    ],
    u: "1fa83",
    a: "13.0"
  },
  {
    n: [
      "bow and arrow"
    ],
    u: "1f3f9",
    a: "1.0"
  },
  {
    n: [
      "shield"
    ],
    u: "1f6e1-fe0f",
    a: "0.7"
  },
  {
    n: [
      "carpentry saw"
    ],
    u: "1fa9a",
    a: "13.0"
  },
  {
    n: [
      "wrench"
    ],
    u: "1f527",
    a: "0.6"
  },
  {
    n: [
      "screwdriver"
    ],
    u: "1fa9b",
    a: "13.0"
  },
  {
    n: [
      "nut and bolt"
    ],
    u: "1f529",
    a: "0.6"
  },
  {
    n: [
      "gear"
    ],
    u: "2699-fe0f",
    a: "1.0"
  },
  {
    n: [
      "clamp",
      "compression"
    ],
    u: "1f5dc-fe0f",
    a: "0.7"
  },
  {
    n: [
      "scales",
      "balance scale"
    ],
    u: "2696-fe0f",
    a: "1.0"
  },
  {
    n: [
      "probing cane"
    ],
    u: "1f9af",
    a: "12.0"
  },
  {
    n: [
      "link",
      "link symbol"
    ],
    u: "1f517",
    a: "0.6"
  },
  {
    n: [
      "chains"
    ],
    u: "26d3-fe0f",
    a: "0.7"
  },
  {
    n: [
      "hook"
    ],
    u: "1fa9d",
    a: "13.0"
  },
  {
    n: [
      "toolbox"
    ],
    u: "1f9f0",
    a: "11.0"
  },
  {
    n: [
      "magnet"
    ],
    u: "1f9f2",
    a: "11.0"
  },
  {
    n: [
      "ladder"
    ],
    u: "1fa9c",
    a: "13.0"
  },
  {
    n: [
      "alembic"
    ],
    u: "2697-fe0f",
    a: "1.0"
  },
  {
    n: [
      "test tube"
    ],
    u: "1f9ea",
    a: "11.0"
  },
  {
    n: [
      "petri dish"
    ],
    u: "1f9eb",
    a: "11.0"
  },
  {
    n: [
      "dna",
      "dna double helix"
    ],
    u: "1f9ec",
    a: "11.0"
  },
  {
    n: [
      "microscope"
    ],
    u: "1f52c",
    a: "1.0"
  },
  {
    n: [
      "telescope"
    ],
    u: "1f52d",
    a: "1.0"
  },
  {
    n: [
      "satellite antenna"
    ],
    u: "1f4e1",
    a: "0.6"
  },
  {
    n: [
      "syringe"
    ],
    u: "1f489",
    a: "0.6"
  },
  {
    n: [
      "drop of blood"
    ],
    u: "1fa78",
    a: "12.0"
  },
  {
    n: [
      "pill"
    ],
    u: "1f48a",
    a: "0.6"
  },
  {
    n: [
      "adhesive bandage"
    ],
    u: "1fa79",
    a: "12.0"
  },
  {
    n: [
      "crutch"
    ],
    u: "1fa7c",
    a: "14.0"
  },
  {
    n: [
      "stethoscope"
    ],
    u: "1fa7a",
    a: "12.0"
  },
  {
    n: [
      "x-ray"
    ],
    u: "1fa7b",
    a: "14.0"
  },
  {
    n: [
      "door"
    ],
    u: "1f6aa",
    a: "0.6"
  },
  {
    n: [
      "elevator"
    ],
    u: "1f6d7",
    a: "13.0"
  },
  {
    n: [
      "mirror"
    ],
    u: "1fa9e",
    a: "13.0"
  },
  {
    n: [
      "window"
    ],
    u: "1fa9f",
    a: "13.0"
  },
  {
    n: [
      "bed"
    ],
    u: "1f6cf-fe0f",
    a: "0.7"
  },
  {
    n: [
      "couch and lamp"
    ],
    u: "1f6cb-fe0f",
    a: "0.7"
  },
  {
    n: [
      "chair"
    ],
    u: "1fa91",
    a: "12.0"
  },
  {
    n: [
      "toilet"
    ],
    u: "1f6bd",
    a: "0.6"
  },
  {
    n: [
      "plunger"
    ],
    u: "1faa0",
    a: "13.0"
  },
  {
    n: [
      "shower"
    ],
    u: "1f6bf",
    a: "1.0"
  },
  {
    n: [
      "bathtub"
    ],
    u: "1f6c1",
    a: "1.0"
  },
  {
    n: [
      "mouse trap"
    ],
    u: "1faa4",
    a: "13.0"
  },
  {
    n: [
      "razor"
    ],
    u: "1fa92",
    a: "12.0"
  },
  {
    n: [
      "lotion bottle"
    ],
    u: "1f9f4",
    a: "11.0"
  },
  {
    n: [
      "safety pin"
    ],
    u: "1f9f7",
    a: "11.0"
  },
  {
    n: [
      "broom"
    ],
    u: "1f9f9",
    a: "11.0"
  },
  {
    n: [
      "basket"
    ],
    u: "1f9fa",
    a: "11.0"
  },
  {
    n: [
      "roll of paper"
    ],
    u: "1f9fb",
    a: "11.0"
  },
  {
    n: [
      "bucket"
    ],
    u: "1faa3",
    a: "13.0"
  },
  {
    n: [
      "soap",
      "bar of soap"
    ],
    u: "1f9fc",
    a: "11.0"
  },
  {
    n: [
      "bubbles"
    ],
    u: "1fae7",
    a: "14.0"
  },
  {
    n: [
      "toothbrush"
    ],
    u: "1faa5",
    a: "13.0"
  },
  {
    n: [
      "sponge"
    ],
    u: "1f9fd",
    a: "11.0"
  },
  {
    n: [
      "fire extinguisher"
    ],
    u: "1f9ef",
    a: "11.0"
  },
  {
    n: [
      "shopping trolley"
    ],
    u: "1f6d2",
    a: "3.0"
  },
  {
    n: [
      "smoking",
      "smoking symbol"
    ],
    u: "1f6ac",
    a: "0.6"
  },
  {
    n: [
      "coffin"
    ],
    u: "26b0-fe0f",
    a: "1.0"
  },
  {
    n: [
      "headstone"
    ],
    u: "1faa6",
    a: "13.0"
  },
  {
    n: [
      "funeral urn"
    ],
    u: "26b1-fe0f",
    a: "1.0"
  },
  {
    n: [
      "moyai"
    ],
    u: "1f5ff",
    a: "0.6"
  },
  {
    n: [
      "placard"
    ],
    u: "1faa7",
    a: "13.0"
  },
  {
    n: [
      "identification card"
    ],
    u: "1faaa",
    a: "14.0"
  }
];
var symbols = [
  {
    n: [
      "atm",
      "automated teller machine"
    ],
    u: "1f3e7",
    a: "0.6"
  },
  {
    n: [
      "put litter in its place",
      "put litter in its place symbol"
    ],
    u: "1f6ae",
    a: "1.0"
  },
  {
    n: [
      "potable water",
      "potable water symbol"
    ],
    u: "1f6b0",
    a: "1.0"
  },
  {
    n: [
      "wheelchair",
      "wheelchair symbol"
    ],
    u: "267f",
    a: "0.6"
  },
  {
    n: [
      "mens",
      "mens symbol"
    ],
    u: "1f6b9",
    a: "0.6"
  },
  {
    n: [
      "womens",
      "womens symbol"
    ],
    u: "1f6ba",
    a: "0.6"
  },
  {
    n: [
      "restroom"
    ],
    u: "1f6bb",
    a: "0.6"
  },
  {
    n: [
      "baby symbol"
    ],
    u: "1f6bc",
    a: "0.6"
  },
  {
    n: [
      "wc",
      "water closet"
    ],
    u: "1f6be",
    a: "0.6"
  },
  {
    n: [
      "passport control"
    ],
    u: "1f6c2",
    a: "1.0"
  },
  {
    n: [
      "customs"
    ],
    u: "1f6c3",
    a: "1.0"
  },
  {
    n: [
      "baggage claim"
    ],
    u: "1f6c4",
    a: "1.0"
  },
  {
    n: [
      "left luggage"
    ],
    u: "1f6c5",
    a: "1.0"
  },
  {
    n: [
      "warning",
      "warning sign"
    ],
    u: "26a0-fe0f",
    a: "0.6"
  },
  {
    n: [
      "children crossing"
    ],
    u: "1f6b8",
    a: "1.0"
  },
  {
    n: [
      "no entry"
    ],
    u: "26d4",
    a: "0.6"
  },
  {
    n: [
      "no entry sign"
    ],
    u: "1f6ab",
    a: "0.6"
  },
  {
    n: [
      "no bicycles"
    ],
    u: "1f6b3",
    a: "1.0"
  },
  {
    n: [
      "no smoking",
      "no smoking symbol"
    ],
    u: "1f6ad",
    a: "0.6"
  },
  {
    n: [
      "do not litter",
      "do not litter symbol"
    ],
    u: "1f6af",
    a: "1.0"
  },
  {
    n: [
      "non-potable water",
      "non-potable water symbol"
    ],
    u: "1f6b1",
    a: "1.0"
  },
  {
    n: [
      "no pedestrians"
    ],
    u: "1f6b7",
    a: "1.0"
  },
  {
    n: [
      "no mobile phones"
    ],
    u: "1f4f5",
    a: "1.0"
  },
  {
    n: [
      "underage",
      "no one under eighteen symbol"
    ],
    u: "1f51e",
    a: "0.6"
  },
  {
    n: [
      "radioactive",
      "radioactive sign"
    ],
    u: "2622-fe0f",
    a: "1.0"
  },
  {
    n: [
      "biohazard",
      "biohazard sign"
    ],
    u: "2623-fe0f",
    a: "1.0"
  },
  {
    n: [
      "arrow up",
      "upwards black arrow"
    ],
    u: "2b06-fe0f",
    a: "0.6"
  },
  {
    n: [
      "north east arrow",
      "arrow upper right"
    ],
    u: "2197-fe0f",
    a: "0.6"
  },
  {
    n: [
      "arrow right",
      "black rightwards arrow"
    ],
    u: "27a1-fe0f",
    a: "0.6"
  },
  {
    n: [
      "south east arrow",
      "arrow lower right"
    ],
    u: "2198-fe0f",
    a: "0.6"
  },
  {
    n: [
      "arrow down",
      "downwards black arrow"
    ],
    u: "2b07-fe0f",
    a: "0.6"
  },
  {
    n: [
      "south west arrow",
      "arrow lower left"
    ],
    u: "2199-fe0f",
    a: "0.6"
  },
  {
    n: [
      "arrow left",
      "leftwards black arrow"
    ],
    u: "2b05-fe0f",
    a: "0.6"
  },
  {
    n: [
      "north west arrow",
      "arrow upper left"
    ],
    u: "2196-fe0f",
    a: "0.6"
  },
  {
    n: [
      "up down arrow",
      "arrow up down"
    ],
    u: "2195-fe0f",
    a: "0.6"
  },
  {
    n: [
      "left right arrow"
    ],
    u: "2194-fe0f",
    a: "0.6"
  },
  {
    n: [
      "leftwards arrow with hook"
    ],
    u: "21a9-fe0f",
    a: "0.6"
  },
  {
    n: [
      "arrow right hook",
      "rightwards arrow with hook"
    ],
    u: "21aa-fe0f",
    a: "0.6"
  },
  {
    n: [
      "arrow heading up",
      "arrow pointing rightwards then curving upwards"
    ],
    u: "2934-fe0f",
    a: "0.6"
  },
  {
    n: [
      "arrow heading down",
      "arrow pointing rightwards then curving downwards"
    ],
    u: "2935-fe0f",
    a: "0.6"
  },
  {
    n: [
      "arrows clockwise",
      "clockwise downwards and upwards open circle arrows"
    ],
    u: "1f503",
    a: "0.6"
  },
  {
    n: [
      "arrows counterclockwise",
      "anticlockwise downwards and upwards open circle arrows"
    ],
    u: "1f504",
    a: "1.0"
  },
  {
    n: [
      "back",
      "back with leftwards arrow above"
    ],
    u: "1f519",
    a: "0.6"
  },
  {
    n: [
      "end",
      "end with leftwards arrow above"
    ],
    u: "1f51a",
    a: "0.6"
  },
  {
    n: [
      "on",
      "on with exclamation mark with left right arrow above"
    ],
    u: "1f51b",
    a: "0.6"
  },
  {
    n: [
      "soon",
      "soon with rightwards arrow above"
    ],
    u: "1f51c",
    a: "0.6"
  },
  {
    n: [
      "top",
      "top with upwards arrow above"
    ],
    u: "1f51d",
    a: "0.6"
  },
  {
    n: [
      "place of worship"
    ],
    u: "1f6d0",
    a: "1.0"
  },
  {
    n: [
      "atom symbol"
    ],
    u: "269b-fe0f",
    a: "1.0"
  },
  {
    n: [
      "om",
      "om symbol"
    ],
    u: "1f549-fe0f",
    a: "0.7"
  },
  {
    n: [
      "star of david"
    ],
    u: "2721-fe0f",
    a: "0.7"
  },
  {
    n: [
      "wheel of dharma"
    ],
    u: "2638-fe0f",
    a: "0.7"
  },
  {
    n: [
      "yin yang"
    ],
    u: "262f-fe0f",
    a: "0.7"
  },
  {
    n: [
      "latin cross"
    ],
    u: "271d-fe0f",
    a: "0.7"
  },
  {
    n: [
      "orthodox cross"
    ],
    u: "2626-fe0f",
    a: "1.0"
  },
  {
    n: [
      "star and crescent"
    ],
    u: "262a-fe0f",
    a: "0.7"
  },
  {
    n: [
      "peace symbol"
    ],
    u: "262e-fe0f",
    a: "1.0"
  },
  {
    n: [
      "menorah with nine branches"
    ],
    u: "1f54e",
    a: "1.0"
  },
  {
    n: [
      "six pointed star",
      "six pointed star with middle dot"
    ],
    u: "1f52f",
    a: "0.6"
  },
  {
    n: [
      "aries"
    ],
    u: "2648",
    a: "0.6"
  },
  {
    n: [
      "taurus"
    ],
    u: "2649",
    a: "0.6"
  },
  {
    n: [
      "gemini"
    ],
    u: "264a",
    a: "0.6"
  },
  {
    n: [
      "cancer"
    ],
    u: "264b",
    a: "0.6"
  },
  {
    n: [
      "leo"
    ],
    u: "264c",
    a: "0.6"
  },
  {
    n: [
      "virgo"
    ],
    u: "264d",
    a: "0.6"
  },
  {
    n: [
      "libra"
    ],
    u: "264e",
    a: "0.6"
  },
  {
    n: [
      "scorpius"
    ],
    u: "264f",
    a: "0.6"
  },
  {
    n: [
      "sagittarius"
    ],
    u: "2650",
    a: "0.6"
  },
  {
    n: [
      "capricorn"
    ],
    u: "2651",
    a: "0.6"
  },
  {
    n: [
      "aquarius"
    ],
    u: "2652",
    a: "0.6"
  },
  {
    n: [
      "pisces"
    ],
    u: "2653",
    a: "0.6"
  },
  {
    n: [
      "ophiuchus"
    ],
    u: "26ce",
    a: "0.6"
  },
  {
    n: [
      "twisted rightwards arrows"
    ],
    u: "1f500",
    a: "1.0"
  },
  {
    n: [
      "repeat",
      "clockwise rightwards and leftwards open circle arrows"
    ],
    u: "1f501",
    a: "1.0"
  },
  {
    n: [
      "repeat one",
      "clockwise rightwards and leftwards open circle arrows with circled one overlay"
    ],
    u: "1f502",
    a: "1.0"
  },
  {
    n: [
      "arrow forward",
      "black right-pointing triangle"
    ],
    u: "25b6-fe0f",
    a: "0.6"
  },
  {
    n: [
      "fast forward",
      "black right-pointing double triangle"
    ],
    u: "23e9",
    a: "0.6"
  },
  {
    n: [
      "next track button",
      "black right pointing double triangle with vertical bar"
    ],
    u: "23ed-fe0f",
    a: "0.7"
  },
  {
    n: [
      "play or pause button",
      "black right pointing triangle with double vertical bar"
    ],
    u: "23ef-fe0f",
    a: "1.0"
  },
  {
    n: [
      "arrow backward",
      "black left-pointing triangle"
    ],
    u: "25c0-fe0f",
    a: "0.6"
  },
  {
    n: [
      "rewind",
      "black left-pointing double triangle"
    ],
    u: "23ea",
    a: "0.6"
  },
  {
    n: [
      "last track button",
      "black left pointing double triangle with vertical bar"
    ],
    u: "23ee-fe0f",
    a: "0.7"
  },
  {
    n: [
      "arrow up small",
      "up-pointing small red triangle"
    ],
    u: "1f53c",
    a: "0.6"
  },
  {
    n: [
      "arrow double up",
      "black up-pointing double triangle"
    ],
    u: "23eb",
    a: "0.6"
  },
  {
    n: [
      "arrow down small",
      "down-pointing small red triangle"
    ],
    u: "1f53d",
    a: "0.6"
  },
  {
    n: [
      "arrow double down",
      "black down-pointing double triangle"
    ],
    u: "23ec",
    a: "0.6"
  },
  {
    n: [
      "pause button",
      "double vertical bar"
    ],
    u: "23f8-fe0f",
    a: "0.7"
  },
  {
    n: [
      "stop button",
      "black square for stop"
    ],
    u: "23f9-fe0f",
    a: "0.7"
  },
  {
    n: [
      "record button",
      "black circle for record"
    ],
    u: "23fa-fe0f",
    a: "0.7"
  },
  {
    n: [
      "eject",
      "eject button"
    ],
    u: "23cf-fe0f",
    a: "1.0"
  },
  {
    n: [
      "cinema"
    ],
    u: "1f3a6",
    a: "0.6"
  },
  {
    n: [
      "low brightness",
      "low brightness symbol"
    ],
    u: "1f505",
    a: "1.0"
  },
  {
    n: [
      "high brightness",
      "high brightness symbol"
    ],
    u: "1f506",
    a: "1.0"
  },
  {
    n: [
      "signal strength",
      "antenna with bars"
    ],
    u: "1f4f6",
    a: "0.6"
  },
  {
    n: [
      "vibration mode"
    ],
    u: "1f4f3",
    a: "0.6"
  },
  {
    n: [
      "mobile phone off"
    ],
    u: "1f4f4",
    a: "0.6"
  },
  {
    n: [
      "female sign"
    ],
    u: "2640-fe0f",
    a: "4.0"
  },
  {
    n: [
      "male sign"
    ],
    u: "2642-fe0f",
    a: "4.0"
  },
  {
    n: [
      "transgender symbol"
    ],
    u: "26a7-fe0f",
    a: "13.0"
  },
  {
    n: [
      "heavy multiplication x"
    ],
    u: "2716-fe0f",
    a: "0.6"
  },
  {
    n: [
      "heavy plus sign"
    ],
    u: "2795",
    a: "0.6"
  },
  {
    n: [
      "heavy minus sign"
    ],
    u: "2796",
    a: "0.6"
  },
  {
    n: [
      "heavy division sign"
    ],
    u: "2797",
    a: "0.6"
  },
  {
    n: [
      "heavy equals sign"
    ],
    u: "1f7f0",
    a: "14.0"
  },
  {
    n: [
      "infinity"
    ],
    u: "267e-fe0f",
    a: "11.0"
  },
  {
    n: [
      "bangbang",
      "double exclamation mark"
    ],
    u: "203c-fe0f",
    a: "0.6"
  },
  {
    n: [
      "interrobang",
      "exclamation question mark"
    ],
    u: "2049-fe0f",
    a: "0.6"
  },
  {
    n: [
      "question",
      "black question mark ornament"
    ],
    u: "2753",
    a: "0.6"
  },
  {
    n: [
      "grey question",
      "white question mark ornament"
    ],
    u: "2754",
    a: "0.6"
  },
  {
    n: [
      "grey exclamation",
      "white exclamation mark ornament"
    ],
    u: "2755",
    a: "0.6"
  },
  {
    n: [
      "exclamation",
      "heavy exclamation mark",
      "heavy exclamation mark symbol"
    ],
    u: "2757",
    a: "0.6"
  },
  {
    n: [
      "wavy dash"
    ],
    u: "3030-fe0f",
    a: "0.6"
  },
  {
    n: [
      "currency exchange"
    ],
    u: "1f4b1",
    a: "0.6"
  },
  {
    n: [
      "heavy dollar sign"
    ],
    u: "1f4b2",
    a: "0.6"
  },
  {
    n: [
      "medical symbol",
      "staff of aesculapius"
    ],
    u: "2695-fe0f",
    a: "4.0"
  },
  {
    n: [
      "recycle",
      "black universal recycling symbol"
    ],
    u: "267b-fe0f",
    a: "0.6"
  },
  {
    n: [
      "fleur-de-lis",
      "fleur de lis"
    ],
    u: "269c-fe0f",
    a: "1.0"
  },
  {
    n: [
      "trident",
      "trident emblem"
    ],
    u: "1f531",
    a: "0.6"
  },
  {
    n: [
      "name badge"
    ],
    u: "1f4db",
    a: "0.6"
  },
  {
    n: [
      "beginner",
      "japanese symbol for beginner"
    ],
    u: "1f530",
    a: "0.6"
  },
  {
    n: [
      "o",
      "heavy large circle"
    ],
    u: "2b55",
    a: "0.6"
  },
  {
    n: [
      "white check mark",
      "white heavy check mark"
    ],
    u: "2705",
    a: "0.6"
  },
  {
    n: [
      "ballot box with check"
    ],
    u: "2611-fe0f",
    a: "0.6"
  },
  {
    n: [
      "heavy check mark"
    ],
    u: "2714-fe0f",
    a: "0.6"
  },
  {
    n: [
      "x",
      "cross mark"
    ],
    u: "274c",
    a: "0.6"
  },
  {
    n: [
      "negative squared cross mark"
    ],
    u: "274e",
    a: "0.6"
  },
  {
    n: [
      "curly loop"
    ],
    u: "27b0",
    a: "0.6"
  },
  {
    n: [
      "loop",
      "double curly loop"
    ],
    u: "27bf",
    a: "1.0"
  },
  {
    n: [
      "part alternation mark"
    ],
    u: "303d-fe0f",
    a: "0.6"
  },
  {
    n: [
      "eight spoked asterisk"
    ],
    u: "2733-fe0f",
    a: "0.6"
  },
  {
    n: [
      "eight pointed black star"
    ],
    u: "2734-fe0f",
    a: "0.6"
  },
  {
    n: [
      "sparkle"
    ],
    u: "2747-fe0f",
    a: "0.6"
  },
  {
    n: [
      "copyright",
      "copyright sign"
    ],
    u: "00a9-fe0f",
    a: "0.6"
  },
  {
    n: [
      "registered",
      "registered sign"
    ],
    u: "00ae-fe0f",
    a: "0.6"
  },
  {
    n: [
      "tm",
      "trade mark sign"
    ],
    u: "2122-fe0f",
    a: "0.6"
  },
  {
    n: [
      "hash",
      "hash key"
    ],
    u: "0023-fe0f-20e3",
    a: "0.6"
  },
  {
    n: [
      "keycap: *",
      "keycap star"
    ],
    u: "002a-fe0f-20e3",
    a: "2.0"
  },
  {
    n: [
      "zero",
      "keycap 0"
    ],
    u: "0030-fe0f-20e3",
    a: "0.6"
  },
  {
    n: [
      "one",
      "keycap 1"
    ],
    u: "0031-fe0f-20e3",
    a: "0.6"
  },
  {
    n: [
      "two",
      "keycap 2"
    ],
    u: "0032-fe0f-20e3",
    a: "0.6"
  },
  {
    n: [
      "three",
      "keycap 3"
    ],
    u: "0033-fe0f-20e3",
    a: "0.6"
  },
  {
    n: [
      "four",
      "keycap 4"
    ],
    u: "0034-fe0f-20e3",
    a: "0.6"
  },
  {
    n: [
      "five",
      "keycap 5"
    ],
    u: "0035-fe0f-20e3",
    a: "0.6"
  },
  {
    n: [
      "six",
      "keycap 6"
    ],
    u: "0036-fe0f-20e3",
    a: "0.6"
  },
  {
    n: [
      "seven",
      "keycap 7"
    ],
    u: "0037-fe0f-20e3",
    a: "0.6"
  },
  {
    n: [
      "eight",
      "keycap 8"
    ],
    u: "0038-fe0f-20e3",
    a: "0.6"
  },
  {
    n: [
      "nine",
      "keycap 9"
    ],
    u: "0039-fe0f-20e3",
    a: "0.6"
  },
  {
    n: [
      "keycap ten"
    ],
    u: "1f51f",
    a: "0.6"
  },
  {
    n: [
      "capital abcd",
      "input symbol for latin capital letters"
    ],
    u: "1f520",
    a: "0.6"
  },
  {
    n: [
      "abcd",
      "input symbol for latin small letters"
    ],
    u: "1f521",
    a: "0.6"
  },
  {
    n: [
      "1234",
      "input symbol for numbers"
    ],
    u: "1f522",
    a: "0.6"
  },
  {
    n: [
      "symbols",
      "input symbol for symbols"
    ],
    u: "1f523",
    a: "0.6"
  },
  {
    n: [
      "abc",
      "input symbol for latin letters"
    ],
    u: "1f524",
    a: "0.6"
  },
  {
    n: [
      "a",
      "negative squared latin capital letter a"
    ],
    u: "1f170-fe0f",
    a: "0.6"
  },
  {
    n: [
      "ab",
      "negative squared ab"
    ],
    u: "1f18e",
    a: "0.6"
  },
  {
    n: [
      "b",
      "negative squared latin capital letter b"
    ],
    u: "1f171-fe0f",
    a: "0.6"
  },
  {
    n: [
      "cl",
      "squared cl"
    ],
    u: "1f191",
    a: "0.6"
  },
  {
    n: [
      "cool",
      "squared cool"
    ],
    u: "1f192",
    a: "0.6"
  },
  {
    n: [
      "free",
      "squared free"
    ],
    u: "1f193",
    a: "0.6"
  },
  {
    n: [
      "information source"
    ],
    u: "2139-fe0f",
    a: "0.6"
  },
  {
    n: [
      "id",
      "squared id"
    ],
    u: "1f194",
    a: "0.6"
  },
  {
    n: [
      "m",
      "circled latin capital letter m"
    ],
    u: "24c2-fe0f",
    a: "0.6"
  },
  {
    n: [
      "new",
      "squared new"
    ],
    u: "1f195",
    a: "0.6"
  },
  {
    n: [
      "ng",
      "squared ng"
    ],
    u: "1f196",
    a: "0.6"
  },
  {
    n: [
      "o2",
      "negative squared latin capital letter o"
    ],
    u: "1f17e-fe0f",
    a: "0.6"
  },
  {
    n: [
      "ok",
      "squared ok"
    ],
    u: "1f197",
    a: "0.6"
  },
  {
    n: [
      "parking",
      "negative squared latin capital letter p"
    ],
    u: "1f17f-fe0f",
    a: "0.6"
  },
  {
    n: [
      "sos",
      "squared sos"
    ],
    u: "1f198",
    a: "0.6"
  },
  {
    n: [
      "up",
      "squared up with exclamation mark"
    ],
    u: "1f199",
    a: "0.6"
  },
  {
    n: [
      "vs",
      "squared vs"
    ],
    u: "1f19a",
    a: "0.6"
  },
  {
    n: [
      "koko",
      "squared katakana koko"
    ],
    u: "1f201",
    a: "0.6"
  },
  {
    n: [
      "sa",
      "squared katakana sa"
    ],
    u: "1f202-fe0f",
    a: "0.6"
  },
  {
    n: [
      "u6708",
      "squared cjk unified ideograph-6708"
    ],
    u: "1f237-fe0f",
    a: "0.6"
  },
  {
    n: [
      "u6709",
      "squared cjk unified ideograph-6709"
    ],
    u: "1f236",
    a: "0.6"
  },
  {
    n: [
      "u6307",
      "squared cjk unified ideograph-6307"
    ],
    u: "1f22f",
    a: "0.6"
  },
  {
    n: [
      "ideograph advantage",
      "circled ideograph advantage"
    ],
    u: "1f250",
    a: "0.6"
  },
  {
    n: [
      "u5272",
      "squared cjk unified ideograph-5272"
    ],
    u: "1f239",
    a: "0.6"
  },
  {
    n: [
      "u7121",
      "squared cjk unified ideograph-7121"
    ],
    u: "1f21a",
    a: "0.6"
  },
  {
    n: [
      "u7981",
      "squared cjk unified ideograph-7981"
    ],
    u: "1f232",
    a: "0.6"
  },
  {
    n: [
      "accept",
      "circled ideograph accept"
    ],
    u: "1f251",
    a: "0.6"
  },
  {
    n: [
      "u7533",
      "squared cjk unified ideograph-7533"
    ],
    u: "1f238",
    a: "0.6"
  },
  {
    n: [
      "u5408",
      "squared cjk unified ideograph-5408"
    ],
    u: "1f234",
    a: "0.6"
  },
  {
    n: [
      "u7a7a",
      "squared cjk unified ideograph-7a7a"
    ],
    u: "1f233",
    a: "0.6"
  },
  {
    n: [
      "congratulations",
      "circled ideograph congratulation"
    ],
    u: "3297-fe0f",
    a: "0.6"
  },
  {
    n: [
      "secret",
      "circled ideograph secret"
    ],
    u: "3299-fe0f",
    a: "0.6"
  },
  {
    n: [
      "u55b6",
      "squared cjk unified ideograph-55b6"
    ],
    u: "1f23a",
    a: "0.6"
  },
  {
    n: [
      "u6e80",
      "squared cjk unified ideograph-6e80"
    ],
    u: "1f235",
    a: "0.6"
  },
  {
    n: [
      "red circle",
      "large red circle"
    ],
    u: "1f534",
    a: "0.6"
  },
  {
    n: [
      "large orange circle"
    ],
    u: "1f7e0",
    a: "12.0"
  },
  {
    n: [
      "large yellow circle"
    ],
    u: "1f7e1",
    a: "12.0"
  },
  {
    n: [
      "large green circle"
    ],
    u: "1f7e2",
    a: "12.0"
  },
  {
    n: [
      "large blue circle"
    ],
    u: "1f535",
    a: "0.6"
  },
  {
    n: [
      "large purple circle"
    ],
    u: "1f7e3",
    a: "12.0"
  },
  {
    n: [
      "large brown circle"
    ],
    u: "1f7e4",
    a: "12.0"
  },
  {
    n: [
      "black circle",
      "medium black circle"
    ],
    u: "26ab",
    a: "0.6"
  },
  {
    n: [
      "white circle",
      "medium white circle"
    ],
    u: "26aa",
    a: "0.6"
  },
  {
    n: [
      "large red square"
    ],
    u: "1f7e5",
    a: "12.0"
  },
  {
    n: [
      "large orange square"
    ],
    u: "1f7e7",
    a: "12.0"
  },
  {
    n: [
      "large yellow square"
    ],
    u: "1f7e8",
    a: "12.0"
  },
  {
    n: [
      "large green square"
    ],
    u: "1f7e9",
    a: "12.0"
  },
  {
    n: [
      "large blue square"
    ],
    u: "1f7e6",
    a: "12.0"
  },
  {
    n: [
      "large purple square"
    ],
    u: "1f7ea",
    a: "12.0"
  },
  {
    n: [
      "large brown square"
    ],
    u: "1f7eb",
    a: "12.0"
  },
  {
    n: [
      "black large square"
    ],
    u: "2b1b",
    a: "0.6"
  },
  {
    n: [
      "white large square"
    ],
    u: "2b1c",
    a: "0.6"
  },
  {
    n: [
      "black medium square"
    ],
    u: "25fc-fe0f",
    a: "0.6"
  },
  {
    n: [
      "white medium square"
    ],
    u: "25fb-fe0f",
    a: "0.6"
  },
  {
    n: [
      "black medium small square"
    ],
    u: "25fe",
    a: "0.6"
  },
  {
    n: [
      "white medium small square"
    ],
    u: "25fd",
    a: "0.6"
  },
  {
    n: [
      "black small square"
    ],
    u: "25aa-fe0f",
    a: "0.6"
  },
  {
    n: [
      "white small square"
    ],
    u: "25ab-fe0f",
    a: "0.6"
  },
  {
    n: [
      "large orange diamond"
    ],
    u: "1f536",
    a: "0.6"
  },
  {
    n: [
      "large blue diamond"
    ],
    u: "1f537",
    a: "0.6"
  },
  {
    n: [
      "small orange diamond"
    ],
    u: "1f538",
    a: "0.6"
  },
  {
    n: [
      "small blue diamond"
    ],
    u: "1f539",
    a: "0.6"
  },
  {
    n: [
      "small red triangle",
      "up-pointing red triangle"
    ],
    u: "1f53a",
    a: "0.6"
  },
  {
    n: [
      "small red triangle down",
      "down-pointing red triangle"
    ],
    u: "1f53b",
    a: "0.6"
  },
  {
    n: [
      "diamond shape with a dot inside"
    ],
    u: "1f4a0",
    a: "0.6"
  },
  {
    n: [
      "radio button"
    ],
    u: "1f518",
    a: "0.6"
  },
  {
    n: [
      "white square button"
    ],
    u: "1f533",
    a: "0.6"
  },
  {
    n: [
      "black square button"
    ],
    u: "1f532",
    a: "0.6"
  }
];
var flags = [
  {
    n: [
      "chequered flag",
      "checkered flag"
    ],
    u: "1f3c1",
    a: "0.6"
  },
  {
    n: [
      "triangular flag on post"
    ],
    u: "1f6a9",
    a: "0.6"
  },
  {
    n: [
      "crossed flags"
    ],
    u: "1f38c",
    a: "0.6"
  },
  {
    n: [
      "waving black flag"
    ],
    u: "1f3f4",
    a: "1.0"
  },
  {
    n: [
      "white flag",
      "waving white flag"
    ],
    u: "1f3f3-fe0f",
    a: "0.7"
  },
  {
    n: [
      "rainbow flag",
      "rainbow-flag"
    ],
    u: "1f3f3-fe0f-200d-1f308",
    a: "4.0"
  },
  {
    n: [
      "transgender flag"
    ],
    u: "1f3f3-fe0f-200d-26a7-fe0f",
    a: "13.0"
  },
  {
    n: [
      "pirate flag"
    ],
    u: "1f3f4-200d-2620-fe0f",
    a: "11.0"
  },
  {
    n: [
      "flag-ac",
      "ascension island flag"
    ],
    u: "1f1e6-1f1e8",
    a: "2.0"
  },
  {
    n: [
      "flag-ad",
      "andorra flag"
    ],
    u: "1f1e6-1f1e9",
    a: "2.0"
  },
  {
    n: [
      "flag-ae",
      "united arab emirates flag"
    ],
    u: "1f1e6-1f1ea",
    a: "2.0"
  },
  {
    n: [
      "flag-af",
      "afghanistan flag"
    ],
    u: "1f1e6-1f1eb",
    a: "2.0"
  },
  {
    n: [
      "flag-ag",
      "antigua & barbuda flag"
    ],
    u: "1f1e6-1f1ec",
    a: "2.0"
  },
  {
    n: [
      "flag-ai",
      "anguilla flag"
    ],
    u: "1f1e6-1f1ee",
    a: "2.0"
  },
  {
    n: [
      "flag-al",
      "albania flag"
    ],
    u: "1f1e6-1f1f1",
    a: "2.0"
  },
  {
    n: [
      "flag-am",
      "armenia flag"
    ],
    u: "1f1e6-1f1f2",
    a: "2.0"
  },
  {
    n: [
      "flag-ao",
      "angola flag"
    ],
    u: "1f1e6-1f1f4",
    a: "2.0"
  },
  {
    n: [
      "flag-aq",
      "antarctica flag"
    ],
    u: "1f1e6-1f1f6",
    a: "2.0"
  },
  {
    n: [
      "flag-ar",
      "argentina flag"
    ],
    u: "1f1e6-1f1f7",
    a: "2.0"
  },
  {
    n: [
      "flag-as",
      "american samoa flag"
    ],
    u: "1f1e6-1f1f8",
    a: "2.0"
  },
  {
    n: [
      "flag-at",
      "austria flag"
    ],
    u: "1f1e6-1f1f9",
    a: "2.0"
  },
  {
    n: [
      "flag-au",
      "australia flag"
    ],
    u: "1f1e6-1f1fa",
    a: "2.0"
  },
  {
    n: [
      "flag-aw",
      "aruba flag"
    ],
    u: "1f1e6-1f1fc",
    a: "2.0"
  },
  {
    n: [
      "flag-ax",
      "åland islands flag"
    ],
    u: "1f1e6-1f1fd",
    a: "2.0"
  },
  {
    n: [
      "flag-az",
      "azerbaijan flag"
    ],
    u: "1f1e6-1f1ff",
    a: "2.0"
  },
  {
    n: [
      "flag-ba",
      "bosnia & herzegovina flag"
    ],
    u: "1f1e7-1f1e6",
    a: "2.0"
  },
  {
    n: [
      "flag-bb",
      "barbados flag"
    ],
    u: "1f1e7-1f1e7",
    a: "2.0"
  },
  {
    n: [
      "flag-bd",
      "bangladesh flag"
    ],
    u: "1f1e7-1f1e9",
    a: "2.0"
  },
  {
    n: [
      "flag-be",
      "belgium flag"
    ],
    u: "1f1e7-1f1ea",
    a: "2.0"
  },
  {
    n: [
      "flag-bf",
      "burkina faso flag"
    ],
    u: "1f1e7-1f1eb",
    a: "2.0"
  },
  {
    n: [
      "flag-bg",
      "bulgaria flag"
    ],
    u: "1f1e7-1f1ec",
    a: "2.0"
  },
  {
    n: [
      "flag-bh",
      "bahrain flag"
    ],
    u: "1f1e7-1f1ed",
    a: "2.0"
  },
  {
    n: [
      "flag-bi",
      "burundi flag"
    ],
    u: "1f1e7-1f1ee",
    a: "2.0"
  },
  {
    n: [
      "flag-bj",
      "benin flag"
    ],
    u: "1f1e7-1f1ef",
    a: "2.0"
  },
  {
    n: [
      "flag-bl",
      "st. barthélemy flag"
    ],
    u: "1f1e7-1f1f1",
    a: "2.0"
  },
  {
    n: [
      "flag-bm",
      "bermuda flag"
    ],
    u: "1f1e7-1f1f2",
    a: "2.0"
  },
  {
    n: [
      "flag-bn",
      "brunei flag"
    ],
    u: "1f1e7-1f1f3",
    a: "2.0"
  },
  {
    n: [
      "flag-bo",
      "bolivia flag"
    ],
    u: "1f1e7-1f1f4",
    a: "2.0"
  },
  {
    n: [
      "flag-bq",
      "caribbean netherlands flag"
    ],
    u: "1f1e7-1f1f6",
    a: "2.0"
  },
  {
    n: [
      "flag-br",
      "brazil flag"
    ],
    u: "1f1e7-1f1f7",
    a: "2.0"
  },
  {
    n: [
      "flag-bs",
      "bahamas flag"
    ],
    u: "1f1e7-1f1f8",
    a: "2.0"
  },
  {
    n: [
      "flag-bt",
      "bhutan flag"
    ],
    u: "1f1e7-1f1f9",
    a: "2.0"
  },
  {
    n: [
      "flag-bv",
      "bouvet island flag"
    ],
    u: "1f1e7-1f1fb",
    a: "2.0"
  },
  {
    n: [
      "flag-bw",
      "botswana flag"
    ],
    u: "1f1e7-1f1fc",
    a: "2.0"
  },
  {
    n: [
      "flag-by",
      "belarus flag"
    ],
    u: "1f1e7-1f1fe",
    a: "2.0"
  },
  {
    n: [
      "flag-bz",
      "belize flag"
    ],
    u: "1f1e7-1f1ff",
    a: "2.0"
  },
  {
    n: [
      "flag-ca",
      "canada flag"
    ],
    u: "1f1e8-1f1e6",
    a: "2.0"
  },
  {
    n: [
      "flag-cc",
      "cocos (keeling) islands flag"
    ],
    u: "1f1e8-1f1e8",
    a: "2.0"
  },
  {
    n: [
      "flag-cd",
      "congo - kinshasa flag"
    ],
    u: "1f1e8-1f1e9",
    a: "2.0"
  },
  {
    n: [
      "flag-cf",
      "central african republic flag"
    ],
    u: "1f1e8-1f1eb",
    a: "2.0"
  },
  {
    n: [
      "flag-cg",
      "congo - brazzaville flag"
    ],
    u: "1f1e8-1f1ec",
    a: "2.0"
  },
  {
    n: [
      "flag-ch",
      "switzerland flag"
    ],
    u: "1f1e8-1f1ed",
    a: "2.0"
  },
  {
    n: [
      "flag-ci",
      "côte d’ivoire flag"
    ],
    u: "1f1e8-1f1ee",
    a: "2.0"
  },
  {
    n: [
      "flag-ck",
      "cook islands flag"
    ],
    u: "1f1e8-1f1f0",
    a: "2.0"
  },
  {
    n: [
      "flag-cl",
      "chile flag"
    ],
    u: "1f1e8-1f1f1",
    a: "2.0"
  },
  {
    n: [
      "flag-cm",
      "cameroon flag"
    ],
    u: "1f1e8-1f1f2",
    a: "2.0"
  },
  {
    n: [
      "cn",
      "flag-cn",
      "china flag"
    ],
    u: "1f1e8-1f1f3",
    a: "0.6"
  },
  {
    n: [
      "flag-co",
      "colombia flag"
    ],
    u: "1f1e8-1f1f4",
    a: "2.0"
  },
  {
    n: [
      "flag-cp",
      "clipperton island flag"
    ],
    u: "1f1e8-1f1f5",
    a: "2.0"
  },
  {
    n: [
      "flag-cr",
      "costa rica flag"
    ],
    u: "1f1e8-1f1f7",
    a: "2.0"
  },
  {
    n: [
      "flag-cu",
      "cuba flag"
    ],
    u: "1f1e8-1f1fa",
    a: "2.0"
  },
  {
    n: [
      "flag-cv",
      "cape verde flag"
    ],
    u: "1f1e8-1f1fb",
    a: "2.0"
  },
  {
    n: [
      "flag-cw",
      "curaçao flag"
    ],
    u: "1f1e8-1f1fc",
    a: "2.0"
  },
  {
    n: [
      "flag-cx",
      "christmas island flag"
    ],
    u: "1f1e8-1f1fd",
    a: "2.0"
  },
  {
    n: [
      "flag-cy",
      "cyprus flag"
    ],
    u: "1f1e8-1f1fe",
    a: "2.0"
  },
  {
    n: [
      "flag-cz",
      "czechia flag"
    ],
    u: "1f1e8-1f1ff",
    a: "2.0"
  },
  {
    n: [
      "de",
      "flag-de",
      "germany flag"
    ],
    u: "1f1e9-1f1ea",
    a: "0.6"
  },
  {
    n: [
      "flag-dg",
      "diego garcia flag"
    ],
    u: "1f1e9-1f1ec",
    a: "2.0"
  },
  {
    n: [
      "flag-dj",
      "djibouti flag"
    ],
    u: "1f1e9-1f1ef",
    a: "2.0"
  },
  {
    n: [
      "flag-dk",
      "denmark flag"
    ],
    u: "1f1e9-1f1f0",
    a: "2.0"
  },
  {
    n: [
      "flag-dm",
      "dominica flag"
    ],
    u: "1f1e9-1f1f2",
    a: "2.0"
  },
  {
    n: [
      "flag-do",
      "dominican republic flag"
    ],
    u: "1f1e9-1f1f4",
    a: "2.0"
  },
  {
    n: [
      "flag-dz",
      "algeria flag"
    ],
    u: "1f1e9-1f1ff",
    a: "2.0"
  },
  {
    n: [
      "flag-ea",
      "ceuta & melilla flag"
    ],
    u: "1f1ea-1f1e6",
    a: "2.0"
  },
  {
    n: [
      "flag-ec",
      "ecuador flag"
    ],
    u: "1f1ea-1f1e8",
    a: "2.0"
  },
  {
    n: [
      "flag-ee",
      "estonia flag"
    ],
    u: "1f1ea-1f1ea",
    a: "2.0"
  },
  {
    n: [
      "flag-eg",
      "egypt flag"
    ],
    u: "1f1ea-1f1ec",
    a: "2.0"
  },
  {
    n: [
      "flag-eh",
      "western sahara flag"
    ],
    u: "1f1ea-1f1ed",
    a: "2.0"
  },
  {
    n: [
      "flag-er",
      "eritrea flag"
    ],
    u: "1f1ea-1f1f7",
    a: "2.0"
  },
  {
    n: [
      "es",
      "flag-es",
      "spain flag"
    ],
    u: "1f1ea-1f1f8",
    a: "0.6"
  },
  {
    n: [
      "flag-et",
      "ethiopia flag"
    ],
    u: "1f1ea-1f1f9",
    a: "2.0"
  },
  {
    n: [
      "flag-eu",
      "european union flag"
    ],
    u: "1f1ea-1f1fa",
    a: "2.0"
  },
  {
    n: [
      "flag-fi",
      "finland flag"
    ],
    u: "1f1eb-1f1ee",
    a: "2.0"
  },
  {
    n: [
      "flag-fj",
      "fiji flag"
    ],
    u: "1f1eb-1f1ef",
    a: "2.0"
  },
  {
    n: [
      "flag-fk",
      "falkland islands flag"
    ],
    u: "1f1eb-1f1f0",
    a: "2.0"
  },
  {
    n: [
      "flag-fm",
      "micronesia flag"
    ],
    u: "1f1eb-1f1f2",
    a: "2.0"
  },
  {
    n: [
      "flag-fo",
      "faroe islands flag"
    ],
    u: "1f1eb-1f1f4",
    a: "2.0"
  },
  {
    n: [
      "fr",
      "flag-fr",
      "france flag"
    ],
    u: "1f1eb-1f1f7",
    a: "0.6"
  },
  {
    n: [
      "flag-ga",
      "gabon flag"
    ],
    u: "1f1ec-1f1e6",
    a: "2.0"
  },
  {
    n: [
      "gb",
      "uk",
      "flag-gb",
      "united kingdom flag"
    ],
    u: "1f1ec-1f1e7",
    a: "0.6"
  },
  {
    n: [
      "flag-gd",
      "grenada flag"
    ],
    u: "1f1ec-1f1e9",
    a: "2.0"
  },
  {
    n: [
      "flag-ge",
      "georgia flag"
    ],
    u: "1f1ec-1f1ea",
    a: "2.0"
  },
  {
    n: [
      "flag-gf",
      "french guiana flag"
    ],
    u: "1f1ec-1f1eb",
    a: "2.0"
  },
  {
    n: [
      "flag-gg",
      "guernsey flag"
    ],
    u: "1f1ec-1f1ec",
    a: "2.0"
  },
  {
    n: [
      "flag-gh",
      "ghana flag"
    ],
    u: "1f1ec-1f1ed",
    a: "2.0"
  },
  {
    n: [
      "flag-gi",
      "gibraltar flag"
    ],
    u: "1f1ec-1f1ee",
    a: "2.0"
  },
  {
    n: [
      "flag-gl",
      "greenland flag"
    ],
    u: "1f1ec-1f1f1",
    a: "2.0"
  },
  {
    n: [
      "flag-gm",
      "gambia flag"
    ],
    u: "1f1ec-1f1f2",
    a: "2.0"
  },
  {
    n: [
      "flag-gn",
      "guinea flag"
    ],
    u: "1f1ec-1f1f3",
    a: "2.0"
  },
  {
    n: [
      "flag-gp",
      "guadeloupe flag"
    ],
    u: "1f1ec-1f1f5",
    a: "2.0"
  },
  {
    n: [
      "flag-gq",
      "equatorial guinea flag"
    ],
    u: "1f1ec-1f1f6",
    a: "2.0"
  },
  {
    n: [
      "flag-gr",
      "greece flag"
    ],
    u: "1f1ec-1f1f7",
    a: "2.0"
  },
  {
    n: [
      "flag-gs",
      "south georgia & south sandwich islands flag"
    ],
    u: "1f1ec-1f1f8",
    a: "2.0"
  },
  {
    n: [
      "flag-gt",
      "guatemala flag"
    ],
    u: "1f1ec-1f1f9",
    a: "2.0"
  },
  {
    n: [
      "flag-gu",
      "guam flag"
    ],
    u: "1f1ec-1f1fa",
    a: "2.0"
  },
  {
    n: [
      "flag-gw",
      "guinea-bissau flag"
    ],
    u: "1f1ec-1f1fc",
    a: "2.0"
  },
  {
    n: [
      "flag-gy",
      "guyana flag"
    ],
    u: "1f1ec-1f1fe",
    a: "2.0"
  },
  {
    n: [
      "flag-hk",
      "hong kong sar china flag"
    ],
    u: "1f1ed-1f1f0",
    a: "2.0"
  },
  {
    n: [
      "flag-hm",
      "heard & mcdonald islands flag"
    ],
    u: "1f1ed-1f1f2",
    a: "2.0"
  },
  {
    n: [
      "flag-hn",
      "honduras flag"
    ],
    u: "1f1ed-1f1f3",
    a: "2.0"
  },
  {
    n: [
      "flag-hr",
      "croatia flag"
    ],
    u: "1f1ed-1f1f7",
    a: "2.0"
  },
  {
    n: [
      "flag-ht",
      "haiti flag"
    ],
    u: "1f1ed-1f1f9",
    a: "2.0"
  },
  {
    n: [
      "flag-hu",
      "hungary flag"
    ],
    u: "1f1ed-1f1fa",
    a: "2.0"
  },
  {
    n: [
      "flag-ic",
      "canary islands flag"
    ],
    u: "1f1ee-1f1e8",
    a: "2.0"
  },
  {
    n: [
      "flag-id",
      "indonesia flag"
    ],
    u: "1f1ee-1f1e9",
    a: "2.0"
  },
  {
    n: [
      "flag-ie",
      "ireland flag"
    ],
    u: "1f1ee-1f1ea",
    a: "2.0"
  },
  {
    n: [
      "flag-il",
      "israel flag"
    ],
    u: "1f1ee-1f1f1",
    a: "2.0"
  },
  {
    n: [
      "flag-im",
      "isle of man flag"
    ],
    u: "1f1ee-1f1f2",
    a: "2.0"
  },
  {
    n: [
      "flag-in",
      "india flag"
    ],
    u: "1f1ee-1f1f3",
    a: "2.0"
  },
  {
    n: [
      "flag-io",
      "british indian ocean territory flag"
    ],
    u: "1f1ee-1f1f4",
    a: "2.0"
  },
  {
    n: [
      "flag-iq",
      "iraq flag"
    ],
    u: "1f1ee-1f1f6",
    a: "2.0"
  },
  {
    n: [
      "flag-ir",
      "iran flag"
    ],
    u: "1f1ee-1f1f7",
    a: "2.0"
  },
  {
    n: [
      "flag-is",
      "iceland flag"
    ],
    u: "1f1ee-1f1f8",
    a: "2.0"
  },
  {
    n: [
      "it",
      "flag-it",
      "italy flag"
    ],
    u: "1f1ee-1f1f9",
    a: "0.6"
  },
  {
    n: [
      "flag-je",
      "jersey flag"
    ],
    u: "1f1ef-1f1ea",
    a: "2.0"
  },
  {
    n: [
      "flag-jm",
      "jamaica flag"
    ],
    u: "1f1ef-1f1f2",
    a: "2.0"
  },
  {
    n: [
      "flag-jo",
      "jordan flag"
    ],
    u: "1f1ef-1f1f4",
    a: "2.0"
  },
  {
    n: [
      "jp",
      "flag-jp",
      "japan flag"
    ],
    u: "1f1ef-1f1f5",
    a: "0.6"
  },
  {
    n: [
      "flag-ke",
      "kenya flag"
    ],
    u: "1f1f0-1f1ea",
    a: "2.0"
  },
  {
    n: [
      "flag-kg",
      "kyrgyzstan flag"
    ],
    u: "1f1f0-1f1ec",
    a: "2.0"
  },
  {
    n: [
      "flag-kh",
      "cambodia flag"
    ],
    u: "1f1f0-1f1ed",
    a: "2.0"
  },
  {
    n: [
      "flag-ki",
      "kiribati flag"
    ],
    u: "1f1f0-1f1ee",
    a: "2.0"
  },
  {
    n: [
      "flag-km",
      "comoros flag"
    ],
    u: "1f1f0-1f1f2",
    a: "2.0"
  },
  {
    n: [
      "flag-kn",
      "st. kitts & nevis flag"
    ],
    u: "1f1f0-1f1f3",
    a: "2.0"
  },
  {
    n: [
      "flag-kp",
      "north korea flag"
    ],
    u: "1f1f0-1f1f5",
    a: "2.0"
  },
  {
    n: [
      "kr",
      "flag-kr",
      "south korea flag"
    ],
    u: "1f1f0-1f1f7",
    a: "0.6"
  },
  {
    n: [
      "flag-kw",
      "kuwait flag"
    ],
    u: "1f1f0-1f1fc",
    a: "2.0"
  },
  {
    n: [
      "flag-ky",
      "cayman islands flag"
    ],
    u: "1f1f0-1f1fe",
    a: "2.0"
  },
  {
    n: [
      "flag-kz",
      "kazakhstan flag"
    ],
    u: "1f1f0-1f1ff",
    a: "2.0"
  },
  {
    n: [
      "flag-la",
      "laos flag"
    ],
    u: "1f1f1-1f1e6",
    a: "2.0"
  },
  {
    n: [
      "flag-lb",
      "lebanon flag"
    ],
    u: "1f1f1-1f1e7",
    a: "2.0"
  },
  {
    n: [
      "flag-lc",
      "st. lucia flag"
    ],
    u: "1f1f1-1f1e8",
    a: "2.0"
  },
  {
    n: [
      "flag-li",
      "liechtenstein flag"
    ],
    u: "1f1f1-1f1ee",
    a: "2.0"
  },
  {
    n: [
      "flag-lk",
      "sri lanka flag"
    ],
    u: "1f1f1-1f1f0",
    a: "2.0"
  },
  {
    n: [
      "flag-lr",
      "liberia flag"
    ],
    u: "1f1f1-1f1f7",
    a: "2.0"
  },
  {
    n: [
      "flag-ls",
      "lesotho flag"
    ],
    u: "1f1f1-1f1f8",
    a: "2.0"
  },
  {
    n: [
      "flag-lt",
      "lithuania flag"
    ],
    u: "1f1f1-1f1f9",
    a: "2.0"
  },
  {
    n: [
      "flag-lu",
      "luxembourg flag"
    ],
    u: "1f1f1-1f1fa",
    a: "2.0"
  },
  {
    n: [
      "flag-lv",
      "latvia flag"
    ],
    u: "1f1f1-1f1fb",
    a: "2.0"
  },
  {
    n: [
      "flag-ly",
      "libya flag"
    ],
    u: "1f1f1-1f1fe",
    a: "2.0"
  },
  {
    n: [
      "flag-ma",
      "morocco flag"
    ],
    u: "1f1f2-1f1e6",
    a: "2.0"
  },
  {
    n: [
      "flag-mc",
      "monaco flag"
    ],
    u: "1f1f2-1f1e8",
    a: "2.0"
  },
  {
    n: [
      "flag-md",
      "moldova flag"
    ],
    u: "1f1f2-1f1e9",
    a: "2.0"
  },
  {
    n: [
      "flag-me",
      "montenegro flag"
    ],
    u: "1f1f2-1f1ea",
    a: "2.0"
  },
  {
    n: [
      "flag-mf",
      "st. martin flag"
    ],
    u: "1f1f2-1f1eb",
    a: "2.0"
  },
  {
    n: [
      "flag-mg",
      "madagascar flag"
    ],
    u: "1f1f2-1f1ec",
    a: "2.0"
  },
  {
    n: [
      "flag-mh",
      "marshall islands flag"
    ],
    u: "1f1f2-1f1ed",
    a: "2.0"
  },
  {
    n: [
      "flag-mk",
      "north macedonia flag"
    ],
    u: "1f1f2-1f1f0",
    a: "2.0"
  },
  {
    n: [
      "flag-ml",
      "mali flag"
    ],
    u: "1f1f2-1f1f1",
    a: "2.0"
  },
  {
    n: [
      "flag-mm",
      "myanmar (burma) flag"
    ],
    u: "1f1f2-1f1f2",
    a: "2.0"
  },
  {
    n: [
      "flag-mn",
      "mongolia flag"
    ],
    u: "1f1f2-1f1f3",
    a: "2.0"
  },
  {
    n: [
      "flag-mo",
      "macao sar china flag"
    ],
    u: "1f1f2-1f1f4",
    a: "2.0"
  },
  {
    n: [
      "flag-mp",
      "northern mariana islands flag"
    ],
    u: "1f1f2-1f1f5",
    a: "2.0"
  },
  {
    n: [
      "flag-mq",
      "martinique flag"
    ],
    u: "1f1f2-1f1f6",
    a: "2.0"
  },
  {
    n: [
      "flag-mr",
      "mauritania flag"
    ],
    u: "1f1f2-1f1f7",
    a: "2.0"
  },
  {
    n: [
      "flag-ms",
      "montserrat flag"
    ],
    u: "1f1f2-1f1f8",
    a: "2.0"
  },
  {
    n: [
      "flag-mt",
      "malta flag"
    ],
    u: "1f1f2-1f1f9",
    a: "2.0"
  },
  {
    n: [
      "flag-mu",
      "mauritius flag"
    ],
    u: "1f1f2-1f1fa",
    a: "2.0"
  },
  {
    n: [
      "flag-mv",
      "maldives flag"
    ],
    u: "1f1f2-1f1fb",
    a: "2.0"
  },
  {
    n: [
      "flag-mw",
      "malawi flag"
    ],
    u: "1f1f2-1f1fc",
    a: "2.0"
  },
  {
    n: [
      "flag-mx",
      "mexico flag"
    ],
    u: "1f1f2-1f1fd",
    a: "2.0"
  },
  {
    n: [
      "flag-my",
      "malaysia flag"
    ],
    u: "1f1f2-1f1fe",
    a: "2.0"
  },
  {
    n: [
      "flag-mz",
      "mozambique flag"
    ],
    u: "1f1f2-1f1ff",
    a: "2.0"
  },
  {
    n: [
      "flag-na",
      "namibia flag"
    ],
    u: "1f1f3-1f1e6",
    a: "2.0"
  },
  {
    n: [
      "flag-nc",
      "new caledonia flag"
    ],
    u: "1f1f3-1f1e8",
    a: "2.0"
  },
  {
    n: [
      "flag-ne",
      "niger flag"
    ],
    u: "1f1f3-1f1ea",
    a: "2.0"
  },
  {
    n: [
      "flag-nf",
      "norfolk island flag"
    ],
    u: "1f1f3-1f1eb",
    a: "2.0"
  },
  {
    n: [
      "flag-ng",
      "nigeria flag"
    ],
    u: "1f1f3-1f1ec",
    a: "2.0"
  },
  {
    n: [
      "flag-ni",
      "nicaragua flag"
    ],
    u: "1f1f3-1f1ee",
    a: "2.0"
  },
  {
    n: [
      "flag-nl",
      "netherlands flag"
    ],
    u: "1f1f3-1f1f1",
    a: "2.0"
  },
  {
    n: [
      "flag-no",
      "norway flag"
    ],
    u: "1f1f3-1f1f4",
    a: "2.0"
  },
  {
    n: [
      "flag-np",
      "nepal flag"
    ],
    u: "1f1f3-1f1f5",
    a: "2.0"
  },
  {
    n: [
      "flag-nr",
      "nauru flag"
    ],
    u: "1f1f3-1f1f7",
    a: "2.0"
  },
  {
    n: [
      "flag-nu",
      "niue flag"
    ],
    u: "1f1f3-1f1fa",
    a: "2.0"
  },
  {
    n: [
      "flag-nz",
      "new zealand flag"
    ],
    u: "1f1f3-1f1ff",
    a: "2.0"
  },
  {
    n: [
      "flag-om",
      "oman flag"
    ],
    u: "1f1f4-1f1f2",
    a: "2.0"
  },
  {
    n: [
      "flag-pa",
      "panama flag"
    ],
    u: "1f1f5-1f1e6",
    a: "2.0"
  },
  {
    n: [
      "flag-pe",
      "peru flag"
    ],
    u: "1f1f5-1f1ea",
    a: "2.0"
  },
  {
    n: [
      "flag-pf",
      "french polynesia flag"
    ],
    u: "1f1f5-1f1eb",
    a: "2.0"
  },
  {
    n: [
      "flag-pg",
      "papua new guinea flag"
    ],
    u: "1f1f5-1f1ec",
    a: "2.0"
  },
  {
    n: [
      "flag-ph",
      "philippines flag"
    ],
    u: "1f1f5-1f1ed",
    a: "2.0"
  },
  {
    n: [
      "flag-pk",
      "pakistan flag"
    ],
    u: "1f1f5-1f1f0",
    a: "2.0"
  },
  {
    n: [
      "flag-pl",
      "poland flag"
    ],
    u: "1f1f5-1f1f1",
    a: "2.0"
  },
  {
    n: [
      "flag-pm",
      "st. pierre & miquelon flag"
    ],
    u: "1f1f5-1f1f2",
    a: "2.0"
  },
  {
    n: [
      "flag-pn",
      "pitcairn islands flag"
    ],
    u: "1f1f5-1f1f3",
    a: "2.0"
  },
  {
    n: [
      "flag-pr",
      "puerto rico flag"
    ],
    u: "1f1f5-1f1f7",
    a: "2.0"
  },
  {
    n: [
      "flag-ps",
      "palestinian territories flag"
    ],
    u: "1f1f5-1f1f8",
    a: "2.0"
  },
  {
    n: [
      "flag-pt",
      "portugal flag"
    ],
    u: "1f1f5-1f1f9",
    a: "2.0"
  },
  {
    n: [
      "flag-pw",
      "palau flag"
    ],
    u: "1f1f5-1f1fc",
    a: "2.0"
  },
  {
    n: [
      "flag-py",
      "paraguay flag"
    ],
    u: "1f1f5-1f1fe",
    a: "2.0"
  },
  {
    n: [
      "flag-qa",
      "qatar flag"
    ],
    u: "1f1f6-1f1e6",
    a: "2.0"
  },
  {
    n: [
      "flag-re",
      "réunion flag"
    ],
    u: "1f1f7-1f1ea",
    a: "2.0"
  },
  {
    n: [
      "flag-ro",
      "romania flag"
    ],
    u: "1f1f7-1f1f4",
    a: "2.0"
  },
  {
    n: [
      "flag-rs",
      "serbia flag"
    ],
    u: "1f1f7-1f1f8",
    a: "2.0"
  },
  {
    n: [
      "ru",
      "flag-ru",
      "russia flag"
    ],
    u: "1f1f7-1f1fa",
    a: "0.6"
  },
  {
    n: [
      "flag-rw",
      "rwanda flag"
    ],
    u: "1f1f7-1f1fc",
    a: "2.0"
  },
  {
    n: [
      "flag-sa",
      "saudi arabia flag"
    ],
    u: "1f1f8-1f1e6",
    a: "2.0"
  },
  {
    n: [
      "flag-sb",
      "solomon islands flag"
    ],
    u: "1f1f8-1f1e7",
    a: "2.0"
  },
  {
    n: [
      "flag-sc",
      "seychelles flag"
    ],
    u: "1f1f8-1f1e8",
    a: "2.0"
  },
  {
    n: [
      "flag-sd",
      "sudan flag"
    ],
    u: "1f1f8-1f1e9",
    a: "2.0"
  },
  {
    n: [
      "flag-se",
      "sweden flag"
    ],
    u: "1f1f8-1f1ea",
    a: "2.0"
  },
  {
    n: [
      "flag-sg",
      "singapore flag"
    ],
    u: "1f1f8-1f1ec",
    a: "2.0"
  },
  {
    n: [
      "flag-sh",
      "st. helena flag"
    ],
    u: "1f1f8-1f1ed",
    a: "2.0"
  },
  {
    n: [
      "flag-si",
      "slovenia flag"
    ],
    u: "1f1f8-1f1ee",
    a: "2.0"
  },
  {
    n: [
      "flag-sj",
      "svalbard & jan mayen flag"
    ],
    u: "1f1f8-1f1ef",
    a: "2.0"
  },
  {
    n: [
      "flag-sk",
      "slovakia flag"
    ],
    u: "1f1f8-1f1f0",
    a: "2.0"
  },
  {
    n: [
      "flag-sl",
      "sierra leone flag"
    ],
    u: "1f1f8-1f1f1",
    a: "2.0"
  },
  {
    n: [
      "flag-sm",
      "san marino flag"
    ],
    u: "1f1f8-1f1f2",
    a: "2.0"
  },
  {
    n: [
      "flag-sn",
      "senegal flag"
    ],
    u: "1f1f8-1f1f3",
    a: "2.0"
  },
  {
    n: [
      "flag-so",
      "somalia flag"
    ],
    u: "1f1f8-1f1f4",
    a: "2.0"
  },
  {
    n: [
      "flag-sr",
      "suriname flag"
    ],
    u: "1f1f8-1f1f7",
    a: "2.0"
  },
  {
    n: [
      "flag-ss",
      "south sudan flag"
    ],
    u: "1f1f8-1f1f8",
    a: "2.0"
  },
  {
    n: [
      "flag-st",
      "são tomé & príncipe flag"
    ],
    u: "1f1f8-1f1f9",
    a: "2.0"
  },
  {
    n: [
      "flag-sv",
      "el salvador flag"
    ],
    u: "1f1f8-1f1fb",
    a: "2.0"
  },
  {
    n: [
      "flag-sx",
      "sint maarten flag"
    ],
    u: "1f1f8-1f1fd",
    a: "2.0"
  },
  {
    n: [
      "flag-sy",
      "syria flag"
    ],
    u: "1f1f8-1f1fe",
    a: "2.0"
  },
  {
    n: [
      "flag-sz",
      "eswatini flag"
    ],
    u: "1f1f8-1f1ff",
    a: "2.0"
  },
  {
    n: [
      "flag-ta",
      "tristan da cunha flag"
    ],
    u: "1f1f9-1f1e6",
    a: "2.0"
  },
  {
    n: [
      "flag-tc",
      "turks & caicos islands flag"
    ],
    u: "1f1f9-1f1e8",
    a: "2.0"
  },
  {
    n: [
      "flag-td",
      "chad flag"
    ],
    u: "1f1f9-1f1e9",
    a: "2.0"
  },
  {
    n: [
      "flag-tf",
      "french southern territories flag"
    ],
    u: "1f1f9-1f1eb",
    a: "2.0"
  },
  {
    n: [
      "flag-tg",
      "togo flag"
    ],
    u: "1f1f9-1f1ec",
    a: "2.0"
  },
  {
    n: [
      "flag-th",
      "thailand flag"
    ],
    u: "1f1f9-1f1ed",
    a: "2.0"
  },
  {
    n: [
      "flag-tj",
      "tajikistan flag"
    ],
    u: "1f1f9-1f1ef",
    a: "2.0"
  },
  {
    n: [
      "flag-tk",
      "tokelau flag"
    ],
    u: "1f1f9-1f1f0",
    a: "2.0"
  },
  {
    n: [
      "flag-tl",
      "timor-leste flag"
    ],
    u: "1f1f9-1f1f1",
    a: "2.0"
  },
  {
    n: [
      "flag-tm",
      "turkmenistan flag"
    ],
    u: "1f1f9-1f1f2",
    a: "2.0"
  },
  {
    n: [
      "flag-tn",
      "tunisia flag"
    ],
    u: "1f1f9-1f1f3",
    a: "2.0"
  },
  {
    n: [
      "flag-to",
      "tonga flag"
    ],
    u: "1f1f9-1f1f4",
    a: "2.0"
  },
  {
    n: [
      "flag-tr",
      "turkey flag"
    ],
    u: "1f1f9-1f1f7",
    a: "2.0"
  },
  {
    n: [
      "flag-tt",
      "trinidad & tobago flag"
    ],
    u: "1f1f9-1f1f9",
    a: "2.0"
  },
  {
    n: [
      "flag-tv",
      "tuvalu flag"
    ],
    u: "1f1f9-1f1fb",
    a: "2.0"
  },
  {
    n: [
      "flag-tw",
      "taiwan flag"
    ],
    u: "1f1f9-1f1fc",
    a: "2.0"
  },
  {
    n: [
      "flag-tz",
      "tanzania flag"
    ],
    u: "1f1f9-1f1ff",
    a: "2.0"
  },
  {
    n: [
      "flag-ua",
      "ukraine flag"
    ],
    u: "1f1fa-1f1e6",
    a: "2.0"
  },
  {
    n: [
      "flag-ug",
      "uganda flag"
    ],
    u: "1f1fa-1f1ec",
    a: "2.0"
  },
  {
    n: [
      "flag-um",
      "u.s. outlying islands flag"
    ],
    u: "1f1fa-1f1f2",
    a: "2.0"
  },
  {
    n: [
      "flag-un",
      "united nations flag"
    ],
    u: "1f1fa-1f1f3",
    a: "4.0"
  },
  {
    n: [
      "us",
      "flag-us",
      "united states flag"
    ],
    u: "1f1fa-1f1f8",
    a: "0.6"
  },
  {
    n: [
      "flag-uy",
      "uruguay flag"
    ],
    u: "1f1fa-1f1fe",
    a: "2.0"
  },
  {
    n: [
      "flag-uz",
      "uzbekistan flag"
    ],
    u: "1f1fa-1f1ff",
    a: "2.0"
  },
  {
    n: [
      "flag-va",
      "vatican city flag"
    ],
    u: "1f1fb-1f1e6",
    a: "2.0"
  },
  {
    n: [
      "flag-vc",
      "st. vincent & grenadines flag"
    ],
    u: "1f1fb-1f1e8",
    a: "2.0"
  },
  {
    n: [
      "flag-ve",
      "venezuela flag"
    ],
    u: "1f1fb-1f1ea",
    a: "2.0"
  },
  {
    n: [
      "flag-vg",
      "british virgin islands flag"
    ],
    u: "1f1fb-1f1ec",
    a: "2.0"
  },
  {
    n: [
      "flag-vi",
      "u.s. virgin islands flag"
    ],
    u: "1f1fb-1f1ee",
    a: "2.0"
  },
  {
    n: [
      "flag-vn",
      "vietnam flag"
    ],
    u: "1f1fb-1f1f3",
    a: "2.0"
  },
  {
    n: [
      "flag-vu",
      "vanuatu flag"
    ],
    u: "1f1fb-1f1fa",
    a: "2.0"
  },
  {
    n: [
      "flag-wf",
      "wallis & futuna flag"
    ],
    u: "1f1fc-1f1eb",
    a: "2.0"
  },
  {
    n: [
      "flag-ws",
      "samoa flag"
    ],
    u: "1f1fc-1f1f8",
    a: "2.0"
  },
  {
    n: [
      "flag-xk",
      "kosovo flag"
    ],
    u: "1f1fd-1f1f0",
    a: "2.0"
  },
  {
    n: [
      "flag-ye",
      "yemen flag"
    ],
    u: "1f1fe-1f1ea",
    a: "2.0"
  },
  {
    n: [
      "flag-yt",
      "mayotte flag"
    ],
    u: "1f1fe-1f1f9",
    a: "2.0"
  },
  {
    n: [
      "flag-za",
      "south africa flag"
    ],
    u: "1f1ff-1f1e6",
    a: "2.0"
  },
  {
    n: [
      "flag-zm",
      "zambia flag"
    ],
    u: "1f1ff-1f1f2",
    a: "2.0"
  },
  {
    n: [
      "flag-zw",
      "zimbabwe flag"
    ],
    u: "1f1ff-1f1fc",
    a: "2.0"
  },
  {
    n: [
      "england flag",
      "flag-england"
    ],
    u: "1f3f4-e0067-e0062-e0065-e006e-e0067-e007f",
    a: "5.0"
  },
  {
    n: [
      "scotland flag",
      "flag-scotland"
    ],
    u: "1f3f4-e0067-e0062-e0073-e0063-e0074-e007f",
    a: "5.0"
  },
  {
    n: [
      "wales flag",
      "flag-wales"
    ],
    u: "1f3f4-e0067-e0062-e0077-e006c-e0073-e007f",
    a: "5.0"
  }
];
var emojis = {
  custom,
  smileys_people,
  animals_nature,
  food_drink,
  travel_places,
  activities,
  objects,
  symbols,
  flags
};
var skinToneVariations = [SkinTones.NEUTRAL, SkinTones.LIGHT, SkinTones.MEDIUM_LIGHT, SkinTones.MEDIUM, SkinTones.MEDIUM_DARK, SkinTones.DARK];
var skinTonesNamed = /* @__PURE__ */ Object.entries(SkinTones).reduce(function(acc, _ref) {
  var key = _ref[0], value = _ref[1];
  acc[value] = key;
  return acc;
}, {});
var skinTonesMapped = /* @__PURE__ */ skinToneVariations.reduce(function(mapped, skinTone) {
  var _Object$assign;
  return Object.assign(mapped, (_Object$assign = {}, _Object$assign[skinTone] = skinTone, _Object$assign));
}, {});
var EmojiProperties;
(function(EmojiProperties2) {
  EmojiProperties2["name"] = "n";
  EmojiProperties2["unified"] = "u";
  EmojiProperties2["variations"] = "v";
  EmojiProperties2["added_in"] = "a";
  EmojiProperties2["imgUrl"] = "imgUrl";
})(EmojiProperties || (EmojiProperties = {}));
var alphaNumericEmojiIndex = {};
setTimeout(function() {
  allEmojis.reduce(function(searchIndex, emoji) {
    indexEmoji(emoji);
    return searchIndex;
  }, alphaNumericEmojiIndex);
});
function indexEmoji(emoji) {
  var joinedNameString = emojiNames(emoji).flat().join("").toLowerCase().replace(/[^a-zA-Z\d]/g, "").split("");
  joinedNameString.forEach(function(_char) {
    var _alphaNumericEmojiInd;
    alphaNumericEmojiIndex[_char] = (_alphaNumericEmojiInd = alphaNumericEmojiIndex[_char]) != null ? _alphaNumericEmojiInd : {};
    alphaNumericEmojiIndex[_char][emojiUnified(emoji)] = emoji;
  });
}
function emojiNames(emoji) {
  var _emoji$EmojiPropertie;
  return (_emoji$EmojiPropertie = emoji[EmojiProperties.name]) != null ? _emoji$EmojiPropertie : [];
}
function addedIn(emoji) {
  return parseFloat(emoji[EmojiProperties.added_in]);
}
function emojiName(emoji) {
  if (!emoji) {
    return "";
  }
  return emojiNames(emoji)[0];
}
function unifiedWithoutSkinTone(unified) {
  var splat = unified.split("-");
  var _splat$splice = splat.splice(1, 1), skinTone = _splat$splice[0];
  if (skinTonesMapped[skinTone]) {
    return splat.join("-");
  }
  return unified;
}
function emojiUnified(emoji, skinTone) {
  var _emojiVariationUnifie;
  var unified = emoji[EmojiProperties.unified];
  if (!skinTone || !emojiHasVariations(emoji)) {
    return unified;
  }
  return (_emojiVariationUnifie = emojiVariationUnified(emoji, skinTone)) != null ? _emojiVariationUnifie : unified;
}
function emojisByCategory(category) {
  var _emojis$category;
  return (_emojis$category = emojis == null ? void 0 : emojis[category]) != null ? _emojis$category : [];
}
function emojiUrlByUnified(unified, emojiStyle) {
  return "" + cdnUrl(emojiStyle) + unified + ".png";
}
function emojiVariations(emoji) {
  var _emoji$EmojiPropertie2;
  return (_emoji$EmojiPropertie2 = emoji[EmojiProperties.variations]) != null ? _emoji$EmojiPropertie2 : [];
}
function emojiHasVariations(emoji) {
  return emojiVariations(emoji).length > 0;
}
function emojiVariationUnified(emoji, skinTone) {
  return skinTone ? emojiVariations(emoji).find(function(variation) {
    return variation.includes(skinTone);
  }) : emojiUnified(emoji);
}
function emojiByUnified(unified) {
  if (!unified) {
    return;
  }
  if (allEmojisByUnified[unified]) {
    return allEmojisByUnified[unified];
  }
  var withoutSkinTone = unifiedWithoutSkinTone(unified);
  return allEmojisByUnified[withoutSkinTone];
}
var allEmojis = /* @__PURE__ */ Object.values(emojis).flat();
function setCustomEmojis(customEmojis) {
  emojis[Categories.CUSTOM].length = 0;
  customEmojis.forEach(function(emoji) {
    var emojiData = customToRegularEmoji(emoji);
    emojis[Categories.CUSTOM].push(emojiData);
    if (allEmojisByUnified[emojiData[EmojiProperties.unified]]) {
      return;
    }
    allEmojis.push(emojiData);
    allEmojisByUnified[emojiData[EmojiProperties.unified]] = emojiData;
    indexEmoji(emojiData);
  });
}
function customToRegularEmoji(emoji) {
  var _ref;
  return _ref = {}, _ref[EmojiProperties.name] = emoji.names.map(function(name) {
    return name.toLowerCase();
  }), _ref[EmojiProperties.unified] = emoji.id.toLowerCase(), _ref[EmojiProperties.added_in] = "0", _ref[EmojiProperties.imgUrl] = emoji.imgUrl, _ref;
}
var allEmojisByUnified = {};
setTimeout(function() {
  allEmojis.reduce(function(allEmojis2, Emoji) {
    allEmojis2[emojiUnified(Emoji)] = Emoji;
    if (emojiHasVariations(Emoji)) {
      emojiVariations(Emoji).forEach(function(variation) {
        allEmojis2[variation] = Emoji;
      });
    }
    return allEmojis2;
  }, allEmojisByUnified);
});
function activeVariationFromUnified(unified) {
  var _unified$split = unified.split("-"), suspectedSkinTone = _unified$split[1];
  return skinToneVariations.includes(suspectedSkinTone) ? suspectedSkinTone : null;
}
var KNOWN_FAILING_EMOJIS = ["2640-fe0f", "2642-fe0f", "2695-fe0f"];
var DEFAULT_SEARCH_PLACEHOLDER = "Search";
var SEARCH_RESULTS_NO_RESULTS_FOUND = "No results found";
var SEARCH_RESULTS_SUFFIX = " found. Use up and down arrow keys to navigate.";
var SEARCH_RESULTS_ONE_RESULT_FOUND = "1 result" + SEARCH_RESULTS_SUFFIX;
var SEARCH_RESULTS_MULTIPLE_RESULTS_FOUND = "%n results" + SEARCH_RESULTS_SUFFIX;
function mergeConfig(userConfig) {
  var _userConfig$previewCo, _config$customEmojis;
  if (userConfig === void 0) {
    userConfig = {};
  }
  var base2 = basePickerConfig();
  var previewConfig = Object.assign(base2.previewConfig, (_userConfig$previewCo = userConfig.previewConfig) != null ? _userConfig$previewCo : {});
  var config2 = Object.assign(base2, userConfig);
  var categories = mergeCategoriesConfig(userConfig.categories, {
    suggestionMode: config2.suggestedEmojisMode
  });
  config2.hiddenEmojis.forEach(function(emoji) {
    config2.unicodeToHide.add(emoji);
  });
  setCustomEmojis((_config$customEmojis = config2.customEmojis) != null ? _config$customEmojis : []);
  var skinTonePickerLocation = config2.searchDisabled ? SkinTonePickerLocation.PREVIEW : config2.skinTonePickerLocation;
  return _extends({}, config2, {
    categories,
    previewConfig,
    skinTonePickerLocation
  });
}
function basePickerConfig() {
  return {
    autoFocusSearch: true,
    categories: baseCategoriesConfig(),
    className: "",
    customEmojis: [],
    defaultSkinTone: SkinTones.NEUTRAL,
    emojiStyle: EmojiStyle.APPLE,
    emojiVersion: null,
    getEmojiUrl: emojiUrlByUnified,
    height: 450,
    lazyLoadEmojis: false,
    previewConfig: _extends({}, basePreviewConfig),
    searchDisabled: false,
    searchPlaceHolder: DEFAULT_SEARCH_PLACEHOLDER,
    searchPlaceholder: DEFAULT_SEARCH_PLACEHOLDER,
    skinTonePickerLocation: SkinTonePickerLocation.SEARCH,
    skinTonesDisabled: false,
    style: {},
    suggestedEmojisMode: SuggestionMode.FREQUENT,
    theme: Theme.LIGHT,
    unicodeToHide: new Set(KNOWN_FAILING_EMOJIS),
    width: 350,
    reactionsDefaultOpen: false,
    reactions: DEFAULT_REACTIONS,
    open: true,
    allowExpandReactions: true,
    hiddenEmojis: []
  };
}
var basePreviewConfig = {
  defaultEmoji: "1f60a",
  defaultCaption: "What's your mood?",
  showPreview: true
};
var _excluded = ["children"];
var ConfigContext = /* @__PURE__ */ createContext(/* @__PURE__ */ basePickerConfig());
function PickerConfigProvider(_ref) {
  var children = _ref.children, config2 = _objectWithoutPropertiesLoose(_ref, _excluded);
  var mergedConfig = useSetConfig(config2);
  return createElement(ConfigContext.Provider, {
    value: mergedConfig
  }, children);
}
function useSetConfig(config2) {
  var _config$customEmojis;
  var _React$useState = useState(function() {
    return mergeConfig(config2);
  }), mergedConfig = _React$useState[0], setMergedConfig = _React$useState[1];
  useEffect(function() {
    if (compareConfig(mergedConfig, config2)) {
      return;
    }
    setMergedConfig(mergeConfig(config2));
  }, [(_config$customEmojis = config2.customEmojis) == null ? void 0 : _config$customEmojis.length, config2.open, config2.emojiVersion, config2.reactionsDefaultOpen, config2.searchPlaceHolder, config2.searchPlaceholder, config2.defaultSkinTone, config2.skinTonesDisabled, config2.autoFocusSearch, config2.emojiStyle, config2.theme, config2.suggestedEmojisMode, config2.lazyLoadEmojis, config2.className, config2.height, config2.width, config2.searchDisabled, config2.skinTonePickerLocation, config2.allowExpandReactions]);
  return mergedConfig;
}
function usePickerConfig() {
  return useContext(ConfigContext);
}
var MutableConfigContext = /* @__PURE__ */ React__default.createContext({});
function useMutableConfig() {
  var mutableConfig = React__default.useContext(MutableConfigContext);
  return mutableConfig;
}
function useDefineMutableConfig(config2) {
  var MutableConfigRef = React__default.useRef({
    onEmojiClick: config2.onEmojiClick || emptyFunc,
    onReactionClick: config2.onReactionClick || config2.onEmojiClick,
    onSkinToneChange: config2.onSkinToneChange || emptyFunc
  });
  React__default.useEffect(function() {
    MutableConfigRef.current.onEmojiClick = config2.onEmojiClick || emptyFunc;
    MutableConfigRef.current.onReactionClick = config2.onReactionClick || config2.onEmojiClick;
  }, [config2.onEmojiClick, config2.onReactionClick]);
  React__default.useEffect(function() {
    MutableConfigRef.current.onSkinToneChange = config2.onSkinToneChange || emptyFunc;
  }, [config2.onSkinToneChange]);
  return MutableConfigRef;
}
function emptyFunc() {
}
var MOUSE_EVENT_SOURCE;
(function(MOUSE_EVENT_SOURCE2) {
  MOUSE_EVENT_SOURCE2["REACTIONS"] = "reactions";
  MOUSE_EVENT_SOURCE2["PICKER"] = "picker";
})(MOUSE_EVENT_SOURCE || (MOUSE_EVENT_SOURCE = {}));
function useSearchPlaceHolderConfig() {
  var _find;
  var _usePickerConfig = usePickerConfig(), searchPlaceHolder = _usePickerConfig.searchPlaceHolder, searchPlaceholder = _usePickerConfig.searchPlaceholder;
  return (_find = [searchPlaceHolder, searchPlaceholder].find(function(p2) {
    return p2 !== DEFAULT_SEARCH_PLACEHOLDER;
  })) != null ? _find : DEFAULT_SEARCH_PLACEHOLDER;
}
function useDefaultSkinToneConfig() {
  var _usePickerConfig2 = usePickerConfig(), defaultSkinTone = _usePickerConfig2.defaultSkinTone;
  return defaultSkinTone;
}
function useAllowExpandReactions() {
  var _usePickerConfig3 = usePickerConfig(), allowExpandReactions = _usePickerConfig3.allowExpandReactions;
  return allowExpandReactions;
}
function useSkinTonesDisabledConfig() {
  var _usePickerConfig4 = usePickerConfig(), skinTonesDisabled = _usePickerConfig4.skinTonesDisabled;
  return skinTonesDisabled;
}
function useEmojiStyleConfig() {
  var _usePickerConfig5 = usePickerConfig(), emojiStyle = _usePickerConfig5.emojiStyle;
  return emojiStyle;
}
function useAutoFocusSearchConfig() {
  var _usePickerConfig6 = usePickerConfig(), autoFocusSearch = _usePickerConfig6.autoFocusSearch;
  return autoFocusSearch;
}
function useCategoriesConfig() {
  var _usePickerConfig7 = usePickerConfig(), categories = _usePickerConfig7.categories;
  return categories;
}
function useCustomEmojisConfig() {
  var _usePickerConfig8 = usePickerConfig(), customEmojis = _usePickerConfig8.customEmojis;
  return customEmojis;
}
function useOpenConfig() {
  var _usePickerConfig9 = usePickerConfig(), open = _usePickerConfig9.open;
  return open;
}
function useOnEmojiClickConfig(mouseEventSource) {
  var _ref;
  var _useMutableConfig = useMutableConfig(), current = _useMutableConfig.current;
  var handler = (_ref = mouseEventSource === MOUSE_EVENT_SOURCE.REACTIONS ? current.onReactionClick : current.onEmojiClick) != null ? _ref : current.onEmojiClick;
  return handler || function() {
  };
}
function useOnSkinToneChangeConfig() {
  var _useMutableConfig2 = useMutableConfig(), current = _useMutableConfig2.current;
  return current.onSkinToneChange || function() {
  };
}
function usePreviewConfig() {
  var _usePickerConfig10 = usePickerConfig(), previewConfig = _usePickerConfig10.previewConfig;
  return previewConfig;
}
function useThemeConfig() {
  var _usePickerConfig11 = usePickerConfig(), theme = _usePickerConfig11.theme;
  return theme;
}
function useSuggestedEmojisModeConfig() {
  var _usePickerConfig12 = usePickerConfig(), suggestedEmojisMode = _usePickerConfig12.suggestedEmojisMode;
  return suggestedEmojisMode;
}
function useLazyLoadEmojisConfig() {
  var _usePickerConfig13 = usePickerConfig(), lazyLoadEmojis = _usePickerConfig13.lazyLoadEmojis;
  return lazyLoadEmojis;
}
function useClassNameConfig() {
  var _usePickerConfig14 = usePickerConfig(), className = _usePickerConfig14.className;
  return className;
}
function useStyleConfig() {
  var _usePickerConfig15 = usePickerConfig(), height2 = _usePickerConfig15.height, width2 = _usePickerConfig15.width, style2 = _usePickerConfig15.style;
  return _extends({
    height: getDimension(height2),
    width: getDimension(width2)
  }, style2);
}
function useReactionsOpenConfig() {
  var _usePickerConfig16 = usePickerConfig(), reactionsDefaultOpen = _usePickerConfig16.reactionsDefaultOpen;
  return reactionsDefaultOpen;
}
function useEmojiVersionConfig() {
  var _usePickerConfig17 = usePickerConfig(), emojiVersion = _usePickerConfig17.emojiVersion;
  return emojiVersion;
}
function useSearchDisabledConfig() {
  var _usePickerConfig18 = usePickerConfig(), searchDisabled = _usePickerConfig18.searchDisabled;
  return searchDisabled;
}
function useSkinTonePickerLocationConfig() {
  var _usePickerConfig19 = usePickerConfig(), skinTonePickerLocation = _usePickerConfig19.skinTonePickerLocation;
  return skinTonePickerLocation;
}
function useUnicodeToHide() {
  var _usePickerConfig20 = usePickerConfig(), unicodeToHide = _usePickerConfig20.unicodeToHide;
  return unicodeToHide;
}
function useReactionsConfig() {
  var _usePickerConfig21 = usePickerConfig(), reactions = _usePickerConfig21.reactions;
  return reactions;
}
function useGetEmojiUrlConfig() {
  var _usePickerConfig22 = usePickerConfig(), getEmojiUrl = _usePickerConfig22.getEmojiUrl;
  return getEmojiUrl;
}
function getDimension(dimensionConfig) {
  return typeof dimensionConfig === "number" ? dimensionConfig + "px" : dimensionConfig;
}
function useSearchResultsConfig(searchResultsCount) {
  var hasResults = searchResultsCount > 0;
  var isPlural = searchResultsCount > 1;
  if (hasResults) {
    return isPlural ? SEARCH_RESULTS_MULTIPLE_RESULTS_FOUND.replace("%n", searchResultsCount.toString()) : SEARCH_RESULTS_ONE_RESULT_FOUND;
  }
  return SEARCH_RESULTS_NO_RESULTS_FOUND;
}
function useDebouncedState(initialValue, delay) {
  if (delay === void 0) {
    delay = 0;
  }
  var _useState = useState(initialValue), state2 = _useState[0], setState = _useState[1];
  var timer = useRef(null);
  function debouncedSetState(value) {
    return new Promise(function(resolve) {
      var _window;
      if (timer.current) {
        clearTimeout(timer.current);
      }
      timer.current = (_window = window) == null ? void 0 : _window.setTimeout(function() {
        setState(value);
        resolve(value);
      }, delay);
    });
  }
  return [state2, debouncedSetState];
}
function useIsUnicodeHidden() {
  var unicodeToHide = useUnicodeToHide();
  return function(emojiUnified2) {
    return unicodeToHide.has(emojiUnified2);
  };
}
function useDisallowedEmojis() {
  var DisallowedEmojisRef = useRef({});
  var emojiVersionConfig = useEmojiVersionConfig();
  return useMemo(function() {
    var emojiVersion = parseFloat("" + emojiVersionConfig);
    if (!emojiVersionConfig || Number.isNaN(emojiVersion)) {
      return DisallowedEmojisRef.current;
    }
    return allEmojis.reduce(function(disallowedEmojis, emoji) {
      if (addedInNewerVersion(emoji, emojiVersion)) {
        disallowedEmojis[emojiUnified(emoji)] = true;
      }
      return disallowedEmojis;
    }, DisallowedEmojisRef.current);
  }, [emojiVersionConfig]);
}
function useIsEmojiDisallowed() {
  var disallowedEmojis = useDisallowedEmojis();
  var isUnicodeHidden = useIsUnicodeHidden();
  return function isEmojiDisallowed(emoji) {
    var unified = unifiedWithoutSkinTone(emojiUnified(emoji));
    return Boolean(disallowedEmojis[unified] || isUnicodeHidden(unified));
  };
}
function addedInNewerVersion(emoji, supportedLevel) {
  return addedIn(emoji) > supportedLevel;
}
function useMarkInitialLoad(dispatch) {
  useEffect(function() {
    dispatch(true);
  }, [dispatch]);
}
function PickerContextProvider(_ref) {
  var children = _ref.children;
  var disallowedEmojis = useDisallowedEmojis();
  var defaultSkinTone = useDefaultSkinToneConfig();
  var reactionsDefaultOpen = useReactionsOpenConfig();
  var filterRef = useRef(alphaNumericEmojiIndex);
  var disallowClickRef = useRef(false);
  var disallowMouseRef = useRef(false);
  var disallowedEmojisRef = useRef(disallowedEmojis);
  var suggestedUpdateState = useDebouncedState(Date.now(), 200);
  var searchTerm = useDebouncedState("", 100);
  var skinToneFanOpenState = useState(false);
  var activeSkinTone = useState(defaultSkinTone);
  var activeCategoryState = useState(null);
  var emojisThatFailedToLoadState = useState(/* @__PURE__ */ new Set());
  var emojiVariationPickerState = useState(null);
  var reactionsModeState = useState(reactionsDefaultOpen);
  var _useState = useState(false), isPastInitialLoad = _useState[0], setIsPastInitialLoad = _useState[1];
  useMarkInitialLoad(setIsPastInitialLoad);
  return createElement(PickerContext.Provider, {
    value: {
      activeCategoryState,
      activeSkinTone,
      disallowClickRef,
      disallowMouseRef,
      disallowedEmojisRef,
      emojiVariationPickerState,
      emojisThatFailedToLoadState,
      filterRef,
      isPastInitialLoad,
      searchTerm,
      skinToneFanOpenState,
      suggestedUpdateState,
      reactionsModeState
    }
  }, children);
}
var PickerContext = /* @__PURE__ */ createContext({
  activeCategoryState: [null, function() {
  }],
  activeSkinTone: [SkinTones.NEUTRAL, function() {
  }],
  disallowClickRef: {
    current: false
  },
  disallowMouseRef: {
    current: false
  },
  disallowedEmojisRef: {
    current: {}
  },
  emojiVariationPickerState: [null, function() {
  }],
  emojisThatFailedToLoadState: [/* @__PURE__ */ new Set(), function() {
  }],
  filterRef: {
    current: {}
  },
  isPastInitialLoad: true,
  searchTerm: ["", function() {
    return new Promise(function() {
      return void 0;
    });
  }],
  skinToneFanOpenState: [false, function() {
  }],
  suggestedUpdateState: [/* @__PURE__ */ Date.now(), function() {
  }],
  reactionsModeState: [false, function() {
  }]
});
function useFilterRef() {
  var _React$useContext = useContext(PickerContext), filterRef = _React$useContext.filterRef;
  return filterRef;
}
function useDisallowClickRef() {
  var _React$useContext2 = useContext(PickerContext), disallowClickRef = _React$useContext2.disallowClickRef;
  return disallowClickRef;
}
function useDisallowMouseRef() {
  var _React$useContext3 = useContext(PickerContext), disallowMouseRef = _React$useContext3.disallowMouseRef;
  return disallowMouseRef;
}
function useReactionsModeState() {
  var _React$useContext4 = useContext(PickerContext), reactionsModeState = _React$useContext4.reactionsModeState;
  return reactionsModeState;
}
function useSearchTermState() {
  var _React$useContext5 = useContext(PickerContext), searchTerm = _React$useContext5.searchTerm;
  return searchTerm;
}
function useActiveSkinToneState() {
  var _React$useContext6 = useContext(PickerContext), activeSkinTone = _React$useContext6.activeSkinTone;
  return activeSkinTone;
}
function useEmojisThatFailedToLoadState() {
  var _React$useContext7 = useContext(PickerContext), emojisThatFailedToLoadState = _React$useContext7.emojisThatFailedToLoadState;
  return emojisThatFailedToLoadState;
}
function useIsPastInitialLoad() {
  var _React$useContext8 = useContext(PickerContext), isPastInitialLoad = _React$useContext8.isPastInitialLoad;
  return isPastInitialLoad;
}
function useEmojiVariationPickerState() {
  var _React$useContext9 = useContext(PickerContext), emojiVariationPickerState = _React$useContext9.emojiVariationPickerState;
  return emojiVariationPickerState;
}
function useSkinToneFanOpenState() {
  var _React$useContext10 = useContext(PickerContext), skinToneFanOpenState = _React$useContext10.skinToneFanOpenState;
  return skinToneFanOpenState;
}
function useUpdateSuggested() {
  var _React$useContext12 = useContext(PickerContext), suggestedUpdateState = _React$useContext12.suggestedUpdateState;
  var suggestedUpdated = suggestedUpdateState[0], setsuggestedUpdate = suggestedUpdateState[1];
  return [suggestedUpdated, function updateSuggested() {
    setsuggestedUpdate(Date.now());
  }];
}
function useIsSearchMode() {
  var _useSearchTermState = useSearchTermState(), searchTerm = _useSearchTermState[0];
  return !!searchTerm;
}
function focusElement(element) {
  if (!element) {
    return;
  }
  requestAnimationFrame(function() {
    element.focus();
  });
}
function focusPrevElementSibling(element) {
  if (!element) return;
  var prev2 = element.previousElementSibling;
  focusElement(prev2);
}
function focusNextElementSibling(element) {
  if (!element) return;
  var next2 = element.nextElementSibling;
  focusElement(next2);
}
function focusFirstElementChild(element) {
  if (!element) return;
  var first = element.firstElementChild;
  focusElement(first);
}
function getActiveElement() {
  return document.activeElement;
}
function ElementRefContextProvider(_ref) {
  var children = _ref.children;
  var PickerMainRef = useRef(null);
  var AnchoredEmojiRef = useRef(null);
  var BodyRef = useRef(null);
  var SearchInputRef = useRef(null);
  var SkinTonePickerRef = useRef(null);
  var CategoryNavigationRef = useRef(null);
  var VariationPickerRef = useRef(null);
  var ReactionsRef = useRef(null);
  return createElement(ElementRefContext.Provider, {
    value: {
      AnchoredEmojiRef,
      BodyRef,
      CategoryNavigationRef,
      PickerMainRef,
      SearchInputRef,
      SkinTonePickerRef,
      VariationPickerRef,
      ReactionsRef
    }
  }, children);
}
var ElementRefContext = /* @__PURE__ */ createContext({
  AnchoredEmojiRef: /* @__PURE__ */ createRef(),
  BodyRef: /* @__PURE__ */ createRef(),
  CategoryNavigationRef: /* @__PURE__ */ createRef(),
  PickerMainRef: /* @__PURE__ */ createRef(),
  SearchInputRef: /* @__PURE__ */ createRef(),
  SkinTonePickerRef: /* @__PURE__ */ createRef(),
  VariationPickerRef: /* @__PURE__ */ createRef(),
  ReactionsRef: /* @__PURE__ */ createRef()
});
function useElementRef() {
  return useContext(ElementRefContext);
}
function usePickerMainRef() {
  return useElementRef()["PickerMainRef"];
}
function useAnchoredEmojiRef() {
  return useElementRef()["AnchoredEmojiRef"];
}
function useSetAnchoredEmojiRef() {
  var AnchoredEmojiRef = useAnchoredEmojiRef();
  return function(target) {
    if (target === null && AnchoredEmojiRef.current !== null) {
      focusElement(AnchoredEmojiRef.current);
    }
    AnchoredEmojiRef.current = target;
  };
}
function useBodyRef() {
  return useElementRef()["BodyRef"];
}
function useReactionsRef() {
  return useElementRef()["ReactionsRef"];
}
function useSearchInputRef() {
  return useElementRef()["SearchInputRef"];
}
function useSkinTonePickerRef() {
  return useElementRef()["SkinTonePickerRef"];
}
function useCategoryNavigationRef() {
  return useElementRef()["CategoryNavigationRef"];
}
function useVariationPickerRef() {
  return useElementRef()["VariationPickerRef"];
}
function scrollTo(root, top) {
  if (top === void 0) {
    top = 0;
  }
  var $eprBody = queryScrollBody(root);
  if (!$eprBody) {
    return;
  }
  requestAnimationFrame(function() {
    $eprBody.scrollTop = top;
  });
}
function scrollBy(root, by) {
  var $eprBody = queryScrollBody(root);
  if (!$eprBody) {
    return;
  }
  requestAnimationFrame(function() {
    $eprBody.scrollTop = $eprBody.scrollTop + by;
  });
}
function useScrollTo() {
  var BodyRef = useBodyRef();
  return useCallback(function(top) {
    requestAnimationFrame(function() {
      if (BodyRef.current) {
        BodyRef.current.scrollTop = top;
      }
    });
  }, [BodyRef]);
}
function scrollEmojiAboveLabel(emoji) {
  if (!emoji || !isEmojiBehindLabel(emoji)) {
    return;
  }
  if (emoji.closest(asSelectors(ClassNames.variationPicker))) {
    return;
  }
  var scrollBody = closestScrollBody(emoji);
  var by = emojiDistanceFromScrollTop(emoji);
  scrollBy(scrollBody, -(categoryLabelHeight(closestCategory(emoji)) - by));
}
function focusFirstVisibleEmoji(parent) {
  var emoji = firstVisibleEmoji(parent);
  focusElement(emoji);
  scrollEmojiAboveLabel(emoji);
}
function focusAndClickFirstVisibleEmoji(parent) {
  var firstEmoji = firstVisibleEmoji(parent);
  focusElement(firstEmoji);
  firstEmoji == null ? void 0 : firstEmoji.click();
}
function focusLastVisibleEmoji(parent) {
  focusElement(lastVisibleEmoji(parent));
}
function focusNextVisibleEmoji(element) {
  if (!element) {
    return;
  }
  var next2 = nextVisibleEmoji(element);
  if (!next2) {
    return focusFirstVisibleEmoji(nextCategory(element));
  }
  focusElement(next2);
  scrollEmojiAboveLabel(next2);
}
function focusPrevVisibleEmoji(element) {
  if (!element) {
    return;
  }
  var prev2 = prevVisibleEmoji(element);
  if (!prev2) {
    return focusLastVisibleEmoji(prevCategory(element));
  }
  focusElement(prev2);
  scrollEmojiAboveLabel(prev2);
}
function focusVisibleEmojiOneRowUp(element, exitUp) {
  if (!element) {
    return;
  }
  var prev2 = visibleEmojiOneRowUp(element);
  if (!prev2) {
    return exitUp();
  }
  focusElement(prev2);
  scrollEmojiAboveLabel(prev2);
}
function focusVisibleEmojiOneRowDown(element) {
  if (!element) {
    return;
  }
  var next2 = visibleEmojiOneRowDown(element);
  return focusElement(next2);
}
function visibleEmojiOneRowUp(element) {
  if (!element) {
    return null;
  }
  var categoryContent = closestCategoryContent(element);
  var category = closestCategory(categoryContent);
  var indexInRow = elementIndexInRow(categoryContent, element);
  var row = rowNumber(categoryContent, element);
  var countInRow = elementCountInRow(categoryContent, element);
  if (row === 0) {
    var prevVisibleCategory = prevCategory(category);
    if (!prevVisibleCategory) {
      return null;
    }
    return getElementInRow(
      allVisibleEmojis(prevVisibleCategory),
      -1,
      // last row
      countInRow,
      indexInRow
    );
  }
  return getElementInPrevRow(allVisibleEmojis(categoryContent), row, countInRow, indexInRow);
}
function visibleEmojiOneRowDown(element) {
  if (!element) {
    return null;
  }
  var categoryContent = closestCategoryContent(element);
  var category = closestCategory(categoryContent);
  var indexInRow = elementIndexInRow(categoryContent, element);
  var row = rowNumber(categoryContent, element);
  var countInRow = elementCountInRow(categoryContent, element);
  if (!hasNextRow(categoryContent, element)) {
    var nextVisibleCategory = nextCategory(category);
    if (!nextVisibleCategory) {
      return null;
    }
    return getElementInRow(allVisibleEmojis(nextVisibleCategory), 0, countInRow, indexInRow);
  }
  var itemInNextRow = getElementInNextRow(allVisibleEmojis(categoryContent), row, countInRow, indexInRow);
  return itemInNextRow;
}
function useCloseAllOpenToggles() {
  var _useEmojiVariationPic = useEmojiVariationPickerState(), variationPicker = _useEmojiVariationPic[0], setVariationPicker = _useEmojiVariationPic[1];
  var _useSkinToneFanOpenSt = useSkinToneFanOpenState(), skinToneFanOpen = _useSkinToneFanOpenSt[0], setSkinToneFanOpen = _useSkinToneFanOpenSt[1];
  var closeAllOpenToggles = useCallback(function() {
    if (variationPicker) {
      setVariationPicker(null);
    }
    if (skinToneFanOpen) {
      setSkinToneFanOpen(false);
    }
  }, [variationPicker, skinToneFanOpen, setVariationPicker, setSkinToneFanOpen]);
  return closeAllOpenToggles;
}
function useHasOpenToggles() {
  var _useEmojiVariationPic2 = useEmojiVariationPickerState(), variationPicker = _useEmojiVariationPic2[0];
  var _useSkinToneFanOpenSt2 = useSkinToneFanOpenState(), skinToneFanOpen = _useSkinToneFanOpenSt2[0];
  return function hasOpenToggles() {
    return !!variationPicker || skinToneFanOpen;
  };
}
function useDisallowMouseMove() {
  var DisallowMouseRef = useDisallowMouseRef();
  return function disallowMouseMove() {
    DisallowMouseRef.current = true;
  };
}
function useAllowMouseMove() {
  var DisallowMouseRef = useDisallowMouseRef();
  return function allowMouseMove() {
    DisallowMouseRef.current = false;
  };
}
function useIsMouseDisallowed() {
  var DisallowMouseRef = useDisallowMouseRef();
  return function isMouseDisallowed() {
    return DisallowMouseRef.current;
  };
}
function useOnMouseMove() {
  var BodyRef = useBodyRef();
  var allowMouseMove = useAllowMouseMove();
  var isMouseDisallowed = useIsMouseDisallowed();
  useEffect(function() {
    var bodyRef = BodyRef.current;
    bodyRef == null ? void 0 : bodyRef.addEventListener("mousemove", onMouseMove, {
      passive: true
    });
    function onMouseMove() {
      if (isMouseDisallowed()) {
        allowMouseMove();
      }
    }
    return function() {
      bodyRef == null ? void 0 : bodyRef.removeEventListener("mousemove", onMouseMove);
    };
  }, [BodyRef, allowMouseMove, isMouseDisallowed]);
}
function useFocusSearchInput() {
  var SearchInputRef = useSearchInputRef();
  return useCallback(function() {
    focusElement(SearchInputRef.current);
  }, [SearchInputRef]);
}
function useFocusSkinTonePicker() {
  var SkinTonePickerRef = useSkinTonePickerRef();
  return useCallback(function() {
    if (!SkinTonePickerRef.current) {
      return;
    }
    focusFirstElementChild(SkinTonePickerRef.current);
  }, [SkinTonePickerRef]);
}
function useFocusCategoryNavigation() {
  var CategoryNavigationRef = useCategoryNavigationRef();
  return useCallback(function() {
    if (!CategoryNavigationRef.current) {
      return;
    }
    focusFirstElementChild(CategoryNavigationRef.current);
  }, [CategoryNavigationRef]);
}
function useSetFilterRef() {
  var filterRef = useFilterRef();
  return function setFilter(setter) {
    if (typeof setter === "function") {
      return setFilter(setter(filterRef.current));
    }
    filterRef.current = setter;
  };
}
function useClearSearch() {
  var applySearch = useApplySearch();
  var SearchInputRef = useSearchInputRef();
  var focusSearchInput = useFocusSearchInput();
  return function clearSearch() {
    if (SearchInputRef.current) {
      SearchInputRef.current.value = "";
    }
    applySearch("");
    focusSearchInput();
  };
}
function useAppendSearch() {
  var SearchInputRef = useSearchInputRef();
  var applySearch = useApplySearch();
  return function appendSearch(str) {
    if (SearchInputRef.current) {
      SearchInputRef.current.value = "" + SearchInputRef.current.value + str;
      applySearch(getNormalizedSearchTerm(SearchInputRef.current.value));
    } else {
      applySearch(getNormalizedSearchTerm(str));
    }
  };
}
function useFilter() {
  var SearchInputRef = useSearchInputRef();
  var filterRef = useFilterRef();
  var setFilterRef = useSetFilterRef();
  var applySearch = useApplySearch();
  var _useSearchTermState = useSearchTermState(), searchTerm = _useSearchTermState[0];
  var statusSearchResults = getStatusSearchResults(filterRef.current, searchTerm);
  return {
    onChange,
    searchTerm,
    SearchInputRef,
    statusSearchResults
  };
  function onChange(inputValue) {
    var filter = filterRef.current;
    var nextValue = inputValue.toLowerCase();
    if (filter != null && filter[nextValue] || nextValue.length <= 1) {
      return applySearch(nextValue);
    }
    var longestMatch = findLongestMatch(nextValue, filter);
    if (!longestMatch) {
      return applySearch(nextValue);
    }
    setFilterRef(function(current) {
      var _Object$assign;
      return Object.assign(current, (_Object$assign = {}, _Object$assign[nextValue] = filterEmojiObjectByKeyword(longestMatch, nextValue), _Object$assign));
    });
    applySearch(nextValue);
  }
}
function useApplySearch() {
  var _useSearchTermState2 = useSearchTermState(), setSearchTerm = _useSearchTermState2[1];
  var PickerMainRef = usePickerMainRef();
  return function applySearch(searchTerm) {
    requestAnimationFrame(function() {
      setSearchTerm(searchTerm ? searchTerm == null ? void 0 : searchTerm.toLowerCase() : searchTerm).then(function() {
        scrollTo(PickerMainRef.current, 0);
      });
    });
  };
}
function filterEmojiObjectByKeyword(emojis2, keyword) {
  var filtered = {};
  for (var unified in emojis2) {
    var emoji = emojis2[unified];
    if (hasMatch(emoji, keyword)) {
      filtered[unified] = emoji;
    }
  }
  return filtered;
}
function hasMatch(emoji, keyword) {
  return emojiNames(emoji).some(function(name) {
    return name.includes(keyword);
  });
}
function useIsEmojiFiltered() {
  var _useFilterRef = useFilterRef(), filter = _useFilterRef.current;
  var _useSearchTermState3 = useSearchTermState(), searchTerm = _useSearchTermState3[0];
  return function(unified) {
    return isEmojiFilteredBySearchTerm(unified, filter, searchTerm);
  };
}
function isEmojiFilteredBySearchTerm(unified, filter, searchTerm) {
  var _filter$searchTerm;
  if (!filter || !searchTerm) {
    return false;
  }
  return !((_filter$searchTerm = filter[searchTerm]) != null && _filter$searchTerm[unified]);
}
function findLongestMatch(keyword, dict) {
  if (!dict) {
    return null;
  }
  if (dict[keyword]) {
    return dict[keyword];
  }
  var longestMatchingKey = Object.keys(dict).sort(function(a, b) {
    return b.length - a.length;
  }).find(function(key) {
    return keyword.includes(key);
  });
  if (longestMatchingKey) {
    return dict[longestMatchingKey];
  }
  return null;
}
function getNormalizedSearchTerm(str) {
  if (!str || typeof str !== "string") {
    return "";
  }
  return str.trim().toLowerCase();
}
function getStatusSearchResults(filterState, searchTerm) {
  var _Object$entries;
  if (!(filterState != null && filterState[searchTerm])) return "";
  var searchResultsCount = ((_Object$entries = Object.entries(filterState == null ? void 0 : filterState[searchTerm])) == null ? void 0 : _Object$entries.length) || 0;
  return useSearchResultsConfig(searchResultsCount);
}
function useSetVariationPicker() {
  var setAnchoredEmojiRef = useSetAnchoredEmojiRef();
  var _useEmojiVariationPic = useEmojiVariationPickerState(), setEmojiVariationPicker = _useEmojiVariationPic[1];
  return function setVariationPicker(element) {
    var _emojiFromElement = emojiFromElement(element), emoji = _emojiFromElement[0];
    if (emoji) {
      setAnchoredEmojiRef(element);
      setEmojiVariationPicker(emoji);
    }
  };
}
function useIsSkinToneInSearch() {
  var skinTonePickerLocationConfig = useSkinTonePickerLocationConfig();
  return skinTonePickerLocationConfig === SkinTonePickerLocation.SEARCH;
}
function useIsSkinToneInPreview() {
  var skinTonePickerLocationConfig = useSkinTonePickerLocationConfig();
  return skinTonePickerLocationConfig === SkinTonePickerLocation.PREVIEW;
}
var KeyboardEvents;
(function(KeyboardEvents2) {
  KeyboardEvents2["ArrowDown"] = "ArrowDown";
  KeyboardEvents2["ArrowUp"] = "ArrowUp";
  KeyboardEvents2["ArrowLeft"] = "ArrowLeft";
  KeyboardEvents2["ArrowRight"] = "ArrowRight";
  KeyboardEvents2["Escape"] = "Escape";
  KeyboardEvents2["Enter"] = "Enter";
  KeyboardEvents2["Space"] = " ";
})(KeyboardEvents || (KeyboardEvents = {}));
function useKeyboardNavigation() {
  usePickerMainKeyboardEvents();
  useSearchInputKeyboardEvents();
  useSkinTonePickerKeyboardEvents();
  useCategoryNavigationKeyboardEvents();
  useBodyKeyboardEvents();
}
function usePickerMainKeyboardEvents() {
  var PickerMainRef = usePickerMainRef();
  var clearSearch = useClearSearch();
  var scrollTo2 = useScrollTo();
  var SearchInputRef = useSearchInputRef();
  var focusSearchInput = useFocusSearchInput();
  var hasOpenToggles = useHasOpenToggles();
  var disallowMouseMove = useDisallowMouseMove();
  var closeAllOpenToggles = useCloseAllOpenToggles();
  var onKeyDown = useMemo(function() {
    return function onKeyDown2(event) {
      var key = event.key;
      disallowMouseMove();
      switch (key) {
        // eslint-disable-next-line no-fallthrough
        case KeyboardEvents.Escape:
          event.preventDefault();
          if (hasOpenToggles()) {
            closeAllOpenToggles();
            return;
          }
          clearSearch();
          scrollTo2(0);
          focusSearchInput();
          break;
      }
    };
  }, [scrollTo2, clearSearch, closeAllOpenToggles, focusSearchInput, hasOpenToggles, disallowMouseMove]);
  useEffect(function() {
    var current = PickerMainRef.current;
    if (!current) {
      return;
    }
    current.addEventListener("keydown", onKeyDown);
    return function() {
      current.removeEventListener("keydown", onKeyDown);
    };
  }, [PickerMainRef, SearchInputRef, scrollTo2, onKeyDown]);
}
function useSearchInputKeyboardEvents() {
  var focusSkinTonePicker = useFocusSkinTonePicker();
  var PickerMainRef = usePickerMainRef();
  var BodyRef = useBodyRef();
  var SearchInputRef = useSearchInputRef();
  var _useSkinToneFanOpenSt = useSkinToneFanOpenState(), setSkinToneFanOpenState = _useSkinToneFanOpenSt[1];
  var goDownFromSearchInput = useGoDownFromSearchInput();
  var isSkinToneInSearch = useIsSkinToneInSearch();
  var onKeyDown = useMemo(function() {
    return function onKeyDown2(event) {
      var key = event.key;
      switch (key) {
        case KeyboardEvents.ArrowRight:
          if (!isSkinToneInSearch) {
            return;
          }
          event.preventDefault();
          setSkinToneFanOpenState(true);
          focusSkinTonePicker();
          break;
        case KeyboardEvents.ArrowDown:
          event.preventDefault();
          goDownFromSearchInput();
          break;
        case KeyboardEvents.Enter:
          event.preventDefault();
          focusAndClickFirstVisibleEmoji(BodyRef.current);
          break;
      }
    };
  }, [focusSkinTonePicker, goDownFromSearchInput, setSkinToneFanOpenState, BodyRef, isSkinToneInSearch]);
  useEffect(function() {
    var current = SearchInputRef.current;
    if (!current) {
      return;
    }
    current.addEventListener("keydown", onKeyDown);
    return function() {
      current.removeEventListener("keydown", onKeyDown);
    };
  }, [PickerMainRef, SearchInputRef, onKeyDown]);
}
function useSkinTonePickerKeyboardEvents() {
  var SkinTonePickerRef = useSkinTonePickerRef();
  var focusSearchInput = useFocusSearchInput();
  var SearchInputRef = useSearchInputRef();
  var goDownFromSearchInput = useGoDownFromSearchInput();
  var _useSkinToneFanOpenSt2 = useSkinToneFanOpenState(), isOpen = _useSkinToneFanOpenSt2[0], setIsOpen = _useSkinToneFanOpenSt2[1];
  var isSkinToneInPreview = useIsSkinToneInPreview();
  var isSkinToneInSearch = useIsSkinToneInSearch();
  var onType = useOnType();
  var onKeyDown = useMemo(function() {
    return (
      // eslint-disable-next-line complexity
      function onKeyDown2(event) {
        var key = event.key;
        if (isSkinToneInSearch) {
          switch (key) {
            case KeyboardEvents.ArrowLeft:
              event.preventDefault();
              if (!isOpen) {
                return focusSearchInput();
              }
              focusNextSkinTone(focusSearchInput);
              break;
            case KeyboardEvents.ArrowRight:
              event.preventDefault();
              if (!isOpen) {
                return focusSearchInput();
              }
              focusPrevSkinTone();
              break;
            case KeyboardEvents.ArrowDown:
              event.preventDefault();
              if (isOpen) {
                setIsOpen(false);
              }
              goDownFromSearchInput();
              break;
            default:
              onType(event);
              break;
          }
        }
        if (isSkinToneInPreview) {
          switch (key) {
            case KeyboardEvents.ArrowUp:
              event.preventDefault();
              if (!isOpen) {
                return focusSearchInput();
              }
              focusNextSkinTone(focusSearchInput);
              break;
            case KeyboardEvents.ArrowDown:
              event.preventDefault();
              if (!isOpen) {
                return focusSearchInput();
              }
              focusPrevSkinTone();
              break;
            default:
              onType(event);
              break;
          }
        }
      }
    );
  }, [isOpen, focusSearchInput, setIsOpen, goDownFromSearchInput, onType, isSkinToneInPreview, isSkinToneInSearch]);
  useEffect(function() {
    var current = SkinTonePickerRef.current;
    if (!current) {
      return;
    }
    current.addEventListener("keydown", onKeyDown);
    return function() {
      current.removeEventListener("keydown", onKeyDown);
    };
  }, [SkinTonePickerRef, SearchInputRef, isOpen, onKeyDown]);
}
function useCategoryNavigationKeyboardEvents() {
  var focusSearchInput = useFocusSearchInput();
  var CategoryNavigationRef = useCategoryNavigationRef();
  var BodyRef = useBodyRef();
  var onType = useOnType();
  var onKeyDown = useMemo(function() {
    return function onKeyDown2(event) {
      var key = event.key;
      switch (key) {
        case KeyboardEvents.ArrowUp:
          event.preventDefault();
          focusSearchInput();
          break;
        case KeyboardEvents.ArrowRight:
          event.preventDefault();
          focusNextElementSibling(getActiveElement());
          break;
        case KeyboardEvents.ArrowLeft:
          event.preventDefault();
          focusPrevElementSibling(getActiveElement());
          break;
        case KeyboardEvents.ArrowDown:
          event.preventDefault();
          focusFirstVisibleEmoji(BodyRef.current);
          break;
        default:
          onType(event);
          break;
      }
    };
  }, [BodyRef, focusSearchInput, onType]);
  useEffect(function() {
    var current = CategoryNavigationRef.current;
    if (!current) {
      return;
    }
    current.addEventListener("keydown", onKeyDown);
    return function() {
      current.removeEventListener("keydown", onKeyDown);
    };
  }, [CategoryNavigationRef, BodyRef, onKeyDown]);
}
function useBodyKeyboardEvents() {
  var BodyRef = useBodyRef();
  var goUpFromBody = useGoUpFromBody();
  var setVariationPicker = useSetVariationPicker();
  var hasOpenToggles = useHasOpenToggles();
  var closeAllOpenToggles = useCloseAllOpenToggles();
  var onType = useOnType();
  var onKeyDown = useMemo(function() {
    return (
      // eslint-disable-next-line complexity
      function onKeyDown2(event) {
        var key = event.key;
        var activeElement = buttonFromTarget(getActiveElement());
        switch (key) {
          case KeyboardEvents.ArrowRight:
            event.preventDefault();
            focusNextVisibleEmoji(activeElement);
            break;
          case KeyboardEvents.ArrowLeft:
            event.preventDefault();
            focusPrevVisibleEmoji(activeElement);
            break;
          case KeyboardEvents.ArrowDown:
            event.preventDefault();
            if (hasOpenToggles()) {
              closeAllOpenToggles();
              break;
            }
            focusVisibleEmojiOneRowDown(activeElement);
            break;
          case KeyboardEvents.ArrowUp:
            event.preventDefault();
            if (hasOpenToggles()) {
              closeAllOpenToggles();
              break;
            }
            focusVisibleEmojiOneRowUp(activeElement, goUpFromBody);
            break;
          case KeyboardEvents.Space:
            event.preventDefault();
            setVariationPicker(event.target);
            break;
          default:
            onType(event);
            break;
        }
      }
    );
  }, [goUpFromBody, onType, setVariationPicker, hasOpenToggles, closeAllOpenToggles]);
  useEffect(function() {
    var current = BodyRef.current;
    if (!current) {
      return;
    }
    current.addEventListener("keydown", onKeyDown);
    return function() {
      current.removeEventListener("keydown", onKeyDown);
    };
  }, [BodyRef, onKeyDown]);
}
function useGoDownFromSearchInput() {
  var focusCategoryNavigation = useFocusCategoryNavigation();
  var isSearchMode = useIsSearchMode();
  var BodyRef = useBodyRef();
  return useCallback(function goDownFromSearchInput() {
    if (isSearchMode) {
      return focusFirstVisibleEmoji(BodyRef.current);
    }
    return focusCategoryNavigation();
  }, [BodyRef, focusCategoryNavigation, isSearchMode]);
}
function useGoUpFromBody() {
  var focusSearchInput = useFocusSearchInput();
  var focusCategoryNavigation = useFocusCategoryNavigation();
  var isSearchMode = useIsSearchMode();
  return useCallback(function goUpFromEmoji() {
    if (isSearchMode) {
      return focusSearchInput();
    }
    return focusCategoryNavigation();
  }, [focusSearchInput, isSearchMode, focusCategoryNavigation]);
}
function focusNextSkinTone(exitLeft) {
  var currentSkinTone = getActiveElement();
  if (!currentSkinTone) {
    return;
  }
  if (!hasNextElementSibling(currentSkinTone)) {
    exitLeft();
  }
  focusNextElementSibling(currentSkinTone);
}
function focusPrevSkinTone() {
  var currentSkinTone = getActiveElement();
  if (!currentSkinTone) {
    return;
  }
  focusPrevElementSibling(currentSkinTone);
}
function useOnType() {
  var appendSearch = useAppendSearch();
  var focusSearchInput = useFocusSearchInput();
  var searchDisabled = useSearchDisabledConfig();
  var closeAllOpenToggles = useCloseAllOpenToggles();
  return function onType(event) {
    var key = event.key;
    if (hasModifier(event) || searchDisabled) {
      return;
    }
    if (key.match(/(^[a-zA-Z0-9]$){1}/)) {
      event.preventDefault();
      closeAllOpenToggles();
      focusSearchInput();
      appendSearch(key);
    }
  };
}
function hasModifier(event) {
  var metaKey = event.metaKey, ctrlKey = event.ctrlKey, altKey = event.altKey;
  return metaKey || ctrlKey || altKey;
}
function preloadEmoji(getEmojiUrl, emoji, emojiStyle) {
  if (!emoji) {
    return;
  }
  if (emojiStyle === EmojiStyle.NATIVE) {
    return;
  }
  var unified = emojiUnified(emoji);
  if (preloadedEmojs.has(unified)) {
    return;
  }
  emojiVariations(emoji).forEach(function(variation) {
    var emojiUrl = getEmojiUrl(variation, emojiStyle);
    preloadImage(emojiUrl);
  });
  preloadedEmojs.add(unified);
}
var preloadedEmojs = /* @__PURE__ */ new Set();
function preloadImage(url) {
  var image2 = new Image();
  image2.src = url;
}
function useOnFocus() {
  var BodyRef = useBodyRef();
  var emojiStyle = useEmojiStyleConfig();
  var getEmojiUrl = useGetEmojiUrlConfig();
  useEffect(function() {
    if (emojiStyle === EmojiStyle.NATIVE) {
      return;
    }
    var bodyRef = BodyRef.current;
    bodyRef == null ? void 0 : bodyRef.addEventListener("focusin", onFocus);
    return function() {
      bodyRef == null ? void 0 : bodyRef.removeEventListener("focusin", onFocus);
    };
    function onFocus(event) {
      var button = buttonFromTarget(event.target);
      if (!button) {
        return;
      }
      var _emojiFromElement = emojiFromElement(button), emoji = _emojiFromElement[0];
      if (!emoji) {
        return;
      }
      if (emojiHasVariations(emoji)) {
        preloadEmoji(getEmojiUrl, emoji, emojiStyle);
      }
    }
  }, [BodyRef, emojiStyle, getEmojiUrl]);
}
var _excluded$1 = ["width", "height"];
var DEFAULT_LABEL_HEIGHT = 40;
function PickerMain(_ref) {
  var children = _ref.children;
  return createElement(PickerContextProvider, null, createElement(PickerRootElement, null, children));
}
function PickerRootElement(_ref2) {
  var _cx;
  var children = _ref2.children;
  var _useReactionsModeStat = useReactionsModeState(), reactionsMode = _useReactionsModeStat[0];
  var theme = useThemeConfig();
  var searchModeActive = useIsSearchMode();
  var PickerMainRef = usePickerMainRef();
  var className = useClassNameConfig();
  var style2 = useStyleConfig();
  useKeyboardNavigation();
  useOnFocus();
  var _ref3 = style2 || {}, width2 = _ref3.width, height2 = _ref3.height, styleProps = _objectWithoutPropertiesLoose(_ref3, _excluded$1);
  return createElement("aside", {
    className: cx(styles.main, styles.baseVariables, theme === Theme.DARK && styles.darkTheme, theme === Theme.AUTO && styles.autoThemeDark, (_cx = {}, _cx[ClassNames.searchActive] = searchModeActive, _cx), reactionsMode && styles.reactionsMenu, className),
    ref: PickerMainRef,
    style: _extends({}, styleProps, !reactionsMode && {
      height: height2,
      width: width2
    })
  }, children);
}
var DarkTheme = {
  "--epr-emoji-variation-picker-bg-color": "var(--epr-dark-emoji-variation-picker-bg-color)",
  "--epr-hover-bg-color-reduced-opacity": "var(--epr-dark-hover-bg-color-reduced-opacity)",
  "--epr-highlight-color": "var(--epr-dark-highlight-color)",
  "--epr-text-color": "var(--epr-dark-text-color)",
  "--epr-hover-bg-color": "var(--epr-dark-hover-bg-color)",
  "--epr-focus-bg-color": "var(--epr-dark-focus-bg-color)",
  "--epr-search-input-bg-color": "var(--epr-dark-search-input-bg-color)",
  "--epr-category-label-bg-color": "var(--epr-dark-category-label-bg-color)",
  "--epr-picker-border-color": "var(--epr-dark-picker-border-color)",
  "--epr-bg-color": "var(--epr-dark-bg-color)",
  "--epr-reactions-bg-color": "var(--epr-dark-reactions-bg-color)",
  "--epr-search-input-bg-color-active": "var(--epr-dark-search-input-bg-color-active)",
  "--epr-emoji-variation-indicator-color": "var(--epr-dark-emoji-variation-indicator-color)",
  "--epr-category-icon-active-color": "var(--epr-dark-category-icon-active-color)",
  "--epr-skin-tone-picker-menu-color": "var(--epr-dark-skin-tone-picker-menu-color)"
};
var styles = /* @__PURE__ */ stylesheet.create({
  main: {
    ".": ["epr-main", ClassNames.emojiPicker],
    position: "relative",
    display: "flex",
    flexDirection: "column",
    borderWidth: "1px",
    borderStyle: "solid",
    borderRadius: "var(--epr-picker-border-radius)",
    borderColor: "var(--epr-picker-border-color)",
    backgroundColor: "var(--epr-bg-color)",
    overflow: "hidden",
    transition: "all 0.3s ease-in-out, background-color 0.1s ease-in-out",
    "*": {
      boxSizing: "border-box",
      fontFamily: "sans-serif"
    }
  },
  baseVariables: {
    "--": {
      "--epr-highlight-color": "#007aeb",
      "--epr-hover-bg-color": "#f1f8ff",
      "--epr-hover-bg-color-reduced-opacity": "#f1f8ff80",
      "--epr-focus-bg-color": "#e0f0ff",
      "--epr-text-color": "#858585",
      "--epr-search-input-bg-color": "#f6f6f6",
      "--epr-picker-border-color": "#e7e7e7",
      "--epr-bg-color": "#fff",
      "--epr-reactions-bg-color": "#ffffff90",
      "--epr-category-icon-active-color": "#6aa8de",
      "--epr-skin-tone-picker-menu-color": "#ffffff95",
      "--epr-horizontal-padding": "10px",
      "--epr-picker-border-radius": "8px",
      /* Header */
      "--epr-search-border-color": "var(--epr-highlight-color)",
      "--epr-header-padding": "15px var(--epr-horizontal-padding)",
      /* Skin Tone Picker */
      "--epr-active-skin-tone-indicator-border-color": "var(--epr-highlight-color)",
      "--epr-active-skin-hover-color": "var(--epr-hover-bg-color)",
      /* Search */
      "--epr-search-input-bg-color-active": "var(--epr-search-input-bg-color)",
      "--epr-search-input-padding": "0 30px",
      "--epr-search-input-border-radius": "8px",
      "--epr-search-input-height": "40px",
      "--epr-search-input-text-color": "var(--epr-text-color)",
      "--epr-search-input-placeholder-color": "var(--epr-text-color)",
      "--epr-search-bar-inner-padding": "var(--epr-horizontal-padding)",
      /*  Category Navigation */
      "--epr-category-navigation-button-size": "30px",
      /* Variation Picker */
      "--epr-emoji-variation-picker-height": "45px",
      "--epr-emoji-variation-picker-bg-color": "var(--epr-bg-color)",
      /*  Preview */
      "--epr-preview-height": "70px",
      "--epr-preview-text-size": "14px",
      "--epr-preview-text-padding": "0 var(--epr-horizontal-padding)",
      "--epr-preview-border-color": "var(--epr-picker-border-color)",
      "--epr-preview-text-color": "var(--epr-text-color)",
      /* Category */
      "--epr-category-padding": "0 var(--epr-horizontal-padding)",
      /*  Category Label */
      "--epr-category-label-bg-color": "#ffffffe6",
      "--epr-category-label-text-color": "var(--epr-text-color)",
      "--epr-category-label-padding": "0 var(--epr-horizontal-padding)",
      "--epr-category-label-height": DEFAULT_LABEL_HEIGHT + "px",
      /*  Emoji */
      "--epr-emoji-size": "30px",
      "--epr-emoji-padding": "5px",
      "--epr-emoji-fullsize": "calc(var(--epr-emoji-size) + var(--epr-emoji-padding) * 2)",
      "--epr-emoji-hover-color": "var(--epr-hover-bg-color)",
      "--epr-emoji-variation-indicator-color": "var(--epr-picker-border-color)",
      "--epr-emoji-variation-indicator-color-hover": "var(--epr-text-color)",
      /* Z-Index */
      "--epr-header-overlay-z-index": "3",
      "--epr-emoji-variations-indictator-z-index": "1",
      "--epr-category-label-z-index": "2",
      "--epr-skin-variation-picker-z-index": "5",
      "--epr-preview-z-index": "6",
      /* Dark Theme Variables */
      "--epr-dark": "#000",
      "--epr-dark-emoji-variation-picker-bg-color": "var(--epr-dark)",
      "--epr-dark-highlight-color": "#c0c0c0",
      "--epr-dark-text-color": "var(--epr-highlight-color)",
      "--epr-dark-hover-bg-color": "#363636f6",
      "--epr-dark-hover-bg-color-reduced-opacity": "#36363680",
      "--epr-dark-focus-bg-color": "#474747",
      "--epr-dark-search-input-bg-color": "#333333",
      "--epr-dark-category-label-bg-color": "#222222e6",
      "--epr-dark-picker-border-color": "#151617",
      "--epr-dark-bg-color": "#222222",
      "--epr-dark-reactions-bg-color": "#22222290",
      "--epr-dark-search-input-bg-color-active": "var(--epr-dark)",
      "--epr-dark-emoji-variation-indicator-color": "#444",
      "--epr-dark-category-icon-active-color": "#3271b7",
      "--epr-dark-skin-tone-picker-menu-color": "#22222295"
    }
  },
  autoThemeDark: {
    ".": ClassNames.autoTheme,
    "@media (prefers-color-scheme: dark)": {
      "--": DarkTheme
    }
  },
  darkTheme: {
    ".": ClassNames.darkTheme,
    "--": DarkTheme
  },
  reactionsMenu: {
    ".": "epr-reactions",
    height: "50px",
    display: "inline-flex",
    backgroundColor: "var(--epr-reactions-bg-color)",
    // @ts-ignore - backdropFilter is not recognized.
    backdropFilter: "blur(8px)",
    "--": {
      "--epr-picker-border-radius": "50px"
    }
  }
});
function elementCountInRow(parent, element) {
  if (!parent || !element) {
    return 0;
  }
  var parentWidth = parent.getBoundingClientRect().width;
  var elementWidth = element.getBoundingClientRect().width;
  return Math.floor(parentWidth / elementWidth);
}
function elementIndexInRow(parent, element) {
  if (!parent || !element) {
    return 0;
  }
  var elementWidth = element.getBoundingClientRect().width;
  var elementLeft = element.getBoundingClientRect().left;
  var parentLeft = parent.getBoundingClientRect().left;
  return Math.floor((elementLeft - parentLeft) / elementWidth);
}
function rowNumber(parent, element) {
  if (!parent || !element) {
    return 0;
  }
  var elementHeight2 = element.getBoundingClientRect().height;
  var elementTop = element.getBoundingClientRect().top;
  var parentTop = parent.getBoundingClientRect().top;
  return Math.round((elementTop - parentTop) / elementHeight2);
}
function hasNextRow(parent, element) {
  if (!parent || !element) {
    return false;
  }
  var elementHeight2 = element.getBoundingClientRect().height;
  var elementTop = element.getBoundingClientRect().top;
  var parentTop = parent.getBoundingClientRect().top;
  var parentHeight = parent.getBoundingClientRect().height;
  return Math.round(elementTop - parentTop + elementHeight2) < parentHeight;
}
function getRowElements(elements, row, elementsInRow) {
  if (row === -1) {
    var lastRow = Math.floor((elements.length - 1) / elementsInRow);
    var firstElementIndex = lastRow * elementsInRow;
    var lastElementIndex = elements.length - 1;
    return elements.slice(firstElementIndex, lastElementIndex + 1);
  }
  return elements.slice(row * elementsInRow, (row + 1) * elementsInRow);
}
function getNextRowElements(allElements, currentRow, elementsInRow) {
  var nextRow = currentRow + 1;
  if (nextRow * elementsInRow > allElements.length) {
    return [];
  }
  return getRowElements(allElements, nextRow, elementsInRow);
}
function getElementInRow(elements, row, elementsInRow, indexInRow) {
  var rowElements = getRowElements(elements, row, elementsInRow);
  return rowElements[indexInRow] || rowElements[rowElements.length - 1] || null;
}
function getElementInNextRow(allElements, currentRow, elementsInRow, index) {
  var nextRowElements = getNextRowElements(allElements, currentRow, elementsInRow);
  return nextRowElements[index] || nextRowElements[nextRowElements.length - 1] || null;
}
function getElementInPrevRow(allElements, currentRow, elementsInRow, index) {
  var prevRowElements = getRowElements(allElements, currentRow - 1, elementsInRow);
  return prevRowElements[index] || prevRowElements[prevRowElements.length - 1] || null;
}
function firstVisibleElementInContainer(parent, elements, maxVisibilityDiffThreshold) {
  if (!parent || !elements.length) {
    return null;
  }
  var parentTop = parent.getBoundingClientRect().top;
  var parentBottom = parent.getBoundingClientRect().bottom;
  var parentTopWithLabel = parentTop + getLabelHeight(parent);
  var visibleElements = elements.find(function(element) {
    var elementTop = element.getBoundingClientRect().top;
    var elementBottom = element.getBoundingClientRect().bottom;
    var maxVisibilityDiffPixels = element.clientHeight * maxVisibilityDiffThreshold;
    var elementTopWithAllowedDiff = elementTop + maxVisibilityDiffPixels;
    var elementBottomWithAllowedDiff = elementBottom - maxVisibilityDiffPixels;
    if (elementTopWithAllowedDiff < parentTopWithLabel) {
      return false;
    }
    return elementTopWithAllowedDiff >= parentTop && elementTopWithAllowedDiff <= parentBottom || elementBottomWithAllowedDiff >= parentTop && elementBottomWithAllowedDiff <= parentBottom;
  });
  return visibleElements || null;
}
function hasNextElementSibling(element) {
  return !!element.nextElementSibling;
}
function getLabelHeight(parentNode) {
  var labels = Array.from(parentNode.querySelectorAll(asSelectors(ClassNames.label)));
  for (var _i = 0, _labels = labels; _i < _labels.length; _i++) {
    var label = _labels[_i];
    var height2 = label.getBoundingClientRect().height;
    if (height2 > 0) {
      return height2;
    }
  }
  return DEFAULT_LABEL_HEIGHT;
}
var EmojiButtonSelector = "button" + /* @__PURE__ */ asSelectors(ClassNames.emoji);
var VisibleEmojiSelector = /* @__PURE__ */ [EmojiButtonSelector, asSelectors(ClassNames.visible), ":not(" + asSelectors(ClassNames.hidden) + ")"].join("");
function buttonFromTarget(emojiElement) {
  var _emojiElement$closest;
  return (_emojiElement$closest = emojiElement == null ? void 0 : emojiElement.closest(EmojiButtonSelector)) != null ? _emojiElement$closest : null;
}
function emojiFromElement(element) {
  var originalUnified = originalUnifiedFromEmojiElement(element);
  var unified = unifiedFromEmojiElement(element);
  if (!originalUnified) {
    return [];
  }
  var emoji = emojiByUnified(unified != null ? unified : originalUnified);
  if (!emoji) {
    return [];
  }
  return [emoji, unified];
}
function isEmojiElement(element) {
  var _element$parentElemen;
  return Boolean((element == null ? void 0 : element.matches(EmojiButtonSelector)) || (element == null ? void 0 : (_element$parentElemen = element.parentElement) == null ? void 0 : _element$parentElemen.matches(EmojiButtonSelector)));
}
function elementHeight(element) {
  var _element$clientHeight;
  return (_element$clientHeight = element == null ? void 0 : element.clientHeight) != null ? _element$clientHeight : 0;
}
function emojiTrueOffsetTop(element) {
  if (!element) {
    return 0;
  }
  var button = buttonFromTarget(element);
  var category = closestCategory(button);
  var labelHeight = categoryLabelHeight(category);
  return elementOffsetTop(button) + elementOffsetTop(category) + labelHeight;
}
function categoryLabelHeight(category) {
  var _category$clientHeigh, _categoryWithoutLabel;
  if (!category) {
    return 0;
  }
  var categoryWithoutLabel = category.querySelector(asSelectors(ClassNames.categoryContent));
  return ((_category$clientHeigh = category == null ? void 0 : category.clientHeight) != null ? _category$clientHeigh : 0) - ((_categoryWithoutLabel = categoryWithoutLabel == null ? void 0 : categoryWithoutLabel.clientHeight) != null ? _categoryWithoutLabel : 0);
}
function isEmojiBehindLabel(emoji) {
  if (!emoji) {
    return false;
  }
  return emojiDistanceFromScrollTop(emoji) < categoryLabelHeight(closestCategory(emoji));
}
function queryScrollBody(root) {
  if (!root) return null;
  return root.matches(asSelectors(ClassNames.scrollBody)) ? root : root.querySelector(asSelectors(ClassNames.scrollBody));
}
function emojiDistanceFromScrollTop(emoji) {
  var _closestScrollBody$sc, _closestScrollBody;
  if (!emoji) {
    return 0;
  }
  return emojiTrueOffsetTop(emoji) - ((_closestScrollBody$sc = (_closestScrollBody = closestScrollBody(emoji)) == null ? void 0 : _closestScrollBody.scrollTop) != null ? _closestScrollBody$sc : 0);
}
function closestScrollBody(element) {
  var _element$closest;
  if (!element) {
    return null;
  }
  return (_element$closest = element.closest(asSelectors(ClassNames.scrollBody))) != null ? _element$closest : null;
}
function emojiTruOffsetLeft(element) {
  var button = buttonFromTarget(element);
  var category = closestCategory(button);
  return elementOffsetLeft(button) + elementOffsetLeft(category);
}
function elementOffsetTop(element) {
  var _element$offsetTop;
  return (_element$offsetTop = element == null ? void 0 : element.offsetTop) != null ? _element$offsetTop : 0;
}
function elementOffsetLeft(element) {
  var _element$offsetLeft;
  return (_element$offsetLeft = element == null ? void 0 : element.offsetLeft) != null ? _element$offsetLeft : 0;
}
function unifiedFromEmojiElement(emoji) {
  var _elementDataSetKey;
  return (_elementDataSetKey = elementDataSetKey(buttonFromTarget(emoji), "unified")) != null ? _elementDataSetKey : null;
}
function originalUnifiedFromEmojiElement(emoji) {
  var unified = unifiedFromEmojiElement(emoji);
  if (unified) {
    return unifiedWithoutSkinTone(unified);
  }
  return null;
}
function allUnifiedFromEmojiElement(emoji) {
  if (!emoji) {
    return {
      unified: null,
      originalUnified: null
    };
  }
  return {
    unified: unifiedFromEmojiElement(emoji),
    originalUnified: originalUnifiedFromEmojiElement(emoji)
  };
}
function elementDataSetKey(element, key) {
  var _elementDataSet$key;
  return (_elementDataSet$key = elementDataSet(element)[key]) != null ? _elementDataSet$key : null;
}
function elementDataSet(element) {
  var _element$dataset;
  return (_element$dataset = element == null ? void 0 : element.dataset) != null ? _element$dataset : {};
}
function isVisibleEmoji(element) {
  return element.classList.contains(ClassNames.visible);
}
function isHidden(element) {
  if (!element) return true;
  return element.classList.contains(ClassNames.hidden);
}
function allVisibleEmojis(parent) {
  if (!parent) {
    return [];
  }
  return Array.from(parent.querySelectorAll(VisibleEmojiSelector));
}
function lastVisibleEmoji(element) {
  if (!element) return null;
  var allEmojis2 = allVisibleEmojis(element);
  var _allEmojis$slice = allEmojis2.slice(-1), last = _allEmojis$slice[0];
  if (!last) {
    return null;
  }
  if (!isVisibleEmoji(last)) {
    return prevVisibleEmoji(last);
  }
  return last;
}
function nextVisibleEmoji(element) {
  var next2 = element.nextElementSibling;
  if (!next2) {
    return firstVisibleEmoji(nextCategory(element));
  }
  if (!isVisibleEmoji(next2)) {
    return nextVisibleEmoji(next2);
  }
  return next2;
}
function prevVisibleEmoji(element) {
  var prev2 = element.previousElementSibling;
  if (!prev2) {
    return lastVisibleEmoji(prevCategory(element));
  }
  if (!isVisibleEmoji(prev2)) {
    return prevVisibleEmoji(prev2);
  }
  return prev2;
}
function firstVisibleEmoji(parent) {
  if (!parent) {
    return null;
  }
  var allEmojis2 = allVisibleEmojis(parent);
  return firstVisibleElementInContainer(parent, allEmojis2, 0.1);
}
function prevCategory(element) {
  var category = closestCategory(element);
  if (!category) {
    return null;
  }
  var prev2 = category.previousElementSibling;
  if (!prev2) {
    return null;
  }
  if (isHidden(prev2)) {
    return prevCategory(prev2);
  }
  return prev2;
}
function nextCategory(element) {
  var category = closestCategory(element);
  if (!category) {
    return null;
  }
  var next2 = category.nextElementSibling;
  if (!next2) {
    return null;
  }
  if (isHidden(next2)) {
    return nextCategory(next2);
  }
  return next2;
}
function closestCategory(element) {
  if (!element) {
    return null;
  }
  return element.closest(asSelectors(ClassNames.category));
}
function closestCategoryContent(element) {
  if (!element) {
    return null;
  }
  return element.closest(asSelectors(ClassNames.categoryContent));
}
function parseNativeEmoji(unified) {
  return unified.split("-").map(function(hex) {
    return String.fromCodePoint(parseInt(hex, 16));
  }).join("");
}
var SUGGESTED_LS_KEY = "epr_suggested";
function getSuggested(mode) {
  try {
    var _window, _window$localStorage$, _window2;
    if (!((_window = window) != null && _window.localStorage)) {
      return [];
    }
    var recent = JSON.parse((_window$localStorage$ = (_window2 = window) == null ? void 0 : _window2.localStorage.getItem(SUGGESTED_LS_KEY)) != null ? _window$localStorage$ : "[]");
    if (mode === SuggestionMode.FREQUENT) {
      return recent.sort(function(a, b) {
        return b.count - a.count;
      });
    }
    return recent;
  } catch (_unused) {
    return [];
  }
}
function setSuggested(emoji, skinTone) {
  var recent = getSuggested();
  var unified = emojiUnified(emoji, skinTone);
  var originalUnified = emojiUnified(emoji);
  var existing = recent.find(function(_ref) {
    var u2 = _ref.unified;
    return u2 === unified;
  });
  var nextList;
  if (existing) {
    nextList = [existing].concat(recent.filter(function(i) {
      return i !== existing;
    }));
  } else {
    existing = {
      unified,
      original: originalUnified,
      count: 0
    };
    nextList = [existing].concat(recent);
  }
  existing.count++;
  nextList.length = Math.min(nextList.length, 14);
  try {
    var _window3;
    (_window3 = window) == null ? void 0 : _window3.localStorage.setItem(SUGGESTED_LS_KEY, JSON.stringify(nextList));
  } catch (_unused2) {
  }
}
function isCustomCategory(category) {
  return category.category === Categories.CUSTOM;
}
function isCustomEmoji(emoji) {
  return emoji.imgUrl !== void 0;
}
function useMouseDownHandlers(ContainerRef, mouseEventSource) {
  var mouseDownTimerRef = useRef();
  var setVariationPicker = useSetVariationPicker();
  var disallowClickRef = useDisallowClickRef();
  var _useEmojiVariationPic = useEmojiVariationPickerState(), setEmojiVariationPicker = _useEmojiVariationPic[1];
  var closeAllOpenToggles = useCloseAllOpenToggles();
  var _useActiveSkinToneSta = useActiveSkinToneState(), activeSkinTone = _useActiveSkinToneSta[0];
  var onEmojiClick = useOnEmojiClickConfig(mouseEventSource);
  var _useUpdateSuggested = useUpdateSuggested(), updateSuggested = _useUpdateSuggested[1];
  var getEmojiUrl = useGetEmojiUrlConfig();
  var activeEmojiStyle = useEmojiStyleConfig();
  var onClick = useCallback(function onClick2(event) {
    if (disallowClickRef.current) {
      return;
    }
    closeAllOpenToggles();
    var _emojiFromEvent = emojiFromEvent(event), emoji = _emojiFromEvent[0], unified = _emojiFromEvent[1];
    if (!emoji || !unified) {
      return;
    }
    var skinToneToUse = activeVariationFromUnified(unified) || activeSkinTone;
    updateSuggested();
    setSuggested(emoji, skinToneToUse);
    onEmojiClick(emojiClickOutput(emoji, skinToneToUse, activeEmojiStyle, getEmojiUrl), event);
  }, [activeSkinTone, closeAllOpenToggles, disallowClickRef, onEmojiClick, updateSuggested, getEmojiUrl, activeEmojiStyle]);
  var onMouseDown = useCallback(function onMouseDown2(event) {
    var _window;
    if (mouseDownTimerRef.current) {
      clearTimeout(mouseDownTimerRef.current);
    }
    var _emojiFromEvent2 = emojiFromEvent(event), emoji = _emojiFromEvent2[0];
    if (!emoji || !emojiHasVariations(emoji)) {
      return;
    }
    mouseDownTimerRef.current = (_window = window) == null ? void 0 : _window.setTimeout(function() {
      disallowClickRef.current = true;
      mouseDownTimerRef.current = void 0;
      closeAllOpenToggles();
      setVariationPicker(event.target);
      setEmojiVariationPicker(emoji);
    }, 500);
  }, [disallowClickRef, closeAllOpenToggles, setVariationPicker, setEmojiVariationPicker]);
  var onMouseUp = useCallback(function onMouseUp2() {
    if (mouseDownTimerRef.current) {
      clearTimeout(mouseDownTimerRef.current);
      mouseDownTimerRef.current = void 0;
    } else if (disallowClickRef.current) {
      requestAnimationFrame(function() {
        disallowClickRef.current = false;
      });
    }
  }, [disallowClickRef]);
  useEffect(function() {
    if (!ContainerRef.current) {
      return;
    }
    var confainerRef = ContainerRef.current;
    confainerRef.addEventListener("click", onClick, {
      passive: true
    });
    confainerRef.addEventListener("mousedown", onMouseDown, {
      passive: true
    });
    confainerRef.addEventListener("mouseup", onMouseUp, {
      passive: true
    });
    return function() {
      confainerRef == null ? void 0 : confainerRef.removeEventListener("click", onClick);
      confainerRef == null ? void 0 : confainerRef.removeEventListener("mousedown", onMouseDown);
      confainerRef == null ? void 0 : confainerRef.removeEventListener("mouseup", onMouseUp);
    };
  }, [ContainerRef, onClick, onMouseDown, onMouseUp]);
}
function emojiFromEvent(event) {
  var target = event == null ? void 0 : event.target;
  if (!isEmojiElement(target)) {
    return [];
  }
  return emojiFromElement(target);
}
function emojiClickOutput(emoji, activeSkinTone, activeEmojiStyle, getEmojiUrl) {
  var names = emojiNames(emoji);
  if (isCustomEmoji(emoji)) {
    var _unified = emojiUnified(emoji);
    return {
      activeSkinTone,
      emoji: _unified,
      getImageUrl: function getImageUrl() {
        return emoji.imgUrl;
      },
      imageUrl: emoji.imgUrl,
      isCustom: true,
      names,
      unified: _unified,
      unifiedWithoutSkinTone: _unified
    };
  }
  var unified = emojiUnified(emoji, activeSkinTone);
  return {
    activeSkinTone,
    emoji: parseNativeEmoji(unified),
    getImageUrl: function getImageUrl(emojiStyle) {
      if (emojiStyle === void 0) {
        emojiStyle = activeEmojiStyle != null ? activeEmojiStyle : EmojiStyle.APPLE;
      }
      return getEmojiUrl(unified, emojiStyle);
    },
    imageUrl: getEmojiUrl(unified, activeEmojiStyle != null ? activeEmojiStyle : EmojiStyle.APPLE),
    isCustom: false,
    names,
    unified,
    unifiedWithoutSkinTone: emojiUnified(emoji)
  };
}
function Button$1(props) {
  return createElement("button", Object.assign({
    type: "button"
  }, props, {
    className: cx(styles$1.button, props.className)
  }), props.children);
}
var styles$1 = /* @__PURE__ */ stylesheet.create({
  button: {
    ".": "epr-btn",
    cursor: "pointer",
    border: "0",
    background: "none",
    outline: "none"
  }
});
function ClickableEmojiButton(_ref) {
  var _cx;
  var emojiNames2 = _ref.emojiNames, unified = _ref.unified, hidden2 = _ref.hidden, hiddenOnSearch = _ref.hiddenOnSearch, _ref$showVariations = _ref.showVariations, showVariations = _ref$showVariations === void 0 ? true : _ref$showVariations, hasVariations = _ref.hasVariations, children = _ref.children, className = _ref.className, _ref$noBackground = _ref.noBackground, noBackground = _ref$noBackground === void 0 ? false : _ref$noBackground;
  return createElement(Button$1, {
    className: cx(styles$2.emoji, hidden2 && commonStyles.hidden, hiddenOnSearch && commonInteractionStyles.hiddenOnSearch, (_cx = {}, _cx[ClassNames.visible] = !hidden2 && !hiddenOnSearch, _cx), !!(hasVariations && showVariations) && styles$2.hasVariations, noBackground && styles$2.noBackground, className),
    "data-unified": unified,
    "aria-label": getAriaLabel(emojiNames2),
    "data-full-name": emojiNames2
  }, children);
}
function getAriaLabel(emojiNames2) {
  var _emojiNames$;
  return emojiNames2[0].match("flag-") ? (_emojiNames$ = emojiNames2[1]) != null ? _emojiNames$ : emojiNames2[0] : emojiNames2[0];
}
var styles$2 = /* @__PURE__ */ stylesheet.create({
  emoji: {
    ".": ClassNames.emoji,
    position: "relative",
    width: "var(--epr-emoji-fullsize)",
    height: "var(--epr-emoji-fullsize)",
    boxSizing: "border-box",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    maxWidth: "var(--epr-emoji-fullsize)",
    maxHeight: "var(--epr-emoji-fullsize)",
    borderRadius: "8px",
    overflow: "hidden",
    transition: "background-color 0.2s",
    ":hover": {
      backgroundColor: "var(--epr-emoji-hover-color)"
    },
    ":focus": {
      backgroundColor: "var(--epr-focus-bg-color)"
    }
  },
  noBackground: {
    background: "none",
    ":hover": {
      backgroundColor: "transparent",
      background: "none"
    },
    ":focus": {
      backgroundColor: "transparent",
      background: "none"
    }
  },
  hasVariations: {
    ".": ClassNames.emojiHasVariations,
    ":after": {
      content: "",
      display: "block",
      width: "0",
      height: "0",
      right: "0px",
      bottom: "1px",
      position: "absolute",
      borderLeft: "4px solid transparent",
      borderRight: "4px solid transparent",
      transform: "rotate(135deg)",
      borderBottom: "4px solid var(--epr-emoji-variation-indicator-color)",
      zIndex: "var(--epr-emoji-variations-indictator-z-index)"
    },
    ":hover:after": {
      borderBottom: "4px solid var(--epr-emoji-variation-indicator-color-hover)"
    }
  }
});
var emojiStyles = /* @__PURE__ */ stylesheet.create({
  external: {
    ".": ClassNames.external,
    fontSize: "0"
  },
  common: {
    alignSelf: "center",
    justifySelf: "center",
    display: "block"
  }
});
function EmojiImg(_ref) {
  var emojiName2 = _ref.emojiName, style2 = _ref.style, _ref$lazyLoad = _ref.lazyLoad, lazyLoad = _ref$lazyLoad === void 0 ? false : _ref$lazyLoad, imgUrl = _ref.imgUrl, onError = _ref.onError, className = _ref.className;
  return createElement("img", {
    src: imgUrl,
    alt: emojiName2,
    className: cx(styles$3.emojiImag, emojiStyles.external, emojiStyles.common, className),
    loading: lazyLoad ? "lazy" : "eager",
    onError,
    style: style2
  });
}
var styles$3 = /* @__PURE__ */ stylesheet.create({
  emojiImag: {
    ".": "epr-emoji-img",
    maxWidth: "var(--epr-emoji-fullsize)",
    maxHeight: "var(--epr-emoji-fullsize)",
    minWidth: "var(--epr-emoji-fullsize)",
    minHeight: "var(--epr-emoji-fullsize)",
    padding: "var(--epr-emoji-padding)"
  }
});
function NativeEmoji(_ref) {
  var unified = _ref.unified, style2 = _ref.style, className = _ref.className;
  return createElement("span", {
    className: cx(styles$4.nativeEmoji, emojiStyles.common, emojiStyles.external, className),
    "data-unified": unified,
    style: style2
  }, parseNativeEmoji(unified));
}
var styles$4 = /* @__PURE__ */ stylesheet.create({
  nativeEmoji: {
    ".": "epr-emoji-native",
    fontFamily: '"Segoe UI Emoji", "Segoe UI Symbol", "Segoe UI", "Apple Color Emoji", "Twemoji Mozilla", "Noto Color Emoji", "EmojiOne Color", "Android Emoji"!important',
    position: "relative",
    lineHeight: "100%",
    fontSize: "var(--epr-emoji-size)",
    textAlign: "center",
    alignSelf: "center",
    justifySelf: "center",
    letterSpacing: "0",
    padding: "var(--epr-emoji-padding)"
  }
});
function ViewOnlyEmoji(_ref) {
  var emoji = _ref.emoji, unified = _ref.unified, emojiStyle = _ref.emojiStyle, size = _ref.size, lazyLoad = _ref.lazyLoad, _ref$getEmojiUrl = _ref.getEmojiUrl, getEmojiUrl = _ref$getEmojiUrl === void 0 ? emojiUrlByUnified : _ref$getEmojiUrl, className = _ref.className;
  var _useEmojisThatFailedT = useEmojisThatFailedToLoadState(), setEmojisThatFailedToLoad = _useEmojisThatFailedT[1];
  var style2 = {};
  if (size) {
    style2.width = style2.height = style2.fontSize = size + "px";
  }
  var emojiToRender = emoji ? emoji : emojiByUnified(unified);
  if (!emojiToRender) {
    return null;
  }
  if (isCustomEmoji(emojiToRender)) {
    return createElement(EmojiImg, {
      style: style2,
      emojiName: unified,
      emojiStyle: EmojiStyle.NATIVE,
      lazyLoad,
      imgUrl: emojiToRender.imgUrl,
      onError,
      className
    });
  }
  return createElement(Fragment, null, emojiStyle === EmojiStyle.NATIVE ? createElement(NativeEmoji, {
    unified,
    style: style2,
    className
  }) : createElement(EmojiImg, {
    style: style2,
    emojiName: emojiName(emojiToRender),
    emojiStyle,
    lazyLoad,
    imgUrl: getEmojiUrl(unified, emojiStyle),
    onError,
    className
  }));
  function onError() {
    setEmojisThatFailedToLoad(function(prev2) {
      return new Set(prev2).add(unified);
    });
  }
}
function ClickableEmoji(_ref) {
  var emoji = _ref.emoji, unified = _ref.unified, hidden2 = _ref.hidden, hiddenOnSearch = _ref.hiddenOnSearch, emojiStyle = _ref.emojiStyle, _ref$showVariations = _ref.showVariations, showVariations = _ref$showVariations === void 0 ? true : _ref$showVariations, size = _ref.size, lazyLoad = _ref.lazyLoad, getEmojiUrl = _ref.getEmojiUrl, className = _ref.className, _ref$noBackground = _ref.noBackground, noBackground = _ref$noBackground === void 0 ? false : _ref$noBackground;
  var hasVariations = emojiHasVariations(emoji);
  return createElement(ClickableEmojiButton, {
    hasVariations,
    showVariations,
    hidden: hidden2,
    hiddenOnSearch,
    emojiNames: emojiNames(emoji),
    unified,
    noBackground
  }, createElement(ViewOnlyEmoji, {
    unified,
    emoji,
    size,
    emojiStyle,
    lazyLoad,
    getEmojiUrl,
    className
  }));
}
var Plus = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI4LjEuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHdpZHRoPSIyMHB4IiBoZWlnaHQ9IjgwcHgiIHZpZXdCb3g9IjAgMCAyMCA4MCIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwIDAgMjAgODAiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8cGF0aCBmaWxsPSIjODY4Njg2IiBkPSJNNS43LDEwLjRjMCwwLjEsMC4xLDAuMywwLjIsMC40QzYsMTAuOSw2LjEsMTEsNi4zLDExaDMuNHYzLjRjMCwwLjEsMC4xLDAuMywwLjIsMC40CgljMC4xLDAuMSwwLjIsMC4yLDAuNCwwLjJjMC4zLDAsMC41LTAuMiwwLjUtMC41di0zLjRoMy40YzAuMywwLDAuNS0wLjIsMC41LTAuNXMtMC4yLTAuNS0wLjUtMC41aC0zLjRWNi43YzAtMC4zLTAuMi0wLjUtMC41LTAuNQoJQzkuOCw2LDkuNiw2LjIsOS42LDYuNXYzLjRINi4yQzUuOSw5LjksNS43LDEwLjEsNS43LDEwLjRMNS43LDEwLjR6Ii8+CjxwYXRoIGZpbGw9IiMzMzcxQjciIGQ9Ik01LjcsMzAuNGMwLDAuMSwwLjEsMC4zLDAuMiwwLjRTNi4xLDMxLDYuMywzMWgzLjR2My40YzAsMC4xLDAuMSwwLjMsMC4yLDAuNGMwLjEsMC4xLDAuMiwwLjIsMC40LDAuMgoJYzAuMywwLDAuNS0wLjIsMC41LTAuNXYtMy40aDMuNGMwLjMsMCwwLjUtMC4yLDAuNS0wLjVzLTAuMi0wLjUtMC41LTAuNWgtMy40di0zLjRjMC0wLjMtMC4yLTAuNS0wLjUtMC41cy0wLjUsMC4yLTAuNSwwLjV2My40SDYuMgoJQzUuOSwyOS45LDUuNywzMC4xLDUuNywzMC40TDUuNywzMC40eiIvPgo8cGF0aCBmaWxsPSIjQzBDMEJGIiBkPSJNNS43LDUwLjRjMCwwLjEsMC4xLDAuMywwLjIsMC40QzYsNTAuOSw2LjEsNTEsNi4zLDUxaDMuNHYzLjRjMCwwLjEsMC4xLDAuMywwLjIsMC40CgljMC4xLDAuMSwwLjIsMC4yLDAuNCwwLjJjMC4zLDAsMC41LTAuMiwwLjUtMC41di0zLjRoMy40YzAuMywwLDAuNS0wLjIsMC41LTAuNXMtMC4yLTAuNS0wLjUtMC41aC0zLjR2LTMuNGMwLTAuMy0wLjItMC41LTAuNS0wLjUKCXMtMC41LDAuMi0wLjUsMC41djMuNEg2LjJDNS45LDQ5LjksNS43LDUwLjEsNS43LDUwLjRMNS43LDUwLjR6Ii8+CjxwYXRoIGZpbGw9IiM2QUE5REQiIGQ9Ik01LjcsNzAuNGMwLDAuMSwwLjEsMC4zLDAuMiwwLjRTNi4xLDcxLDYuMyw3MWgzLjR2My40YzAsMC4xLDAuMSwwLjMsMC4yLDAuNGMwLjEsMC4xLDAuMiwwLjIsMC40LDAuMgoJYzAuMywwLDAuNS0wLjIsMC41LTAuNXYtMy40aDMuNGMwLjMsMCwwLjUtMC4yLDAuNS0wLjVzLTAuMi0wLjUtMC41LTAuNWgtMy40di0zLjRjMC0wLjMtMC4yLTAuNS0wLjUtMC41cy0wLjUsMC4yLTAuNSwwLjV2My40SDYuNAoJQzUuOSw2OS45LDUuNyw3MC4xLDUuNyw3MC40TDUuNyw3MC40eiIvPgo8L3N2Zz4=";
function BtnPlus() {
  var _useReactionsModeStat = useReactionsModeState(), setReactionsMode = _useReactionsModeStat[1];
  return createElement(Button$1, {
    "aria-label": "Show all Emojis",
    title: "Show all Emojis",
    tabIndex: 0,
    className: cx(styles$5.plusSign),
    onClick: function onClick() {
      return setReactionsMode(false);
    }
  });
}
var styles$5 = /* @__PURE__ */ stylesheet.create(/* @__PURE__ */ _extends({
  plusSign: {
    fontSize: "20px",
    padding: "17px",
    color: "var(--epr-text-color)",
    borderRadius: "50%",
    textAlign: "center",
    lineHeight: "100%",
    width: "20px",
    height: "20px",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    transition: "background-color 0.2s ease-in-out",
    ":after": {
      content: "",
      minWidth: "20px",
      minHeight: "20px",
      backgroundImage: "url(" + Plus + ")",
      backgroundColor: "transparent",
      backgroundRepeat: "no-repeat",
      backgroundSize: "20px",
      backgroundPositionY: "0"
    },
    ":hover": {
      color: "var(--epr-highlight-color)",
      backgroundColor: "var(--epr-hover-bg-color-reduced-opacity)",
      ":after": {
        backgroundPositionY: "-20px"
      }
    },
    ":focus": {
      color: "var(--epr-highlight-color)",
      backgroundColor: "var(--epr-hover-bg-color-reduced-opacity)",
      ":after": {
        backgroundPositionY: "-40px"
      }
    }
  }
}, /* @__PURE__ */ darkMode("plusSign", {
  ":after": {
    backgroundPositionY: "-40px"
  },
  ":hover:after": {
    backgroundPositionY: "-60px"
  }
})));
function Reactions() {
  var _useReactionsModeStat = useReactionsModeState(), reactionsOpen = _useReactionsModeStat[0];
  var ReactionsRef = useReactionsRef();
  var reactions = useReactionsConfig();
  useMouseDownHandlers(ReactionsRef, MOUSE_EVENT_SOURCE.REACTIONS);
  var emojiStyle = useEmojiStyleConfig();
  var allowExpandReactions = useAllowExpandReactions();
  var getEmojiUrl = useGetEmojiUrlConfig();
  if (!reactionsOpen) {
    return null;
  }
  return createElement("ul", {
    className: cx(styles$6.list, !reactionsOpen && commonStyles.hidden),
    ref: ReactionsRef
  }, reactions.map(function(reaction) {
    return createElement("li", {
      key: reaction
    }, createElement(ClickableEmoji, {
      emoji: emojiByUnified(reaction),
      emojiStyle,
      unified: reaction,
      showVariations: false,
      className: cx(styles$6.emojiButton),
      noBackground: true,
      getEmojiUrl
    }));
  }), allowExpandReactions ? createElement("li", null, createElement(BtnPlus, null)) : null);
}
var styles$6 = /* @__PURE__ */ stylesheet.create({
  list: {
    listStyle: "none",
    margin: "0",
    padding: "0 5px",
    display: "flex",
    justifyContent: "space-between",
    alignItems: "center",
    height: "100%"
  },
  emojiButton: {
    ":hover": {
      transform: "scale(1.2)"
    },
    ":focus": {
      transform: "scale(1.2)"
    },
    ":active": {
      transform: "scale(1.1)"
    },
    transition: "transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.5)"
  }
});
function useOnScroll(BodyRef) {
  var closeAllOpenToggles = useCloseAllOpenToggles();
  useEffect(function() {
    var bodyRef = BodyRef.current;
    if (!bodyRef) {
      return;
    }
    bodyRef.addEventListener("scroll", onScroll, {
      passive: true
    });
    function onScroll() {
      closeAllOpenToggles();
    }
    return function() {
      bodyRef == null ? void 0 : bodyRef.removeEventListener("scroll", onScroll);
    };
  }, [BodyRef, closeAllOpenToggles]);
}
function useIsEmojiHidden() {
  var _useEmojisThatFailedT = useEmojisThatFailedToLoadState(), emojisThatFailedToLoad = _useEmojisThatFailedT[0];
  var isEmojiFiltered = useIsEmojiFiltered();
  return function(emoji) {
    var unified = emojiUnified(emoji);
    var failedToLoad = emojisThatFailedToLoad.has(unified);
    var filteredOut = isEmojiFiltered(unified);
    return {
      failedToLoad,
      filteredOut,
      hidden: failedToLoad || filteredOut
    };
  };
}
function EmojiCategory(_ref) {
  var categoryConfig = _ref.categoryConfig, children = _ref.children, hidden2 = _ref.hidden, hiddenOnSearch = _ref.hiddenOnSearch;
  var category = categoryFromCategoryConfig(categoryConfig);
  var categoryName = categoryNameFromCategoryConfig(categoryConfig);
  return createElement("li", {
    className: cx(styles$7.category, hidden2 && commonStyles.hidden, hiddenOnSearch && commonInteractionStyles.hiddenOnSearch),
    "data-name": category,
    "aria-label": categoryName
  }, createElement("h2", {
    className: cx(styles$7.label)
  }, categoryName), createElement("div", {
    className: cx(styles$7.categoryContent)
  }, children));
}
var styles$7 = /* @__PURE__ */ stylesheet.create({
  category: {
    ".": ClassNames.category,
    ":not(:has(.epr-visible))": {
      display: "none"
    }
  },
  categoryContent: {
    ".": ClassNames.categoryContent,
    display: "grid",
    gridGap: "0",
    gridTemplateColumns: "repeat(auto-fill, var(--epr-emoji-fullsize))",
    justifyContent: "space-between",
    margin: "var(--epr-category-padding)",
    position: "relative"
  },
  label: {
    ".": ClassNames.label,
    alignItems: "center",
    // @ts-ignore - backdropFilter is not recognized.
    backdropFilter: "blur(3px)",
    backgroundColor: "var(--epr-category-label-bg-color)",
    color: "var(--epr-category-label-text-color)",
    display: "flex",
    fontSize: "16px",
    fontWeight: "bold",
    height: "var(--epr-category-label-height)",
    margin: "0",
    padding: "var(--epr-category-label-padding)",
    position: "sticky",
    textTransform: "capitalize",
    top: "0",
    width: "100%",
    zIndex: "var(--epr-category-label-z-index)"
  }
});
var isEverMounted = false;
function useIsEverMounted() {
  var _React$useState = useState(isEverMounted), isMounted = _React$useState[0], setIsMounted = _React$useState[1];
  useEffect(function() {
    setIsMounted(true);
    isEverMounted = true;
  }, []);
  return isMounted || isEverMounted;
}
function Suggested(_ref) {
  var categoryConfig = _ref.categoryConfig;
  var _useUpdateSuggested = useUpdateSuggested(), suggestedUpdated = _useUpdateSuggested[0];
  var isMounted = useIsEverMounted();
  var suggestedEmojisModeConfig = useSuggestedEmojisModeConfig();
  var getEmojiUrl = useGetEmojiUrlConfig();
  var suggested = useMemo(
    function() {
      var _getSuggested;
      return (_getSuggested = getSuggested(suggestedEmojisModeConfig)) != null ? _getSuggested : [];
    },
    // eslint-disable-next-line https://esm.sh/react-hooks/exhaustive-deps
    [suggestedUpdated, suggestedEmojisModeConfig]
  );
  var emojiStyle = useEmojiStyleConfig();
  if (!isMounted) {
    return null;
  }
  return createElement(EmojiCategory, {
    categoryConfig,
    hiddenOnSearch: true,
    hidden: suggested.length === 0
  }, suggested.map(function(suggestedItem) {
    var emoji = emojiByUnified(suggestedItem.original);
    if (!emoji) {
      return null;
    }
    return createElement(ClickableEmoji, {
      showVariations: false,
      unified: suggestedItem.unified,
      emojiStyle,
      emoji,
      key: suggestedItem.unified,
      getEmojiUrl
    });
  }));
}
function EmojiList() {
  var categories = useCategoriesConfig();
  var renderdCategoriesCountRef = useRef(0);
  return createElement("ul", {
    className: cx(styles$8.emojiList)
  }, categories.map(function(categoryConfig) {
    var category = categoryFromCategoryConfig(categoryConfig);
    if (category === Categories.SUGGESTED) {
      return createElement(Suggested, {
        key: category,
        categoryConfig
      });
    }
    return createElement(Suspense, {
      key: category
    }, createElement(RenderCategory, {
      category,
      categoryConfig,
      renderdCategoriesCountRef
    }));
  }));
}
function RenderCategory(_ref) {
  var category = _ref.category, categoryConfig = _ref.categoryConfig, renderdCategoriesCountRef = _ref.renderdCategoriesCountRef;
  var isEmojiHidden = useIsEmojiHidden();
  var lazyLoadEmojis = useLazyLoadEmojisConfig();
  var emojiStyle = useEmojiStyleConfig();
  var isPastInitialLoad = useIsPastInitialLoad();
  var _useActiveSkinToneSta = useActiveSkinToneState(), activeSkinTone = _useActiveSkinToneSta[0];
  var isEmojiDisallowed = useIsEmojiDisallowed();
  var getEmojiUrl = useGetEmojiUrlConfig();
  var showVariations = !useSkinTonesDisabledConfig();
  var emojisToPush = !isPastInitialLoad && renderdCategoriesCountRef.current > 0 ? [] : emojisByCategory(category);
  if (emojisToPush.length > 0) {
    renderdCategoriesCountRef.current++;
  }
  var hiddenCounter = 0;
  var emojis2 = emojisToPush.map(function(emoji) {
    var unified = emojiUnified(emoji, activeSkinTone);
    var _isEmojiHidden = isEmojiHidden(emoji), failedToLoad = _isEmojiHidden.failedToLoad, filteredOut = _isEmojiHidden.filteredOut, hidden2 = _isEmojiHidden.hidden;
    var isDisallowed = isEmojiDisallowed(emoji);
    if (hidden2 || isDisallowed) {
      hiddenCounter++;
    }
    if (isDisallowed) {
      return null;
    }
    return createElement(ClickableEmoji, {
      showVariations,
      key: unified,
      emoji,
      unified,
      hidden: failedToLoad,
      hiddenOnSearch: filteredOut,
      emojiStyle,
      lazyLoad: lazyLoadEmojis,
      getEmojiUrl
    });
  });
  return createElement(EmojiCategory, {
    categoryConfig,
    // Indicates that there are no visible emojis
    // Hence, the category should be hidden
    hidden: hiddenCounter === emojis2.length
  }, emojis2);
}
var styles$8 = /* @__PURE__ */ stylesheet.create({
  emojiList: {
    ".": ClassNames.emojiList,
    listStyle: "none",
    margin: "0",
    padding: "0"
  }
});
var SVGTriangle = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI2LjMuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSI1MHB4IgoJIGhlaWdodD0iMTVweCIgdmlld0JveD0iMCAwIDUwIDE1IiBlbmFibGUtYmFja2dyb3VuZD0ibmV3IDAgMCA1MCAxNSIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxnIGlkPSJMYXllcl8xIj4KPC9nPgo8ZyBpZD0iTGF5ZXJfMiI+Cgk8cGF0aCBmaWxsPSIjRkZGRkZGIiBzdHJva2U9IiNFOEU3RTciIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTEuODYtMC40M2w5LjgzLDExLjUzYzAuNTksMC42OSwxLjU2LDAuNjksMi4xNCwwbDkuODMtMTEuNTMiLz4KCTxwYXRoIGZpbGw9IiMwMTAyMDIiIHN0cm9rZT0iIzE1MTYxNyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjYuODYtMC40M2w5LjgzLDExLjUzYzAuNTksMC42OSwxLjU2LDAuNjksMi4xNCwwbDkuODMtMTEuNTMiLz4KPC9nPgo8L3N2Zz4=";
var Direction;
(function(Direction2) {
  Direction2[Direction2["Up"] = 0] = "Up";
  Direction2[Direction2["Down"] = 1] = "Down";
})(Direction || (Direction = {}));
function EmojiVariationPicker() {
  var AnchoredEmojiRef = useAnchoredEmojiRef();
  var VariationPickerRef = useVariationPickerRef();
  var _useEmojiVariationPic = useEmojiVariationPickerState(), emoji = _useEmojiVariationPic[0];
  var emojiStyle = useEmojiStyleConfig();
  var _useVariationPickerTo = useVariationPickerTop(VariationPickerRef), getTop = _useVariationPickerTo.getTop, getMenuDirection = _useVariationPickerTo.getMenuDirection;
  var setAnchoredEmojiRef = useSetAnchoredEmojiRef();
  var getPointerStyle = usePointerStyle(VariationPickerRef);
  var getEmojiUrl = useGetEmojiUrlConfig();
  var button = buttonFromTarget(AnchoredEmojiRef.current);
  var visible = Boolean(emoji && button && emojiHasVariations(emoji) && button.classList.contains(ClassNames.emojiHasVariations));
  useEffect(function() {
    if (!visible) {
      return;
    }
    focusFirstVisibleEmoji(VariationPickerRef.current);
  }, [VariationPickerRef, visible, AnchoredEmojiRef]);
  var top, pointerStyle;
  if (!visible && AnchoredEmojiRef.current) {
    setAnchoredEmojiRef(null);
  } else {
    top = getTop();
    pointerStyle = getPointerStyle();
  }
  return createElement("div", {
    ref: VariationPickerRef,
    className: cx(styles$9.variationPicker, getMenuDirection() === Direction.Down && styles$9.pointingUp, visible && styles$9.visible),
    style: {
      top
    }
  }, visible && emoji ? [emojiUnified(emoji)].concat(emojiVariations(emoji)).slice(0, 6).map(function(unified) {
    return createElement(ClickableEmoji, {
      key: unified,
      emoji,
      unified,
      emojiStyle,
      showVariations: false,
      getEmojiUrl
    });
  }) : null, createElement("div", {
    className: cx(styles$9.pointer),
    style: pointerStyle
  }));
}
function usePointerStyle(VariationPickerRef) {
  var AnchoredEmojiRef = useAnchoredEmojiRef();
  return function getPointerStyle() {
    var style2 = {};
    if (!VariationPickerRef.current) {
      return style2;
    }
    if (AnchoredEmojiRef.current) {
      var button = buttonFromTarget(AnchoredEmojiRef.current);
      var offsetLeft = emojiTruOffsetLeft(button);
      if (!button) {
        return style2;
      }
      style2.left = offsetLeft + (button == null ? void 0 : button.clientWidth) / 2;
    }
    return style2;
  };
}
function useVariationPickerTop(VariationPickerRef) {
  var AnchoredEmojiRef = useAnchoredEmojiRef();
  var BodyRef = useBodyRef();
  var direction = Direction.Up;
  return {
    getMenuDirection,
    getTop
  };
  function getMenuDirection() {
    return direction;
  }
  function getTop() {
    direction = Direction.Up;
    var emojiOffsetTop = 0;
    if (!VariationPickerRef.current) {
      return 0;
    }
    var height2 = elementHeight(VariationPickerRef.current);
    if (AnchoredEmojiRef.current) {
      var _bodyRef$scrollTop;
      var bodyRef = BodyRef.current;
      var button = buttonFromTarget(AnchoredEmojiRef.current);
      var buttonHeight = elementHeight(button);
      emojiOffsetTop = emojiTrueOffsetTop(button);
      var scrollTop = (_bodyRef$scrollTop = bodyRef == null ? void 0 : bodyRef.scrollTop) != null ? _bodyRef$scrollTop : 0;
      if (scrollTop > emojiOffsetTop - height2) {
        direction = Direction.Down;
        emojiOffsetTop += buttonHeight + height2;
      }
    }
    return emojiOffsetTop - height2;
  }
}
var styles$9 = /* @__PURE__ */ stylesheet.create(/* @__PURE__ */ _extends({
  variationPicker: {
    ".": ClassNames.variationPicker,
    position: "absolute",
    right: "15px",
    left: "15px",
    padding: "5px",
    boxShadow: "0px 2px 5px rgba(0, 0, 0, 0.2)",
    borderRadius: "3px",
    display: "flex",
    alignItems: "center",
    justifyContent: "space-around",
    opacity: "0",
    visibility: "hidden",
    pointerEvents: "none",
    top: "-100%",
    border: "1px solid var(--epr-picker-border-color)",
    height: "var(--epr-emoji-variation-picker-height)",
    zIndex: "var(--epr-skin-variation-picker-z-index)",
    background: "var(--epr-emoji-variation-picker-bg-color)",
    transform: "scale(0.9)",
    transition: "transform 0.1s ease-out, opacity 0.2s ease-out"
  },
  visible: {
    opacity: "1",
    visibility: "visible",
    pointerEvents: "all",
    transform: "scale(1)"
  },
  pointingUp: {
    ".": "pointing-up",
    transformOrigin: "center 0%",
    transform: "scale(0.9)"
  },
  ".pointing-up": {
    pointer: {
      top: "0",
      transform: "rotate(180deg) translateY(100%) translateX(18px)"
    }
  },
  pointer: {
    ".": "epr-emoji-pointer",
    content: "",
    position: "absolute",
    width: "25px",
    height: "15px",
    backgroundRepeat: "no-repeat",
    backgroundPosition: "0 0",
    backgroundSize: "50px 15px",
    top: "100%",
    transform: "translateX(-18px)",
    backgroundImage: "url(" + SVGTriangle + ")"
  }
}, /* @__PURE__ */ darkMode("pointer", {
  backgroundPosition: "-25px 0"
})));
function Body() {
  var BodyRef = useBodyRef();
  useOnScroll(BodyRef);
  useMouseDownHandlers(BodyRef, MOUSE_EVENT_SOURCE.PICKER);
  useOnMouseMove();
  return createElement("div", {
    className: cx(styles$a.body, commonInteractionStyles.hiddenOnReactions),
    ref: BodyRef
  }, createElement(EmojiVariationPicker, null), createElement(EmojiList, null));
}
var styles$a = /* @__PURE__ */ stylesheet.create({
  body: {
    ".": ClassNames.scrollBody,
    flex: "1",
    overflowY: "scroll",
    overflowX: "hidden",
    position: "relative"
  }
});
function detectEmojyPartiallyBelowFold(button, bodyRef) {
  if (!button || !bodyRef) {
    return 0;
  }
  var buttonRect = button.getBoundingClientRect();
  var bodyRect = bodyRef.getBoundingClientRect();
  return bodyRect.height - (buttonRect.y - bodyRect.y);
}
function useEmojiPreviewEvents(allow, setPreviewEmoji) {
  var BodyRef = useBodyRef();
  var isMouseDisallowed = useIsMouseDisallowed();
  var allowMouseMove = useAllowMouseMove();
  useEffect(function() {
    if (!allow) {
      return;
    }
    var bodyRef = BodyRef.current;
    bodyRef == null ? void 0 : bodyRef.addEventListener("keydown", onEscape, {
      passive: true
    });
    bodyRef == null ? void 0 : bodyRef.addEventListener("mouseover", onMouseOver, true);
    bodyRef == null ? void 0 : bodyRef.addEventListener("focus", onEnter, true);
    bodyRef == null ? void 0 : bodyRef.addEventListener("mouseout", onLeave, {
      passive: true
    });
    bodyRef == null ? void 0 : bodyRef.addEventListener("blur", onLeave, true);
    function onEnter(e) {
      var button = buttonFromTarget(e.target);
      if (!button) {
        return onLeave();
      }
      var _allUnifiedFromEmojiE = allUnifiedFromEmojiElement(button), unified = _allUnifiedFromEmojiE.unified, originalUnified = _allUnifiedFromEmojiE.originalUnified;
      if (!unified || !originalUnified) {
        return onLeave();
      }
      setPreviewEmoji({
        unified,
        originalUnified
      });
    }
    function onLeave(e) {
      if (e) {
        var relatedTarget = e.relatedTarget;
        if (!buttonFromTarget(relatedTarget)) {
          return setPreviewEmoji(null);
        }
      }
      setPreviewEmoji(null);
    }
    function onEscape(e) {
      if (e.key === "Escape") {
        setPreviewEmoji(null);
      }
    }
    function onMouseOver(e) {
      if (isMouseDisallowed()) {
        return;
      }
      var button = buttonFromTarget(e.target);
      if (button) {
        var belowFoldByPx = detectEmojyPartiallyBelowFold(button, bodyRef);
        var buttonHeight = button.getBoundingClientRect().height;
        if (belowFoldByPx < buttonHeight) {
          return handlePartiallyVisibleElementFocus(button, setPreviewEmoji);
        }
        focusElement(button);
      }
    }
    return function() {
      bodyRef == null ? void 0 : bodyRef.removeEventListener("mouseover", onMouseOver);
      bodyRef == null ? void 0 : bodyRef.removeEventListener("mouseout", onLeave);
      bodyRef == null ? void 0 : bodyRef.removeEventListener("focus", onEnter, true);
      bodyRef == null ? void 0 : bodyRef.removeEventListener("blur", onLeave, true);
      bodyRef == null ? void 0 : bodyRef.removeEventListener("keydown", onEscape);
    };
  }, [BodyRef, allow, setPreviewEmoji, isMouseDisallowed, allowMouseMove]);
}
function handlePartiallyVisibleElementFocus(button, setPreviewEmoji) {
  var _document$activeEleme;
  var _allUnifiedFromEmojiE2 = allUnifiedFromEmojiElement(button), unified = _allUnifiedFromEmojiE2.unified, originalUnified = _allUnifiedFromEmojiE2.originalUnified;
  if (!unified || !originalUnified) {
    return;
  }
  (_document$activeEleme = document.activeElement) == null ? void 0 : _document$activeEleme.blur == null ? void 0 : _document$activeEleme.blur();
  setPreviewEmoji({
    unified,
    originalUnified
  });
}
var _stylesheet$create;
var FlexDirection;
(function(FlexDirection2) {
  FlexDirection2["ROW"] = "FlexRow";
  FlexDirection2["COLUMN"] = "FlexColumn";
})(FlexDirection || (FlexDirection = {}));
function Flex(_ref) {
  var children = _ref.children, className = _ref.className, _ref$style = _ref.style, style2 = _ref$style === void 0 ? {} : _ref$style, _ref$direction = _ref.direction, direction = _ref$direction === void 0 ? FlexDirection.ROW : _ref$direction;
  return createElement("div", {
    style: _extends({}, style2),
    className: cx(styles$b.flex, className, styles$b[direction])
  }, children);
}
var styles$b = /* @__PURE__ */ stylesheet.create((_stylesheet$create = {
  flex: {
    display: "flex"
  }
}, _stylesheet$create[FlexDirection.ROW] = {
  flexDirection: "row"
}, _stylesheet$create[FlexDirection.COLUMN] = {
  flexDirection: "column"
}, _stylesheet$create));
function Space(_ref) {
  var className = _ref.className, _ref$style = _ref.style, style2 = _ref$style === void 0 ? {} : _ref$style;
  return createElement("div", {
    style: _extends({
      flex: 1
    }, style2),
    className: cx(className)
  });
}
function Absolute(_ref) {
  var children = _ref.children, className = _ref.className, style2 = _ref.style;
  return createElement("div", {
    style: _extends({}, style2, {
      position: "absolute"
    }),
    className
  }, children);
}
function Relative(_ref) {
  var children = _ref.children, className = _ref.className, style2 = _ref.style;
  return createElement("div", {
    style: _extends({}, style2, {
      position: "relative"
    }),
    className
  }, children);
}
function BtnSkinToneVariation(_ref) {
  var isOpen = _ref.isOpen, onClick = _ref.onClick, isActive = _ref.isActive, skinToneVariation = _ref.skinToneVariation, style2 = _ref.style;
  return createElement(Button$1, {
    style: style2,
    onClick,
    className: cx("epr-tone-" + skinToneVariation, styles$c.tone, !isOpen && styles$c.closedTone, isActive && styles$c.active),
    tabIndex: isOpen ? 0 : -1,
    "aria-pressed": isActive,
    "aria-label": "Skin tone " + skinTonesNamed[skinToneVariation]
  });
}
var styles$c = /* @__PURE__ */ stylesheet.create({
  closedTone: {
    opacity: "0",
    zIndex: "0"
  },
  active: {
    ".": "epr-active",
    zIndex: "1",
    opacity: "1"
  },
  tone: {
    ".": "epr-tone",
    ":hover": {
      boxShadow: "0 0 0 3px var(--epr-active-skin-hover-color)"
    },
    ":focus": {
      boxShadow: "0 0 0 3px var(--epr-focus-bg-color)"
    },
    "&.epr-tone-neutral": {
      backgroundColor: "#ffd225"
    },
    "&.epr-tone-1f3fb": {
      backgroundColor: "#ffdfbd"
    },
    "&.epr-tone-1f3fc": {
      backgroundColor: "#e9c197"
    },
    "&.epr-tone-1f3fd": {
      backgroundColor: "#c88e62"
    },
    "&.epr-tone-1f3fe": {
      backgroundColor: "#a86637"
    },
    "&.epr-tone-1f3ff": {
      backgroundColor: "#60463a"
    }
  }
});
var ITEM_SIZE = 28;
function SkinTonePickerMenu() {
  return createElement(Relative, {
    style: {
      height: ITEM_SIZE
    }
  }, createElement(Absolute, {
    style: {
      bottom: 0,
      right: 0
    }
  }, createElement(SkinTonePicker, {
    direction: SkinTonePickerDirection.VERTICAL
  })));
}
function SkinTonePicker(_ref) {
  var _ref$direction = _ref.direction, direction = _ref$direction === void 0 ? SkinTonePickerDirection.HORIZONTAL : _ref$direction;
  var SkinTonePickerRef = useSkinTonePickerRef();
  var isDisabled = useSkinTonesDisabledConfig();
  var _useSkinToneFanOpenSt = useSkinToneFanOpenState(), isOpen = _useSkinToneFanOpenSt[0], setIsOpen = _useSkinToneFanOpenSt[1];
  var _useActiveSkinToneSta = useActiveSkinToneState(), activeSkinTone = _useActiveSkinToneSta[0], setActiveSkinTone = _useActiveSkinToneSta[1];
  var onSkinToneChange = useOnSkinToneChangeConfig();
  var closeAllOpenToggles = useCloseAllOpenToggles();
  var focusSearchInput = useFocusSearchInput();
  if (isDisabled) {
    return null;
  }
  var fullWidth = ITEM_SIZE * skinToneVariations.length + "px";
  var expandedSize = isOpen ? fullWidth : ITEM_SIZE + "px";
  var vertical = direction === SkinTonePickerDirection.VERTICAL;
  return createElement(Relative, {
    className: cx(styles$d.skinTones, vertical && styles$d.vertical, isOpen && styles$d.open, vertical && isOpen && styles$d.verticalShadow),
    style: vertical ? {
      flexBasis: expandedSize,
      height: expandedSize
    } : {
      flexBasis: expandedSize
    }
  }, createElement("div", {
    className: cx(styles$d.select),
    ref: SkinTonePickerRef
  }, skinToneVariations.map(function(skinToneVariation, i) {
    var active = skinToneVariation === activeSkinTone;
    return createElement(BtnSkinToneVariation, {
      key: skinToneVariation,
      skinToneVariation,
      isOpen,
      style: {
        transform: cx(vertical ? "translateY(-" + i * (isOpen ? ITEM_SIZE : 0) + "px)" : "translateX(-" + i * (isOpen ? ITEM_SIZE : 0) + "px)", isOpen && active && "scale(1.3)")
      },
      isActive: active,
      onClick: function onClick() {
        if (isOpen) {
          setActiveSkinTone(skinToneVariation);
          onSkinToneChange(skinToneVariation);
          focusSearchInput();
        } else {
          setIsOpen(true);
        }
        closeAllOpenToggles();
      }
    });
  })));
}
var SkinTonePickerDirection;
(function(SkinTonePickerDirection2) {
  SkinTonePickerDirection2["VERTICAL"] = "epr-vertical";
  SkinTonePickerDirection2["HORIZONTAL"] = "epr-horizontal";
})(SkinTonePickerDirection || (SkinTonePickerDirection = {}));
var styles$d = /* @__PURE__ */ stylesheet.create({
  skinTones: {
    ".": "epr-skin-tones",
    "--": {
      "--epr-skin-tone-size": "15px"
    },
    display: "flex",
    alignItems: "center",
    justifyContent: "flex-end",
    transition: "all 0.3s ease-in-out",
    padding: "10px 0"
  },
  vertical: {
    padding: "9px",
    alignItems: "flex-end",
    flexDirection: "column",
    borderRadius: "6px",
    border: "1px solid var(--epr-bg-color)"
  },
  verticalShadow: {
    boxShadow: "0px 0 7px var(--epr-picker-border-color)"
  },
  open: {
    // @ts-ignore - backdropFilter is not recognized.
    backdropFilter: "blur(5px)",
    background: "var(--epr-skin-tone-picker-menu-color)",
    ".epr-active:after": {
      content: "",
      position: "absolute",
      top: "-2px",
      left: "-2px",
      right: "-2px",
      bottom: "-2px",
      borderRadius: "5px",
      border: "1px solid var(--epr-active-skin-tone-indicator-border-color)"
    }
  },
  select: {
    ".": "epr-skin-tone-select",
    position: "relative",
    width: "var(--epr-skin-tone-size)",
    height: "var(--epr-skin-tone-size)",
    "> button": {
      width: "var(--epr-skin-tone-size)",
      display: "block",
      cursor: "pointer",
      borderRadius: "4px",
      height: "var(--epr-skin-tone-size)",
      position: "absolute",
      right: "0",
      transition: "transform 0.3s ease-in-out, opacity 0.35s ease-in-out",
      zIndex: "0",
      boxShadow: "0 0 0 0px var(--epr-active-skin-hover-color)"
    }
  }
});
function Preview() {
  var previewConfig = usePreviewConfig();
  var isSkinToneInPreview = useIsSkinToneInPreview();
  if (!previewConfig.showPreview) {
    return null;
  }
  return createElement(Flex, {
    className: cx(styles$e.preview, commonInteractionStyles.hiddenOnReactions)
  }, createElement(PreviewBody, null), createElement(Space, null), isSkinToneInPreview ? createElement(SkinTonePickerMenu, null) : null);
}
function PreviewBody() {
  var _previewEmoji$unified;
  var previewConfig = usePreviewConfig();
  var _useState = useState(null), previewEmoji = _useState[0], setPreviewEmoji = _useState[1];
  var emojiStyle = useEmojiStyleConfig();
  var _useEmojiVariationPic = useEmojiVariationPickerState(), variationPickerEmoji = _useEmojiVariationPic[0];
  var getEmojiUrl = useGetEmojiUrlConfig();
  useEmojiPreviewEvents(previewConfig.showPreview, setPreviewEmoji);
  var emoji = emojiByUnified((_previewEmoji$unified = previewEmoji == null ? void 0 : previewEmoji.unified) != null ? _previewEmoji$unified : previewEmoji == null ? void 0 : previewEmoji.originalUnified);
  var show = emoji != null && previewEmoji != null;
  return createElement(PreviewContent, null);
  function PreviewContent() {
    var defaultEmoji = variationPickerEmoji != null ? variationPickerEmoji : emojiByUnified(previewConfig.defaultEmoji);
    if (!defaultEmoji) {
      return null;
    }
    var defaultText = variationPickerEmoji ? emojiName(variationPickerEmoji) : previewConfig.defaultCaption;
    return createElement(Fragment, null, createElement("div", null, show ? createElement(ViewOnlyEmoji, {
      unified: previewEmoji == null ? void 0 : previewEmoji.unified,
      emoji,
      emojiStyle,
      size: 45,
      getEmojiUrl,
      className: cx(styles$e.emoji)
    }) : defaultEmoji ? createElement(ViewOnlyEmoji, {
      unified: emojiUnified(defaultEmoji),
      emoji: defaultEmoji,
      emojiStyle,
      size: 45,
      getEmojiUrl,
      className: cx(styles$e.emoji)
    }) : null), createElement("div", {
      className: cx(styles$e.label)
    }, show ? emojiName(emoji) : defaultText));
  }
}
var styles$e = /* @__PURE__ */ stylesheet.create({
  preview: {
    alignItems: "center",
    borderTop: "1px solid var(--epr-preview-border-color)",
    height: "var(--epr-preview-height)",
    padding: "0 var(--epr-horizontal-padding)",
    position: "relative",
    zIndex: "var(--epr-preview-z-index)"
  },
  label: {
    color: "var(--epr-preview-text-color)",
    fontSize: "var(--epr-preview-text-size)",
    padding: "var(--epr-preview-text-padding)",
    textTransform: "capitalize"
  },
  emoji: {
    padding: "0"
  }
});
function categoryNameFromDom($category) {
  var _$category$getAttribu;
  return (_$category$getAttribu = $category == null ? void 0 : $category.getAttribute("data-name")) != null ? _$category$getAttribu : null;
}
function useActiveCategoryScrollDetection(setActiveCategory) {
  var BodyRef = useBodyRef();
  useEffect(function() {
    var visibleCategories = /* @__PURE__ */ new Map();
    var bodyRef = BodyRef.current;
    var observer = new IntersectionObserver(function(entries) {
      if (!bodyRef) {
        return;
      }
      for (var _iterator = _createForOfIteratorHelperLoose(entries), _step; !(_step = _iterator()).done; ) {
        var entry = _step.value;
        var _id = categoryNameFromDom(entry.target);
        visibleCategories.set(_id, entry.intersectionRatio);
      }
      var ratios = Array.from(visibleCategories);
      var lastCategory = ratios[ratios.length - 1];
      if (lastCategory[1] == 1) {
        return setActiveCategory(lastCategory[0]);
      }
      for (var _i = 0, _ratios = ratios; _i < _ratios.length; _i++) {
        var _ratios$_i = _ratios[_i], id = _ratios$_i[0], ratio = _ratios$_i[1];
        if (ratio) {
          setActiveCategory(id);
          break;
        }
      }
    }, {
      threshold: [0, 1]
    });
    bodyRef == null ? void 0 : bodyRef.querySelectorAll(asSelectors(ClassNames.category)).forEach(function(el) {
      observer.observe(el);
    });
  }, [BodyRef, setActiveCategory]);
}
function useScrollCategoryIntoView() {
  var BodyRef = useBodyRef();
  var PickerMainRef = usePickerMainRef();
  return function scrollCategoryIntoView(category) {
    var _BodyRef$current;
    if (!BodyRef.current) {
      return;
    }
    var $category = (_BodyRef$current = BodyRef.current) == null ? void 0 : _BodyRef$current.querySelector('[data-name="' + category + '"]');
    if (!$category) {
      return;
    }
    var offsetTop = $category.offsetTop || 0;
    scrollTo(PickerMainRef.current, offsetTop);
  };
}
function useShouldHideCustomEmojis() {
  var customCategoryConfig = useCustomEmojisConfig();
  if (!customCategoryConfig) {
    return false;
  }
  return customCategoryConfig.length === 0;
}
var SVGNavigation = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI2LjMuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHdpZHRoPSIyMDBweCIgaGVpZ2h0PSI4MHB4IiB2aWV3Qm94PSIwIDAgMjAwIDgwIiBlbmFibGUtYmFja2dyb3VuZD0ibmV3IDAgMCAyMDAgODAiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8ZyBpZD0iTGF5ZXJfMTEiPgoJPGc+CgkJPHBhdGggZmlsbD0iIzMzNzFCNyIgc3Ryb2tlPSIjMzM3MUI3IiBzdHJva2Utd2lkdGg9IjAuMSIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMTIuOCwyOS41YzAuNiwwLDEuMS0wLjUsMS4xLTEuMQoJCQljMC0wLjYtMC41LTEuMi0xLjEtMS4yYy0wLjYsMC0xLjIsMC41LTEuMiwxLjJDMTEuNiwyOSwxMi4yLDI5LjUsMTIuOCwyOS41eiBNMTIuOCwyOGMwLjIsMCwwLjQsMC4yLDAuNCwwLjQKCQkJYzAsMC4yLTAuMiwwLjQtMC40LDAuNGMtMC4yLDAtMC40LTAuMi0wLjQtMC40QzEyLjQsMjguMSwxMi42LDI4LDEyLjgsMjh6Ii8+CgkJPHBhdGggZmlsbD0iIzMzNzFCNyIgc3Ryb2tlPSIjMzM3MUI3IiBzdHJva2Utd2lkdGg9IjAuMSIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMTAsMjNjLTMuOCwwLTcsMy4xLTcsN2MwLDMuOCwzLjEsNyw3LDcKCQkJczctMy4xLDctN0MxNywyNi4yLDEzLjgsMjMsMTAsMjN6IE0xMCwzNi4yYy0zLjQsMC02LjItMi44LTYuMi02LjJjMC0zLjQsMi44LTYuMiw2LjItNi4yczYuMiwyLjgsNi4yLDYuMgoJCQlDMTYuMiwzMy40LDEzLjQsMzYuMiwxMCwzNi4yeiIvPgoJCTxwYXRoIGZpbGw9IiMzMzcxQjciIHN0cm9rZT0iIzMzNzFCNyIgc3Ryb2tlLXdpZHRoPSIwLjEiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTE0LjYsMzEuMmMtMC4xLTAuMS0wLjItMC4yLTAuMy0wLjJINS43CgkJCWMtMC4xLDAtMC4yLDAuMS0wLjMsMC4yYy0wLjEsMC4xLTAuMSwwLjIsMCwwLjRjMC43LDIsMi41LDMuMyw0LjYsMy4zczMuOS0xLjMsNC42LTMuM0MxNC43LDMxLjUsMTQuNywzMS4zLDE0LjYsMzEuMnogTTEwLDM0LjEKCQkJYy0xLjYsMC0zLTAuOS0zLjctMi4yaDcuM0MxMywzMy4yLDExLjYsMzQuMSwxMCwzNC4xeiIvPgoJCTxwYXRoIGZpbGw9IiMzMzcxQjciIHN0cm9rZT0iIzMzNzFCNyIgc3Ryb2tlLXdpZHRoPSIwLjEiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTcuMiwyOS41YzAuNiwwLDEuMi0wLjUsMS4yLTEuMQoJCQljMC0wLjYtMC41LTEuMi0xLjItMS4yYy0wLjYsMC0xLjEsMC41LTEuMSwxLjJDNi4xLDI5LDYuNiwyOS41LDcuMiwyOS41eiBNNy4yLDI4YzAuMiwwLDAuNCwwLjIsMC40LDAuNGMwLDAuMi0wLjIsMC40LTAuNCwwLjQKCQkJYy0wLjIsMC0wLjQtMC4yLTAuNC0wLjRDNi44LDI4LjEsNywyOCw3LjIsMjh6Ii8+Cgk8L2c+Cgk8Zz4KCQk8Zz4KCQkJPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMzM3MUI3IiBkPSJNNjQuMSwzMy40bDIuMywwYzAuMiwwLDAuNCwwLjIsMC40LDAuNHYyLjFjMCwwLjItMC4yLDAuNC0wLjQsMC40aC0yLjMKCQkJCWMtMC4yLDAtMC40LTAuMi0wLjQtMC40di0yLjFDNjMuNywzMy42LDYzLjgsMzMuNCw2NC4xLDMzLjR6Ii8+CgkJCTxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzMzNzFCNyIgZD0iTTczLjUsMzMuNWgyLjRjMC4yLDAsMC40LDAuMiwwLjQsMC40djJjMCwwLjItMC4yLDAuNC0wLjQsMC40aC0yLjQKCQkJCWMtMC4yLDAtMC40LTAuMi0wLjQtMC40bDAtMkM3My4xLDMzLjYsNzMuMywzMy41LDczLjUsMzMuNXoiLz4KCQkJPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMzM3MUI3IiBkPSJNNjMuNywyOC40aDEyLjZ2NUg2My43VjI4LjR6Ii8+CgkJCTxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzMzNzFCNyIgZD0iTTY1LjUsMjMuNmg4LjljMSwwLDEuOSwwLjgsMS45LDEuOXYzLjFINjMuN3YtMy4xQzYzLjcsMjQuNSw2NC41LDIzLjYsNjUuNSwyMy42eiIvPgoJCQk8ZWxsaXBzZSBmaWxsPSIjMzM3MUI3IiBjeD0iNjYuMiIgY3k9IjMwLjkiIHJ4PSIwLjkiIHJ5PSIxIi8+CgkJCTxlbGxpcHNlIGZpbGw9IiMzMzcxQjciIGN4PSI3My44IiBjeT0iMzAuOSIgcng9IjAuOSIgcnk9IjEiLz4KCQk8L2c+Cgk8L2c+Cgk8Zz4KCQk8Zz4KCQkJPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMzM3MUI3IiBkPSJNOTYuNCwzMGMwLDMuNi0yLjksNi41LTYuNCw2LjVzLTYuNC0yLjktNi40LTYuNXMyLjktNi41LDYuNC02LjVTOTYuNCwyNi40LDk2LjQsMzB6Ii8+CgkJCTxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzMzNzFCNyIgZD0iTTk2LjMsMjguNmMwLDAsMCwwLjEsMCwwLjFjLTAuOSwwLjEtMi45LDAuMS00LjYtMS4xYy0xLjEtMC44LTItMS43LTIuNi0yLjUKCQkJCWMtMC4zLTAuNC0wLjYtMC44LTAuNy0xYy0wLjEtMC4xLTAuMS0wLjEtMC4xLTAuMmMwLjUtMC4xLDEuMi0wLjIsMi0wLjFjMS4yLDAsMi41LDAuMywzLjUsMS4xYzEsMC44LDEuNywxLjgsMi4xLDIuOAoJCQkJQzk2LjEsMjcuOSw5Ni4yLDI4LjMsOTYuMywyOC42eiIvPgoJCQk8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiMzMzcxQjciIGQ9Ik04NCwzMi4yYzAsMCwwLTAuMSwwLTAuMWMwLjktMC4yLDIuOS0wLjQsNC43LDAuNmMxLjEsMC43LDEuOSwxLjUsMi40LDIuMwoJCQkJYzAuNCwwLjUsMC42LDEsMC43LDEuM2MtMC40LDAuMS0xLDAuMi0xLjcsMC4zYy0xLDAtMi4xLTAuMS0zLjItMC44cy0xLjktMS42LTIuNC0yLjVDODQuMiwzMi44LDg0LjEsMzIuNSw4NCwzMi4yeiIvPgoJCTwvZz4KCTwvZz4KCTxnPgoJCTxnPgoJCQk8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiMzMzcxQjciIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgZD0iTTExNi4zLDI2LjhsLTEuNCwybC0wLjgtMC44bC0wLjYtMC42bDAsMC45bC0wLjEsOC4yaC02LjgKCQkJCWwtMC4xLTguMmwwLTAuOWwtMC42LDAuNmwtMC44LDAuOGwtMS40LTJsMi42LTIuOWMwLjEtMC4xLDAuMi0wLjEsMC4zLTAuMWgxLjNsMC40LDAuN2MwLjcsMS4zLDIuNiwxLjMsMy4zLTAuMWwwLjMtMC42aDEuMgoJCQkJYzAuMSwwLDAuMiwwLDAuMywwLjFsMC4zLTAuM2wtMC4zLDAuM0wxMTYuMywyNi44eiIvPgoJCQk8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiMzMzcxQjciIGQ9Ik0xMTAuMSwyNy43aDJ2MC45YzAsMC40LTAuNCwwLjctMSwwLjdjLTAuNiwwLTEtMC4zLTEtMC43TDExMC4xLDI3LjdMMTEwLjEsMjcuN3oiLz4KCQk8L2c+Cgk8L2c+Cgk8Zz4KCQk8Zz4KCQkJPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMzM3MUI3IiBkPSJNMTI2LjgsMzQuM2MwLDEuMi0xLDIuMi0yLjIsMi4ycy0yLjItMS0yLjItMi4yczEtMi4yLDIuMi0yLjJTMTI2LjgsMzMuMSwxMjYuOCwzNC4zeiIvPgoJCQk8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiMzMzcxQjciIGQ9Ik0xMzcuNiwzNC4zYzAsMS4yLTEsMi4yLTIuMiwyLjJjLTEuMiwwLTIuMi0xLTIuMi0yLjJzMS0yLjIsMi4yLTIuMgoJCQkJQzEzNi42LDMyLjEsMTM3LjYsMzMuMSwxMzcuNiwzNC4zeiIvPgoJCQk8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiMzMzcxQjciIGQ9Ik0xMjYuOCwyNC40djkuOSIvPgoJCQk8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiMzMzcxQjciIGQ9Ik0xMzcuNywyNC40djkuOSIvPgoJCQk8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiMzMzcxQjciIGQ9Ik0xMjYuOCwyMy41aDEwLjh2Mi43aC0xMC44QzEyNi44LDI2LjIsMTI2LjgsMjMuNSwxMjYuOCwyMy41eiIvPgoJCTwvZz4KCTwvZz4KCTxnPgoJCTxnPgoJCQk8cGF0aCBmaWxsPSIjMzM3MUI3IiBkPSJNMTcwLjgsMjMuMUwxNzAuOCwyMy4xYy0wLjMsMC0wLjUsMC0wLjgsMGMtMi4xLDAtNCwxLTUuMywyLjVsLTAuMSwwbC0wLjEtMC4xbC0xLTEuMmwtMC4zLDMuNGwzLjQsMC4zCgkJCQlsLTEuMS0xLjNsLTAuMS0wLjFsMC4xLTAuMWMxLjEtMS41LDMtMi4zLDUtMi4xbDAsMGMzLjIsMC4zLDUuNSwzLjEsNS4yLDYuM2MtMC4zLDMtMy4xLDUuMy02LjEsNS4xYy0zLjEtMC4yLTUuNC0yLjktNS4zLTYKCQkJCWwtMS4zLTAuMWMtMC4yLDMuOCwyLjYsNy4xLDYuMyw3LjRjMy45LDAuMyw3LjMtMi42LDcuNi02LjVDMTc3LjIsMjYuOCwxNzQuNCwyMy41LDE3MC44LDIzLjF6Ii8+CgkJCTxwYXRoIGZpbGw9IiMzMzcxQjciIGQ9Ik0xNzAuMywyNy40YzAtMC4zLTAuMy0wLjYtMC42LTAuNnMtMC42LDAuMy0wLjYsMC42djMuMmMwLDAuMiwwLjEsMC4zLDAuMiwwLjRjMC4xLDAuMSwwLjMsMC4yLDAuNCwwLjIKCQkJCWgyLjRjMC40LDAsMC42LTAuMywwLjYtMC42YzAtMC40LTAuMy0wLjYtMC42LTAuNmgtMS42aC0wLjJ2LTAuMkwxNzAuMywyNy40TDE3MC4zLDI3LjR6Ii8+CgkJPC9nPgoJPC9nPgoJPGc+CgkJPGc+CgkJCTxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzMzNzFCNyIgZD0iTTE4Ni4yLDIzLjRoNy43YzEuNSwwLDIuNywxLjIsMi43LDIuN3Y3LjdjMCwxLjUtMS4yLDIuNy0yLjcsMi43aC03LjcKCQkJCWMtMS41LDAtMi43LTEuMi0yLjctMi43di03LjdDMTgzLjQsMjQuNiwxODQuNywyMy40LDE4Ni4yLDIzLjR6Ii8+CgkJCTxlbGxpcHNlIGZpbGw9IiMzMzcxQjciIGN4PSIxODYiIGN5PSIyOC45IiByeD0iMC43IiByeT0iMC43Ii8+CgkJCTxlbGxpcHNlIGZpbGw9IiMzMzcxQjciIGN4PSIxOTQiIGN5PSIyNi43IiByeD0iMC43IiByeT0iMC43Ii8+CgkJCTxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzMzNzFCNyIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBkPSJNMTg2LDMzLjNsMC40LTAuM2MwLjQtMC4zLDEtMC4zLDEuNS0wLjFsMSwwLjQKCQkJCWMwLjUsMC4yLDEsMC4yLDEuNS0wLjFsMC44LTAuNWMwLjQtMC4zLDEtMC4zLDEuNS0wLjFsMS44LDAuOCIvPgoJCTwvZz4KCTwvZz4KCTxwYXRoIGZpbGw9IiMzMzcxQjciIHN0cm9rZT0iIzMzNzFCNyIgc3Ryb2tlLXdpZHRoPSIwLjI1IiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0xNTYsMjQuM2MtMC4yLTAuMS0wLjQtMC4xLTAuNSwwCgkJYzAsMC0wLjIsMC4xLTAuOSwwLjJjLTAuNywwLTIuNC0wLjEtMy44LTAuNmMtMC44LTAuMy0xLjctMC41LTIuNS0wLjVjLTAuMiwwLTAuNCwwLTAuNSwwYy0xLjMsMC0yLjUsMC4zLTMuNiwxCgkJYy0wLjIsMC4xLTAuMiwwLjItMC4yLDAuNHYxMS42YzAsMC4zLDAuMSwwLjUsMC4zLDAuNWMwLjYsMCwwLjUtMC40LDAuNS0wLjZ2LTUuN2MwLjctMC4zLDMuMi0xLjEsNS44LTAuMQoJCWMxLjYsMC42LDMuNSwwLjcsNC4zLDAuN2MwLjgsMCwxLjMtMC4zLDEuMy0wLjNjMC4yLTAuMSwwLjMtMC4yLDAuMy0wLjR2LTUuN0MxNTYuMiwyNC42LDE1Ni4xLDI0LjQsMTU2LDI0LjN6IE0xNTUuNiwzMC4yCgkJYy0wLjEsMC0wLjcsMC4xLTEsMC4xYy0wLjcsMC0yLjQtMC4xLTMuOC0wLjZjLTIuNS0xLTUtMC41LTYuMi0wLjF2LTQuOWMwLjktMC41LDIuMi0wLjcsMy4yLTAuN2MwLjEsMCwwLjMsMCwwLjQsMAoJCWMwLjcsMCwxLjUsMC4yLDIuMiwwLjRjMS42LDAuNiwzLjUsMC43LDQuMywwLjdjMC4yLDAsMC44LDAsMS0wLjFWMzAuMnoiLz4KCTxnPgoJCTxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzMzNzFCNyIgZD0iTTQ4LjEsMjMuNWgzLjdjMi41LDAsNC41LDIsNC41LDQuNWMwLDAuNS0wLjQsMC45LTAuOSwwLjlINDQuNWMtMC41LDAtMC45LTAuNC0wLjktMC45CgkJCUM0My42LDI1LjUsNDUuNiwyMy41LDQ4LjEsMjMuNXoiLz4KCQk8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiMzMzcxQjciIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgZD0iTTQzLjUsMjguOGMtMC4yLDAuMS0wLjUsMS4yLDAsMS41YzEuNCwxLDguNSwwLjgsMTEuMywwLjYKCQkJYzAuOC0wLjEsMS42LTAuNCwxLjctMS4yYzAtMC4zLTAuMS0wLjYtMC42LTAuOSIvPgoJCTxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzMzNzFCNyIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBkPSJNNDMuNSwzMC42TDQzLjMsMzFjLTAuMiwwLjUsMC4yLDEsMC43LDAuOWMwLjMtMC4xLDAuNSwwLDAuNywwLjMKCQkJbDAuMSwwLjJjMC4zLDAuNSwxLDAuNiwxLjUsMC4ybDAsMGMwLjMtMC4yLDAuNy0wLjMsMS0wLjJsMC44LDAuM2MwLjQsMC4yLDAuOCwwLjEsMS4yLDBsMC41LTAuMmMwLjQtMC4yLDAuOS0wLjIsMS4zLDBsMC41LDAuMgoJCQljMC40LDAuMiwwLjgsMC4yLDEuMiwwbDAuMi0wLjFjMC4zLTAuMiwwLjgtMC4yLDEuMSwwLjFsMC4yLDAuMmMwLjMsMC4zLDAuOCwwLjIsMS0wLjJsMC4xLTAuMmMwLjEtMC4yLDAtMC4zLDAuMi0wLjMKCQkJYzAuNSwwLDEuMi0wLjMsMS4xLTAuN2wtMC40LTEuMSIvPgoJCTxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzMzNzFCNyIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBkPSJNNDMuNSwzMi4yYy0wLjEsMC4yLTAuMywwLjgsMCwxLjFjMC4zLDAuNCwzLDEuMSw2LjQsMS4xCgkJCWMyLjIsMCw0LjYtMC4zLDYtMC42YzAuNS0wLjEsMC45LTAuNSwwLjgtMC45YzAtMC4yLTAuMi0wLjUtMC40LTAuNyIvPgoJCTxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzMzNzFCNyIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBkPSJNNDMuNSwzMy4zYzAsMC41LDAuNiwyLjMsMS4zLDIuN2MxLjgsMC44LDUuNywwLjcsOC4xLDAuNQoJCQljMS4zLTAuMSwyLjUtMC43LDMuMi0xLjhjMC4zLTAuNSwwLjUtMSwwLjUtMS40Ii8+CgkJPGVsbGlwc2UgZmlsbD0iIzMzNzFCNyIgY3g9IjUxLjYiIGN5PSIyNi41IiByeD0iMC4zIiByeT0iMC40Ii8+CgkJPGVsbGlwc2UgZmlsbD0iIzMzNzFCNyIgY3g9IjUzIiBjeT0iMjUiIHJ4PSIwLjMiIHJ5PSIwLjQiLz4KCQk8ZWxsaXBzZSBmaWxsPSIjMzM3MUI3IiBjeD0iNTMiIGN5PSIyNy4yIiByeD0iMC4zIiByeT0iMC40Ii8+CgkJPGVsbGlwc2UgZmlsbD0iIzMzNzFCNyIgY3g9IjU0LjMiIGN5PSIyNi41IiByeD0iMC4zIiByeT0iMC40Ii8+CgkJPGVsbGlwc2UgZmlsbD0iIzMzNzFCNyIgY3g9IjUwLjkiIGN5PSIyNSIgcng9IjAuMyIgcnk9IjAuNCIvPgoJPC9nPgoJPGc+CgkJPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMzM3MUI3IiBkPSJNMjQuMiwzMXYtNy42YzAuMSwwLjEsMC44LDAuOSwyLjgsMy4xYzIuNS0xLjYsNS42LTAuNyw2LjksMGwyLjQtMy4xdjcuMQoJCQljMCwxLjItMC4xLDIuNS0wLjksMy40Yy0xLDEuMi0yLjcsMi41LTUuMywyLjVjLTIuOSwwLTQuNS0xLjUtNS4zLTIuOUMyNC4yLDMyLjksMjQuMiwzMiwyNC4yLDMxeiIvPgoJCTxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzMzNzFCNyIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBkPSJNMjEuMiwzMGw1LjQsMS4yIi8+CgkJPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMzM3MUI3IiBzdHJva2UtbGluZWNhcD0icm91bmQiIGQ9Ik0yMS4yLDM0LjFsNS40LTEuMiIvPgoJCTxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzMzNzFCNyIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBkPSJNMzguOCwzMGwtNS40LDEuMiIvPgoJCTxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzMzNzFCNyIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBkPSJNMzguOCwzNC4xbC01LjQtMS4yIi8+CgkJPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGZpbGw9IiMzMzcxQjciIGQ9Ik0yOS41LDMyLjRMMjksMzEuN2MtMC4yLTAuMywwLTAuNiwwLjMtMC42aDEuNAoJCQljMC4zLDAsMC41LDAuNCwwLjMsMC42bC0wLjcsMWwwLDBjLTAuNywxLjItMi42LDEuMS0zLjEtMC4zbC0wLjEtMC4yYy0wLjEtMC4yLDAtMC40LDAuMi0wLjVzMC40LDAsMC41LDAuMmwwLjEsMC4yCgkJCUMyOC4zLDMyLjgsMjkuMSwzMi45LDI5LjUsMzIuNHoiLz4KCQk8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiMzMzcxQjciIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgZD0iTTMyLjQsMzIuMWwtMC4xLDAuMmMtMC40LDEtMS44LDEuMS0yLjMsMC4yIi8+CgkJPGVsbGlwc2UgZmlsbD0iIzMzNzFCNyIgY3g9IjI3LjYiIGN5PSIyOS43IiByeD0iMC43IiByeT0iMC43Ii8+CgkJPGVsbGlwc2UgZmlsbD0iIzMzNzFCNyIgY3g9IjMyLjQiIGN5PSIyOS43IiByeD0iMC43IiByeT0iMC43Ii8+Cgk8L2c+Cgk8Zz4KCQk8cGF0aCBmaWxsPSIjQzBDMEJGIiBzdHJva2U9IiNDMEMwQkYiIHN0cm9rZS13aWR0aD0iMC4xIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0xMi44LDQ5LjVjMC42LDAsMS4xLTAuNSwxLjEtMS4xCgkJCWMwLTAuNi0wLjUtMS4yLTEuMS0xLjJjLTAuNiwwLTEuMiwwLjUtMS4yLDEuMkMxMS42LDQ5LDEyLjIsNDkuNSwxMi44LDQ5LjV6IE0xMi44LDQ4YzAuMiwwLDAuNCwwLjIsMC40LDAuNAoJCQljMCwwLjItMC4yLDAuNC0wLjQsMC40Yy0wLjIsMC0wLjQtMC4yLTAuNC0wLjRDMTIuNCw0OC4xLDEyLjYsNDgsMTIuOCw0OHoiLz4KCQk8cGF0aCBmaWxsPSIjQzBDMEJGIiBzdHJva2U9IiNDMEMwQkYiIHN0cm9rZS13aWR0aD0iMC4xIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0xNC42LDUxLjJjLTAuMS0wLjEtMC4yLTAuMi0wLjMtMC4ySDUuNwoJCQljLTAuMSwwLTAuMiwwLjEtMC4zLDAuMmMtMC4xLDAuMS0wLjEsMC4yLDAsMC40YzAuNywyLDIuNSwzLjMsNC42LDMuM3MzLjktMS4zLDQuNi0zLjNDMTQuNyw1MS41LDE0LjcsNTEuMywxNC42LDUxLjJ6IE0xMCw1NC4xCgkJCWMtMS42LDAtMy0wLjktMy43LTIuMmg3LjNDMTMsNTMuMiwxMS42LDU0LjEsMTAsNTQuMXoiLz4KCQk8cGF0aCBmaWxsPSIjQzBDMEJGIiBzdHJva2U9IiNDMEMwQkYiIHN0cm9rZS13aWR0aD0iMC4xIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik03LjIsNDkuNWMwLjYsMCwxLjItMC41LDEuMi0xLjEKCQkJYzAtMC42LTAuNS0xLjItMS4yLTEuMmMtMC42LDAtMS4xLDAuNS0xLjEsMS4yQzYuMSw0OSw2LjYsNDkuNSw3LjIsNDkuNXogTTcuMiw0OGMwLjIsMCwwLjQsMC4yLDAuNCwwLjRjMCwwLjItMC4yLDAuNC0wLjQsMC40CgkJCWMtMC4yLDAtMC40LTAuMi0wLjQtMC40QzYuOCw0OC4xLDcsNDgsNy4yLDQ4eiIvPgoJCTxwYXRoIGZpbGw9IiNDMEMwQkYiIHN0cm9rZT0iI0MwQzBCRiIgc3Ryb2tlLXdpZHRoPSIwLjEiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTEwLDQzYy0zLjgsMC03LDMuMS03LDdjMCwzLjgsMy4xLDcsNyw3CgkJCXM3LTMuMSw3LTdDMTcsNDYuMiwxMy44LDQzLDEwLDQzeiBNMTAsNTYuMmMtMy40LDAtNi4yLTIuOC02LjItNi4yYzAtMy40LDIuOC02LjIsNi4yLTYuMnM2LjIsMi44LDYuMiw2LjIKCQkJQzE2LjIsNTMuNCwxMy40LDU2LjIsMTAsNTYuMnoiLz4KCTwvZz4KCTxnPgoJCTxnPgoJCQk8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNDMEMwQkYiIGQ9Ik02NC4xLDUzLjRsMi4zLDBjMC4yLDAsMC40LDAuMiwwLjQsMC40djIuMWMwLDAuMi0wLjIsMC40LTAuNCwwLjRoLTIuMwoJCQkJYy0wLjIsMC0wLjQtMC4yLTAuNC0wLjR2LTIuMUM2My43LDUzLjYsNjMuOCw1My40LDY0LjEsNTMuNHoiLz4KCQkJPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjQzBDMEJGIiBkPSJNNzMuNSw1My41aDIuNGMwLjIsMCwwLjQsMC4yLDAuNCwwLjR2MmMwLDAuMi0wLjIsMC40LTAuNCwwLjRoLTIuNAoJCQkJYy0wLjIsMC0wLjQtMC4yLTAuNC0wLjRsMC0yQzczLjEsNTMuNiw3My4zLDUzLjUsNzMuNSw1My41eiIvPgoJCQk8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNDMEMwQkYiIGQ9Ik02My43LDQ4LjRoMTIuNnY1SDYzLjdWNDguNHoiLz4KCQkJPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjQzBDMEJGIiBkPSJNNjUuNSw0My42aDguOWMxLDAsMS45LDAuOCwxLjksMS45djMuMUg2My43di0zLjFDNjMuNyw0NC41LDY0LjUsNDMuNiw2NS41LDQzLjZ6Ii8+CgkJCTxlbGxpcHNlIGZpbGw9IiNDMEMwQkYiIGN4PSI2Ni4yIiBjeT0iNTAuOSIgcng9IjAuOSIgcnk9IjEiLz4KCQkJPGVsbGlwc2UgZmlsbD0iI0MwQzBCRiIgY3g9IjczLjgiIGN5PSI1MC45IiByeD0iMC45IiByeT0iMSIvPgoJCTwvZz4KCTwvZz4KCTxnPgoJCTxnPgoJCQk8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNDMEMwQkYiIGQ9Ik05Ni40LDUwYzAsMy42LTIuOSw2LjUtNi40LDYuNXMtNi40LTIuOS02LjQtNi41czIuOS02LjUsNi40LTYuNVM5Ni40LDQ2LjQsOTYuNCw1MHoiLz4KCQkJPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjQzBDMEJGIiBkPSJNOTYuMyw0OC42YzAsMCwwLDAuMSwwLDAuMWMtMC45LDAuMS0yLjksMC4xLTQuNi0xLjJjLTEuMS0wLjgtMi0xLjctMi42LTIuNQoJCQkJYy0wLjMtMC40LTAuNi0wLjgtMC43LTFjLTAuMS0wLjEtMC4xLTAuMi0wLjEtMC4yYzAuNS0wLjEsMS4yLTAuMiwyLTAuMmMxLjIsMCwyLjUsMC4zLDMuNSwxLjFjMSwwLjgsMS43LDEuOCwyLjEsMi44CgkJCQlDOTYuMSw0Ny45LDk2LjIsNDguMyw5Ni4zLDQ4LjZ6Ii8+CgkJCTxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0MwQzBCRiIgZD0iTTg0LDUyLjJjMCwwLDAtMC4xLDAtMC4xYzAuOS0wLjIsMi45LTAuNCw0LjcsMC42YzEuMSwwLjcsMS45LDEuNSwyLjQsMi4zCgkJCQljMC40LDAuNSwwLjYsMSwwLjcsMS4zYy0wLjQsMC4xLTEsMC4yLTEuNywwLjNjLTEsMC0yLjEtMC4xLTMuMi0wLjhzLTEuOS0xLjYtMi40LTIuNUM4NC4yLDUyLjgsODQuMSw1Mi41LDg0LDUyLjJ6Ii8+CgkJPC9nPgoJPC9nPgoJPGc+CgkJPGc+CgkJCTxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0MwQzBCRiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBkPSJNMTE2LjMsNDYuOGwtMS40LDJsLTAuOC0wLjhsLTAuNi0wLjdsMCwwLjlsLTAuMSw4LjJoLTYuOAoJCQkJbC0wLjEtOC4ybDAtMC45bC0wLjYsMC43bC0wLjgsMC44bC0xLjQtMmwyLjYtMi45YzAuMS0wLjEsMC4yLTAuMSwwLjMtMC4xaDEuM2wwLjQsMC43YzAuNywxLjMsMi42LDEuMywzLjMtMC4xbDAuMy0wLjZoMS4yCgkJCQljMC4xLDAsMC4yLDAsMC4zLDAuMWwwLjMtMC4zbC0wLjMsMC4zTDExNi4zLDQ2Ljh6Ii8+CgkJCTxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0MwQzBCRiIgZD0iTTExMC4xLDQ3LjdoMnYwLjljMCwwLjQtMC40LDAuNy0xLDAuN2MtMC42LDAtMS0wLjMtMS0wLjdMMTEwLjEsNDcuN0wxMTAuMSw0Ny43eiIvPgoJCTwvZz4KCTwvZz4KCTxnPgoJCTxnPgoJCQk8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNDMEMwQkYiIGQ9Ik0xMjYuOCw1NC4zYzAsMS4yLTEsMi4yLTIuMiwyLjJzLTIuMi0xLTIuMi0yLjJzMS0yLjIsMi4yLTIuMlMxMjYuOCw1My4xLDEyNi44LDU0LjN6Ii8+CgkJCTxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0MwQzBCRiIgZD0iTTEzNy42LDU0LjNjMCwxLjItMSwyLjItMi4yLDIuMmMtMS4yLDAtMi4yLTEtMi4yLTIuMnMxLTIuMiwyLjItMi4yCgkJCQlDMTM2LjYsNTIuMSwxMzcuNiw1My4xLDEzNy42LDU0LjN6Ii8+CgkJCTxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0MwQzBCRiIgZD0iTTEyNi44LDQ0LjR2OS45Ii8+CgkJCTxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0MwQzBCRiIgZD0iTTEzNy43LDQ0LjR2OS45Ii8+CgkJCTxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0MwQzBCRiIgZD0iTTEyNi44LDQzLjVoMTAuOHYyLjdoLTEwLjhDMTI2LjgsNDYuMiwxMjYuOCw0My41LDEyNi44LDQzLjV6Ii8+CgkJPC9nPgoJPC9nPgoJPGc+CgkJPGc+CgkJCTxwYXRoIGZpbGw9IiNDMEMwQkYiIGQ9Ik0xNzAuOCw0My4xTDE3MC44LDQzLjFjLTAuMywwLTAuNSwwLTAuOCwwYy0yLjEsMC00LDEtNS4zLDIuNWwtMC4xLDBsLTAuMS0wLjFsLTEtMS4ybC0wLjMsMy40bDMuNCwwLjMKCQkJCWwtMS4xLTEuM2wtMC4xLTAuMWwwLjEtMC4xYzEuMS0xLjUsMy0yLjMsNS0yLjFsMCwwYzMuMiwwLjMsNS41LDMuMSw1LjIsNi4zYy0wLjMsMy0zLjEsNS4zLTYuMSw1LjFjLTMuMS0wLjItNS40LTIuOS01LjMtNgoJCQkJbC0xLjMtMC4xYy0wLjIsMy44LDIuNiw3LjEsNi4zLDcuNGMzLjksMC4zLDcuMy0yLjYsNy42LTYuNUMxNzcuMiw0Ni44LDE3NC40LDQzLjUsMTcwLjgsNDMuMXoiLz4KCQkJPHBhdGggZmlsbD0iI0MwQzBCRiIgZD0iTTE3MC4zLDQ3LjRjMC0wLjMtMC4zLTAuNi0wLjYtMC42cy0wLjYsMC4zLTAuNiwwLjZ2My4yYzAsMC4yLDAuMSwwLjMsMC4yLDAuNGMwLjEsMC4xLDAuMywwLjIsMC40LDAuMgoJCQkJaDIuNGMwLjQsMCwwLjYtMC4zLDAuNi0wLjZjMC0wLjMtMC4zLTAuNi0wLjYtMC42aC0xLjZoLTAuMnYtMC4yTDE3MC4zLDQ3LjRMMTcwLjMsNDcuNHoiLz4KCQk8L2c+Cgk8L2c+Cgk8Zz4KCQk8Zz4KCQkJPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjQzBDMEJGIiBkPSJNMTg2LjIsNDMuNGg3LjdjMS41LDAsMi43LDEuMiwyLjcsMi43djcuN2MwLDEuNS0xLjIsMi43LTIuNywyLjdoLTcuNwoJCQkJYy0xLjUsMC0yLjctMS4yLTIuNy0yLjd2LTcuN0MxODMuNCw0NC43LDE4NC43LDQzLjQsMTg2LjIsNDMuNHoiLz4KCQkJPGVsbGlwc2UgZmlsbD0iI0MwQzBCRiIgY3g9IjE4NiIgY3k9IjQ4LjkiIHJ4PSIwLjciIHJ5PSIwLjciLz4KCQkJPGVsbGlwc2UgZmlsbD0iI0MwQzBCRiIgY3g9IjE5NCIgY3k9IjQ2LjciIHJ4PSIwLjciIHJ5PSIwLjciLz4KCQkJPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjQzBDMEJGIiBzdHJva2UtbGluZWNhcD0icm91bmQiIGQ9Ik0xODYsNTMuM2wwLjQtMC4zYzAuNC0wLjMsMS0wLjMsMS41LTAuMWwxLDAuNAoJCQkJYzAuNSwwLjIsMSwwLjIsMS41LTAuMWwwLjgtMC41YzAuNC0wLjMsMS0wLjMsMS41LTAuMWwxLjgsMC44Ii8+CgkJPC9nPgoJPC9nPgoJPHBhdGggZmlsbD0iI0MwQzBCRiIgc3Ryb2tlPSIjQzBDMEJGIiBzdHJva2Utd2lkdGg9IjAuMjUiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTE1Niw0NC4zYy0wLjItMC4xLTAuNC0wLjEtMC41LDAKCQljMCwwLTAuMiwwLjEtMC45LDAuMmMtMC43LDAtMi40LTAuMS0zLjgtMC42Yy0wLjgtMC4zLTEuNy0wLjUtMi41LTAuNWMtMC4yLDAtMC40LDAtMC41LDBjLTEuMywwLTIuNSwwLjMtMy42LDEKCQljLTAuMiwwLjEtMC4yLDAuMi0wLjIsMC40djExLjZjMCwwLjMsMC4xLDAuNSwwLjMsMC41YzAuNiwwLDAuNS0wLjQsMC41LTAuNnYtNS43YzAuNy0wLjMsMy4yLTEuMSw1LjgtMC4xCgkJYzEuNiwwLjYsMy41LDAuNyw0LjMsMC43YzAuOCwwLDEuMy0wLjMsMS4zLTAuM2MwLjItMC4xLDAuMy0wLjIsMC4zLTAuNHYtNS43QzE1Ni4yLDQ0LjYsMTU2LjEsNDQuNCwxNTYsNDQuM3ogTTE1NS42LDUwLjIKCQljLTAuMSwwLTAuNywwLjEtMSwwLjFjLTAuNywwLTIuNC0wLjEtMy44LTAuNmMtMi41LTEtNS0wLjUtNi4yLTAuMXYtNC45YzAuOS0wLjUsMi4yLTAuNywzLjItMC43YzAuMSwwLDAuMywwLDAuNCwwCgkJYzAuNywwLDEuNSwwLjIsMi4yLDAuNGMxLjYsMC42LDMuNSwwLjcsNC4zLDAuN2MwLjIsMCwwLjgsMCwxLTAuMVY1MC4yeiIvPgoJPGc+CgkJPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjQzBDMEJGIiBkPSJNNDguMSw0My41aDMuN2MyLjUsMCw0LjUsMiw0LjUsNC41YzAsMC41LTAuNCwwLjktMC45LDAuOUg0NC41Yy0wLjUsMC0wLjktMC40LTAuOS0wLjkKCQkJQzQzLjYsNDUuNSw0NS42LDQzLjUsNDguMSw0My41eiIvPgoJCTxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0MwQzBCRiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBkPSJNNDMuNSw0OC44Yy0wLjIsMC4xLTAuNSwxLjIsMCwxLjVjMS40LDEsOC41LDAuOCwxMS4zLDAuNgoJCQljMC44LTAuMSwxLjYtMC40LDEuNy0xLjJjMC0wLjMtMC4xLTAuNi0wLjYtMC45Ii8+CgkJPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjQzBDMEJGIiBzdHJva2UtbGluZWNhcD0icm91bmQiIGQ9Ik00My41LDUwLjZMNDMuMyw1MWMtMC4yLDAuNSwwLjIsMSwwLjcsMC45YzAuMy0wLjEsMC41LDAsMC43LDAuMwoJCQlsMC4xLDAuMmMwLjMsMC41LDEsMC42LDEuNSwwLjJsMCwwYzAuMy0wLjIsMC43LTAuMywxLTAuMmwwLjgsMC4zYzAuNCwwLjIsMC44LDAuMSwxLjIsMGwwLjUtMC4yYzAuNC0wLjIsMC45LTAuMiwxLjMsMGwwLjUsMC4yCgkJCWMwLjQsMC4yLDAuOCwwLjIsMS4yLDBsMC4yLTAuMWMwLjMtMC4yLDAuOC0wLjIsMS4xLDAuMWwwLjIsMC4yYzAuMywwLjMsMC44LDAuMiwxLTAuMmwwLjEtMC4yYzAuMS0wLjIsMC0wLjMsMC4yLTAuMwoJCQljMC41LDAsMS4yLTAuMywxLjEtMC43bC0wLjQtMS4xIi8+CgkJPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjQzBDMEJGIiBzdHJva2UtbGluZWNhcD0icm91bmQiIGQ9Ik00My41LDUyLjJjLTAuMSwwLjItMC4zLDAuOCwwLDEuMWMwLjMsMC40LDMsMS4xLDYuNCwxLjEKCQkJYzIuMiwwLDQuNi0wLjMsNi0wLjZjMC41LTAuMSwwLjktMC41LDAuOC0wLjljMC0wLjItMC4yLTAuNS0wLjQtMC43Ii8+CgkJPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjQzBDMEJGIiBzdHJva2UtbGluZWNhcD0icm91bmQiIGQ9Ik00My41LDUzLjNjMCwwLjUsMC42LDIuMywxLjMsMi43YzEuOCwwLjgsNS43LDAuNyw4LjEsMC41CgkJCWMxLjMtMC4xLDIuNS0wLjcsMy4yLTEuOGMwLjMtMC41LDAuNS0xLDAuNS0xLjQiLz4KCQk8ZWxsaXBzZSBmaWxsPSIjQzBDMEJGIiBjeD0iNTEuNiIgY3k9IjQ2LjUiIHJ4PSIwLjMiIHJ5PSIwLjQiLz4KCQk8ZWxsaXBzZSBmaWxsPSIjQzBDMEJGIiBjeD0iNTMiIGN5PSI0NSIgcng9IjAuMyIgcnk9IjAuNCIvPgoJCTxlbGxpcHNlIGZpbGw9IiNDMEMwQkYiIGN4PSI1MyIgY3k9IjQ3LjIiIHJ4PSIwLjMiIHJ5PSIwLjQiLz4KCQk8ZWxsaXBzZSBmaWxsPSIjQzBDMEJGIiBjeD0iNTQuMyIgY3k9IjQ2LjUiIHJ4PSIwLjMiIHJ5PSIwLjQiLz4KCQk8ZWxsaXBzZSBmaWxsPSIjQzBDMEJGIiBjeD0iNTAuOSIgY3k9IjQ1IiByeD0iMC4zIiByeT0iMC40Ii8+Cgk8L2c+Cgk8Zz4KCQk8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNDMEMwQkYiIGQ9Ik0yNC4yLDUxdi03LjZjMC4xLDAuMSwwLjgsMC45LDIuOCwzLjFjMi41LTEuNyw1LjYtMC43LDYuOSwwbDIuNC0zLjF2Ny4xCgkJCWMwLDEuMi0wLjEsMi41LTAuOSwzLjRjLTEsMS4yLTIuNywyLjUtNS4zLDIuNWMtMi45LDAtNC41LTEuNS01LjMtMi45QzI0LjIsNTIuOSwyNC4yLDUyLDI0LjIsNTF6Ii8+CgkJPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjQzBDMEJGIiBzdHJva2UtbGluZWNhcD0icm91bmQiIGQ9Ik0yMS4yLDUwbDUuNCwxLjIiLz4KCQk8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNDMEMwQkYiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgZD0iTTIxLjIsNTQuMWw1LjQtMS4yIi8+CgkJPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjQzBDMEJGIiBzdHJva2UtbGluZWNhcD0icm91bmQiIGQ9Ik0zOC44LDUwbC01LjQsMS4yIi8+CgkJPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjQzBDMEJGIiBzdHJva2UtbGluZWNhcD0icm91bmQiIGQ9Ik0zOC44LDU0LjFsLTUuNC0xLjIiLz4KCQk8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZmlsbD0iI0MwQzBCRiIgZD0iTTI5LjUsNTIuNEwyOSw1MS43Yy0wLjItMC4zLDAtMC42LDAuMy0wLjZoMS40CgkJCWMwLjMsMCwwLjUsMC40LDAuMywwLjZsLTAuNywxbDAsMGMtMC43LDEuMi0yLjYsMS4xLTMuMS0wLjNsLTAuMS0wLjJjLTAuMS0wLjIsMC0wLjQsMC4yLTAuNXMwLjQsMCwwLjUsMC4ybDAuMSwwLjIKCQkJQzI4LjMsNTIuOCwyOS4xLDUyLjksMjkuNSw1Mi40eiIvPgoJCTxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0MwQzBCRiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBkPSJNMzIuNCw1Mi4xbC0wLjEsMC4yYy0wLjQsMS0xLjgsMS4xLTIuMywwLjIiLz4KCQk8ZWxsaXBzZSBmaWxsPSIjQzBDMEJGIiBjeD0iMjcuNiIgY3k9IjQ5LjciIHJ4PSIwLjciIHJ5PSIwLjciLz4KCQk8ZWxsaXBzZSBmaWxsPSIjQzBDMEJGIiBjeD0iMzIuNCIgY3k9IjQ5LjciIHJ4PSIwLjciIHJ5PSIwLjciLz4KCTwvZz4KCTxnPgoJCTxwYXRoIGZpbGw9IiM2QUE5REQiIHN0cm9rZT0iIzZBQTlERCIgc3Ryb2tlLXdpZHRoPSIwLjEiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTE0LjYsNzEuMmMtMC4xLTAuMS0wLjItMC4yLTAuMy0wLjJINS43CgkJCWMtMC4xLDAtMC4yLDAuMS0wLjMsMC4yYy0wLjEsMC4xLTAuMSwwLjIsMCwwLjRjMC43LDIsMi41LDMuMyw0LjYsMy4zczMuOS0xLjMsNC42LTMuM0MxNC43LDcxLjUsMTQuNyw3MS4zLDE0LjYsNzEuMnogTTEwLDc0LjEKCQkJYy0xLjYsMC0zLTAuOS0zLjctMi4yaDcuM0MxMyw3My4yLDExLjYsNzQuMSwxMCw3NC4xeiIvPgoJCTxwYXRoIGZpbGw9IiM2QUE5REQiIHN0cm9rZT0iIzZBQTlERCIgc3Ryb2tlLXdpZHRoPSIwLjEiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTEyLjgsNjkuNWMwLjYsMCwxLjEtMC41LDEuMS0xLjEKCQkJYzAtMC42LTAuNS0xLjItMS4xLTEuMmMtMC42LDAtMS4yLDAuNS0xLjIsMS4yQzExLjYsNjksMTIuMiw2OS41LDEyLjgsNjkuNXogTTEyLjgsNjhjMC4yLDAsMC40LDAuMiwwLjQsMC40CgkJCWMwLDAuMi0wLjIsMC40LTAuNCwwLjRjLTAuMiwwLTAuNC0wLjItMC40LTAuNEMxMi40LDY4LjEsMTIuNiw2OCwxMi44LDY4eiIvPgoJCTxwYXRoIGZpbGw9IiM2QUE5REQiIHN0cm9rZT0iIzZBQTlERCIgc3Ryb2tlLXdpZHRoPSIwLjEiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTcuMiw2OS41YzAuNiwwLDEuMi0wLjUsMS4yLTEuMQoJCQljMC0wLjYtMC41LTEuMi0xLjItMS4yYy0wLjYsMC0xLjEsMC41LTEuMSwxLjJDNi4xLDY5LDYuNiw2OS41LDcuMiw2OS41eiBNNy4yLDY4YzAuMiwwLDAuNCwwLjIsMC40LDAuNGMwLDAuMi0wLjIsMC40LTAuNCwwLjQKCQkJYy0wLjIsMC0wLjQtMC4yLTAuNC0wLjRDNi44LDY4LjEsNyw2OCw3LjIsNjh6Ii8+CgkJPHBhdGggZmlsbD0iIzZBQTlERCIgc3Ryb2tlPSIjNkFBOUREIiBzdHJva2Utd2lkdGg9IjAuMSIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMTAsNjNjLTMuOCwwLTcsMy4xLTcsN2MwLDMuOCwzLjEsNyw3LDcKCQkJczctMy4xLDctN0MxNyw2Ni4yLDEzLjgsNjMsMTAsNjN6IE0xMCw3Ni4yYy0zLjQsMC02LjItMi44LTYuMi02LjJjMC0zLjQsMi44LTYuMiw2LjItNi4yczYuMiwyLjgsNi4yLDYuMgoJCQlDMTYuMiw3My40LDEzLjQsNzYuMiwxMCw3Ni4yeiIvPgoJPC9nPgoJPGc+CgkJPGc+CgkJCTxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzZBQTlERCIgZD0iTTY0LjEsNzMuNGwyLjMsMGMwLjIsMCwwLjQsMC4yLDAuNCwwLjR2Mi4xYzAsMC4yLTAuMiwwLjQtMC40LDAuNGgtMi4zCgkJCQljLTAuMiwwLTAuNC0wLjItMC40LTAuNHYtMi4xQzYzLjcsNzMuNiw2My44LDczLjQsNjQuMSw3My40eiIvPgoJCQk8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiM2QUE5REQiIGQ9Ik03My41LDczLjVoMi40YzAuMiwwLDAuNCwwLjIsMC40LDAuNHYyLjFjMCwwLjItMC4yLDAuNC0wLjQsMC40aC0yLjQKCQkJCWMtMC4yLDAtMC40LTAuMi0wLjQtMC40bDAtMi4xQzczLjEsNzMuNiw3My4zLDczLjUsNzMuNSw3My41eiIvPgoJCQk8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiM2QUE5REQiIGQ9Ik02My43LDY4LjRoMTIuNnY1SDYzLjdWNjguNHoiLz4KCQkJPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjNkFBOUREIiBkPSJNNjUuNSw2My42aDguOWMxLDAsMS45LDAuOCwxLjksMS45djMuMUg2My43di0zLjFDNjMuNyw2NC41LDY0LjUsNjMuNiw2NS41LDYzLjZ6Ii8+CgkJCTxlbGxpcHNlIGZpbGw9IiM2QUE5REQiIGN4PSI2Ni4yIiBjeT0iNzAuOSIgcng9IjAuOSIgcnk9IjAuOSIvPgoJCQk8ZWxsaXBzZSBmaWxsPSIjNkFBOUREIiBjeD0iNzMuOCIgY3k9IjcwLjkiIHJ4PSIwLjkiIHJ5PSIwLjkiLz4KCQk8L2c+Cgk8L2c+Cgk8Zz4KCQk8Zz4KCQkJPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjNkFBOUREIiBkPSJNOTYuNCw3MGMwLDMuNi0yLjksNi41LTYuNCw2LjVzLTYuNC0yLjktNi40LTYuNXMyLjktNi41LDYuNC02LjVTOTYuNCw2Ni40LDk2LjQsNzB6Ii8+CgkJCTxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzZBQTlERCIgZD0iTTk2LjMsNjguNmMwLDAsMCwwLjEsMCwwLjFjLTAuOSwwLjEtMi45LDAuMS00LjYtMS4yYy0xLjEtMC44LTItMS43LTIuNi0yLjUKCQkJCWMtMC4zLTAuNC0wLjYtMC44LTAuNy0xLjFjLTAuMS0wLjEtMC4xLTAuMi0wLjEtMC4yYzAuNS0wLjEsMS4yLTAuMiwyLTAuMmMxLjIsMCwyLjUsMC4zLDMuNSwxLjFjMSwwLjgsMS43LDEuOCwyLjEsMi44CgkJCQlDOTYuMSw2Ny45LDk2LjIsNjguMyw5Ni4zLDY4LjZ6Ii8+CgkJCTxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzZBQTlERCIgZD0iTTg0LDcyLjJjMCwwLDAtMC4xLDAtMC4xYzAuOS0wLjIsMi45LTAuNCw0LjcsMC42YzEuMSwwLjcsMS45LDEuNSwyLjQsMi4zCgkJCQljMC40LDAuNSwwLjYsMSwwLjcsMS4zYy0wLjQsMC4xLTEsMC4yLTEuNywwLjNjLTEsMC0yLjEtMC4xLTMuMi0wLjhzLTEuOS0xLjYtMi40LTIuNUM4NC4yLDcyLjgsODQuMSw3Mi40LDg0LDcyLjJ6Ii8+CgkJPC9nPgoJPC9nPgoJPGc+CgkJPGc+CgkJCTxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzZBQTlERCIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBkPSJNMTE2LjMsNjYuOGwtMS40LDJsLTAuOC0wLjhsLTAuNi0wLjdsMCwwLjlsLTAuMSw4LjJoLTYuOAoJCQkJbC0wLjEtOC4ybDAtMC45bC0wLjYsMC43bC0wLjgsMC44bC0xLjQtMmwyLjYtMi45YzAuMS0wLjEsMC4yLTAuMSwwLjMtMC4xaDEuM2wwLjQsMC43YzAuNywxLjMsMi42LDEuMywzLjMtMC4xbDAuMy0wLjZoMS4yCgkJCQljMC4xLDAsMC4yLDAsMC4zLDAuMWwwLjMtMC4zbC0wLjMsMC4zTDExNi4zLDY2Ljh6Ii8+CgkJCTxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzZBQTlERCIgZD0iTTExMC4xLDY3LjdoMnYwLjljMCwwLjQtMC40LDAuNy0xLDAuN2MtMC42LDAtMS0wLjMtMS0wLjdMMTEwLjEsNjcuN0wxMTAuMSw2Ny43eiIvPgoJCTwvZz4KCTwvZz4KCTxnPgoJCTxnPgoJCQk8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiM2QUE5REQiIGQ9Ik0xMjYuOCw3NC4zYzAsMS4yLTEsMi4yLTIuMiwyLjJzLTIuMi0xLTIuMi0yLjJzMS0yLjIsMi4yLTIuMlMxMjYuOCw3My4xLDEyNi44LDc0LjN6Ii8+CgkJCTxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzZBQTlERCIgZD0iTTEzNy42LDc0LjNjMCwxLjItMSwyLjItMi4yLDIuMmMtMS4yLDAtMi4yLTEtMi4yLTIuMnMxLTIuMiwyLjItMi4yCgkJCQlDMTM2LjYsNzIuMSwxMzcuNiw3My4xLDEzNy42LDc0LjN6Ii8+CgkJCTxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzZBQTlERCIgZD0iTTEyNi44LDY0LjR2OS45Ii8+CgkJCTxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzZBQTlERCIgZD0iTTEzNy43LDY0LjR2OS45Ii8+CgkJCTxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzZBQTlERCIgZD0iTTEyNi44LDYzLjVoMTAuOHYyLjdoLTEwLjhDMTI2LjgsNjYuMiwxMjYuOCw2My41LDEyNi44LDYzLjV6Ii8+CgkJPC9nPgoJPC9nPgoJPGc+CgkJPGc+CgkJCTxwYXRoIGZpbGw9IiM2QUE5REQiIGQ9Ik0xNzAuOCw2My4xTDE3MC44LDYzLjFjLTAuMywwLTAuNSwwLTAuOCwwYy0yLjEsMC00LDEtNS4zLDIuNWwtMC4xLDBsLTAuMS0wLjFsLTEtMS4ybC0wLjMsMy40bDMuNCwwLjMKCQkJCWwtMS4xLTEuM2wtMC4xLTAuMWwwLjEtMC4xYzEuMS0xLjQsMy0yLjMsNS0yLjFsMCwwYzMuMiwwLjMsNS41LDMuMSw1LjIsNi4zYy0wLjMsMy0zLjEsNS4zLTYuMSw1LjFjLTMuMS0wLjItNS40LTIuOS01LjMtNgoJCQkJbC0xLjMtMC4xYy0wLjIsMy44LDIuNiw3LjEsNi4zLDcuNGMzLjksMC4zLDcuMy0yLjYsNy42LTYuNUMxNzcuMiw2Ni44LDE3NC40LDYzLjUsMTcwLjgsNjMuMXoiLz4KCQkJPHBhdGggZmlsbD0iIzZBQTlERCIgZD0iTTE3MC4zLDY3LjRjMC0wLjMtMC4zLTAuNi0wLjYtMC42cy0wLjYsMC4zLTAuNiwwLjZ2My4yYzAsMC4yLDAuMSwwLjMsMC4yLDAuNGMwLjEsMC4xLDAuMywwLjIsMC40LDAuMgoJCQkJaDIuNGMwLjQsMCwwLjYtMC4zLDAuNi0wLjZTMTcyLjQsNzAsMTcyLDcwaC0xLjZoLTAuMnYtMC4yTDE3MC4zLDY3LjRMMTcwLjMsNjcuNHoiLz4KCQk8L2c+Cgk8L2c+Cgk8Zz4KCQk8Zz4KCQkJPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjNkFBOUREIiBkPSJNMTg2LjIsNjMuNGg3LjdjMS41LDAsMi43LDEuMiwyLjcsMi43djcuN2MwLDEuNS0xLjIsMi43LTIuNywyLjdoLTcuNwoJCQkJYy0xLjUsMC0yLjctMS4yLTIuNy0yLjd2LTcuN0MxODMuNCw2NC43LDE4NC43LDYzLjQsMTg2LjIsNjMuNHoiLz4KCQkJPGVsbGlwc2UgZmlsbD0iIzZBQTlERCIgY3g9IjE4NiIgY3k9IjY4LjkiIHJ4PSIwLjciIHJ5PSIwLjciLz4KCQkJPGVsbGlwc2UgZmlsbD0iIzZBQTlERCIgY3g9IjE5NCIgY3k9IjY2LjciIHJ4PSIwLjciIHJ5PSIwLjciLz4KCQkJPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjNkFBOUREIiBzdHJva2UtbGluZWNhcD0icm91bmQiIGQ9Ik0xODYsNzMuM2wwLjQtMC4zYzAuNC0wLjMsMS0wLjMsMS41LTAuMWwxLDAuNAoJCQkJYzAuNSwwLjIsMSwwLjIsMS41LTAuMWwwLjgtMC41YzAuNC0wLjMsMS0wLjMsMS41LTAuMWwxLjgsMC44Ii8+CgkJPC9nPgoJPC9nPgoJPHBhdGggZmlsbD0iIzZBQTlERCIgc3Ryb2tlPSIjNkFBOUREIiBzdHJva2Utd2lkdGg9IjAuMjUiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTE1Niw2NC4zYy0wLjItMC4xLTAuNC0wLjEtMC41LDAKCQljMCwwLTAuMiwwLjEtMC45LDAuMmMtMC43LDAtMi40LTAuMS0zLjgtMC42Yy0wLjgtMC4zLTEuNy0wLjUtMi41LTAuNWMtMC4yLDAtMC40LDAtMC41LDBjLTEuMywwLTIuNSwwLjMtMy42LDEKCQljLTAuMiwwLjEtMC4yLDAuMi0wLjIsMC40djExLjZjMCwwLjMsMC4xLDAuNSwwLjMsMC41YzAuNiwwLDAuNS0wLjQsMC41LTAuNnYtNS43YzAuNy0wLjMsMy4yLTEuMSw1LjgtMC4xCgkJYzEuNiwwLjYsMy41LDAuNyw0LjMsMC43YzAuOCwwLDEuMy0wLjMsMS4zLTAuM2MwLjItMC4xLDAuMy0wLjIsMC4zLTAuNHYtNS43QzE1Ni4yLDY0LjYsMTU2LjEsNjQuNCwxNTYsNjQuM3ogTTE1NS42LDcwLjIKCQljLTAuMSwwLTAuNywwLjEtMSwwLjFjLTAuNywwLTIuNC0wLjEtMy44LTAuNmMtMi41LTEtNS0wLjUtNi4yLTAuMXYtNC45YzAuOS0wLjUsMi4yLTAuNywzLjItMC43YzAuMSwwLDAuMywwLDAuNCwwCgkJYzAuNywwLDEuNSwwLjIsMi4yLDAuNGMxLjYsMC42LDMuNSwwLjcsNC4zLDAuN2MwLjIsMCwwLjgsMCwxLTAuMVY3MC4yeiIvPgoJPGc+CgkJPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjNkFBOUREIiBkPSJNNDguMSw2My41aDMuN2MyLjUsMCw0LjUsMiw0LjUsNC41YzAsMC41LTAuNCwwLjktMC45LDAuOUg0NC41Yy0wLjUsMC0wLjktMC40LTAuOS0wLjkKCQkJQzQzLjYsNjUuNSw0NS42LDYzLjUsNDguMSw2My41eiIvPgoJCTxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzZBQTlERCIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBkPSJNNDMuNSw2OC44Yy0wLjIsMC4xLTAuNSwxLjIsMCwxLjVjMS40LDAuOSw4LjUsMC44LDExLjMsMC42CgkJCWMwLjgtMC4xLDEuNi0wLjQsMS43LTEuMmMwLTAuMy0wLjEtMC42LTAuNi0wLjkiLz4KCQk8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiM2QUE5REQiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgZD0iTTQzLjUsNzAuNkw0My4zLDcxYy0wLjIsMC41LDAuMiwxLDAuNywwLjljMC4zLTAuMSwwLjUsMC4xLDAuNywwLjMKCQkJbDAuMSwwLjJjMC4zLDAuNSwxLDAuNiwxLjUsMC4ybDAsMGMwLjMtMC4yLDAuNy0wLjMsMS0wLjJsMC44LDAuM2MwLjQsMC4yLDAuOCwwLjEsMS4yLDBsMC41LTAuMmMwLjQtMC4yLDAuOS0wLjIsMS4zLDBsMC41LDAuMgoJCQljMC40LDAuMiwwLjgsMC4yLDEuMi0wLjFsMC4yLTAuMWMwLjMtMC4yLDAuOC0wLjIsMS4xLDAuMWwwLjIsMC4yYzAuMywwLjMsMC44LDAuMiwxLTAuMmwwLjEtMC4yYzAuMS0wLjIsMC0wLjMsMC4yLTAuMwoJCQljMC41LDAsMS4yLTAuMywxLjEtMC43bC0wLjQtMS4xIi8+CgkJPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjNkFBOUREIiBzdHJva2UtbGluZWNhcD0icm91bmQiIGQ9Ik00My41LDcyLjJjLTAuMSwwLjItMC4zLDAuOCwwLDEuMWMwLjMsMC40LDMsMS4xLDYuNCwxLjEKCQkJYzIuMiwwLDQuNi0wLjMsNi0wLjZjMC41LTAuMSwwLjktMC40LDAuOC0wLjljMC0wLjItMC4yLTAuNS0wLjQtMC43Ii8+CgkJPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjNkFBOUREIiBzdHJva2UtbGluZWNhcD0icm91bmQiIGQ9Ik00My41LDczLjNjMCwwLjUsMC42LDIuMywxLjMsMi43YzEuOCwwLjgsNS43LDAuNyw4LjEsMC41CgkJCWMxLjMtMC4xLDIuNS0wLjcsMy4yLTEuOGMwLjMtMC41LDAuNS0xLDAuNS0xLjQiLz4KCQk8ZWxsaXBzZSBmaWxsPSIjNkFBOUREIiBjeD0iNTEuNiIgY3k9IjY2LjUiIHJ4PSIwLjMiIHJ5PSIwLjQiLz4KCQk8ZWxsaXBzZSBmaWxsPSIjNkFBOUREIiBjeD0iNTMiIGN5PSI2NSIgcng9IjAuMyIgcnk9IjAuNCIvPgoJCTxlbGxpcHNlIGZpbGw9IiM2QUE5REQiIGN4PSI1MyIgY3k9IjY3LjIiIHJ4PSIwLjMiIHJ5PSIwLjQiLz4KCQk8ZWxsaXBzZSBmaWxsPSIjNkFBOUREIiBjeD0iNTQuMyIgY3k9IjY2LjUiIHJ4PSIwLjMiIHJ5PSIwLjQiLz4KCQk8ZWxsaXBzZSBmaWxsPSIjNkFBOUREIiBjeD0iNTAuOSIgY3k9IjY1IiByeD0iMC4zIiByeT0iMC40Ii8+Cgk8L2c+Cgk8Zz4KCQk8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiM2QUE5REQiIGQ9Ik0yNC4yLDcxdi03LjZjMC4xLDAuMSwwLjgsMC45LDIuOCwzLjFjMi41LTEuNyw1LjYtMC43LDYuOSwwbDIuNC0zLjF2Ny4xCgkJCWMwLDEuMi0wLjEsMi41LTAuOSwzLjRjLTEsMS4yLTIuNywyLjUtNS4zLDIuNWMtMi45LDAtNC41LTEuNS01LjMtMi45QzI0LjIsNzIuOSwyNC4yLDcyLDI0LjIsNzF6Ii8+CgkJPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjNkFBOUREIiBzdHJva2UtbGluZWNhcD0icm91bmQiIGQ9Ik0yMS4yLDcwLjFsNS40LDEuMiIvPgoJCTxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzZBQTlERCIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBkPSJNMjEuMiw3NC4xbDUuNC0xLjIiLz4KCQk8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiM2QUE5REQiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgZD0iTTM4LjgsNzAuMWwtNS40LDEuMiIvPgoJCTxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzZBQTlERCIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBkPSJNMzguOCw3NC4xbC01LjQtMS4yIi8+CgkJPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGZpbGw9IiM2QUE5REQiIGQ9Ik0yOS41LDcyLjRMMjksNzEuN2MtMC4yLTAuMywwLTAuNiwwLjMtMC42aDEuNAoJCQljMC4zLDAsMC41LDAuNCwwLjMsMC42bC0wLjcsMWwwLDBjLTAuNywxLjItMi42LDEuMS0zLjEtMC4zbC0wLjEtMC4yYy0wLjEtMC4yLDAtMC40LDAuMi0wLjVjMC4yLTAuMSwwLjQsMCwwLjUsMC4ybDAuMSwwLjIKCQkJQzI4LjMsNzIuOCwyOS4xLDcyLjksMjkuNSw3Mi40eiIvPgoJCTxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzZBQTlERCIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBkPSJNMzIuNCw3Mi4xbC0wLjEsMC4yYy0wLjQsMS0xLjgsMS4xLTIuMywwLjIiLz4KCQk8ZWxsaXBzZSBmaWxsPSIjNkFBOUREIiBjeD0iMjcuNiIgY3k9IjY5LjciIHJ4PSIwLjciIHJ5PSIwLjciLz4KCQk8ZWxsaXBzZSBmaWxsPSIjNkFBOUREIiBjeD0iMzIuNCIgY3k9IjY5LjciIHJ4PSIwLjciIHJ5PSIwLjciLz4KCTwvZz4KPC9nPgo8Zz4KCTxwYXRoIGZpbGw9IiM4Njg2ODYiIHN0cm9rZT0iIzg2ODY4NiIgc3Ryb2tlLXdpZHRoPSIwLjEiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTEyLjgsOS41YzAuNiwwLDEuMS0wLjUsMS4xLTEuMgoJCWMwLTAuNi0wLjUtMS4xLTEuMS0xLjFjLTAuNiwwLTEuMiwwLjUtMS4yLDEuMVMxMi4yLDkuNSwxMi44LDkuNXogTTEyLjgsNy45YzAuMiwwLDAuNCwwLjIsMC40LDAuNGMwLDAuMi0wLjIsMC40LTAuNCwwLjQKCQljLTAuMiwwLTAuNC0wLjItMC40LTAuNEMxMi40LDguMSwxMi42LDcuOSwxMi44LDcuOXoiLz4KCTxwYXRoIGZpbGw9IiM4Njg2ODYiIHN0cm9rZT0iIzg2ODY4NiIgc3Ryb2tlLXdpZHRoPSIwLjEiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTcuMiw5LjVjMC42LDAsMS4yLTAuNSwxLjItMS4yCgkJYzAtMC42LTAuNS0xLjEtMS4yLTEuMWMtMC42LDAtMS4xLDAuNS0xLjEsMS4xUzYuNiw5LjUsNy4yLDkuNXogTTcuMiw3LjljMC4yLDAsMC40LDAuMiwwLjQsMC40YzAsMC4yLTAuMiwwLjQtMC40LDAuNAoJCUM3LDguNyw2LjgsOC41LDYuOCw4LjNDNi44LDguMSw3LDcuOSw3LjIsNy45eiIvPgoJPHBhdGggZmlsbD0iIzg2ODY4NiIgc3Ryb2tlPSIjODY4Njg2IiBzdHJva2Utd2lkdGg9IjAuMSIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMTQuNiwxMS4yYy0wLjEtMC4xLTAuMi0wLjItMC4zLTAuMkg1LjcKCQljLTAuMSwwLTAuMiwwLjEtMC4zLDAuMmMtMC4xLDAuMS0wLjEsMC4yLDAsMC40YzAuNywyLDIuNSwzLjMsNC42LDMuM3MzLjktMS4zLDQuNi0zLjNDMTQuNywxMS40LDE0LjcsMTEuMywxNC42LDExLjJ6IE0xMCwxNC4xCgkJYy0xLjYsMC0zLTAuOS0zLjctMi4yaDcuM0MxMywxMy4yLDExLjYsMTQuMSwxMCwxNC4xeiIvPgoJPHBhdGggZmlsbD0iIzg2ODY4NiIgc3Ryb2tlPSIjODY4Njg2IiBzdHJva2Utd2lkdGg9IjAuMSIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMTAsM2MtMy44LDAtNywzLjEtNyw3czMuMSw3LDcsN3M3LTMuMSw3LTcKCQlTMTMuOCwzLDEwLDN6IE0xMCwxNi4yYy0zLjQsMC02LjItMi44LTYuMi02LjJTNi42LDMuOCwxMCwzLjhzNi4yLDIuOCw2LjIsNi4yUzEzLjQsMTYuMiwxMCwxNi4yeiIvPgo8L2c+CjxnIGlkPSJDYXJfMDAwMDAwMTg5MzUzOTUwODU0MTM0MTM3NTAwMDAwMDA4MjUyNzM4Nzc4NDI3NzU3MTVfIj4KCTxnPgoJCTxnPgoJCQk8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiM4Njg2ODYiIGQ9Ik02NC4xLDEzLjRsMi4zLDBjMC4yLDAsMC40LDAuMiwwLjQsMC40djIuMWMwLDAuMi0wLjIsMC40LTAuNCwwLjRoLTIuMwoJCQkJYy0wLjIsMC0wLjQtMC4yLTAuNC0wLjR2LTIuMUM2My43LDEzLjYsNjMuOCwxMy40LDY0LjEsMTMuNHoiLz4KCQkJPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjODY4Njg2IiBkPSJNNzMuNSwxMy40aDIuNGMwLjIsMCwwLjQsMC4yLDAuNCwwLjR2Mi4xYzAsMC4yLTAuMiwwLjQtMC40LDAuNGgtMi40CgkJCQljLTAuMiwwLTAuNC0wLjItMC40LTAuNGwwLTIuMUM3My4xLDEzLjYsNzMuMywxMy40LDczLjUsMTMuNHoiLz4KCQkJPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjODY4Njg2IiBkPSJNNjMuNyw4LjRoMTIuNnY1SDYzLjdWOC40eiIvPgoJCQk8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiM4Njg2ODYiIGQ9Ik02NS41LDMuNmg4LjljMSwwLDEuOSwwLjgsMS45LDEuOXYzLjFINjMuN1Y1LjVDNjMuNyw0LjQsNjQuNSwzLjYsNjUuNSwzLjZ6Ii8+CgkJCTxlbGxpcHNlIGZpbGw9IiM4Njg2ODYiIGN4PSI2Ni4yIiBjeT0iMTAuOSIgcng9IjAuOSIgcnk9IjAuOSIvPgoJCQk8ZWxsaXBzZSBmaWxsPSIjODY4Njg2IiBjeD0iNzMuOCIgY3k9IjEwLjkiIHJ4PSIwLjkiIHJ5PSIwLjkiLz4KCQk8L2c+Cgk8L2c+CjwvZz4KPGcgaWQ9IkFjdGl2aXRpZXMiPgoJPGc+CgkJPGc+CgkJCTxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzg2ODY4NiIgZD0iTTk2LjQsMTBjMCwzLjYtMi45LDYuNS02LjQsNi41cy02LjQtMi45LTYuNC02LjVzMi45LTYuNSw2LjQtNi41Uzk2LjQsNi40LDk2LjQsMTB6Ii8+CgkJCTxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzg2ODY4NiIgZD0iTTk2LjMsOC42YzAsMCwwLDAuMSwwLDAuMWMtMC45LDAuMS0yLjksMC4xLTQuNi0xLjJjLTEuMS0wLjgtMi0xLjctMi42LTIuNQoJCQkJYy0wLjMtMC40LTAuNi0wLjgtMC43LTEuMWMtMC4xLTAuMS0wLjEtMC4yLTAuMS0wLjJjMC41LTAuMSwxLjItMC4yLDItMC4yYzEuMiwwLDIuNSwwLjMsMy41LDEuMWMxLDAuOCwxLjcsMS44LDIuMSwyLjgKCQkJCUM5Ni4xLDcuOSw5Ni4yLDguMyw5Ni4zLDguNnoiLz4KCQkJPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjODY4Njg2IiBkPSJNODQsMTIuMWMwLDAsMC0wLjEsMC0wLjFjMC45LTAuMiwyLjktMC40LDQuNywwLjZjMS4xLDAuNiwxLjksMS41LDIuNCwyLjMKCQkJCWMwLjQsMC41LDAuNiwxLDAuNywxLjNjLTAuNCwwLjEtMSwwLjItMS43LDAuM2MtMSwwLTIuMS0wLjEtMy4yLTAuOGMtMS4xLTAuNi0xLjktMS42LTIuNC0yLjVDODQuMiwxMi44LDg0LjEsMTIuNCw4NCwxMi4xeiIvPgoJCTwvZz4KCTwvZz4KPC9nPgo8ZyBpZD0iT2JqZWN0c18wMDAwMDA2NDMxMjM3MTczOTEzMDMxNTI1MDAwMDAxMDIyNTg4OTAzMjIyODYzMjk3NV8iPgoJPGc+CgkJPGc+CgkJCTxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzg2ODY4NiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBkPSJNMTE2LjMsNi44bC0xLjQsMkwxMTQuMSw4bC0wLjYtMC43bDAsMC45bC0wLjEsOC4yaC02LjhsLTAuMS04LjIKCQkJCWwwLTAuOUwxMDUuOSw4bC0wLjgsMC44bC0xLjQtMmwyLjYtMi45YzAuMS0wLjEsMC4yLTAuMSwwLjMtMC4xaDEuM2wwLjQsMC43YzAuNywxLjMsMi42LDEuMywzLjMtMC4xbDAuMy0wLjZoMS4yCgkJCQljMC4xLDAsMC4yLDAsMC4zLDAuMWwwLjMtMC4zbC0wLjMsMC4zTDExNi4zLDYuOHoiLz4KCQkJPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjODY4Njg2IiBkPSJNMTEwLjEsNy43aDJ2MC45YzAsMC40LTAuNCwwLjctMSwwLjdjLTAuNiwwLTEtMC4zLTEtMC43TDExMC4xLDcuN0wxMTAuMSw3Ljd6Ii8+CgkJPC9nPgoJPC9nPgo8L2c+CjxnIGlkPSJTeW1ib2xzXzAwMDAwMDk2NzQ2OTA3ODY5OTI5OTIxMTgwMDAwMDA2NDg0ODEyODMwMjgyNTgyNDE2XyI+Cgk8Zz4KCQk8Zz4KCQkJPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjODY4Njg2IiBkPSJNMTI2LjgsMTQuM2MwLDEuMi0xLDIuMi0yLjIsMi4ycy0yLjItMS0yLjItMi4yczEtMi4yLDIuMi0yLjJTMTI2LjgsMTMuMSwxMjYuOCwxNC4zeiIvPgoJCQk8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiM4Njg2ODYiIGQ9Ik0xMzcuNiwxNC4zYzAsMS4yLTEsMi4yLTIuMiwyLjJjLTEuMiwwLTIuMi0xLTIuMi0yLjJzMS0yLjIsMi4yLTIuMgoJCQkJQzEzNi42LDEyLjEsMTM3LjYsMTMuMSwxMzcuNiwxNC4zeiIvPgoJCQk8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiM4Njg2ODYiIGQ9Ik0xMjYuOCw0LjR2OS45Ii8+CgkJCTxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzg2ODY4NiIgZD0iTTEzNy43LDQuNHY5LjkiLz4KCQkJPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjODY4Njg2IiBkPSJNMTI2LjgsMy41aDEwLjh2Mi43aC0xMC44QzEyNi44LDYuMiwxMjYuOCwzLjUsMTI2LjgsMy41eiIvPgoJCTwvZz4KCTwvZz4KPC9nPgo8ZyBpZD0iUmVjZW50cyI+Cgk8Zz4KCQk8Zz4KCQkJPHBhdGggZmlsbD0iIzg2ODY4NiIgZD0iTTE3MC44LDMuMUwxNzAuOCwzLjFjLTAuMywwLTAuNSwwLTAuOCwwYy0yLjEsMC00LDEtNS4zLDIuNWwtMC4xLDBsLTAuMS0wLjFsLTEtMS4ybC0wLjMsMy40bDMuNCwwLjMKCQkJCWwtMS4xLTEuM2wtMC4xLTAuMWwwLjEtMC4xYzEuMS0xLjQsMy0yLjMsNS0yLjFsMCwwYzMuMiwwLjMsNS41LDMuMSw1LjIsNi4zYy0wLjMsMy0zLjEsNS4zLTYuMSw1LjFjLTMuMS0wLjItNS40LTIuOS01LjMtNgoJCQkJTDE2Myw5LjVjLTAuMiwzLjgsMi42LDcuMSw2LjMsNy40YzMuOSwwLjQsNy4zLTIuNiw3LjYtNi41QzE3Ny4yLDYuOCwxNzQuNCwzLjUsMTcwLjgsMy4xeiIvPgoJCQk8cGF0aCBmaWxsPSIjODY4Njg2IiBkPSJNMTcwLjMsNy40YzAtMC4zLTAuMy0wLjYtMC42LTAuNlMxNjksNy4xLDE2OSw3LjR2My4yYzAsMC4yLDAuMSwwLjMsMC4yLDAuNGMwLjEsMC4xLDAuMywwLjIsMC40LDAuMgoJCQkJaDIuNGMwLjQsMCwwLjYtMC4zLDAuNi0wLjZzLTAuMy0wLjYtMC42LTAuNmgtMS42aC0wLjJWOS44TDE3MC4zLDcuNEwxNzAuMyw3LjR6Ii8+CgkJPC9nPgoJPC9nPgo8L2c+CjxnIGlkPSJDdXN0b21fMDAwMDAxODEwODcyMjk0MzQzMDIzMzY3ODAwMDAwMDUxNTIyNzc5NDU5NDA2NzQ0ODhfIj4KCTxnPgoJCTxnPgoJCQk8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiM4Njg2ODYiIGQ9Ik0xODYuMiwzLjRoNy43YzEuNSwwLDIuNywxLjIsMi43LDIuN3Y3LjdjMCwxLjUtMS4yLDIuNy0yLjcsMi43aC03LjcKCQkJCWMtMS41LDAtMi43LTEuMi0yLjctMi43VjYuMUMxODMuNCw0LjYsMTg0LjcsMy40LDE4Ni4yLDMuNHoiLz4KCQkJPGVsbGlwc2UgZmlsbD0iIzg2ODY4NiIgY3g9IjE4NiIgY3k9IjguOSIgcng9IjAuNyIgcnk9IjAuNyIvPgoJCQk8ZWxsaXBzZSBmaWxsPSIjODY4Njg2IiBjeD0iMTk0IiBjeT0iNi43IiByeD0iMC43IiByeT0iMC43Ii8+CgkJCTxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzg2ODY4NiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBkPSJNMTg2LDEzLjNsMC40LTAuM2MwLjQtMC4zLDEtMC4zLDEuNS0wLjFsMSwwLjQKCQkJCWMwLjUsMC4yLDEsMC4yLDEuNS0wLjFsMC44LTAuNWMwLjQtMC4zLDEtMC4zLDEuNS0wLjFsMS44LDAuOCIvPgoJCTwvZz4KCTwvZz4KPC9nPgo8cGF0aCBmaWxsPSIjODY4Njg2IiBzdHJva2U9IiM4Njg2ODYiIHN0cm9rZS13aWR0aD0iMC4yNSIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMTU2LDQuM2MtMC4yLTAuMS0wLjQtMC4xLTAuNSwwCgljMCwwLTAuMiwwLjEtMC45LDAuMWMtMC43LDAtMi40LTAuMS0zLjgtMC42Yy0wLjgtMC4zLTEuNy0wLjUtMi41LTAuNWMtMC4yLDAtMC40LDAtMC41LDBjLTEuMywwLTIuNSwwLjMtMy42LDEKCWMtMC4yLDAuMS0wLjIsMC4yLTAuMiwwLjR2MTEuNmMwLDAuMywwLjEsMC41LDAuMywwLjVjMC42LDAsMC41LTAuNCwwLjUtMC42di01LjdjMC43LTAuMywzLjItMS4xLDUuOC0wLjFjMS42LDAuNiwzLjUsMC43LDQuMywwLjcKCWMwLjgsMCwxLjMtMC4zLDEuMy0wLjNjMC4yLTAuMSwwLjMtMC4yLDAuMy0wLjRWNC43QzE1Ni4yLDQuNSwxNTYuMSw0LjQsMTU2LDQuM3ogTTE1NS42LDEwLjJjLTAuMSwwLTAuNywwLjEtMSwwLjEKCWMtMC43LDAtMi40LTAuMS0zLjgtMC42Yy0yLjUtMS01LTAuNS02LjItMC4xVjQuN2MwLjktMC41LDIuMi0wLjcsMy4yLTAuN2MwLjEsMCwwLjMsMCwwLjQsMGMwLjcsMCwxLjUsMC4yLDIuMiwwLjQKCWMxLjYsMC42LDMuNSwwLjcsNC4zLDAuN2MwLjIsMCwwLjgsMCwxLTAuMVYxMC4yeiIvPgo8ZyBpZD0iRm9vZCI+Cgk8ZyBpZD0iTGF5ZXJfMTIiPgoJCTxnPgoJCQk8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiM4Njg2ODYiIGQ9Ik00OC4xLDMuNWgzLjdjMi41LDAsNC41LDIsNC41LDQuNWMwLDAuNS0wLjQsMC45LTAuOSwwLjlINDQuNWMtMC41LDAtMC45LTAuNC0wLjktMC45CgkJCQlDNDMuNiw1LjUsNDUuNiwzLjUsNDguMSwzLjV6Ii8+CgkJCTxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzg2ODY4NiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBkPSJNNDMuNSw4LjdjLTAuMiwwLjEtMC41LDEuMiwwLDEuNWMxLjQsMC45LDguNSwwLjgsMTEuMywwLjYKCQkJCWMwLjgtMC4xLDEuNi0wLjQsMS43LTEuMmMwLTAuMy0wLjEtMC42LTAuNi0wLjkiLz4KCQkJPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjODY4Njg2IiBzdHJva2UtbGluZWNhcD0icm91bmQiIGQ9Ik00My41LDEwLjZMNDMuMywxMWMtMC4yLDAuNSwwLjIsMSwwLjcsMC45CgkJCQljMC4zLTAuMSwwLjUsMC4xLDAuNywwLjNsMC4xLDAuMmMwLjMsMC41LDEsMC42LDEuNSwwLjJsMCwwYzAuMy0wLjIsMC43LTAuMywxLTAuMmwwLjgsMC4zYzAuNCwwLjEsMC44LDAuMSwxLjIsMGwwLjUtMC4yCgkJCQljMC40LTAuMiwwLjktMC4yLDEuMywwbDAuNSwwLjJjMC40LDAuMiwwLjgsMC4xLDEuMi0wLjFsMC4yLTAuMWMwLjMtMC4yLDAuOC0wLjEsMS4xLDAuMWwwLjIsMC4yYzAuMywwLjMsMC44LDAuMiwxLTAuMmwwLjEtMC4yCgkJCQljMC4xLTAuMiwwLTAuMywwLjItMC40YzAuNSwwLDEuMi0wLjMsMS4xLTAuN2wtMC40LTEuMSIvPgoJCQk8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiM4Njg2ODYiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgZD0iTTQzLjUsMTIuMWMtMC4xLDAuMi0wLjMsMC44LDAsMS4xYzAuMywwLjQsMywxLjEsNi40LDEuMQoJCQkJYzIuMiwwLDQuNi0wLjMsNi0wLjZjMC41LTAuMSwwLjktMC40LDAuOC0wLjljMC0wLjItMC4yLTAuNS0wLjQtMC43Ii8+CgkJCTxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzg2ODY4NiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBkPSJNNDMuNSwxMy4zYzAsMC41LDAuNiwyLjQsMS4zLDIuNmMxLjgsMC44LDUuNywwLjcsOC4xLDAuNQoJCQkJYzEuMy0wLjEsMi41LTAuNywzLjItMS44YzAuMy0wLjUsMC41LTEsMC41LTEuNCIvPgoJCQk8ZWxsaXBzZSBmaWxsPSIjODY4Njg2IiBjeD0iNTEuNiIgY3k9IjYuNSIgcng9IjAuMyIgcnk9IjAuNCIvPgoJCQk8ZWxsaXBzZSBmaWxsPSIjODY4Njg2IiBjeD0iNTMiIGN5PSI0LjkiIHJ4PSIwLjMiIHJ5PSIwLjQiLz4KCQkJPGVsbGlwc2UgZmlsbD0iIzg2ODY4NiIgY3g9IjUzIiBjeT0iNy4yIiByeD0iMC4zIiByeT0iMC40Ii8+CgkJCTxlbGxpcHNlIGZpbGw9IiM4Njg2ODYiIGN4PSI1NC4zIiBjeT0iNi41IiByeD0iMC4zIiByeT0iMC40Ii8+CgkJCTxlbGxpcHNlIGZpbGw9IiM4Njg2ODYiIGN4PSI1MC45IiBjeT0iNC45IiByeD0iMC4zIiByeT0iMC40Ii8+CgkJPC9nPgoJPC9nPgo8L2c+CjxnIGlkPSJBbmltYWxzIj4KCTxnPgoJCTxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzg2ODY4NiIgZD0iTTI0LjIsMTFWMy41YzAuMSwwLjEsMC44LDAuOSwyLjgsMy4xYzIuNS0xLjcsNS42LTAuNyw2LjksMGwyLjQtMy4xdjcuMQoJCQljMCwxLjItMC4xLDIuNS0wLjksMy40Yy0xLDEuMi0yLjcsMi41LTUuMywyLjVjLTIuOSwwLTQuNS0xLjUtNS4zLTIuOUMyNC4yLDEyLjksMjQuMiwxMS45LDI0LjIsMTF6Ii8+CgkJPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjODY4Njg2IiBzdHJva2UtbGluZWNhcD0icm91bmQiIGQ9Ik0yMS4yLDEwbDUuNCwxLjIiLz4KCQk8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiM4Njg2ODYiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgZD0iTTIxLjIsMTQuMWw1LjQtMS4yIi8+CgkJPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjODY4Njg2IiBzdHJva2UtbGluZWNhcD0icm91bmQiIGQ9Ik0zOC44LDEwbC01LjQsMS4yIi8+CgkJPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjODY4Njg2IiBzdHJva2UtbGluZWNhcD0icm91bmQiIGQ9Ik0zOC44LDE0LjFsLTUuNC0xLjIiLz4KCQk8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZmlsbD0iIzg2ODY4NiIgZD0iTTI5LjUsMTIuNEwyOSwxMS43Yy0wLjItMC4zLDAtMC42LDAuMy0wLjZoMS40CgkJCWMwLjMsMCwwLjUsMC40LDAuMywwLjZsLTAuNywxbDAsMGMtMC43LDEuMi0yLjYsMS4xLTMuMS0wLjNsLTAuMS0wLjJjLTAuMS0wLjIsMC0wLjQsMC4yLTAuNXMwLjQsMCwwLjUsMC4ybDAuMSwwLjIKCQkJQzI4LjMsMTIuNywyOS4xLDEyLjksMjkuNSwxMi40eiIvPgoJCTxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzg2ODY4NiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBkPSJNMzIuNCwxMi4xbC0wLjEsMC4yYy0wLjQsMS0xLjgsMS4xLTIuMywwLjIiLz4KCQk8ZWxsaXBzZSBmaWxsPSIjODY4Njg2IiBjeD0iMjcuNiIgY3k9IjkuNyIgcng9IjAuNyIgcnk9IjAuNyIvPgoJCTxlbGxpcHNlIGZpbGw9IiM4Njg2ODYiIGN4PSIzMi40IiBjeT0iOS43IiByeD0iMC43IiByeT0iMC43Ii8+Cgk8L2c+CjwvZz4KPC9zdmc+";
function CategoryButton(_ref) {
  var _cx;
  var isActiveCategory = _ref.isActiveCategory, category = _ref.category, allowNavigation = _ref.allowNavigation, categoryConfig = _ref.categoryConfig, onClick = _ref.onClick;
  return createElement(Button$1, {
    tabIndex: allowNavigation ? 0 : -1,
    className: cx(styles$f.catBtn, commonInteractionStyles.categoryBtn, "epr-icn-" + category, (_cx = {}, _cx[ClassNames.active] = isActiveCategory, _cx)),
    onClick,
    "aria-label": categoryNameFromCategoryConfig(categoryConfig),
    "aria-selected": isActiveCategory,
    role: "tab",
    "aria-controls": "epr-category-nav-id"
  });
}
var DarkActivePositionY = {
  backgroundPositionY: "calc(var(--epr-category-navigation-button-size) * 3)"
};
var DarkPositionY = {
  backgroundPositionY: "calc(var(--epr-category-navigation-button-size) * 2)"
};
var DarkInactivePosition = {
  ":not(.epr-search-active)": {
    catBtn: {
      ":hover": DarkActivePositionY,
      "&.epr-active": DarkActivePositionY
    }
  }
};
var styles$f = /* @__PURE__ */ stylesheet.create(/* @__PURE__ */ _extends({
  catBtn: {
    ".": "epr-cat-btn",
    display: "inline-block",
    transition: "opacity 0.2s ease-in-out",
    position: "relative",
    height: "var(--epr-category-navigation-button-size)",
    width: "var(--epr-category-navigation-button-size)",
    backgroundSize: "calc(var(--epr-category-navigation-button-size) * 10)",
    outline: "none",
    backgroundPosition: "0 0",
    backgroundImage: "url(" + SVGNavigation + ")",
    ":focus:before": {
      content: "",
      position: "absolute",
      top: "-2px",
      left: "-2px",
      right: "-2px",
      bottom: "-2px",
      border: "2px solid var(--epr-category-icon-active-color)",
      borderRadius: "50%"
    },
    "&.epr-icn-suggested": {
      backgroundPositionX: "calc(var(--epr-category-navigation-button-size) * -8)"
    },
    "&.epr-icn-custom": {
      backgroundPositionX: "calc(var(--epr-category-navigation-button-size) * -9)"
    },
    "&.epr-icn-activities": {
      backgroundPositionX: "calc(var(--epr-category-navigation-button-size) * -4)"
    },
    "&.epr-icn-animals_nature": {
      backgroundPositionX: "calc(var(--epr-category-navigation-button-size) * -1)"
    },
    "&.epr-icn-flags": {
      backgroundPositionX: "calc(var(--epr-category-navigation-button-size) * -7)"
    },
    "&.epr-icn-food_drink": {
      backgroundPositionX: "calc(var(--epr-category-navigation-button-size) * -2)"
    },
    "&.epr-icn-objects": {
      backgroundPositionX: "calc(var(--epr-category-navigation-button-size) * -5)"
    },
    "&.epr-icn-smileys_people": {
      backgroundPositionX: "0px"
    },
    "&.epr-icn-symbols": {
      backgroundPositionX: "calc(var(--epr-category-navigation-button-size) * -6)"
    },
    "&.epr-icn-travel_places": {
      backgroundPositionX: "calc(var(--epr-category-navigation-button-size) * -3)"
    }
  }
}, /* @__PURE__ */ darkMode("catBtn", DarkPositionY), {
  ".epr-dark-theme": /* @__PURE__ */ _extends({}, DarkInactivePosition),
  ".epr-auto-theme": /* @__PURE__ */ _extends({}, DarkInactivePosition)
}));
function CategoryNavigation() {
  var _useState = useState(null), activeCategory = _useState[0], setActiveCategory = _useState[1];
  var scrollCategoryIntoView = useScrollCategoryIntoView();
  useActiveCategoryScrollDetection(setActiveCategory);
  var isSearchMode = useIsSearchMode();
  var categoriesConfig = useCategoriesConfig();
  var CategoryNavigationRef = useCategoryNavigationRef();
  var hideCustomCategory = useShouldHideCustomEmojis();
  return createElement("div", {
    className: cx(styles$g.nav),
    role: "tablist",
    "aria-label": "Category navigation",
    id: "epr-category-nav-id",
    ref: CategoryNavigationRef
  }, categoriesConfig.map(function(categoryConfig) {
    var category = categoryFromCategoryConfig(categoryConfig);
    var isActiveCategory = category === activeCategory;
    if (isCustomCategory(categoryConfig) && hideCustomCategory) {
      return null;
    }
    var allowNavigation = !isSearchMode && !isActiveCategory;
    return createElement(CategoryButton, {
      key: category,
      category,
      isActiveCategory,
      allowNavigation,
      categoryConfig,
      onClick: function onClick() {
        setActiveCategory(category);
        scrollCategoryIntoView(category);
      }
    });
  }));
}
var styles$g = /* @__PURE__ */ stylesheet.create({
  nav: {
    ".": "epr-category-nav",
    display: "flex",
    flexDirection: "row",
    justifyContent: "space-around",
    padding: "var(--epr-header-padding)"
  },
  ".epr-search-active": {
    nav: {
      opacity: "0.3",
      cursor: "default",
      pointerEvents: "none"
    }
  },
  ".epr-main:has(input:not(:placeholder-shown))": {
    nav: {
      opacity: "0.3",
      cursor: "default",
      pointerEvents: "none"
    }
  }
});
var SVGTimes = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI2LjMuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHdpZHRoPSIyMHB4IiBoZWlnaHQ9IjgwcHgiIHZpZXdCb3g9IjAgMCAyMCA4MCIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwIDAgMjAgODAiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8cGF0aCBmaWxsPSIjODY4Njg2IiBkPSJNNi45OCwxMy41OWMwLjEsMC4xLDAuMjQsMC4xNSwwLjM3LDAuMTVzMC4yNy0wLjA1LDAuMzctMC4xNWwyLjQyLTIuNDJsMi40MywyLjQzCgljMC4xLDAuMSwwLjI0LDAuMTUsMC4zNywwLjE1YzAuMTQsMCwwLjI3LTAuMDUsMC4zNy0wLjE1YzAuMjEtMC4yMSwwLjIxLTAuNTQsMC0wLjc1bC0yLjQzLTIuNDNMMTMuMzIsOAoJYzAuMjEtMC4yMSwwLjIxLTAuNTQsMC0wLjc1Yy0wLjIxLTAuMjEtMC41NC0wLjIxLTAuNzUsMGwtMi40MiwyLjQyTDcuNzQsNy4yN2MtMC4yMS0wLjIxLTAuNTQtMC4yMS0wLjc1LDAKCWMtMC4yMSwwLjIxLTAuMjEsMC41NCwwLDAuNzVsMi40MSwyLjQxbC0yLjQyLDIuNDJDNi43NywxMy4wNSw2Ljc3LDEzLjM5LDYuOTgsMTMuNTlMNi45OCwxMy41OXoiLz4KPHBhdGggZmlsbD0iIzg2ODY4NiIgZD0iTTEwLjE1LDE4LjQzYzQuNDEsMCw4LTMuNTksOC04YzAtNC40MS0zLjU5LTgtOC04Yy00LjQxLDAtOCwzLjU5LTgsOEMyLjE1LDE0Ljg0LDUuNzQsMTguNDMsMTAuMTUsMTguNDN6CgkgTTEwLjE1LDMuNDljMy44MywwLDYuOTQsMy4xMSw2Ljk0LDYuOTRjMCwzLjgzLTMuMTEsNi45NC02Ljk0LDYuOTRjLTMuODMsMC02Ljk0LTMuMTEtNi45NC02Ljk0QzMuMjEsNi42LDYuMzMsMy40OSwxMC4xNSwzLjQ5CglMMTAuMTUsMy40OXoiLz4KPHBhdGggZmlsbD0iIzMzNzFCNyIgZD0iTTYuOTgsMzMuNTljMC4xLDAuMSwwLjI0LDAuMTUsMC4zNywwLjE1czAuMjctMC4wNSwwLjM3LTAuMTVsMi40Mi0yLjQybDIuNDMsMi40MwoJYzAuMSwwLjEsMC4yNCwwLjE1LDAuMzcsMC4xNWMwLjE0LDAsMC4yNy0wLjA1LDAuMzctMC4xNWMwLjIxLTAuMjEsMC4yMS0wLjU0LDAtMC43NWwtMi40My0yLjQzTDEzLjMyLDI4CgljMC4yMS0wLjIxLDAuMjEtMC41NCwwLTAuNzVjLTAuMjEtMC4yMS0wLjU0LTAuMjEtMC43NSwwbC0yLjQyLDIuNDJsLTIuNDEtMi40MWMtMC4yMS0wLjIxLTAuNTQtMC4yMS0wLjc1LDAKCWMtMC4yMSwwLjIxLTAuMjEsMC41NCwwLDAuNzVsMi40MSwyLjQxbC0yLjQyLDIuNDJDNi43NywzMy4wNSw2Ljc3LDMzLjM5LDYuOTgsMzMuNTlMNi45OCwzMy41OXoiLz4KPHBhdGggZmlsbD0iIzMzNzFCNyIgZD0iTTEwLjE1LDM4LjQzYzQuNDEsMCw4LTMuNTksOC04YzAtNC40MS0zLjU5LTgtOC04Yy00LjQxLDAtOCwzLjU5LTgsOEMyLjE1LDM0Ljg0LDUuNzQsMzguNDMsMTAuMTUsMzguNDN6CgkgTTEwLjE1LDIzLjQ5YzMuODMsMCw2Ljk0LDMuMTEsNi45NCw2Ljk0YzAsMy44My0zLjExLDYuOTQtNi45NCw2Ljk0Yy0zLjgzLDAtNi45NC0zLjExLTYuOTQtNi45NAoJQzMuMjEsMjYuNiw2LjMzLDIzLjQ5LDEwLjE1LDIzLjQ5TDEwLjE1LDIzLjQ5eiIvPgo8cGF0aCBmaWxsPSIjQzBDMEJGIiBkPSJNNi45OCw1My41OWMwLjEsMC4xLDAuMjQsMC4xNSwwLjM3LDAuMTVzMC4yNy0wLjA1LDAuMzctMC4xNWwyLjQyLTIuNDJsMi40MywyLjQzCgljMC4xLDAuMSwwLjI0LDAuMTUsMC4zNywwLjE1YzAuMTQsMCwwLjI3LTAuMDUsMC4zNy0wLjE1YzAuMjEtMC4yMSwwLjIxLTAuNTQsMC0wLjc1bC0yLjQzLTIuNDNMMTMuMzIsNDgKCWMwLjIxLTAuMjEsMC4yMS0wLjU0LDAtMC43NWMtMC4yMS0wLjIxLTAuNTQtMC4yMS0wLjc1LDBsLTIuNDIsMi40MmwtMi40MS0yLjQxYy0wLjIxLTAuMjEtMC41NC0wLjIxLTAuNzUsMAoJYy0wLjIxLDAuMjEtMC4yMSwwLjU0LDAsMC43NWwyLjQxLDIuNDFsLTIuNDIsMi40MkM2Ljc3LDUzLjA1LDYuNzcsNTMuMzksNi45OCw1My41OUw2Ljk4LDUzLjU5eiIvPgo8cGF0aCBmaWxsPSIjQzBDMEJGIiBkPSJNMTAuMTUsNTguNDNjNC40MSwwLDgtMy41OSw4LThjMC00LjQxLTMuNTktOC04LThjLTQuNDEsMC04LDMuNTktOCw4QzIuMTUsNTQuODQsNS43NCw1OC40MywxMC4xNSw1OC40M3oKCSBNMTAuMTUsNDMuNDljMy44MywwLDYuOTQsMy4xMSw2Ljk0LDYuOTRjMCwzLjgzLTMuMTEsNi45NC02Ljk0LDYuOTRjLTMuODMsMC02Ljk0LTMuMTEtNi45NC02Ljk0CglDMy4yMSw0Ni42LDYuMzMsNDMuNDksMTAuMTUsNDMuNDlMMTAuMTUsNDMuNDl6Ii8+CjxwYXRoIGZpbGw9IiM2QUE5REQiIGQ9Ik02Ljk4LDczLjU5YzAuMSwwLjEsMC4yNCwwLjE1LDAuMzcsMC4xNXMwLjI3LTAuMDUsMC4zNy0wLjE1bDIuNDItMi40MmwyLjQzLDIuNDMKCWMwLjEsMC4xLDAuMjQsMC4xNSwwLjM3LDAuMTVjMC4xNCwwLDAuMjctMC4wNSwwLjM3LTAuMTVjMC4yMS0wLjIxLDAuMjEtMC41NCwwLTAuNzVsLTIuNDMtMi40M0wxMy4zMiw2OAoJYzAuMjEtMC4yMSwwLjIxLTAuNTQsMC0wLjc1Yy0wLjIxLTAuMjEtMC41NC0wLjIxLTAuNzUsMGwtMi40MiwyLjQybC0yLjQxLTIuNDFjLTAuMjEtMC4yMS0wLjU0LTAuMjEtMC43NSwwCgljLTAuMjEsMC4yMS0wLjIxLDAuNTQsMCwwLjc1bDIuNDEsMi40MWwtMi40MiwyLjQyQzYuNzcsNzMuMDUsNi43Nyw3My4zOSw2Ljk4LDczLjU5TDYuOTgsNzMuNTl6Ii8+CjxwYXRoIGZpbGw9IiM2QUE5REQiIGQ9Ik0xMC4xNSw3OC40M2M0LjQxLDAsOC0zLjU5LDgtOGMwLTQuNDEtMy41OS04LTgtOGMtNC40MSwwLTgsMy41OS04LDhDMi4xNSw3NC44NCw1Ljc0LDc4LjQzLDEwLjE1LDc4LjQzegoJIE0xMC4xNSw2My40OWMzLjgzLDAsNi45NCwzLjExLDYuOTQsNi45NGMwLDMuODMtMy4xMSw2Ljk0LTYuOTQsNi45NGMtMy44MywwLTYuOTQtMy4xMS02Ljk0LTYuOTQKCUMzLjIxLDY2LjYsNi4zMyw2My40OSwxMC4xNSw2My40OUwxMC4xNSw2My40OXoiLz4KPC9zdmc+";
function BtnClearSearch() {
  var clearSearch = useClearSearch();
  return createElement(Button$1, {
    className: cx(styles$h.btnClearSearch, commonInteractionStyles.visibleOnSearchOnly),
    onClick: clearSearch,
    "aria-label": "Clear",
    title: "Clear"
  }, createElement("div", {
    className: cx(styles$h.icnClearnSearch)
  }));
}
var HoverDark = {
  ":hover": {
    "> .epr-icn-clear-search": {
      backgroundPositionY: "-60px"
    }
  }
};
var styles$h = /* @__PURE__ */ stylesheet.create(/* @__PURE__ */ _extends({
  btnClearSearch: {
    ".": "epr-btn-clear-search",
    position: "absolute",
    right: "var(--epr-search-bar-inner-padding)",
    height: "30px",
    width: "30px",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    top: "50%",
    transform: "translateY(-50%)",
    padding: "0",
    borderRadius: "50%",
    ":hover": {
      background: "var(--epr-hover-bg-color)"
    },
    ":focus": {
      background: "var(--epr-hover-bg-color)"
    }
  },
  icnClearnSearch: {
    ".": "epr-icn-clear-search",
    backgroundColor: "transparent",
    backgroundRepeat: "no-repeat",
    backgroundSize: "20px",
    height: "20px",
    width: "20px",
    backgroundImage: "url(" + SVGTimes + ")",
    ":hover": {
      backgroundPositionY: "-20px"
    },
    ":focus": {
      backgroundPositionY: "-20px"
    }
  }
}, /* @__PURE__ */ darkMode("icnClearnSearch", {
  backgroundPositionY: "-40px"
}), /* @__PURE__ */ darkMode("btnClearSearch", HoverDark)));
var SCOPE = /* @__PURE__ */ asSelectors(ClassNames.emojiPicker) + " " + /* @__PURE__ */ asSelectors(ClassNames.emojiList);
var EMOJI_BUTTON = /* @__PURE__ */ ["button", asSelectors(ClassNames.emoji)].join("");
var CATEGORY = /* @__PURE__ */ asSelectors(ClassNames.category);
function CssSearch(_ref) {
  var value = _ref.value;
  if (!value) {
    return null;
  }
  var q = genQuery(value);
  return createElement("style", null, "\n    " + SCOPE + " " + EMOJI_BUTTON + " {\n      display: none;\n    }\n\n\n    " + SCOPE + " " + q + " {\n      display: flex;\n    }\n\n    " + SCOPE + " " + CATEGORY + ":not(:has(" + q + ")) {\n      display: none;\n    }\n  ");
}
function genQuery(value) {
  return [EMOJI_BUTTON, '[data-full-name*="', getNormalizedSearchTerm(value), '"]'].join("");
}
var SVGMagnifier = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI2LjMuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHdpZHRoPSIyMHB4IiBoZWlnaHQ9IjQwcHgiIHZpZXdCb3g9IjAgMCAyMCA0MCIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwIDAgMjAgNDAiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZmlsbD0iIzg2ODY4NiIgZD0iTTEyLDguODFjMCwyLjA4LTEuNjgsMy43Ni0zLjc2LDMuNzZjLTIuMDgsMC0zLjc2LTEuNjgtMy43Ni0zLjc2CgljMC0yLjA4LDEuNjgtMy43NiwzLjc2LTMuNzZDMTAuMzIsNS4wNSwxMiw2LjczLDEyLDguODF6IE0xMS4yMywxMi43MmMtMC44MywwLjY0LTEuODcsMS4wMS0yLjk5LDEuMDFjLTIuNzIsMC00LjkyLTIuMi00LjkyLTQuOTIKCWMwLTIuNzIsMi4yLTQuOTIsNC45Mi00LjkyYzIuNzIsMCw0LjkyLDIuMiw0LjkyLDQuOTJjMCwxLjEzLTAuMzgsMi4xNi0xLjAxLDIuOTlsMy45NCwzLjkzYzAuMjUsMC4yNSwwLjI1LDAuNjYsMCwwLjkyCgljLTAuMjUsMC4yNS0wLjY2LDAuMjUtMC45MiwwTDExLjIzLDEyLjcyeiIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZmlsbD0iI0MwQzBCRiIgZD0iTTEyLDI4LjgxYzAsMi4wOC0xLjY4LDMuNzYtMy43NiwzLjc2Yy0yLjA4LDAtMy43Ni0xLjY4LTMuNzYtMy43NgoJYzAtMi4wOCwxLjY4LTMuNzYsMy43Ni0zLjc2QzEwLjMyLDI1LjA1LDEyLDI2LjczLDEyLDI4LjgxeiBNMTEuMjMsMzIuNzJjLTAuODMsMC42NC0xLjg3LDEuMDEtMi45OSwxLjAxCgljLTIuNzIsMC00LjkyLTIuMi00LjkyLTQuOTJjMC0yLjcyLDIuMi00LjkyLDQuOTItNC45MmMyLjcyLDAsNC45MiwyLjIsNC45Miw0LjkyYzAsMS4xMy0wLjM4LDIuMTYtMS4wMSwyLjk5bDMuOTQsMy45MwoJYzAuMjUsMC4yNSwwLjI1LDAuNjYsMCwwLjkyYy0wLjI1LDAuMjUtMC42NiwwLjI1LTAuOTIsMEwxMS4yMywzMi43MnoiLz4KPC9zdmc+";
function IcnSearch() {
  return createElement("div", {
    className: cx(styles$i.icnSearch)
  });
}
var styles$i = /* @__PURE__ */ stylesheet.create(/* @__PURE__ */ _extends({
  icnSearch: {
    ".": "epr-icn-search",
    content: "",
    position: "absolute",
    top: "50%",
    left: "var(--epr-search-bar-inner-padding)",
    transform: "translateY(-50%)",
    width: "20px",
    height: "20px",
    backgroundRepeat: "no-repeat",
    backgroundPosition: "0 0",
    backgroundSize: "20px",
    backgroundImage: "url(" + SVGMagnifier + ")"
  }
}, /* @__PURE__ */ darkMode("icnSearch", {
  backgroundPositionY: "-20px"
})));
function SearchContainer() {
  var searchDisabled = useSearchDisabledConfig();
  var isSkinToneInSearch = useIsSkinToneInSearch();
  if (searchDisabled) {
    return null;
  }
  return createElement(Flex, {
    className: cx(styles$j.overlay)
  }, createElement(Search, null), isSkinToneInSearch ? createElement(SkinTonePicker, null) : null);
}
function Search() {
  var _useState = useState(0), inc = _useState[0], setInc = _useState[1];
  var closeAllOpenToggles = useCloseAllOpenToggles();
  var SearchInputRef = useSearchInputRef();
  var placeholder = useSearchPlaceHolderConfig();
  var autoFocus = useAutoFocusSearchConfig();
  var _useFilter = useFilter(), statusSearchResults = _useFilter.statusSearchResults, searchTerm = _useFilter.searchTerm, _onChange = _useFilter.onChange;
  var input = SearchInputRef == null ? void 0 : SearchInputRef.current;
  var value = input == null ? void 0 : input.value;
  return createElement(Relative, {
    className: cx(styles$j.searchContainer)
  }, createElement(CssSearch, {
    value
  }), createElement("input", {
    // eslint-disable-next-line jsx-a11y/no-autofocus
    autoFocus,
    "aria-label": "Type to search for an emoji",
    onFocus: closeAllOpenToggles,
    className: cx(styles$j.search),
    type: "text",
    "aria-controls": "epr-search-id",
    placeholder,
    onChange: function onChange(event) {
      setInc(inc + 1);
      setTimeout(function() {
        var _event$target$value, _event$target;
        _onChange((_event$target$value = event == null ? void 0 : (_event$target = event.target) == null ? void 0 : _event$target.value) != null ? _event$target$value : value);
      });
    },
    ref: SearchInputRef
  }), searchTerm ? createElement("div", {
    role: "status",
    className: cx("epr-status-search-results", styles$j.visuallyHidden),
    "aria-live": "polite",
    id: "epr-search-id",
    "aria-atomic": "true"
  }, statusSearchResults) : null, createElement(IcnSearch, null), createElement(BtnClearSearch, null));
}
var styles$j = /* @__PURE__ */ stylesheet.create(/* @__PURE__ */ _extends({
  overlay: {
    padding: "var(--epr-header-padding)",
    zIndex: "var(--epr-header-overlay-z-index)"
  },
  searchContainer: {
    ".": "epr-search-container",
    flex: "1",
    display: "block",
    minWidth: "0"
  },
  visuallyHidden: {
    clip: "rect(0 0 0 0)",
    clipPath: "inset(50%)",
    height: "1px",
    overflow: "hidden",
    position: "absolute",
    whiteSpace: "nowrap",
    width: "1px"
  },
  search: {
    outline: "none",
    transition: "all 0.2s ease-in-out",
    color: "var(--epr-search-input-text-color)",
    borderRadius: "var(--epr-search-input-border-radius)",
    padding: "var(--epr-search-input-padding)",
    height: "var(--epr-search-input-height)",
    backgroundColor: "var(--epr-search-input-bg-color)",
    border: "1px solid var(--epr-search-input-bg-color)",
    width: "100%",
    ":focus": {
      backgroundColor: "var(--epr-search-input-bg-color-active)",
      border: "1px solid var(--epr-search-border-color)"
    },
    "::placeholder": {
      color: "var(--epr-search-input-placeholder-color)"
    }
  },
  btnClearSearch: {
    ".": "epr-btn-clear-search",
    position: "absolute",
    right: "var(--epr-search-bar-inner-padding)",
    height: "30px",
    width: "30px",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    top: "50%",
    transform: "translateY(-50%)",
    padding: "0",
    borderRadius: "50%",
    ":hover": {
      background: "var(--epr-hover-bg-color)"
    },
    ":focus": {
      background: "var(--epr-hover-bg-color)"
    }
  },
  icnClearnSearch: {
    ".": "epr-icn-clear-search",
    backgroundColor: "transparent",
    backgroundRepeat: "no-repeat",
    backgroundSize: "20px",
    height: "20px",
    width: "20px",
    backgroundImage: "url(" + SVGTimes + ")",
    ":hover": {
      backgroundPositionY: "-20px"
    },
    ":focus": {
      backgroundPositionY: "-20px"
    }
  }
}, /* @__PURE__ */ darkMode("icnClearnSearch", {
  backgroundPositionY: "-40px"
}), /* @__PURE__ */ darkMode("btnClearSearch", {
  ":hover > .epr-icn-clear-search": {
    backgroundPositionY: "-60px"
  }
})));
function Header$1() {
  return createElement(Relative, {
    className: cx("epr-header", commonInteractionStyles.hiddenOnReactions)
  }, createElement(SearchContainer, null), createElement(CategoryNavigation, null));
}
function EmojiPicker(props) {
  return createElement(ElementRefContextProvider, null, createElement(PickerStyleTag, null), createElement(PickerConfigProvider, Object.assign({}, props), createElement(ContentControl, null)));
}
function ContentControl() {
  var _useReactionsModeStat = useReactionsModeState(), reactionsDefaultOpen = _useReactionsModeStat[0];
  var allowExpandReactions = useAllowExpandReactions();
  var _React$useState = useState(!reactionsDefaultOpen), renderAll = _React$useState[0], setRenderAll = _React$useState[1];
  var isOpen = useOpenConfig();
  useEffect(function() {
    if (reactionsDefaultOpen && !allowExpandReactions) {
      return;
    }
    if (!renderAll) {
      setRenderAll(true);
    }
  }, [renderAll, allowExpandReactions, reactionsDefaultOpen]);
  if (!isOpen) {
    return null;
  }
  return createElement(PickerMain, null, createElement(Reactions, null), createElement(ExpandedPickerContent, {
    renderAll
  }));
}
function ExpandedPickerContent(_ref) {
  var renderAll = _ref.renderAll;
  if (!renderAll) {
    return null;
  }
  return createElement(Fragment, null, createElement(Header$1, null), createElement(Body, null), createElement(Preview, null));
}
var EmojiPickerReact = /* @__PURE__ */ memo(EmojiPicker, compareConfig);
var ErrorBoundary = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(ErrorBoundary2, _React$Component);
  function ErrorBoundary2(props) {
    var _this;
    _this = _React$Component.call(this, props) || this;
    _this.state = {
      hasError: false
    };
    return _this;
  }
  ErrorBoundary2.getDerivedStateFromError = function getDerivedStateFromError() {
    return {
      hasError: true
    };
  };
  var _proto = ErrorBoundary2.prototype;
  _proto.componentDidCatch = function componentDidCatch(error2, errorInfo) {
  };
  _proto.render = function render() {
    if (this.state.hasError) {
      return null;
    }
    return this.props.children;
  };
  return ErrorBoundary2;
}(Component$1);
function EmojiPicker$1(props) {
  var MutableConfigRef = useDefineMutableConfig({
    onEmojiClick: props.onEmojiClick,
    onReactionClick: props.onReactionClick,
    onSkinToneChange: props.onSkinToneChange
  });
  return createElement(ErrorBoundary, null, createElement(MutableConfigContext.Provider, {
    value: MutableConfigRef
  }, createElement(EmojiPickerReact, Object.assign({}, props))));
}
const MenuId = "message-reaction";
function ContextReaction() {
  const contextMenu = useSelector(({ messages }) => messages == null ? void 0 : messages.contextMenu);
  if (!contextMenu || contextMenu.id != MenuId) {
    return;
  }
  const handleReactionClick = (e) => {
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "fit-content" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    EmojiPicker$1,
    {
      onReactionClick: handleReactionClick,
      emojiStyle: EmojiStyle.GOOGLE,
      reactionsDefaultOpen: true,
      allowExpandReactions: false
    }
  ) });
}
function Toolbar({ message: message2, reply, reaction, children }) {
  const msgRef = useRef(null);
  const buttons = useMemo(() => {
    const buttons2 = [];
    if (reaction) {
      buttons2.push({
        icon: faceSmileIcon,
        label: "Cảm xúc",
        onClick: () => msgRef.current && setContextMenu(MenuId, msgRef.current)
      });
    }
    if (reply) {
      buttons2.push({
        icon: replyIcon,
        label: "Reply",
        onClick: () => setReplyMessage(message2)
      });
    }
    return buttons2;
  }, [reply, reaction, message2]);
  const displayMenu = useMemo(() => (ev) => {
    ev.preventDefault();
    setContextMenu(MenuId$1, { x: ev.clientX, y: ev.clientY }, { message: message2 });
  }, [message2]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `rcw-toolbar rcw-toolbar-${message2.sender}`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rcw-toolbar-msg", onContextMenu: displayMenu, ref: msgRef, children }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rcw-toolbar-btns", children: buttons.map(({ icon, label, onClick }, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("button", { title: label, onClick, children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: icon }) }, i)) })
  ] });
}
const quoteIcon = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20448%20512'%3e%3c!--!Font%20Awesome%20Free%206.7.2%20by%20@fontawesome%20-%20https://fontawesome.com%20License%20-%20https://fontawesome.com/license/free%20Copyright%202025%20Fonticons,%20Inc.--%3e%3cpath%20d='M448%20296c0%2066.3-53.7%20120-120%20120l-8%200c-17.7%200-32-14.3-32-32s14.3-32%2032-32l8%200c30.9%200%2056-25.1%2056-56l0-8-64%200c-35.3%200-64-28.7-64-64l0-64c0-35.3%2028.7-64%2064-64l64%200c35.3%200%2064%2028.7%2064%2064l0%2032%200%2032%200%2072zm-256%200c0%2066.3-53.7%20120-120%20120l-8%200c-17.7%200-32-14.3-32-32s14.3-32%2032-32l8%200c30.9%200%2056-25.1%2056-56l0-8-64%200c-35.3%200-64-28.7-64-64l0-64c0-35.3%2028.7-64%2064-64l64%200c35.3%200%2064%2028.7%2064%2064l0%2032%200%2032%200%2072z'/%3e%3c/svg%3e";
function FileAttachment({ item }) {
  const href = useMemo(() => {
    if (item instanceof File) {
      return URL.createObjectURL(item);
    }
    return item.url;
  }, [item]);
  const fileType = useMemo(() => {
    const itemType = item.type ?? item.file_type;
    if (item instanceof File) {
      if (itemType.startsWith("image/")) {
        return "image";
      } else if (itemType.startsWith("video/")) {
        return "video";
      } else {
        return itemType;
      }
    }
    return itemType;
  }, [item]);
  switch (fileType) {
    case "image": {
      const sanitizedHTML = MarkdownIt().use(markdownItClass, { img: ["rcw-message-img"] }).render(`![](${href})`);
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rcw-message-text is-attachment", dangerouslySetInnerHTML: { __html: sanitizedHTML.replace(/\n$/, "") } });
    }
    case "video": {
      const sanitizedHTML = MarkdownIt({ html: true }).use(markdownItClass, { video: ["rcw-message-video"] }).render(`<video src="${href}" controls />`);
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rcw-message-text is-attachment", dangerouslySetInnerHTML: { __html: sanitizedHTML.replace(/\n$/, "") } });
    }
    default: {
      const sanitizedHTML = MarkdownIt().use(markdownItLinkAttributes, { attrs: { target: "_blank", rel: "noopener" } }).render(`[${item.name}](${href})`);
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rcw-message-text is-attachment", "data-type": fileType, dangerouslySetInnerHTML: { __html: sanitizedHTML.replace(/\n$/, "") } });
    }
  }
}
function Message$1({ message: message2, reply, reaction, showTimeStamp, isReplyContext, isReplyMessage }) {
  var _a2, _b, _c;
  const locale = useSelector(({ messages }) => messages == null ? void 0 : messages.statusLocale);
  let sanitizedHTML = null;
  if (message2.text) {
    sanitizedHTML = MarkdownIt({ html: true, breaks: true }).use(markdownItClass, {
      img: ["rcw-message-img"]
    }).use(sup_plugin).use(markdownItSanitizer).use(markdownItLinkAttributes, { attrs: { target: "_blank", rel: "noopener" } }).use(L$1).use(Y).render(message2.text);
  }
  const attachments = [];
  if ((_a2 = message2.props) == null ? void 0 : _a2.files) {
    attachments.push(message2.props.files.map((item, i) => /* @__PURE__ */ jsxRuntimeExports.jsx(FileAttachment, { item }, i)));
  }
  if (isReplyContext || isReplyMessage) {
    if (sanitizedHTML) {
      if (isReplyMessage) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { dangerouslySetInnerHTML: { __html: sanitizedHTML.replace(/\n$/, "") } });
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "reply-content-body", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "reply-content-header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: quoteIcon }),
          "Reply"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rcw-message-text", dangerouslySetInnerHTML: { __html: sanitizedHTML.replace(/\n$/, "") } })
      ] });
    }
    if ((_b = message2.props) == null ? void 0 : _b.files) {
      const { files } = message2.props;
      if (files.length == 1) {
        const file2 = files[0];
        const fileType = file2.type ?? file2.file_type;
        if (fileType.startsWith("image/")) {
          const href = file2.url ?? URL.createObjectURL(file2);
          if (isReplyMessage) {
            return /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: "reply-content-preview", src: href });
          }
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: "reply-content-preview", src: href }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "reply-content-body has-preview", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "reply-content-header", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: quoteIcon }),
                "Reply"
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rcw-message-text", children: "[Image]" })
            ] })
          ] });
        }
        if (isReplyMessage) {
          return /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
            "[File] ",
            file2.name
          ] });
        }
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "reply-content-body", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "reply-content-header", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: quoteIcon }),
            "Reply"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rcw-message-text", children: [
            "[File] ",
            file2.name
          ] })
        ] });
      }
      if (isReplyMessage) {
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
          "[",
          files.length,
          " file]"
        ] });
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "reply-content-body", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "reply-content-header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: quoteIcon }),
          "Reply"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rcw-message-text", children: [
          "[",
          files.length,
          " file]"
        ] })
      ] });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "reply-content-body", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "reply-content-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: quoteIcon }),
        "Reply"
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "[Tin nhắn]" })
    ] });
  }
  let replySection = null;
  if (sanitizedHTML && ((_c = message2.props) == null ? void 0 : _c.replyMessage)) {
    replySection = /* @__PURE__ */ jsxRuntimeExports.jsx(Message$1, { message: message2.props.replyMessage, isReplyMessage: true });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Status$1, { message: message2, showTimeStamp: !!showTimeStamp, locale, showStatus: true, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Toolbar, { message: message2, reply, reaction, children: [
    sanitizedHTML && (replySection ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rcw-message-text", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `reply-section rcw-${message2.sender}`, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "rcw-message-reply-bar" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rcw-message-reply-content", children: replySection })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { dangerouslySetInnerHTML: { __html: sanitizedHTML.replace(/\n$/, "") } })
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rcw-message-text", dangerouslySetInnerHTML: { __html: sanitizedHTML.replace(/\n$/, "") } })),
    attachments
  ] }) });
}
function Snippet({ message: message2, showTimeStamp }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rcw-snippet", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { className: "rcw-snippet-title", children: message2.title }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rcw-snippet-details", children: /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: message2.link, target: message2.target, className: "rcw-link", children: message2.link }) })
    ] }),
    showTimeStamp && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "rcw-timestamp", children: format(message2.timestamp, "hh:mm") })
  ] });
}
function Message({ message: message2, showTimeStamp, reply, reaction, className, children }) {
  const locale = useSelector(({ messages }) => messages == null ? void 0 : messages.statusLocale);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Status$1, { message: message2, showTimeStamp: !!showTimeStamp, locale, showStatus: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Toolbar, { message: message2, reply, reaction, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `rcw-message-custom ${className}`, children }) }) });
}
function QuickButton({ button, onQuickButtonClicked }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "quick-button", onClick: (event) => onQuickButtonClicked(event, button.value), children: button.label });
}
const ref = (v2) => ref$1(v2);
function createNewMessage(text2, sender, id, status, props, overrides) {
  return {
    type: MESSAGES_TYPES.TEXT,
    component: ref(Message$1),
    text: text2,
    props: props ? ref(props) : void 0,
    sender,
    timestamp: /* @__PURE__ */ new Date(),
    showAvatar: true,
    status,
    customId: id,
    unread: sender === MESSAGE_SENDER.RESPONSE,
    ...overrides
  };
}
function createLinkSnippet(link2, id, props) {
  return {
    type: MESSAGES_TYPES.SNIPPET.LINK,
    component: ref(Snippet),
    title: link2.title,
    link: link2.link,
    target: link2.target || "_blank",
    props: props ? ref(props) : void 0,
    sender: MESSAGE_SENDER.RESPONSE,
    timestamp: /* @__PURE__ */ new Date(),
    showAvatar: true,
    customId: id,
    unread: true
  };
}
function createCarouselMessage(items, summary, id, props) {
  return {
    type: MESSAGES_TYPES.CAROUSEL,
    component: ref(CarouselMessage),
    props: props ? ref(props) : void 0,
    timestamp: /* @__PURE__ */ new Date(),
    showAvatar: true,
    customId: id,
    sender: MESSAGE_SENDER.RESPONSE,
    unread: true,
    items,
    summary
  };
}
function createCarouselMessageForAgent(items, summary, id, props) {
  return {
    type: MESSAGES_TYPES.CAROUSEL,
    component: ref(CarouselMessage),
    props: props ? ref(props) : void 0,
    timestamp: /* @__PURE__ */ new Date(),
    showAvatar: true,
    customId: id,
    sender: MESSAGE_SENDER.CLIENT,
    unread: true,
    items,
    summary
  };
}
function createComponentMessage(component, props, showAvatar, id) {
  return {
    type: MESSAGES_TYPES.CUSTOM_COMPONENT,
    component: ref(component),
    props: props ? ref(props) : void 0,
    sender: MESSAGE_SENDER.RESPONSE,
    timestamp: /* @__PURE__ */ new Date(),
    showAvatar,
    customId: id,
    unread: true
  };
}
function createQuickButton(button) {
  return {
    component: ref(QuickButton),
    label: button.label,
    value: button.value
  };
}
function sinEaseOut(timestamp, begining, change, duration2) {
  return change * ((timestamp = timestamp / duration2 - 1) * timestamp * timestamp + 1) + begining;
}
function scrollWithSlowMotion(target, scrollStart, scroll) {
  const raf = window == null ? void 0 : window.requestAnimationFrame;
  let start = 0;
  const step = (timestamp) => {
    if (!start) {
      start = timestamp;
    }
    const stepScroll = sinEaseOut(timestamp - start, 0, scroll, MESSAGE_BOX_SCROLL_DURATION);
    const total = scrollStart + stepScroll;
    target.scrollTop = total;
    if (total < scrollStart + scroll) {
      raf(step);
    }
  };
  raf(step);
}
function scrollToBottom(messagesDiv) {
  if (!messagesDiv) return;
  const screenHeight = messagesDiv.clientHeight;
  const scrollTop = messagesDiv.scrollTop;
  const scrollOffset = messagesDiv.scrollHeight - (scrollTop + screenHeight);
  if (scrollOffset) scrollWithSlowMotion(messagesDiv, scrollTop, scrollOffset);
}
const Component = { Message: Message$1, Snippet, Custom: Message, CarouselMessage };
function addUserMessage(text2, { id, status, props } = {}, overrides) {
  state$6.messages = [...state$6.messages, createNewMessage(text2, MESSAGE_SENDER.CLIENT, id, status, props, overrides)];
}
function addResponseMessage(text2, { id, status, props } = {}, overrides) {
  state$6.messages = [...state$6.messages, createNewMessage(text2, MESSAGE_SENDER.RESPONSE, id, status, props, overrides)];
  state$6.badgeCount += 1;
}
function addSystemMessage(text2, { id, status, props } = {}, overrides) {
  state$6.messages = [...state$6.messages, createNewMessage(text2, MESSAGE_SENDER.SYSTEM, id, status, props, overrides)];
}
function addLinkSnippet(link2, id, props) {
  state$6.messages = [...state$6.messages, createLinkSnippet(link2, id, props)];
}
function renderCustomComponent(component, props, showAvatar, id) {
  state$6.messages = [...state$6.messages, createComponentMessage(component, props, showAvatar, id)];
}
function addCarouselMessage(items, summary, id, props) {
  state$6.messages = [
    ...state$6.messages,
    createCarouselMessage(items, summary, id, props)
    // Ensure correct parameter order
  ];
}
function addCarouselMessageForAgent(items, summary, id, props) {
  state$6.messages = [
    ...state$6.messages,
    createCarouselMessageForAgent(items, summary, id, props)
    // Ensure correct parameter order
  ];
}
function getWebSocketImplementation() {
  if (typeof globalThis.WebSocket === "undefined") {
    try {
      return require("ws");
    } catch (e) {
      throw new Error('You must install the "ws" package to use Strophe in nodejs.');
    }
  }
  return globalThis.WebSocket;
}
const WebSocket = getWebSocketImplementation();
function getXMLSerializerImplementation() {
  if (typeof globalThis.XMLSerializer === "undefined") {
    let JSDOM;
    try {
      JSDOM = require("jsdom").JSDOM;
    } catch (e) {
      throw new Error('You must install the "ws" package to use Strophe in nodejs.');
    }
    const dom = new JSDOM("");
    return dom.window.XMLSerializer;
  }
  return globalThis.XMLSerializer;
}
const XMLSerializer = getXMLSerializerImplementation();
function getDOMParserImplementation() {
  const DOMParserImplementation = globalThis.DOMParser;
  if (typeof DOMParserImplementation === "undefined") {
    let JSDOM;
    try {
      JSDOM = require("jsdom").JSDOM;
    } catch (e) {
      throw new Error('You must install the "jsdom" package to use Strophe in nodejs.');
    }
    const dom = new JSDOM("");
    return dom.window.DOMParser;
  }
  return DOMParserImplementation;
}
const DOMParser = getDOMParserImplementation();
function getDummyXMLDOMDocument() {
  if (typeof document === "undefined") {
    let JSDOM;
    try {
      JSDOM = require("jsdom").JSDOM;
    } catch (e) {
      throw new Error('You must install the "jsdom" package to use Strophe in nodejs.');
    }
    const dom = new JSDOM("");
    return dom.window.document.implementation.createDocument("jabber:client", "strophe", null);
  }
  return document.implementation.createDocument("jabber:client", "strophe", null);
}
const shims = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DOMParser,
  WebSocket,
  XMLSerializer,
  getDummyXMLDOMDocument
}, Symbol.toStringTag, { value: "Module" }));
const NS = {
  HTTPBIND: "http://jabber.org/protocol/httpbind",
  BOSH: "urn:xmpp:xbosh",
  CLIENT: "jabber:client",
  SERVER: "jabber:server",
  AUTH: "jabber:iq:auth",
  ROSTER: "jabber:iq:roster",
  PROFILE: "jabber:iq:profile",
  DISCO_INFO: "http://jabber.org/protocol/disco#info",
  DISCO_ITEMS: "http://jabber.org/protocol/disco#items",
  MUC: "http://jabber.org/protocol/muc",
  SASL: "urn:ietf:params:xml:ns:xmpp-sasl",
  STREAM: "http://etherx.jabber.org/streams",
  FRAMING: "urn:ietf:params:xml:ns:xmpp-framing",
  BIND: "urn:ietf:params:xml:ns:xmpp-bind",
  SESSION: "urn:ietf:params:xml:ns:xmpp-session",
  VERSION: "jabber:iq:version",
  STANZAS: "urn:ietf:params:xml:ns:xmpp-stanzas",
  XHTML_IM: "http://jabber.org/protocol/xhtml-im",
  XHTML: "http://www.w3.org/1999/xhtml"
};
const PARSE_ERROR_NS = "http://www.w3.org/1999/xhtml";
const XHTML = {
  tags: ["a", "blockquote", "br", "cite", "em", "img", "li", "ol", "p", "span", "strong", "ul", "body"],
  attributes: {
    "a": ["href"],
    "blockquote": ["style"],
    /** @type {never[]} */
    "br": [],
    "cite": ["style"],
    /** @type {never[]} */
    "em": [],
    "img": ["src", "alt", "style", "height", "width"],
    "li": ["style"],
    "ol": ["style"],
    "p": ["style"],
    "span": ["style"],
    /** @type {never[]} */
    "strong": [],
    "ul": ["style"],
    /** @type {never[]} */
    "body": []
  },
  css: [
    "background-color",
    "color",
    "font-family",
    "font-size",
    "font-style",
    "font-weight",
    "margin-left",
    "margin-right",
    "text-align",
    "text-decoration"
  ]
};
const Status = {
  ERROR: 0,
  CONNECTING: 1,
  CONNFAIL: 2,
  AUTHENTICATING: 3,
  AUTHFAIL: 4,
  CONNECTED: 5,
  DISCONNECTED: 6,
  DISCONNECTING: 7,
  ATTACHED: 8,
  REDIRECT: 9,
  CONNTIMEOUT: 10,
  BINDREQUIRED: 11,
  ATTACHFAIL: 12,
  RECONNECTING: 13
};
const ErrorCondition = {
  BAD_FORMAT: "bad-format",
  CONFLICT: "conflict",
  MISSING_JID_NODE: "x-strophe-bad-non-anon-jid",
  NO_AUTH_MECH: "no-auth-mech",
  UNKNOWN_REASON: "unknown"
};
const LOG_LEVELS = {
  DEBUG: 0,
  INFO: 1,
  WARN: 2,
  ERROR: 3,
  FATAL: 4
};
const ElementType = {
  NORMAL: 1,
  TEXT: 3,
  CDATA: 4,
  FRAGMENT: 11
};
let logLevel = LOG_LEVELS.DEBUG;
const log = {
  /**
   * Library consumers can use this function to set the log level of Strophe.
   * The default log level is Strophe.LogLevel.INFO.
   * @param {LogLevel} level
   * @example Strophe.setLogLevel(Strophe.LogLevel.DEBUG);
   */
  setLogLevel(level) {
    if (level < LOG_LEVELS.DEBUG || level > LOG_LEVELS.FATAL) {
      throw new Error("Invalid log level supplied to setLogLevel");
    }
    logLevel = level;
  },
  /**
   *
   * Please note that data sent and received over the wire is logged
   * via {@link Strophe.Connection#rawInput|Strophe.Connection.rawInput()}
   * and {@link Strophe.Connection#rawOutput|Strophe.Connection.rawOutput()}.
   *
   * The different levels and their meanings are
   *
   *   DEBUG - Messages useful for debugging purposes.
   *   INFO - Informational messages.  This is mostly information like
   *     'disconnect was called' or 'SASL auth succeeded'.
   *   WARN - Warnings about potential problems.  This is mostly used
   *     to report transient connection errors like request timeouts.
   *   ERROR - Some error occurred.
   *   FATAL - A non-recoverable fatal error occurred.
   *
   * @param {number} level - The log level of the log message.
   *     This will be one of the values in Strophe.LOG_LEVELS.
   * @param {string} msg - The log message.
   */
  log(level, msg) {
    if (level < logLevel) {
      return;
    }
    if (level >= LOG_LEVELS.ERROR) {
    } else if (level === LOG_LEVELS.INFO) {
    } else if (level === LOG_LEVELS.WARN) {
    } else if (level === LOG_LEVELS.DEBUG) {
    }
  },
  /**
   * Log a message at the Strophe.LOG_LEVELS.DEBUG level.
   * @param {string} msg - The log message.
   */
  debug(msg) {
    this.log(LOG_LEVELS.DEBUG, msg);
  },
  /**
   * Log a message at the Strophe.LOG_LEVELS.INFO level.
   * @param {string} msg - The log message.
   */
  info(msg) {
    this.log(LOG_LEVELS.INFO, msg);
  },
  /**
   * Log a message at the Strophe.LOG_LEVELS.WARN level.
   * @param {string} msg - The log message.
   */
  warn(msg) {
    this.log(LOG_LEVELS.WARN, msg);
  },
  /**
   * Log a message at the Strophe.LOG_LEVELS.ERROR level.
   * @param {string} msg - The log message.
   */
  error(msg) {
    this.log(LOG_LEVELS.ERROR, msg);
  },
  /**
   * Log a message at the Strophe.LOG_LEVELS.FATAL level.
   * @param {string} msg - The log message.
   */
  fatal(msg) {
    this.log(LOG_LEVELS.FATAL, msg);
  }
};
function toElement(string, throwErrorIfInvalidNS) {
  const doc = xmlHtmlNode(string);
  const parserError = getParserError(doc);
  if (parserError) {
    throw new Error(`Parser Error: ${parserError}`);
  }
  const node2 = getFirstElementChild(doc);
  if (["message", "iq", "presence"].includes(node2.nodeName.toLowerCase()) && node2.namespaceURI !== "jabber:client" && node2.namespaceURI !== "jabber:server") {
    const err_msg = `Invalid namespaceURI ${node2.namespaceURI}`;
    if (throwErrorIfInvalidNS) {
      throw new Error(err_msg);
    } else {
      log.error(err_msg);
    }
  }
  return node2;
}
function handleError(e) {
  if (typeof e.stack !== "undefined") {
    log.fatal(e.stack);
  }
  log.fatal("error: " + e.message);
}
function utf16to8(str) {
  let out = "";
  const len = str.length;
  for (let i = 0; i < len; i++) {
    const c = str.charCodeAt(i);
    if (c >= 0 && c <= 127) {
      out += str.charAt(i);
    } else if (c > 2047) {
      out += String.fromCharCode(224 | c >> 12 & 15);
      out += String.fromCharCode(128 | c >> 6 & 63);
      out += String.fromCharCode(128 | c >> 0 & 63);
    } else {
      out += String.fromCharCode(192 | c >> 6 & 31);
      out += String.fromCharCode(128 | c >> 0 & 63);
    }
  }
  return out;
}
function xorArrayBuffers(x2, y) {
  const xIntArray = new Uint8Array(x2);
  const yIntArray = new Uint8Array(y);
  const zIntArray = new Uint8Array(x2.byteLength);
  for (let i = 0; i < x2.byteLength; i++) {
    zIntArray[i] = xIntArray[i] ^ yIntArray[i];
  }
  return zIntArray.buffer;
}
function arrayBufToBase64(buffer) {
  let binary = "";
  const bytes = new Uint8Array(buffer);
  const len = bytes.byteLength;
  for (let i = 0; i < len; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary);
}
function base64ToArrayBuf(str) {
  var _a2;
  return (_a2 = Uint8Array.from(atob(str), (c) => c.charCodeAt(0))) == null ? void 0 : _a2.buffer;
}
function stringToArrayBuf(str) {
  const bytes = new TextEncoder().encode(str);
  return bytes.buffer;
}
function addCookies(cookies) {
  if (typeof document === "undefined") {
    log.error(`addCookies: not adding any cookies, since there's no document object`);
  }
  cookies = cookies || {};
  for (const cookieName in cookies) {
    if (Object.prototype.hasOwnProperty.call(cookies, cookieName)) {
      let expires = "";
      let domain = "";
      let path = "";
      const cookieObj = cookies[cookieName];
      const isObj = typeof cookieObj === "object";
      const cookieValue = escape(unescape(isObj ? cookieObj.value : cookieObj));
      if (isObj) {
        expires = cookieObj.expires ? ";expires=" + cookieObj.expires : "";
        domain = cookieObj.domain ? ";domain=" + cookieObj.domain : "";
        path = cookieObj.path ? ";path=" + cookieObj.path : "";
      }
      document.cookie = cookieName + "=" + cookieValue + expires + domain + path;
    }
  }
}
let _xmlGenerator = null;
function xmlGenerator() {
  if (!_xmlGenerator) {
    _xmlGenerator = getDummyXMLDOMDocument();
  }
  return _xmlGenerator;
}
function xmlTextNode(text2) {
  return xmlGenerator().createTextNode(text2);
}
function xmlHtmlNode(text2) {
  const parser = new DOMParser();
  return parser.parseFromString(text2, "text/xml");
}
function getParserError(doc) {
  var _a2;
  const el = ((_a2 = doc.firstElementChild) == null ? void 0 : _a2.nodeName) === "parsererror" ? doc.firstElementChild : doc.getElementsByTagNameNS(PARSE_ERROR_NS, "parsererror")[0];
  return (el == null ? void 0 : el.nodeName) === "parsererror" ? el == null ? void 0 : el.textContent : null;
}
function getFirstElementChild(el) {
  if (el.firstElementChild) return el.firstElementChild;
  let node2, i = 0;
  const nodes = el.childNodes;
  while (node2 = nodes[i++]) {
    if (node2.nodeType === 1) return (
      /** @type {Element} */
      node2
    );
  }
  return null;
}
function xmlElement(name, attrs, text2) {
  if (!name) return null;
  const node2 = xmlGenerator().createElement(name);
  if (text2 && (typeof text2 === "string" || typeof text2 === "number")) {
    node2.appendChild(xmlTextNode(text2.toString()));
  } else if (typeof attrs === "string" || typeof attrs === "number") {
    node2.appendChild(xmlTextNode(
      /** @type {number|string} */
      attrs.toString()
    ));
    return node2;
  }
  if (!attrs) {
    return node2;
  } else if (Array.isArray(attrs)) {
    for (const attr of attrs) {
      if (Array.isArray(attr)) {
        if (attr[0] != null && attr[1] != null) {
          node2.setAttribute(attr[0], attr[1]);
        }
      }
    }
  } else if (typeof attrs === "object") {
    for (const k2 of Object.keys(attrs)) {
      if (k2 && attrs[k2] != null) {
        node2.setAttribute(k2, attrs[k2].toString());
      }
    }
  }
  return node2;
}
function validTag(tag) {
  for (let i = 0; i < XHTML.tags.length; i++) {
    if (tag === XHTML.tags[i]) {
      return true;
    }
  }
  return false;
}
function validAttribute(tag, attribute2) {
  const attrs = XHTML.attributes[
    /** @type {XHTMLAttrs} */
    tag
  ];
  if ((attrs == null ? void 0 : attrs.length) > 0) {
    for (let i = 0; i < attrs.length; i++) {
      if (attribute2 === attrs[i]) {
        return true;
      }
    }
  }
  return false;
}
function validCSS(style2) {
  for (let i = 0; i < XHTML.css.length; i++) {
    if (style2 === XHTML.css[i]) {
      return true;
    }
  }
  return false;
}
function createFromHtmlElement(elem) {
  let el;
  const tag = elem.nodeName.toLowerCase();
  if (validTag(tag)) {
    try {
      el = xmlElement(tag);
      if (tag in XHTML.attributes) {
        const attrs = XHTML.attributes[
          /** @type {XHTMLAttrs} */
          tag
        ];
        for (let i = 0; i < attrs.length; i++) {
          const attribute2 = attrs[i];
          let value = elem.getAttribute(attribute2);
          if (typeof value === "undefined" || value === null || value === "") {
            continue;
          }
          if (attribute2 === "style" && typeof value === "object") {
            value = /** @type {Object.<'csstext',string>} */
            value.cssText ?? value;
          }
          if (attribute2 === "style") {
            const css2 = [];
            const cssAttrs = value.split(";");
            for (let j2 = 0; j2 < cssAttrs.length; j2++) {
              const attr = cssAttrs[j2].split(":");
              const cssName = attr[0].replace(/^\s*/, "").replace(/\s*$/, "").toLowerCase();
              if (validCSS(cssName)) {
                const cssValue = attr[1].replace(/^\s*/, "").replace(/\s*$/, "");
                css2.push(cssName + ": " + cssValue);
              }
            }
            if (css2.length > 0) {
              value = css2.join("; ");
              el.setAttribute(attribute2, value);
            }
          } else {
            el.setAttribute(attribute2, value);
          }
        }
        for (let i = 0; i < elem.childNodes.length; i++) {
          el.appendChild(createHtml(elem.childNodes[i]));
        }
      }
    } catch (e) {
      el = xmlTextNode("");
    }
  } else {
    el = xmlGenerator().createDocumentFragment();
    for (let i = 0; i < elem.childNodes.length; i++) {
      el.appendChild(createHtml(elem.childNodes[i]));
    }
  }
  return el;
}
function createHtml(node2) {
  if (node2.nodeType === ElementType.NORMAL) {
    return createFromHtmlElement(
      /** @type {HTMLElement} */
      node2
    );
  } else if (node2.nodeType === ElementType.FRAGMENT) {
    const el = xmlGenerator().createDocumentFragment();
    for (let i = 0; i < node2.childNodes.length; i++) {
      el.appendChild(createHtml(node2.childNodes[i]));
    }
    return el;
  } else if (node2.nodeType === ElementType.TEXT) {
    return xmlTextNode(node2.nodeValue);
  }
}
function copyElement(node2) {
  let out;
  if (node2.nodeType === ElementType.NORMAL) {
    const el = (
      /** @type {Element} */
      node2
    );
    out = xmlElement(el.tagName);
    for (let i = 0; i < el.attributes.length; i++) {
      out.setAttribute(el.attributes[i].nodeName, el.attributes[i].value);
    }
    for (let i = 0; i < el.childNodes.length; i++) {
      out.appendChild(copyElement(el.childNodes[i]));
    }
  } else if (node2.nodeType === ElementType.TEXT) {
    out = xmlGenerator().createTextNode(node2.nodeValue);
  }
  return out;
}
function xmlescape(text2) {
  text2 = text2.replace(/\&/g, "&amp;");
  text2 = text2.replace(/</g, "&lt;");
  text2 = text2.replace(/>/g, "&gt;");
  text2 = text2.replace(/'/g, "&apos;");
  text2 = text2.replace(/"/g, "&quot;");
  return text2;
}
function xmlunescape(text2) {
  text2 = text2.replace(/\&amp;/g, "&");
  text2 = text2.replace(/&lt;/g, "<");
  text2 = text2.replace(/&gt;/g, ">");
  text2 = text2.replace(/&apos;/g, "'");
  text2 = text2.replace(/&quot;/g, '"');
  return text2;
}
function forEachChild(elem, elemName, func) {
  for (let i = 0; i < elem.childNodes.length; i++) {
    const childNode = elem.childNodes[i];
    if (childNode.nodeType === ElementType.NORMAL && (!elemName || this.isTagEqual(childNode, elemName))) {
      func(childNode);
    }
  }
}
function isTagEqual(el, name) {
  return el.tagName === name;
}
function getText(elem) {
  if (!elem) return null;
  let str = "";
  if (!elem.childNodes.length && elem.nodeType === ElementType.TEXT) {
    str += elem.nodeValue;
  }
  for (const child of elem.childNodes) {
    if (child.nodeType === ElementType.TEXT) {
      str += child.nodeValue;
    }
  }
  return xmlescape(str);
}
function escapeNode(node2) {
  if (typeof node2 !== "string") {
    return node2;
  }
  return node2.replace(/^\s+|\s+$/g, "").replace(/\\/g, "\\5c").replace(/ /g, "\\20").replace(/\"/g, "\\22").replace(/\&/g, "\\26").replace(/\'/g, "\\27").replace(/\//g, "\\2f").replace(/:/g, "\\3a").replace(/</g, "\\3c").replace(/>/g, "\\3e").replace(/@/g, "\\40");
}
function unescapeNode(node2) {
  if (typeof node2 !== "string") {
    return node2;
  }
  return node2.replace(/\\20/g, " ").replace(/\\22/g, '"').replace(/\\26/g, "&").replace(/\\27/g, "'").replace(/\\2f/g, "/").replace(/\\3a/g, ":").replace(/\\3c/g, "<").replace(/\\3e/g, ">").replace(/\\40/g, "@").replace(/\\5c/g, "\\");
}
function getNodeFromJid(jid) {
  if (jid.indexOf("@") < 0) {
    return null;
  }
  return jid.split("@")[0];
}
function getDomainFromJid(jid) {
  const bare = getBareJidFromJid(jid);
  if (bare.indexOf("@") < 0) {
    return bare;
  } else {
    const parts = bare.split("@");
    parts.splice(0, 1);
    return parts.join("@");
  }
}
function getResourceFromJid(jid) {
  if (!jid) {
    return null;
  }
  const s = jid.split("/");
  if (s.length < 2) {
    return null;
  }
  s.splice(0, 1);
  return s.join("/");
}
function getBareJidFromJid(jid) {
  return jid ? jid.split("/")[0] : null;
}
const utils = {
  utf16to8,
  xorArrayBuffers,
  arrayBufToBase64,
  base64ToArrayBuf,
  stringToArrayBuf,
  addCookies
};
const utils$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addCookies,
  arrayBufToBase64,
  base64ToArrayBuf,
  copyElement,
  createHtml,
  default: utils,
  escapeNode,
  forEachChild,
  getBareJidFromJid,
  getDomainFromJid,
  getFirstElementChild,
  getNodeFromJid,
  getParserError,
  getResourceFromJid,
  getText,
  handleError,
  isTagEqual,
  stringToArrayBuf,
  toElement,
  unescapeNode,
  utf16to8,
  validAttribute,
  validCSS,
  validTag,
  xmlElement,
  xmlGenerator,
  xmlHtmlNode,
  xmlTextNode,
  xmlescape,
  xmlunescape,
  xorArrayBuffers
}, Symbol.toStringTag, { value: "Module" }));
function $build(name, attrs) {
  return new Builder(name, attrs);
}
function $msg(attrs) {
  return new Builder("message", attrs);
}
function $iq(attrs) {
  return new Builder("iq", attrs);
}
function $pres(attrs) {
  return new Builder("presence", attrs);
}
const _Builder = class _Builder {
  /**
   * The attributes should be passed in object notation.
   * @param {string} name - The name of the root element.
   * @param {StanzaAttrs} [attrs] - The attributes for the root element in object notation.
   * @example const b = new Builder('message', {to: 'you', from: 'me'});
   * @example const b = new Builder('messsage', {'xml:lang': 'en'});
   */
  constructor(name, attrs) {
    /**
     * @typedef {Object.<string, string|number>} StanzaAttrs
     * @property {string} [StanzaAttrs.xmlns]
     */
    /** @type {Element} */
    __privateAdd(this, _nodeTree);
    /** @type {Element} */
    __privateAdd(this, _node);
    /** @type {string} */
    __privateAdd(this, _name);
    /** @type {StanzaAttrs} */
    __privateAdd(this, _attrs);
    if (name === "presence" || name === "message" || name === "iq") {
      if (attrs && !attrs.xmlns) {
        attrs.xmlns = NS.CLIENT;
      } else if (!attrs) {
        attrs = { xmlns: NS.CLIENT };
      }
    }
    __privateSet(this, _name, name);
    __privateSet(this, _attrs, attrs);
  }
  /**
   * Creates a new Builder object from an XML string.
   * @param {string} str
   * @returns {Builder}
   * @example const stanza = Builder.fromString('<presence from="juliet@example.com/chamber"></presence>');
   */
  static fromString(str) {
    const el = toElement(str, true);
    const b = new _Builder("");
    __privateSet(b, _nodeTree, el);
    return b;
  }
  buildTree() {
    return xmlElement(__privateGet(this, _name), __privateGet(this, _attrs));
  }
  /** @return {Element} */
  get nodeTree() {
    if (!__privateGet(this, _nodeTree)) {
      __privateSet(this, _nodeTree, this.buildTree());
    }
    return __privateGet(this, _nodeTree);
  }
  /** @return {Element} */
  get node() {
    if (!__privateGet(this, _node)) {
      __privateSet(this, _node, this.tree());
    }
    return __privateGet(this, _node);
  }
  /** @param {Element} el */
  set node(el) {
    __privateSet(this, _node, el);
  }
  /**
   * Render a DOM element and all descendants to a String.
   * @param {Element|Builder} elem - A DOM element.
   * @return {string} - The serialized element tree as a String.
   */
  static serialize(elem) {
    if (!elem) return null;
    const el = elem instanceof _Builder ? elem.tree() : elem;
    const names = [...Array(el.attributes.length).keys()].map((i) => el.attributes[i].nodeName);
    names.sort();
    let result = names.reduce(
      (a, n) => `${a} ${n}="${xmlescape(el.attributes.getNamedItem(n).value)}"`,
      `<${el.nodeName}`
    );
    if (el.childNodes.length > 0) {
      result += ">";
      for (let i = 0; i < el.childNodes.length; i++) {
        const child = el.childNodes[i];
        switch (child.nodeType) {
          case ElementType.NORMAL:
            result += _Builder.serialize(
              /** @type {Element} */
              child
            );
            break;
          case ElementType.TEXT:
            result += xmlescape(child.nodeValue);
            break;
          case ElementType.CDATA:
            result += "<![CDATA[" + child.nodeValue + "]]>";
        }
      }
      result += "</" + el.nodeName + ">";
    } else {
      result += "/>";
    }
    return result;
  }
  /**
   * Return the DOM tree.
   *
   * This function returns the current DOM tree as an element object.  This
   * is suitable for passing to functions like Strophe.Connection.send().
   *
   * @return {Element} The DOM tree as a element object.
   */
  tree() {
    return this.nodeTree;
  }
  /**
   * Serialize the DOM tree to a String.
   *
   * This function returns a string serialization of the current DOM
   * tree.  It is often used internally to pass data to a
   * Strophe.Request object.
   *
   * @return {string} The serialized DOM tree in a String.
   */
  toString() {
    return _Builder.serialize(this.tree());
  }
  /**
   * Make the current parent element the new current element.
   * This function is often used after c() to traverse back up the tree.
   *
   * @example
   *  // For example, to add two children to the same element
   *  builder.c('child1', {}).up().c('child2', {});
   *
   * @return {Builder} The Strophe.Builder object.
   */
  up() {
    this.node = this.node.parentElement ? this.node.parentElement : (
      /** @type {Element} */
      this.node.parentNode
    );
    return this;
  }
  /**
   * Make the root element the new current element.
   *
   * When at a deeply nested element in the tree, this function can be used
   * to jump back to the root of the tree, instead of having to repeatedly
   * call up().
   *
   * @return {Builder} The Strophe.Builder object.
   */
  root() {
    this.node = this.tree();
    return this;
  }
  /**
   * Add or modify attributes of the current element.
   *
   * The attributes should be passed in object notation.
   * This function does not move the current element pointer.
   * @param {Object.<string, string|number|null>} moreattrs - The attributes to add/modify in object notation.
   *  If an attribute is set to `null` or `undefined`, it will be removed.
   * @return {Builder} The Strophe.Builder object.
   */
  attrs(moreattrs) {
    for (const k2 in moreattrs) {
      if (Object.prototype.hasOwnProperty.call(moreattrs, k2)) {
        if (moreattrs[k2] != null) {
          this.node.setAttribute(k2, moreattrs[k2].toString());
        } else {
          this.node.removeAttribute(k2);
        }
      }
    }
    return this;
  }
  /**
   * Add a child to the current element and make it the new current
   * element.
   *
   * This function moves the current element pointer to the child,
   * unless text is provided.  If you need to add another child, it
   * is necessary to use up() to go back to the parent in the tree.
   *
   * @param {string} name - The name of the child.
   * @param {Object.<string, string>|string} [attrs] - The attributes of the child in object notation.
   * @param {string} [text] - The text to add to the child.
   *
   * @return {Builder} The Strophe.Builder object.
   */
  c(name, attrs, text2) {
    const child = xmlElement(name, attrs, text2);
    this.node.appendChild(child);
    if (typeof text2 !== "string" && typeof text2 !== "number") {
      this.node = child;
    }
    return this;
  }
  /**
   * Add a child to the current element and make it the new current
   * element.
   *
   * This function is the same as c() except that instead of using a
   * name and an attributes object to create the child it uses an
   * existing DOM element object.
   *
   * @param {Element} elem - A DOM element.
   * @return {Builder} The Strophe.Builder object.
   */
  cnode(elem) {
    let impNode;
    const xmlGen = xmlGenerator();
    try {
      impNode = xmlGen.importNode !== void 0;
    } catch (e) {
      impNode = false;
    }
    const newElem = impNode ? xmlGen.importNode(elem, true) : copyElement(elem);
    this.node.appendChild(newElem);
    this.node = /** @type {Element} */
    newElem;
    return this;
  }
  /**
   * Add a child text element.
   *
   * This *does not* make the child the new current element since there
   * are no children of text elements.
   *
   * @param {string} text - The text data to append to the current element.
   * @return {Builder} The Strophe.Builder object.
   */
  t(text2) {
    const child = xmlTextNode(text2);
    this.node.appendChild(child);
    return this;
  }
  /**
   * Replace current element contents with the HTML passed in.
   *
   * This *does not* make the child the new current element
   *
   * @param {string} html - The html to insert as contents of current element.
   * @return {Builder} The Strophe.Builder object.
   */
  h(html) {
    const fragment = xmlGenerator().createElement("body");
    fragment.innerHTML = html;
    const xhtml = createHtml(fragment);
    while (xhtml.childNodes.length > 0) {
      this.node.appendChild(xhtml.childNodes[0]);
    }
    return this;
  }
};
_nodeTree = new WeakMap();
_node = new WeakMap();
_name = new WeakMap();
_attrs = new WeakMap();
let Builder = _Builder;
let _requestId = 0;
class Request {
  /**
   * Create and initialize a new Request object.
   *
   * @param {Element} elem - The XML data to be sent in the request.
   * @param {Function} func - The function that will be called when the
   *     XMLHttpRequest readyState changes.
   * @param {number} rid - The BOSH rid attribute associated with this request.
   * @param {number} [sends=0] - The number of times this same request has been sent.
   */
  constructor(elem, func, rid, sends = 0) {
    this.id = ++_requestId;
    this.xmlData = elem;
    this.data = Builder.serialize(elem);
    this.origFunc = func;
    this.func = func;
    this.rid = rid;
    this.date = NaN;
    this.sends = sends;
    this.abort = false;
    this.dead = null;
    this.age = () => this.date ? ((/* @__PURE__ */ new Date()).valueOf() - this.date.valueOf()) / 1e3 : 0;
    this.timeDead = () => this.dead ? ((/* @__PURE__ */ new Date()).valueOf() - this.dead.valueOf()) / 1e3 : 0;
    this.xhr = this._newXHR();
  }
  /**
   * Get a response from the underlying XMLHttpRequest.
   * This function attempts to get a response from the request and checks
   * for errors.
   * @throws "parsererror" - A parser error occured.
   * @throws "bad-format" - The entity has sent XML that cannot be processed.
   * @return {Element} - The DOM element tree of the response.
   */
  getResponse() {
    var _a2;
    const node2 = (_a2 = this.xhr.responseXML) == null ? void 0 : _a2.documentElement;
    if (node2) {
      if (node2.tagName === "parsererror") {
        log.error("invalid response received");
        log.error("responseText: " + this.xhr.responseText);
        log.error("responseXML: " + Builder.serialize(node2));
        throw new Error("parsererror");
      }
    } else if (this.xhr.responseText) {
      log.debug("Got responseText but no responseXML; attempting to parse it with DOMParser...");
      const doc = xmlHtmlNode(this.xhr.responseText);
      const parserError = getParserError(doc);
      if (!doc || parserError) {
        if (parserError) {
          log.error("invalid response received: " + parserError);
          log.error("responseText: " + this.xhr.responseText);
        }
        const error2 = new Error();
        error2.name = ErrorCondition.BAD_FORMAT;
        throw error2;
      }
    }
    return node2;
  }
  /**
   * _Private_ helper function to create XMLHttpRequests.
   * This function creates XMLHttpRequests across all implementations.
   * @private
   * @return {XMLHttpRequest}
   */
  _newXHR() {
    const xhr = new XMLHttpRequest();
    if (xhr.overrideMimeType) {
      xhr.overrideMimeType("text/xml; charset=utf-8");
    }
    xhr.onreadystatechange = this.func.bind(null, this);
    return xhr;
  }
}
let timeoutMultiplier = 1.1;
let secondaryTimeoutMultiplier = 0.1;
class Bosh {
  /**
   * @param {Connection} connection - The Connection that will use BOSH.
   */
  constructor(connection) {
    this._conn = connection;
    this.rid = Math.floor(Math.random() * 4294967295);
    this.sid = null;
    this.hold = 1;
    this.wait = 60;
    this.window = 5;
    this.errors = 0;
    this.inactivity = null;
    this.strip = Bosh.prototype.strip ?? false;
    this.lastResponseHeaders = null;
    this._requests = [];
  }
  /**
   * @param {number} m
   */
  static setTimeoutMultiplier(m2) {
    timeoutMultiplier = m2;
  }
  /**
   * @returns {number}
   */
  static getTimeoutMultplier() {
    return timeoutMultiplier;
  }
  /**
   * @param {number} m
   */
  static setSecondaryTimeoutMultiplier(m2) {
    secondaryTimeoutMultiplier = m2;
  }
  /**
   * @returns {number}
   */
  static getSecondaryTimeoutMultplier() {
    return secondaryTimeoutMultiplier;
  }
  /**
   * _Private_ helper function to generate the <body/> wrapper for BOSH.
   * @private
   * @return {Builder} - A Builder with a <body/> element.
   */
  _buildBody() {
    const bodyWrap = $build("body", {
      "rid": this.rid++,
      "xmlns": NS.HTTPBIND
    });
    if (this.sid !== null) {
      bodyWrap.attrs({ "sid": this.sid });
    }
    if (this._conn.options.keepalive && this._conn._sessionCachingSupported()) {
      this._cacheSession();
    }
    return bodyWrap;
  }
  /**
   * Reset the connection.
   * This function is called by the reset function of the Connection
   */
  _reset() {
    this.rid = Math.floor(Math.random() * 4294967295);
    this.sid = null;
    this.errors = 0;
    if (this._conn._sessionCachingSupported()) {
      sessionStorage.removeItem("strophe-bosh-session");
    }
    this._conn.nextValidRid(this.rid);
  }
  /**
   * _Private_ function that initializes the BOSH connection.
   * Creates and sends the Request that initializes the BOSH connection.
   * @param {number} wait - The optional HTTPBIND wait value.  This is the
   *     time the server will wait before returning an empty result for
   *     a request.  The default setting of 60 seconds is recommended.
   *     Other settings will require tweaks to the Strophe.TIMEOUT value.
   * @param {number} hold - The optional HTTPBIND hold value.  This is the
   *     number of connections the server will hold at one time.  This
   *     should almost always be set to 1 (the default).
   * @param {string} route
   */
  _connect(wait, hold, route) {
    this.wait = wait || this.wait;
    this.hold = hold || this.hold;
    this.errors = 0;
    const body = this._buildBody().attrs({
      "to": this._conn.domain,
      "xml:lang": "en",
      "wait": this.wait,
      "hold": this.hold,
      "content": "text/xml; charset=utf-8",
      "ver": "1.6",
      "xmpp:version": "1.0",
      "xmlns:xmpp": NS.BOSH
    });
    if (route) {
      body.attrs({ route });
    }
    const _connect_cb = this._conn._connect_cb;
    this._requests.push(
      new Request(
        body.tree(),
        this._onRequestStateChange.bind(this, _connect_cb.bind(this._conn)),
        Number(body.tree().getAttribute("rid"))
      )
    );
    this._throttledRequestHandler();
  }
  /**
   * Attach to an already created and authenticated BOSH session.
   *
   * This function is provided to allow Strophe to attach to BOSH
   * sessions which have been created externally, perhaps by a Web
   * application.  This is often used to support auto-login type features
   * without putting user credentials into the page.
   *
   * @param {string} jid - The full JID that is bound by the session.
   * @param {string} sid - The SID of the BOSH session.
   * @param {number} rid - The current RID of the BOSH session.  This RID
   *     will be used by the next request.
   * @param {Function} callback The connect callback function.
   * @param {number} wait - The optional HTTPBIND wait value.  This is the
   *     time the server will wait before returning an empty result for
   *     a request.  The default setting of 60 seconds is recommended.
   *     Other settings will require tweaks to the Strophe.TIMEOUT value.
   * @param {number} hold - The optional HTTPBIND hold value.  This is the
   *     number of connections the server will hold at one time.  This
   *     should almost always be set to 1 (the default).
   * @param {number} wind - The optional HTTBIND window value.  This is the
   *     allowed range of request ids that are valid.  The default is 5.
   */
  _attach(jid, sid, rid, callback, wait, hold, wind) {
    this._conn.jid = jid;
    this.sid = sid;
    this.rid = rid;
    this._conn.connect_callback = callback;
    this._conn.domain = getDomainFromJid(this._conn.jid);
    this._conn.authenticated = true;
    this._conn.connected = true;
    this.wait = wait || this.wait;
    this.hold = hold || this.hold;
    this.window = wind || this.window;
    this._conn._changeConnectStatus(Status.ATTACHED, null);
  }
  /**
   * Attempt to restore a cached BOSH session
   *
   * @param {string} jid - The full JID that is bound by the session.
   *     This parameter is optional but recommended, specifically in cases
   *     where prebinded BOSH sessions are used where it's important to know
   *     that the right session is being restored.
   * @param {Function} callback The connect callback function.
   * @param {number} wait - The optional HTTPBIND wait value.  This is the
   *     time the server will wait before returning an empty result for
   *     a request.  The default setting of 60 seconds is recommended.
   *     Other settings will require tweaks to the Strophe.TIMEOUT value.
   * @param {number} hold - The optional HTTPBIND hold value.  This is the
   *     number of connections the server will hold at one time.  This
   *     should almost always be set to 1 (the default).
   * @param {number} wind - The optional HTTBIND window value.  This is the
   *     allowed range of request ids that are valid.  The default is 5.
   */
  _restore(jid, callback, wait, hold, wind) {
    const session = JSON.parse(sessionStorage.getItem("strophe-bosh-session"));
    if (typeof session !== "undefined" && session !== null && session.rid && session.sid && session.jid && (typeof jid === "undefined" || jid === null || getBareJidFromJid(session.jid) === getBareJidFromJid(jid) || // If authcid is null, then it's an anonymous login, so
    // we compare only the domains:
    getNodeFromJid(jid) === null && getDomainFromJid(session.jid) === jid)) {
      this._conn.restored = true;
      this._attach(session.jid, session.sid, session.rid, callback, wait, hold, wind);
    } else {
      const error2 = new Error("_restore: no restoreable session.");
      error2.name = "StropheSessionError";
      throw error2;
    }
  }
  /**
   * _Private_ handler for the beforeunload event.
   * This handler is used to process the Bosh-part of the initial request.
   * @private
   */
  _cacheSession() {
    if (this._conn.authenticated) {
      if (this._conn.jid && this.rid && this.sid) {
        sessionStorage.setItem(
          "strophe-bosh-session",
          JSON.stringify({
            "jid": this._conn.jid,
            "rid": this.rid,
            "sid": this.sid
          })
        );
      }
    } else {
      sessionStorage.removeItem("strophe-bosh-session");
    }
  }
  /**
   * _Private_ handler for initial connection request.
   * This handler is used to process the Bosh-part of the initial request.
   * @param {Element} bodyWrap - The received stanza.
   */
  _connect_cb(bodyWrap) {
    const typ = bodyWrap.getAttribute("type");
    if (typ !== null && typ === "terminate") {
      let cond = bodyWrap.getAttribute("condition");
      log.error("BOSH-Connection failed: " + cond);
      const conflict = bodyWrap.getElementsByTagName("conflict");
      if (cond !== null) {
        if (cond === "remote-stream-error" && conflict.length > 0) {
          cond = "conflict";
        }
        this._conn._changeConnectStatus(Status.CONNFAIL, cond);
      } else {
        this._conn._changeConnectStatus(Status.CONNFAIL, "unknown");
      }
      this._conn._doDisconnect(cond);
      return Status.CONNFAIL;
    }
    if (!this.sid) {
      this.sid = bodyWrap.getAttribute("sid");
    }
    const wind = bodyWrap.getAttribute("requests");
    if (wind) {
      this.window = parseInt(wind, 10);
    }
    const hold = bodyWrap.getAttribute("hold");
    if (hold) {
      this.hold = parseInt(hold, 10);
    }
    const wait = bodyWrap.getAttribute("wait");
    if (wait) {
      this.wait = parseInt(wait, 10);
    }
    const inactivity = bodyWrap.getAttribute("inactivity");
    if (inactivity) {
      this.inactivity = parseInt(inactivity, 10);
    }
  }
  /**
   * _Private_ part of Connection.disconnect for Bosh
   * @param {Element|Builder} pres - This stanza will be sent before disconnecting.
   */
  _disconnect(pres) {
    this._sendTerminate(pres);
  }
  /**
   * _Private_ function to disconnect.
   * Resets the SID and RID.
   */
  _doDisconnect() {
    this.sid = null;
    this.rid = Math.floor(Math.random() * 4294967295);
    if (this._conn._sessionCachingSupported()) {
      sessionStorage.removeItem("strophe-bosh-session");
    }
    this._conn.nextValidRid(this.rid);
  }
  /**
   * _Private_ function to check if the Request queue is empty.
   * @return {boolean} - True, if there are no Requests queued, False otherwise.
   */
  _emptyQueue() {
    return this._requests.length === 0;
  }
  /**
   * _Private_ function to call error handlers registered for HTTP errors.
   * @private
   * @param {Request} req - The request that is changing readyState.
   */
  _callProtocolErrorHandlers(req) {
    const reqStatus = Bosh._getRequestStatus(req);
    const err_callback = this._conn.protocolErrorHandlers.HTTP[reqStatus];
    if (err_callback) {
      err_callback.call(this, reqStatus);
    }
  }
  /**
   * _Private_ function to handle the error count.
   *
   * Requests are resent automatically until their error count reaches
   * 5.  Each time an error is encountered, this function is called to
   * increment the count and disconnect if the count is too high.
   * @private
   * @param {number} reqStatus - The request status.
   */
  _hitError(reqStatus) {
    this.errors++;
    log.warn("request errored, status: " + reqStatus + ", number of errors: " + this.errors);
    if (this.errors > 4) {
      this._conn._onDisconnectTimeout();
    }
  }
  /**
   * @callback connectionCallback
   * @param {Connection} connection
   */
  /**
   * Called on stream start/restart when no stream:features
   * has been received and sends a blank poll request.
   * @param {connectionCallback} callback
   */
  _no_auth_received(callback) {
    log.warn("Server did not yet offer a supported authentication mechanism. Sending a blank poll request.");
    if (callback) {
      callback = callback.bind(this._conn);
    } else {
      callback = this._conn._connect_cb.bind(this._conn);
    }
    const body = this._buildBody();
    this._requests.push(
      new Request(
        body.tree(),
        this._onRequestStateChange.bind(this, callback),
        Number(body.tree().getAttribute("rid"))
      )
    );
    this._throttledRequestHandler();
  }
  /**
   * _Private_ timeout handler for handling non-graceful disconnection.
   * Cancels all remaining Requests and clears the queue.
   */
  _onDisconnectTimeout() {
    this._abortAllRequests();
  }
  /**
   * _Private_ helper function that makes sure all pending requests are aborted.
   */
  _abortAllRequests() {
    while (this._requests.length > 0) {
      const req = this._requests.pop();
      req.abort = true;
      req.xhr.abort();
      req.xhr.onreadystatechange = function() {
      };
    }
  }
  /**
   * _Private_ handler called by {@link Connection#_onIdle|Connection._onIdle()}.
   * Sends all queued Requests or polls with empty Request if there are none.
   */
  _onIdle() {
    const data = this._conn._data;
    if (this._conn.authenticated && this._requests.length === 0 && data.length === 0 && !this._conn.disconnecting) {
      log.debug("no requests during idle cycle, sending blank request");
      data.push(null);
    }
    if (this._conn.paused) {
      return;
    }
    if (this._requests.length < 2 && data.length > 0) {
      const body = this._buildBody();
      for (let i = 0; i < data.length; i++) {
        if (data[i] !== null) {
          if (data[i] === "restart") {
            body.attrs({
              "to": this._conn.domain,
              "xml:lang": "en",
              "xmpp:restart": "true",
              "xmlns:xmpp": NS.BOSH
            });
          } else {
            body.cnode(
              /** @type {Element} */
              data[i]
            ).up();
          }
        }
      }
      delete this._conn._data;
      this._conn._data = [];
      this._requests.push(
        new Request(
          body.tree(),
          this._onRequestStateChange.bind(this, this._conn._dataRecv.bind(this._conn)),
          Number(body.tree().getAttribute("rid"))
        )
      );
      this._throttledRequestHandler();
    }
    if (this._requests.length > 0) {
      const time_elapsed = this._requests[0].age();
      if (this._requests[0].dead !== null) {
        if (this._requests[0].timeDead() > Math.floor(timeoutMultiplier * this.wait)) {
          this._throttledRequestHandler();
        }
      }
      if (time_elapsed > Math.floor(timeoutMultiplier * this.wait)) {
        log.warn(
          "Request " + this._requests[0].id + " timed out, over " + Math.floor(timeoutMultiplier * this.wait) + " seconds since last activity"
        );
        this._throttledRequestHandler();
      }
    }
  }
  /**
   * Returns the HTTP status code from a {@link Request}
   * @private
   * @param {Request} req - The {@link Request} instance.
   * @param {number} [def] - The default value that should be returned if no status value was found.
   */
  static _getRequestStatus(req, def) {
    let reqStatus;
    if (req.xhr.readyState === 4) {
      try {
        reqStatus = req.xhr.status;
      } catch (e) {
        log.error(
          `Caught an error while retrieving a request's status, reqStatus: ${reqStatus}, message: ${e.message}`
        );
      }
    }
    if (typeof reqStatus === "undefined") {
      reqStatus = typeof def === "number" ? def : 0;
    }
    return reqStatus;
  }
  /**
   * _Private_ handler for {@link Request} state changes.
   *
   * This function is called when the XMLHttpRequest readyState changes.
   * It contains a lot of error handling logic for the many ways that
   * requests can fail, and calls the request callback when requests
   * succeed.
   * @private
   *
   * @param {Function} func - The handler for the request.
   * @param {Request} req - The request that is changing readyState.
   */
  _onRequestStateChange(func, req) {
    log.debug("request id " + req.id + "." + req.sends + " state changed to " + req.xhr.readyState);
    if (req.abort) {
      req.abort = false;
      return;
    }
    if (req.xhr.readyState !== 4) {
      return;
    }
    const reqStatus = Bosh._getRequestStatus(req);
    this.lastResponseHeaders = req.xhr.getAllResponseHeaders();
    if (this._conn.disconnecting && reqStatus >= 400) {
      this._hitError(reqStatus);
      this._callProtocolErrorHandlers(req);
      return;
    }
    const reqIs0 = this._requests[0] === req;
    const reqIs1 = this._requests[1] === req;
    const valid_request = reqStatus > 0 && reqStatus < 500;
    const too_many_retries = req.sends > this._conn.maxRetries;
    if (valid_request || too_many_retries) {
      this._removeRequest(req);
      log.debug("request id " + req.id + " should now be removed");
    }
    if (reqStatus === 200) {
      if (reqIs1 || reqIs0 && this._requests.length > 0 && this._requests[0].age() > Math.floor(timeoutMultiplier * this.wait)) {
        this._restartRequest(0);
      }
      this._conn.nextValidRid(req.rid + 1);
      log.debug("request id " + req.id + "." + req.sends + " got 200");
      func(req);
      this.errors = 0;
    } else if (reqStatus === 0 || reqStatus >= 400 && reqStatus < 600 || reqStatus >= 12e3) {
      log.error("request id " + req.id + "." + req.sends + " error " + reqStatus + " happened");
      this._hitError(reqStatus);
      this._callProtocolErrorHandlers(req);
      if (reqStatus >= 400 && reqStatus < 500) {
        this._conn._changeConnectStatus(Status.DISCONNECTING, null);
        this._conn._doDisconnect();
      }
    } else {
      log.error("request id " + req.id + "." + req.sends + " error " + reqStatus + " happened");
    }
    if (!valid_request && !too_many_retries) {
      this._throttledRequestHandler();
    } else if (too_many_retries && !this._conn.connected) {
      this._conn._changeConnectStatus(Status.CONNFAIL, "giving-up");
    }
  }
  /**
   * _Private_ function to process a request in the queue.
   *
   * This function takes requests off the queue and sends them and
   * restarts dead requests.
   * @private
   *
   * @param {number} i - The index of the request in the queue.
   */
  _processRequest(i) {
    var _a2, _b, _c, _d, _e, _f;
    let req = this._requests[i];
    const reqStatus = Bosh._getRequestStatus(req, -1);
    if (req.sends > this._conn.maxRetries) {
      this._conn._onDisconnectTimeout();
      return;
    }
    const time_elapsed = req.age();
    const primary_timeout = !isNaN(time_elapsed) && time_elapsed > Math.floor(timeoutMultiplier * this.wait);
    const secondary_timeout = req.dead !== null && req.timeDead() > Math.floor(secondaryTimeoutMultiplier * this.wait);
    const server_error = req.xhr.readyState === 4 && (reqStatus < 1 || reqStatus >= 500);
    if (primary_timeout || secondary_timeout || server_error) {
      if (secondary_timeout) {
        log.error(`Request ${this._requests[i].id} timed out (secondary), restarting`);
      }
      req.abort = true;
      req.xhr.abort();
      req.xhr.onreadystatechange = function() {
      };
      this._requests[i] = new Request(req.xmlData, req.origFunc, req.rid, req.sends);
      req = this._requests[i];
    }
    if (req.xhr.readyState === 0) {
      log.debug("request id " + req.id + "." + req.sends + " posting");
      try {
        const content_type = this._conn.options.contentType || "text/xml; charset=utf-8";
        req.xhr.open("POST", this._conn.service, this._conn.options.sync ? false : true);
        if (typeof req.xhr.setRequestHeader !== "undefined") {
          req.xhr.setRequestHeader("Content-Type", content_type);
        }
        if (this._conn.options.withCredentials) {
          req.xhr.withCredentials = true;
        }
      } catch (e2) {
        log.error("XHR open failed: " + e2.toString());
        if (!this._conn.connected) {
          this._conn._changeConnectStatus(Status.CONNFAIL, "bad-service");
        }
        this._conn.disconnect();
        return;
      }
      const sendFunc = () => {
        req.date = (/* @__PURE__ */ new Date()).valueOf();
        if (this._conn.options.customHeaders) {
          const headers = this._conn.options.customHeaders;
          for (const header in headers) {
            if (Object.prototype.hasOwnProperty.call(headers, header)) {
              req.xhr.setRequestHeader(header, headers[header]);
            }
          }
        }
        req.xhr.send(req.data);
      };
      if (req.sends > 1) {
        const backoff = Math.min(Math.floor(timeoutMultiplier * this.wait), Math.pow(req.sends, 3)) * 1e3;
        setTimeout(function() {
          sendFunc();
        }, backoff);
      } else {
        sendFunc();
      }
      req.sends++;
      if (this.strip && req.xmlData.nodeName === "body" && req.xmlData.childNodes.length) {
        (_b = (_a2 = this._conn).xmlOutput) == null ? void 0 : _b.call(_a2, req.xmlData.children[0]);
      } else {
        (_d = (_c = this._conn).xmlOutput) == null ? void 0 : _d.call(_c, req.xmlData);
      }
      (_f = (_e = this._conn).rawOutput) == null ? void 0 : _f.call(_e, req.data);
    } else {
      log.debug(
        "_processRequest: " + (i === 0 ? "first" : "second") + " request has readyState of " + req.xhr.readyState
      );
    }
  }
  /**
   * _Private_ function to remove a request from the queue.
   * @private
   * @param {Request} req - The request to remove.
   */
  _removeRequest(req) {
    log.debug("removing request");
    for (let i = this._requests.length - 1; i >= 0; i--) {
      if (req === this._requests[i]) {
        this._requests.splice(i, 1);
      }
    }
    req.xhr.onreadystatechange = function() {
    };
    this._throttledRequestHandler();
  }
  /**
   * _Private_ function to restart a request that is presumed dead.
   * @private
   *
   * @param {number} i - The index of the request in the queue.
   */
  _restartRequest(i) {
    const req = this._requests[i];
    if (req.dead === null) {
      req.dead = /* @__PURE__ */ new Date();
    }
    this._processRequest(i);
  }
  /**
   * _Private_ function to get a stanza out of a request.
   * Tries to extract a stanza out of a Request Object.
   * When this fails the current connection will be disconnected.
   *
   * @param {Request} req - The Request.
   * @return {Element} - The stanza that was passed.
   */
  _reqToData(req) {
    try {
      return req.getResponse();
    } catch (e) {
      if (e.message !== "parsererror") {
        throw e;
      }
      this._conn.disconnect("strophe-parsererror");
    }
  }
  /**
   * _Private_ function to send initial disconnect sequence.
   *
   * This is the first step in a graceful disconnect.  It sends
   * the BOSH server a terminate body and includes an unavailable
   * presence if authentication has completed.
   * @private
   * @param {Element|Builder} [pres]
   */
  _sendTerminate(pres) {
    log.debug("_sendTerminate was called");
    const body = this._buildBody().attrs({ type: "terminate" });
    const el = pres instanceof Builder ? pres.tree() : pres;
    if (pres) {
      body.cnode(el);
    }
    const req = new Request(
      body.tree(),
      this._onRequestStateChange.bind(this, this._conn._dataRecv.bind(this._conn)),
      Number(body.tree().getAttribute("rid"))
    );
    this._requests.push(req);
    this._throttledRequestHandler();
  }
  /**
   * _Private_ part of the Connection.send function for BOSH
   * Just triggers the RequestHandler to send the messages that are in the queue
   */
  _send() {
    clearTimeout(this._conn._idleTimeout);
    this._throttledRequestHandler();
    this._conn._idleTimeout = setTimeout(() => this._conn._onIdle(), 100);
  }
  /**
   * Send an xmpp:restart stanza.
   */
  _sendRestart() {
    this._throttledRequestHandler();
    clearTimeout(this._conn._idleTimeout);
  }
  /**
   * _Private_ function to throttle requests to the connection window.
   *
   * This function makes sure we don't send requests so fast that the
   * request ids overflow the connection window in the case that one
   * request died.
   * @private
   */
  _throttledRequestHandler() {
    if (!this._requests) {
      log.debug("_throttledRequestHandler called with undefined requests");
    } else {
      log.debug("_throttledRequestHandler called with " + this._requests.length + " requests");
    }
    if (!this._requests || this._requests.length === 0) {
      return;
    }
    if (this._requests.length > 0) {
      this._processRequest(0);
    }
    if (this._requests.length > 1 && Math.abs(this._requests[0].rid - this._requests[1].rid) < this.window) {
      this._processRequest(1);
    }
  }
}
class Handler {
  /**
   * @typedef {Object} HandlerOptions
   * @property {boolean} [HandlerOptions.matchBareFromJid]
   * @property {boolean} [HandlerOptions.ignoreNamespaceFragment]
   */
  /**
   * Create and initialize a new Handler.
   *
   * @param {Function} handler - A function to be executed when the handler is run.
   * @param {string} ns - The namespace to match.
   * @param {string} name - The element name to match.
   * @param {string|string[]} type - The stanza type (or types if an array) to match.
   * @param {string} [id] - The element id attribute to match.
   * @param {string} [from] - The element from attribute to match.
   * @param {HandlerOptions} [options] - Handler options
   */
  constructor(handler, ns, name, type, id, from2, options) {
    this.handler = handler;
    this.ns = ns;
    this.name = name;
    this.type = type;
    this.id = id;
    this.options = options || { "matchBareFromJid": false, "ignoreNamespaceFragment": false };
    if (this.options.matchBareFromJid) {
      this.from = from2 ? getBareJidFromJid(from2) : null;
    } else {
      this.from = from2;
    }
    this.user = true;
  }
  /**
   * Returns the XML namespace attribute on an element.
   * If `ignoreNamespaceFragment` was passed in for this handler, then the
   * URL fragment will be stripped.
   * @param {Element} elem - The XML element with the namespace.
   * @return {string} - The namespace, with optionally the fragment stripped.
   */
  getNamespace(elem) {
    let elNamespace = elem.getAttribute("xmlns");
    if (elNamespace && this.options.ignoreNamespaceFragment) {
      elNamespace = elNamespace.split("#")[0];
    }
    return elNamespace;
  }
  /**
   * Tests if a stanza element (or any of its children) matches the
   * namespace set for this Handler.
   * @param {Element} elem - The XML element to test.
   * @return {boolean} - true if the stanza matches and false otherwise.
   */
  namespaceMatch(elem) {
    if (!this.ns || this.getNamespace(elem) === this.ns) {
      return true;
    }
    for (const child of elem.children ?? []) {
      if (this.getNamespace(child) === this.ns) {
        return true;
      } else if (this.namespaceMatch(child)) {
        return true;
      }
    }
    return false;
  }
  /**
   * Tests if a stanza matches the Handler.
   * @param {Element} elem - The XML element to test.
   * @return {boolean} - true if the stanza matches and false otherwise.
   */
  isMatch(elem) {
    let from2 = elem.getAttribute("from");
    if (this.options.matchBareFromJid) {
      from2 = getBareJidFromJid(from2);
    }
    const elem_type = elem.getAttribute("type");
    if (this.namespaceMatch(elem) && (!this.name || isTagEqual(elem, this.name)) && (!this.type || (Array.isArray(this.type) ? this.type.indexOf(elem_type) !== -1 : elem_type === this.type)) && (!this.id || elem.getAttribute("id") === this.id) && (!this.from || from2 === this.from)) {
      return true;
    }
    return false;
  }
  /**
   * Run the callback on a matching stanza.
   * @param {Element} elem - The DOM element that triggered the Handler.
   * @return {boolean} - A boolean indicating if the handler should remain active.
   */
  run(elem) {
    let result = null;
    try {
      result = this.handler(elem);
    } catch (e) {
      handleError(e);
      throw e;
    }
    return result;
  }
  /**
   * Get a String representation of the Handler object.
   * @return {string}
   */
  toString() {
    return "{Handler: " + this.handler + "(" + this.name + "," + this.id + "," + this.ns + ")}";
  }
}
class TimedHandler {
  /**
   * Create and initialize a new Strophe.TimedHandler object.
   * @param {number} period - The number of milliseconds to wait before the
   *     handler is called.
   * @param {Function} handler - The callback to run when the handler fires.  This
   *     function should take no arguments.
   */
  constructor(period, handler) {
    this.period = period;
    this.handler = handler;
    this.lastCalled = (/* @__PURE__ */ new Date()).getTime();
    this.user = true;
  }
  /**
   * Run the callback for the Strophe.TimedHandler.
   *
   * @return {boolean} Returns the result of running the handler,
   *  which is `true` if the Strophe.TimedHandler should be called again,
   *  and `false` otherwise.
   */
  run() {
    this.lastCalled = (/* @__PURE__ */ new Date()).getTime();
    return this.handler();
  }
  /**
   * Reset the last called time for the Strophe.TimedHandler.
   */
  reset() {
    this.lastCalled = (/* @__PURE__ */ new Date()).getTime();
  }
  /**
   * Get a string representation of the Strophe.TimedHandler object.
   * @return {string}
   */
  toString() {
    return "{TimedHandler: " + this.handler + "(" + this.period + ")}";
  }
}
class SASLMechanism {
  /**
   * PrivateConstructor: Strophe.SASLMechanism
   * SASL auth mechanism abstraction.
   * @param {String} [name] - SASL Mechanism name.
   * @param {Boolean} [isClientFirst] - If client should send response first without challenge.
   * @param {Number} [priority] - Priority.
   */
  constructor(name, isClientFirst, priority) {
    this.mechname = name;
    this.isClientFirst = isClientFirst;
    this.priority = priority;
  }
  /**
   * Checks if mechanism able to run.
   * To disable a mechanism, make this return false;
   *
   * To disable plain authentication run
   * > Strophe.SASLPlain.test = function() {
   * >   return false;
   * > }
   *
   * See <SASL mechanisms> for a list of available mechanisms.
   * @param {Connection} connection - Target Connection.
   * @return {boolean} If mechanism was able to run.
   */
  // eslint-disable-next-line class-methods-use-this, no-unused-vars
  test(connection) {
    return true;
  }
  /**
   * Called before starting mechanism on some connection.
   * @param {Connection} connection - Target Connection.
   */
  onStart(connection) {
    this._connection = connection;
  }
  /**
   * Called by protocol implementation on incoming challenge.
   *
   * By deafult, if the client is expected to send data first (isClientFirst === true),
   * this method is called with `challenge` as null on the first call,
   * unless `clientChallenge` is overridden in the relevant subclass.
   * @param {Connection} connection - Target Connection.
   * @param {string} [challenge] - current challenge to handle.
   * @return {string|Promise<string|false>} Mechanism response.
   */
  // eslint-disable-next-line no-unused-vars, class-methods-use-this
  onChallenge(connection, challenge) {
    throw new Error("You should implement challenge handling!");
  }
  /**
   * Called by the protocol implementation if the client is expected to send
   * data first in the authentication exchange (i.e. isClientFirst === true).
   * @param {Connection} connection - Target Connection.
   * @return {string|Promise<string|false>} Mechanism response.
   */
  clientChallenge(connection) {
    if (!this.isClientFirst) {
      throw new Error("clientChallenge should not be called if isClientFirst is false!");
    }
    return this.onChallenge(connection);
  }
  /**
   * Protocol informs mechanism implementation about SASL failure.
   */
  onFailure() {
    this._connection = null;
  }
  /**
   * Protocol informs mechanism implementation about SASL success.
   */
  onSuccess() {
    this._connection = null;
  }
}
class SASLAnonymous extends SASLMechanism {
  /**
   * SASL ANONYMOUS authentication.
   */
  constructor(mechname = "ANONYMOUS", isClientFirst = false, priority = 20) {
    super(mechname, isClientFirst, priority);
  }
  /**
   * @param {Connection} connection
   */
  // eslint-disable-next-line class-methods-use-this
  test(connection) {
    return connection.authcid === null;
  }
}
class SASLExternal extends SASLMechanism {
  /**
   * SASL EXTERNAL authentication.
   *
   * The EXTERNAL mechanism allows a client to request the server to use
   * credentials established by means external to the mechanism to
   * authenticate the client. The external means may be, for instance,
   * TLS services.
   */
  constructor(mechname = "EXTERNAL", isClientFirst = true, priority = 10) {
    super(mechname, isClientFirst, priority);
  }
  /**
   * @param {Connection} connection
   */
  // eslint-disable-next-line class-methods-use-this
  onChallenge(connection) {
    return connection.authcid === connection.authzid ? "" : connection.authzid;
  }
}
class SASLOAuthBearer extends SASLMechanism {
  /**
   * SASL OAuth Bearer authentication.
   */
  constructor(mechname = "OAUTHBEARER", isClientFirst = true, priority = 40) {
    super(mechname, isClientFirst, priority);
  }
  /**
   * @param {Connection} connection
   */
  // eslint-disable-next-line class-methods-use-this
  test(connection) {
    return connection.pass !== null;
  }
  /**
   * @param {Connection} connection
   */
  // eslint-disable-next-line class-methods-use-this
  onChallenge(connection) {
    let auth_str = "n,";
    if (connection.authcid !== null) {
      auth_str = auth_str + "a=" + connection.authzid;
    }
    auth_str = auth_str + ",";
    auth_str = auth_str + "";
    auth_str = auth_str + "auth=Bearer ";
    auth_str = auth_str + connection.pass;
    auth_str = auth_str + "";
    auth_str = auth_str + "";
    return utils.utf16to8(auth_str);
  }
}
class SASLPlain extends SASLMechanism {
  /**
   * SASL PLAIN authentication.
   */
  constructor(mechname = "PLAIN", isClientFirst = true, priority = 50) {
    super(mechname, isClientFirst, priority);
  }
  /**
   * @param {Connection} connection
   */
  // eslint-disable-next-line class-methods-use-this
  test(connection) {
    return connection.authcid !== null;
  }
  /**
   * @param {Connection} connection
   */
  // eslint-disable-next-line class-methods-use-this
  onChallenge(connection) {
    const { authcid, authzid, domain, pass } = connection;
    if (!domain) {
      throw new Error("SASLPlain onChallenge: domain is not defined!");
    }
    let auth_str = authzid !== `${authcid}@${domain}` ? authzid : "";
    auth_str = auth_str + "\0";
    auth_str = auth_str + authcid;
    auth_str = auth_str + "\0";
    auth_str = auth_str + pass;
    return utils.utf16to8(auth_str);
  }
}
async function scramClientProof(authMessage, clientKey, hashName) {
  const storedKey = await crypto.subtle.importKey(
    "raw",
    await crypto.subtle.digest(hashName, clientKey),
    { "name": "HMAC", "hash": hashName },
    false,
    ["sign"]
  );
  const clientSignature = await crypto.subtle.sign("HMAC", storedKey, utils.stringToArrayBuf(authMessage));
  return utils.xorArrayBuffers(clientKey, clientSignature);
}
function scramParseChallenge(challenge) {
  let nonce, salt, iter;
  const attribMatch = /([a-z]+)=([^,]+)(,|$)/;
  while (challenge.match(attribMatch)) {
    const matches = challenge.match(attribMatch);
    challenge = challenge.replace(matches[0], "");
    switch (matches[1]) {
      case "r":
        nonce = matches[2];
        break;
      case "s":
        salt = utils.base64ToArrayBuf(matches[2]);
        break;
      case "i":
        iter = parseInt(matches[2], 10);
        break;
      case "m":
        return void 0;
    }
  }
  if (isNaN(iter) || iter < 4096) {
    log.warn("Failing SCRAM authentication because server supplied iteration count < 4096.");
    return void 0;
  }
  if (!salt) {
    log.warn("Failing SCRAM authentication because server supplied incorrect salt.");
    return void 0;
  }
  return { "nonce": nonce, "salt": salt, "iter": iter };
}
async function scramDeriveKeys(password, salt, iter, hashName, hashBits) {
  const saltedPasswordBits = await crypto.subtle.deriveBits(
    { "name": "PBKDF2", "salt": salt, "iterations": iter, "hash": { "name": hashName } },
    await crypto.subtle.importKey("raw", utils.stringToArrayBuf(password), "PBKDF2", false, ["deriveBits"]),
    hashBits
  );
  const saltedPassword = await crypto.subtle.importKey(
    "raw",
    saltedPasswordBits,
    { "name": "HMAC", "hash": hashName },
    false,
    ["sign"]
  );
  return {
    "ck": await crypto.subtle.sign("HMAC", saltedPassword, utils.stringToArrayBuf("Client Key")),
    "sk": await crypto.subtle.sign("HMAC", saltedPassword, utils.stringToArrayBuf("Server Key"))
  };
}
async function scramServerSign(authMessage, sk, hashName) {
  const serverKey = await crypto.subtle.importKey("raw", sk, { "name": "HMAC", "hash": hashName }, false, ["sign"]);
  return crypto.subtle.sign("HMAC", serverKey, utils.stringToArrayBuf(authMessage));
}
function generate_cnonce() {
  const bytes = new Uint8Array(16);
  return utils.arrayBufToBase64(crypto.getRandomValues(bytes).buffer);
}
const scram = {
  /**
   * On success, sets
   * connection_sasl_data["server-signature"]
   * and
   * connection._sasl_data.keys
   *
   * The server signature should be verified after this function completes..
   *
   * On failure, returns connection._sasl_failure_cb();
   * @param {Connection} connection
   * @param {string} challenge
   * @param {string} hashName
   * @param {number} hashBits
   */
  async scramResponse(connection, challenge, hashName, hashBits) {
    const cnonce = connection._sasl_data.cnonce;
    const challengeData = scramParseChallenge(challenge);
    if (!challengeData && (challengeData == null ? void 0 : challengeData.nonce.slice(0, cnonce.length)) !== cnonce) {
      log.warn("Failing SCRAM authentication because server supplied incorrect nonce.");
      connection._sasl_data = {};
      return connection._sasl_failure_cb();
    }
    let clientKey, serverKey;
    const { pass } = connection;
    if (typeof connection.pass === "string" || connection.pass instanceof String) {
      const keys = await scramDeriveKeys(
        /** @type {string} */
        pass,
        challengeData.salt,
        challengeData.iter,
        hashName,
        hashBits
      );
      clientKey = keys.ck;
      serverKey = keys.sk;
    } else if (
      // Either restore the client key and server key passed in, or derive new ones
      /** @type {Password} */
      (pass == null ? void 0 : pass.name) === hashName && /** @type {Password} */
      (pass == null ? void 0 : pass.salt) === utils.arrayBufToBase64(challengeData.salt) && /** @type {Password} */
      (pass == null ? void 0 : pass.iter) === challengeData.iter
    ) {
      const { ck, sk } = (
        /** @type {Password} */
        pass
      );
      clientKey = utils.base64ToArrayBuf(ck);
      serverKey = utils.base64ToArrayBuf(sk);
    } else {
      return connection._sasl_failure_cb();
    }
    const clientFirstMessageBare = connection._sasl_data["client-first-message-bare"];
    const serverFirstMessage = challenge;
    const clientFinalMessageBare = `c=biws,r=${challengeData.nonce}`;
    const authMessage = `${clientFirstMessageBare},${serverFirstMessage},${clientFinalMessageBare}`;
    const clientProof = await scramClientProof(authMessage, clientKey, hashName);
    const serverSignature = await scramServerSign(authMessage, serverKey, hashName);
    connection._sasl_data["server-signature"] = utils.arrayBufToBase64(serverSignature);
    connection._sasl_data.keys = {
      "name": hashName,
      "iter": challengeData.iter,
      "salt": utils.arrayBufToBase64(challengeData.salt),
      "ck": utils.arrayBufToBase64(clientKey),
      "sk": utils.arrayBufToBase64(serverKey)
    };
    return `${clientFinalMessageBare},p=${utils.arrayBufToBase64(clientProof)}`;
  },
  /**
   * Returns a string containing the client first message
   * @param {Connection} connection
   * @param {string} test_cnonce
   */
  clientChallenge(connection, test_cnonce) {
    const cnonce = test_cnonce || generate_cnonce();
    const client_first_message_bare = `n=${connection.authcid},r=${cnonce}`;
    connection._sasl_data.cnonce = cnonce;
    connection._sasl_data["client-first-message-bare"] = client_first_message_bare;
    return `n,,${client_first_message_bare}`;
  }
};
class SASLSHA1 extends SASLMechanism {
  /**
   * SASL SCRAM SHA 1 authentication.
   */
  constructor(mechname = "SCRAM-SHA-1", isClientFirst = true, priority = 60) {
    super(mechname, isClientFirst, priority);
  }
  /**
   * @param {Connection} connection
   */
  // eslint-disable-next-line class-methods-use-this
  test(connection) {
    return connection.authcid !== null;
  }
  /**
   * @param {Connection} connection
   * @param {string} [challenge]
   * @return {Promise<string|false>} Mechanism response.
   */
  // eslint-disable-next-line class-methods-use-this
  async onChallenge(connection, challenge) {
    return await scram.scramResponse(connection, challenge, "SHA-1", 160);
  }
  /**
   * @param {Connection} connection
   * @param {string} [test_cnonce]
   */
  // eslint-disable-next-line class-methods-use-this
  clientChallenge(connection, test_cnonce) {
    return scram.clientChallenge(connection, test_cnonce);
  }
}
class SASLSHA256 extends SASLMechanism {
  /**
   * SASL SCRAM SHA 256 authentication.
   */
  constructor(mechname = "SCRAM-SHA-256", isClientFirst = true, priority = 70) {
    super(mechname, isClientFirst, priority);
  }
  /**
   * @param {Connection} connection
   */
  // eslint-disable-next-line class-methods-use-this
  test(connection) {
    return connection.authcid !== null;
  }
  /**
   * @param {Connection} connection
   * @param {string} [challenge]
   */
  // eslint-disable-next-line class-methods-use-this
  async onChallenge(connection, challenge) {
    return await scram.scramResponse(connection, challenge, "SHA-256", 256);
  }
  /**
   * @param {Connection} connection
   * @param {string} [test_cnonce]
   */
  // eslint-disable-next-line class-methods-use-this
  clientChallenge(connection, test_cnonce) {
    return scram.clientChallenge(connection, test_cnonce);
  }
}
class SASLSHA384 extends SASLMechanism {
  /**
   * SASL SCRAM SHA 384 authentication.
   */
  constructor(mechname = "SCRAM-SHA-384", isClientFirst = true, priority = 71) {
    super(mechname, isClientFirst, priority);
  }
  /**
   * @param {Connection} connection
   */
  // eslint-disable-next-line class-methods-use-this
  test(connection) {
    return connection.authcid !== null;
  }
  /**
   * @param {Connection} connection
   * @param {string} [challenge]
   */
  // eslint-disable-next-line class-methods-use-this
  async onChallenge(connection, challenge) {
    return await scram.scramResponse(connection, challenge, "SHA-384", 384);
  }
  /**
   * @param {Connection} connection
   * @param {string} [test_cnonce]
   */
  // eslint-disable-next-line class-methods-use-this
  clientChallenge(connection, test_cnonce) {
    return scram.clientChallenge(connection, test_cnonce);
  }
}
class SASLSHA512 extends SASLMechanism {
  /**
   * SASL SCRAM SHA 512 authentication.
   */
  constructor(mechname = "SCRAM-SHA-512", isClientFirst = true, priority = 72) {
    super(mechname, isClientFirst, priority);
  }
  /**
   * @param {Connection} connection
   */
  // eslint-disable-next-line class-methods-use-this
  test(connection) {
    return connection.authcid !== null;
  }
  /**
   * @param {Connection} connection
   * @param {string} [challenge]
   */
  // eslint-disable-next-line class-methods-use-this
  async onChallenge(connection, challenge) {
    return await scram.scramResponse(connection, challenge, "SHA-512", 512);
  }
  /**
   * @param {Connection} connection
   * @param {string} [test_cnonce]
   */
  // eslint-disable-next-line class-methods-use-this
  clientChallenge(connection, test_cnonce) {
    return scram.clientChallenge(connection, test_cnonce);
  }
}
class SASLXOAuth2 extends SASLMechanism {
  /**
   * SASL X-OAuth2 authentication.
   */
  constructor(mechname = "X-OAUTH2", isClientFirst = true, priority = 30) {
    super(mechname, isClientFirst, priority);
  }
  /**
   * @param {Connection} connection
   */
  // eslint-disable-next-line class-methods-use-this
  test(connection) {
    return connection.pass !== null;
  }
  /**
   * @param {Connection} connection
   */
  // eslint-disable-next-line class-methods-use-this
  onChallenge(connection) {
    let auth_str = "\0";
    if (connection.authcid !== null) {
      auth_str = auth_str + connection.authzid;
    }
    auth_str = auth_str + "\0";
    auth_str = auth_str + connection.pass;
    return utils.utf16to8(auth_str);
  }
}
class SessionError extends Error {
  /**
   * @param {string} message
   */
  constructor(message2) {
    super(message2);
    this.name = "StropheSessionError";
  }
}
class Websocket {
  /**
   * Create and initialize a WebSocket object.
   * Currently only sets the connection Object.
   * @param {Connection} connection - The Connection that will use WebSockets.
   */
  constructor(connection) {
    this._conn = connection;
    this.strip = "wrapper";
    const service = connection.service;
    if (service.indexOf("ws:") !== 0 && service.indexOf("wss:") !== 0) {
      let new_service = "";
      if (connection.options.protocol === "ws" && location.protocol !== "https:") {
        new_service += "ws";
      } else {
        new_service += "wss";
      }
      new_service += "://" + location.host;
      if (service.indexOf("/") !== 0) {
        new_service += location.pathname + service;
      } else {
        new_service += service;
      }
      connection.service = new_service;
    }
  }
  /**
   * _Private_ helper function to generate the <stream> start tag for WebSockets
   * @private
   * @return {Builder} - A Builder with a <stream> element.
   */
  _buildStream() {
    return $build("open", {
      "xmlns": NS.FRAMING,
      "to": this._conn.domain,
      "version": "1.0"
    });
  }
  /**
   * _Private_ checks a message for stream:error
   * @private
   * @param {Element} bodyWrap - The received stanza.
   * @param {number} connectstatus - The ConnectStatus that will be set on error.
   * @return {boolean} - true if there was a streamerror, false otherwise.
   */
  _checkStreamError(bodyWrap, connectstatus) {
    let errors2;
    if (bodyWrap.getElementsByTagNameNS) {
      errors2 = bodyWrap.getElementsByTagNameNS(NS.STREAM, "error");
    } else {
      errors2 = bodyWrap.getElementsByTagName("stream:error");
    }
    if (errors2.length === 0) {
      return false;
    }
    const error2 = errors2[0];
    let condition = "";
    let text2 = "";
    const ns = "urn:ietf:params:xml:ns:xmpp-streams";
    for (let i = 0; i < error2.childNodes.length; i++) {
      const e = error2.childNodes[i];
      if (e.nodeType === e.ELEMENT_NODE) {
        const el = (
          /** @type {any} */
          e
        );
        if (el.getAttribute("xmlns") !== ns) {
          break;
        }
      }
      if (e.nodeName === "text") {
        text2 = e.textContent;
      } else {
        condition = e.nodeName;
      }
    }
    let errorString = "WebSocket stream error: ";
    if (condition) {
      errorString += condition;
    } else {
      errorString += "unknown";
    }
    if (text2) {
      errorString += " - " + text2;
    }
    log.error(errorString);
    this._conn._changeConnectStatus(connectstatus, condition);
    this._conn._doDisconnect();
    return true;
  }
  /**
   * Reset the connection.
   *
   * This function is called by the reset function of the Strophe Connection.
   * Is not needed by WebSockets.
   */
  // eslint-disable-next-line class-methods-use-this
  _reset() {
    return;
  }
  /**
   * _Private_ function called by Connection.connect
   *
   * Creates a WebSocket for a connection and assigns Callbacks to it.
   * Does nothing if there already is a WebSocket.
   */
  _connect() {
    this._closeSocket();
    this.socket = new WebSocket(this._conn.service, "xmpp");
    this.socket.onopen = () => this._onOpen();
    this.socket.onerror = (e) => this._onError(e);
    this.socket.onclose = (e) => this._onClose(e);
    this.socket.onmessage = (message2) => this._onInitialMessage(message2);
  }
  /**
   * _Private_ function called by Connection._connect_cb
   * checks for stream:error
   * @param {Element} bodyWrap - The received stanza.
   */
  _connect_cb(bodyWrap) {
    const error2 = this._checkStreamError(bodyWrap, Status.CONNFAIL);
    if (error2) {
      return Status.CONNFAIL;
    }
  }
  /**
   * _Private_ function that checks the opening <open /> tag for errors.
   *
   * Disconnects if there is an error and returns false, true otherwise.
   * @private
   * @param {Element} message - Stanza containing the <open /> tag.
   */
  _handleStreamStart(message2) {
    let error2 = null;
    const ns = message2.getAttribute("xmlns");
    if (typeof ns !== "string") {
      error2 = "Missing xmlns in <open />";
    } else if (ns !== NS.FRAMING) {
      error2 = "Wrong xmlns in <open />: " + ns;
    }
    const ver = message2.getAttribute("version");
    if (typeof ver !== "string") {
      error2 = "Missing version in <open />";
    } else if (ver !== "1.0") {
      error2 = "Wrong version in <open />: " + ver;
    }
    if (error2) {
      this._conn._changeConnectStatus(Status.CONNFAIL, error2);
      this._conn._doDisconnect();
      return false;
    }
    return true;
  }
  /**
   * _Private_ function that handles the first connection messages.
   *
   * On receiving an opening stream tag this callback replaces itself with the real
   * message handler. On receiving a stream error the connection is terminated.
   * @param {MessageEvent} message
   */
  _onInitialMessage(message2) {
    if (message2.data.indexOf("<open ") === 0 || message2.data.indexOf("<?xml") === 0) {
      const data = message2.data.replace(/^(<\?.*?\?>\s*)*/, "");
      if (data === "") return;
      const streamStart = new DOMParser().parseFromString(data, "text/xml").documentElement;
      this._conn.xmlInput(streamStart);
      this._conn.rawInput(message2.data);
      if (this._handleStreamStart(streamStart)) {
        this._connect_cb(streamStart);
      }
    } else if (message2.data.indexOf("<close ") === 0) {
      const parsedMessage = new DOMParser().parseFromString(message2.data, "text/xml").documentElement;
      this._conn.xmlInput(parsedMessage);
      this._conn.rawInput(message2.data);
      const see_uri = parsedMessage.getAttribute("see-other-uri");
      if (see_uri) {
        const service = this._conn.service;
        const isSecureRedirect = service.indexOf("wss:") >= 0 && see_uri.indexOf("wss:") >= 0 || service.indexOf("ws:") >= 0;
        if (isSecureRedirect) {
          this._conn._changeConnectStatus(
            Status.REDIRECT,
            "Received see-other-uri, resetting connection"
          );
          this._conn.reset();
          this._conn.service = see_uri;
          this._connect();
        }
      } else {
        this._conn._changeConnectStatus(Status.CONNFAIL, "Received closing stream");
        this._conn._doDisconnect();
      }
    } else {
      this._replaceMessageHandler();
      const string = this._streamWrap(message2.data);
      const elem = new DOMParser().parseFromString(string, "text/xml").documentElement;
      this._conn._connect_cb(elem, null, message2.data);
    }
  }
  /**
   * Called by _onInitialMessage in order to replace itself with the general message handler.
   * This method is overridden by WorkerWebsocket, which manages a
   * websocket connection via a service worker and doesn't have direct access
   * to the socket.
   */
  _replaceMessageHandler() {
    this.socket.onmessage = (m2) => this._onMessage(m2);
  }
  /**
   * _Private_ function called by Connection.disconnect
   * Disconnects and sends a last stanza if one is given
   * @param {Element|Builder} [pres] - This stanza will be sent before disconnecting.
   */
  _disconnect(pres) {
    if (this.socket && this.socket.readyState !== WebSocket.CLOSED) {
      if (pres) {
        this._conn.send(pres);
      }
      const close2 = $build("close", { "xmlns": NS.FRAMING });
      this._conn.xmlOutput(close2.tree());
      const closeString = Builder.serialize(close2);
      this._conn.rawOutput(closeString);
      try {
        this.socket.send(closeString);
      } catch (e) {
        log.warn(`Couldn't send <close /> tag. "${e.message}"`);
      }
    }
    setTimeout(() => this._conn._doDisconnect(), 0);
  }
  /**
   * _Private_ function to disconnect.
   * Just closes the Socket for WebSockets
   */
  _doDisconnect() {
    log.debug("WebSockets _doDisconnect was called");
    this._closeSocket();
  }
  /**
   * PrivateFunction _streamWrap
   * _Private_ helper function to wrap a stanza in a <stream> tag.
   * This is used so Strophe can process stanzas from WebSockets like BOSH
   * @param {string} stanza
   */
  // eslint-disable-next-line class-methods-use-this
  _streamWrap(stanza) {
    return "<wrapper>" + stanza + "</wrapper>";
  }
  /**
   * _Private_ function to close the WebSocket.
   *
   * Closes the socket if it is still open and deletes it
   */
  _closeSocket() {
    if (this.socket) {
      try {
        this.socket.onclose = null;
        this.socket.onerror = null;
        this.socket.onmessage = null;
        this.socket.close();
      } catch (e) {
        log.debug(e.message);
      }
    }
    this.socket = null;
  }
  /**
   * _Private_ function to check if the message queue is empty.
   * @return {true} - True, because WebSocket messages are send immediately after queueing.
   */
  // eslint-disable-next-line class-methods-use-this
  _emptyQueue() {
    return true;
  }
  /**
   * _Private_ function to handle websockets closing.
   * @param {CloseEvent} [e]
   */
  _onClose(e) {
    if (this._conn.connected && !this._conn.disconnecting) {
      log.error("Websocket closed unexpectedly");
      this._conn._doDisconnect();
    } else if (e && e.code === 1006 && !this._conn.connected && this.socket) {
      log.error("Websocket closed unexcectedly");
      this._conn._changeConnectStatus(
        Status.CONNFAIL,
        "The WebSocket connection could not be established or was disconnected."
      );
      this._conn._doDisconnect();
    } else {
      log.debug("Websocket closed");
    }
  }
  /**
   * @callback connectionCallback
   * @param {Connection} connection
   */
  /**
   * Called on stream start/restart when no stream:features
   * has been received.
   * @param {connectionCallback} callback
   */
  _no_auth_received(callback) {
    log.error("Server did not offer a supported authentication mechanism");
    this._conn._changeConnectStatus(Status.CONNFAIL, ErrorCondition.NO_AUTH_MECH);
    callback == null ? void 0 : callback.call(this._conn);
    this._conn._doDisconnect();
  }
  /**
   * _Private_ timeout handler for handling non-graceful disconnection.
   *
   * This does nothing for WebSockets
   */
  _onDisconnectTimeout() {
  }
  // eslint-disable-line class-methods-use-this
  /**
   * _Private_ helper function that makes sure all pending requests are aborted.
   */
  _abortAllRequests() {
  }
  // eslint-disable-line class-methods-use-this
  /**
   * _Private_ function to handle websockets errors.
   * @param {Object} error - The websocket error.
   */
  _onError(error2) {
    log.error("Websocket error " + JSON.stringify(error2));
    this._conn._changeConnectStatus(
      Status.CONNFAIL,
      "The WebSocket connection could not be established or was disconnected."
    );
    this._disconnect();
  }
  /**
   * _Private_ function called by Connection._onIdle
   * sends all queued stanzas
   */
  _onIdle() {
    const data = this._conn._data;
    if (data.length > 0 && !this._conn.paused) {
      for (let i = 0; i < data.length; i++) {
        if (data[i] !== null) {
          const stanza = data[i] === "restart" ? this._buildStream().tree() : data[i];
          if (stanza === "restart") throw new Error("Wrong type for stanza");
          const rawStanza = Builder.serialize(stanza);
          this._conn.xmlOutput(stanza);
          this._conn.rawOutput(rawStanza);
          this.socket.send(rawStanza);
        }
      }
      this._conn._data = [];
    }
  }
  /**
   * _Private_ function to handle websockets messages.
   *
   * This function parses each of the messages as if they are full documents.
   * [TODO : We may actually want to use a SAX Push parser].
   *
   * Since all XMPP traffic starts with
   * <stream:stream version='1.0'
   *                xml:lang='en'
   *                xmlns='jabber:client'
   *                xmlns:stream='http://etherx.jabber.org/streams'
   *                id='3697395463'
   *                from='SERVER'>
   *
   * The first stanza will always fail to be parsed.
   *
   * Additionally, the seconds stanza will always be <stream:features> with
   * the stream NS defined in the previous stanza, so we need to 'force'
   * the inclusion of the NS in this stanza.
   *
   * @param {MessageEvent} message - The websocket message event
   */
  _onMessage(message2) {
    let elem;
    const close2 = '<close xmlns="urn:ietf:params:xml:ns:xmpp-framing" />';
    if (message2.data === close2) {
      this._conn.rawInput(close2);
      this._conn.xmlInput(message2);
      if (!this._conn.disconnecting) {
        this._conn._doDisconnect();
      }
      return;
    } else if (message2.data.search("<open ") === 0) {
      elem = new DOMParser().parseFromString(message2.data, "text/xml").documentElement;
      if (!this._handleStreamStart(elem)) {
        return;
      }
    } else {
      const data = this._streamWrap(message2.data);
      elem = new DOMParser().parseFromString(data, "text/xml").documentElement;
    }
    if (this._checkStreamError(elem, Status.ERROR)) {
      return;
    }
    if (this._conn.disconnecting && elem.firstElementChild.nodeName === "presence" && elem.firstElementChild.getAttribute("type") === "unavailable") {
      this._conn.xmlInput(elem);
      this._conn.rawInput(Builder.serialize(elem));
      return;
    }
    this._conn._dataRecv(elem, message2.data);
  }
  /**
   * _Private_ function to handle websockets connection setup.
   * The opening stream tag is sent here.
   * @private
   */
  _onOpen() {
    log.debug("Websocket open");
    const start = this._buildStream();
    this._conn.xmlOutput(start.tree());
    const startString = Builder.serialize(start);
    this._conn.rawOutput(startString);
    this.socket.send(startString);
  }
  /**
   * _Private_ part of the Connection.send function for WebSocket
   * Just flushes the messages that are in the queue
   */
  _send() {
    this._conn.flush();
  }
  /**
   * Send an xmpp:restart stanza.
   */
  _sendRestart() {
    clearTimeout(this._conn._idleTimeout);
    this._conn._onIdle.bind(this._conn)();
  }
}
/**
 * @license MIT
 * @copyright JC Brand
 */
class WorkerWebsocket extends Websocket {
  /**
   * @typedef {import("./connection.js").default} Connection
   */
  /**
   * Create and initialize a WorkerWebsocket object.
   * @param {Connection} connection - The Connection
   */
  constructor(connection) {
    super(connection);
    this._conn = connection;
    this.worker = new SharedWorker(this._conn.options.worker, "Strophe XMPP Connection");
    this.worker.onerror = (e) => {
      log.error(`Shared Worker Error: ${e}`);
    };
  }
  /**
   * @private
   */
  _setSocket() {
    this.socket = {
      /** @param {string} str */
      send: (str) => this.worker.port.postMessage(["send", str]),
      close: () => this.worker.port.postMessage(["_closeSocket"]),
      onopen: () => {
      },
      /** @param {ErrorEvent} e */
      onerror: (e) => this._onError(e),
      /** @param {CloseEvent} e */
      onclose: (e) => this._onClose(e),
      onmessage: () => {
      },
      readyState: null
    };
  }
  _connect() {
    this._setSocket();
    this._messageHandler = (m2) => this._onInitialMessage(m2);
    this.worker.port.start();
    this.worker.port.onmessage = (ev) => this._onWorkerMessage(ev);
    this.worker.port.postMessage(["_connect", this._conn.service, this._conn.jid]);
  }
  /**
   * @param {Function} callback
   */
  _attach(callback) {
    this._setSocket();
    this._messageHandler = (m2) => this._onMessage(m2);
    this._conn.connect_callback = callback;
    this.worker.port.start();
    this.worker.port.onmessage = (ev) => this._onWorkerMessage(ev);
    this.worker.port.postMessage(["_attach", this._conn.service]);
  }
  /**
   * @param {number} status
   * @param {string} jid
   */
  _attachCallback(status, jid) {
    if (status === Status.ATTACHED) {
      this._conn.jid = jid;
      this._conn.authenticated = true;
      this._conn.connected = true;
      this._conn.restored = true;
      this._conn._changeConnectStatus(Status.ATTACHED);
    } else if (status === Status.ATTACHFAIL) {
      this._conn.authenticated = false;
      this._conn.connected = false;
      this._conn.restored = false;
      this._conn._changeConnectStatus(Status.ATTACHFAIL);
    }
  }
  /**
   * @param {Element|Builder} pres - This stanza will be sent before disconnecting.
   */
  _disconnect(pres) {
    pres && this._conn.send(pres);
    const close2 = $build("close", { "xmlns": NS.FRAMING });
    this._conn.xmlOutput(close2.tree());
    const closeString = Builder.serialize(close2);
    this._conn.rawOutput(closeString);
    this.worker.port.postMessage(["send", closeString]);
    this._conn._doDisconnect();
  }
  _closeSocket() {
    this.socket.close();
  }
  /**
   * Called by _onInitialMessage in order to replace itself with the general message handler.
   * This method is overridden by WorkerWebsocket, which manages a
   * websocket connection via a service worker and doesn't have direct access
   * to the socket.
   */
  _replaceMessageHandler() {
    this._messageHandler = (m2) => this._onMessage(m2);
  }
  /**
   * function that handles messages received from the service worker
   * @private
   * @param {MessageEvent} ev
   */
  _onWorkerMessage(ev) {
    const { data } = ev;
    const method_name = data[0];
    if (method_name === "_onMessage") {
      this._messageHandler(data[1]);
    } else if (method_name in this) {
      try {
        this[
          /** @type {'_attachCallback'|'_onOpen'|'_onClose'|'_onError'} */
          method_name
        ].apply(this, ev.data.slice(1));
      } catch (e) {
        log.error(e);
      }
    } else if (method_name === "log") {
      const lmap = {
        debug: LOG_LEVELS.DEBUG,
        info: LOG_LEVELS.INFO,
        warn: LOG_LEVELS.WARN,
        error: LOG_LEVELS.ERROR,
        fatal: LOG_LEVELS.FATAL
      };
      const level = data[1];
      const msg = data[2];
      log.log(lmap[level], msg);
    } else {
      log.error(`Found unhandled service worker message: ${data}`);
    }
  }
}
const connectionPlugins = {};
class Connection {
  /**
   * @typedef {Object.<string, string>} Cookie
   * @typedef {Cookie|Object.<string, Cookie>} Cookies
   */
  /**
   * Create and initialize a {@link Connection} object.
   *
   * The transport-protocol for this connection will be chosen automatically
   * based on the given service parameter. URLs starting with "ws://" or
   * "wss://" will use WebSockets, URLs starting with "http://", "https://"
   * or without a protocol will use [BOSH](https://xmpp.org/extensions/xep-0124.html).
   *
   * To make Strophe connect to the current host you can leave out the protocol
   * and host part and just pass the path:
   *
   *  const conn = new Strophe.Connection("/http-bind/");
   *
   * @param {string} service - The BOSH or WebSocket service URL.
   * @param {ConnectionOptions} options - A object containing configuration options
   */
  constructor(service, options = {}) {
    this.service = service;
    this.options = options;
    this.setProtocol();
    this.jid = "";
    this.domain = null;
    this.features = null;
    this._sasl_data = {};
    this.do_bind = false;
    this.do_session = false;
    this.mechanisms = {};
    this.timedHandlers = [];
    this.handlers = [];
    this.removeTimeds = [];
    this.removeHandlers = [];
    this.addTimeds = [];
    this.addHandlers = [];
    this.protocolErrorHandlers = {
      /** @type {Object.<number, Function>} */
      "HTTP": {},
      /** @type {Object.<number, Function>} */
      "websocket": {}
    };
    this._idleTimeout = null;
    this._disconnectTimeout = null;
    this.authenticated = false;
    this.connected = false;
    this.disconnecting = false;
    this.do_authentication = true;
    this.paused = false;
    this.restored = false;
    this._data = [];
    this._uniqueId = 0;
    this._sasl_success_handler = null;
    this._sasl_failure_handler = null;
    this._sasl_challenge_handler = null;
    this.maxRetries = 5;
    this._idleTimeout = setTimeout(() => this._onIdle(), 100);
    addCookies(this.options.cookies);
    this.registerSASLMechanisms(this.options.mechanisms);
    this.iqFallbackHandler = new Handler(
      /**
       * @param {Element} iq
       */
      (iq) => this.send(
        $iq({ type: "error", id: iq.getAttribute("id") }).c("error", { "type": "cancel" }).c("service-unavailable", { "xmlns": NS.STANZAS })
      ),
      null,
      "iq",
      ["get", "set"]
    );
    for (const k2 in connectionPlugins) {
      if (Object.prototype.hasOwnProperty.call(connectionPlugins, k2)) {
        const F = function() {
        };
        F.prototype = connectionPlugins[k2];
        this[k2] = new F();
        this[k2].init(this);
      }
    }
  }
  /**
   * Extends the Connection object with the given plugin.
   * @param {string} name - The name of the extension.
   * @param {Object} ptype - The plugin's prototype.
   */
  static addConnectionPlugin(name, ptype) {
    connectionPlugins[name] = ptype;
  }
  /**
   * Select protocal based on this.options or this.service
   */
  setProtocol() {
    const proto = this.options.protocol || "";
    if (this.options.worker) {
      this._proto = new WorkerWebsocket(this);
    } else if (this.service.indexOf("ws:") === 0 || this.service.indexOf("wss:") === 0 || proto.indexOf("ws") === 0) {
      this._proto = new Websocket(this);
    } else {
      this._proto = new Bosh(this);
    }
  }
  /**
   * Reset the connection.
   *
   * This function should be called after a connection is disconnected
   * before that connection is reused.
   */
  reset() {
    this._proto._reset();
    this.do_session = false;
    this.do_bind = false;
    this.timedHandlers = [];
    this.handlers = [];
    this.removeTimeds = [];
    this.removeHandlers = [];
    this.addTimeds = [];
    this.addHandlers = [];
    this.authenticated = false;
    this.connected = false;
    this.disconnecting = false;
    this.restored = false;
    this._data = [];
    this._requests = [];
    this._uniqueId = 0;
  }
  /**
   * Pause the request manager.
   *
   * This will prevent Strophe from sending any more requests to the
   * server.  This is very useful for temporarily pausing
   * BOSH-Connections while a lot of send() calls are happening quickly.
   * This causes Strophe to send the data in a single request, saving
   * many request trips.
   */
  pause() {
    this.paused = true;
  }
  /**
   * Resume the request manager.
   *
   * This resumes after pause() has been called.
   */
  resume() {
    this.paused = false;
  }
  /**
   * Generate a unique ID for use in <iq/> elements.
   *
   * All <iq/> stanzas are required to have unique id attributes.  This
   * function makes creating these easy.  Each connection instance has
   * a counter which starts from zero, and the value of this counter
   * plus a colon followed by the suffix becomes the unique id. If no
   * suffix is supplied, the counter is used as the unique id.
   *
   * Suffixes are used to make debugging easier when reading the stream
   * data, and their use is recommended.  The counter resets to 0 for
   * every new connection for the same reason.  For connections to the
   * same server that authenticate the same way, all the ids should be
   * the same, which makes it easy to see changes.  This is useful for
   * automated testing as well.
   *
   * @param {string} suffix - A optional suffix to append to the id.
   * @returns {string} A unique string to be used for the id attribute.
   */
  // eslint-disable-next-line class-methods-use-this
  getUniqueId(suffix) {
    const uuid = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
      const r2 = Math.random() * 16 | 0, v2 = c === "x" ? r2 : r2 & 3 | 8;
      return v2.toString(16);
    });
    if (typeof suffix === "string" || typeof suffix === "number") {
      return uuid + ":" + suffix;
    } else {
      return uuid + "";
    }
  }
  /**
   * Register a handler function for when a protocol (websocker or HTTP)
   * error occurs.
   *
   * NOTE: Currently only HTTP errors for BOSH requests are handled.
   * Patches that handle websocket errors would be very welcome.
   *
   * @example
   *  function onError(err_code){
   *    //do stuff
   *  }
   *
   *  const conn = Strophe.connect('http://example.com/http-bind');
   *  conn.addProtocolErrorHandler('HTTP', 500, onError);
   *  // Triggers HTTP 500 error and onError handler will be called
   *  conn.connect('user_jid@incorrect_jabber_host', 'secret', onConnect);
   *
   * @param {'HTTP'|'websocket'} protocol - 'HTTP' or 'websocket'
   * @param {number} status_code - Error status code (e.g 500, 400 or 404)
   * @param {Function} callback - Function that will fire on Http error
   */
  addProtocolErrorHandler(protocol, status_code, callback) {
    this.protocolErrorHandlers[protocol][status_code] = callback;
  }
  /**
   * @typedef {Object} Password
   * @property {string} Password.name
   * @property {string} Password.ck
   * @property {string} Password.sk
   * @property {number} Password.iter
   * @property {string} Password.salt
   */
  /**
   * Starts the connection process.
   *
   * As the connection process proceeds, the user supplied callback will
   * be triggered multiple times with status updates.  The callback
   * should take two arguments - the status code and the error condition.
   *
   * The status code will be one of the values in the Strophe.Status
   * constants.  The error condition will be one of the conditions
   * defined in RFC 3920 or the condition 'strophe-parsererror'.
   *
   * The Parameters _wait_, _hold_ and _route_ are optional and only relevant
   * for BOSH connections. Please see XEP 124 for a more detailed explanation
   * of the optional parameters.
   *
   * @param {string} jid - The user's JID.  This may be a bare JID,
   *     or a full JID.  If a node is not supplied, SASL OAUTHBEARER or
   *     SASL ANONYMOUS authentication will be attempted (OAUTHBEARER will
   *     process the provided password value as an access token).
   *   (String or Object) pass - The user's password, or an object containing
   *     the users SCRAM client and server keys, in a fashion described as follows:
   *
   *     { name: String, representing the hash used (eg. SHA-1),
   *       salt: String, base64 encoded salt used to derive the client key,
   *       iter: Int,    the iteration count used to derive the client key,
   *       ck:   String, the base64 encoding of the SCRAM client key
   *       sk:   String, the base64 encoding of the SCRAM server key
   *     }
   * @param {string|Password} pass - The user password
   * @param {Function} callback - The connect callback function.
   * @param {number} [wait] - The optional HTTPBIND wait value.  This is the
   *     time the server will wait before returning an empty result for
   *     a request.  The default setting of 60 seconds is recommended.
   * @param {number} [hold] - The optional HTTPBIND hold value.  This is the
   *     number of connections the server will hold at one time.  This
   *     should almost always be set to 1 (the default).
   * @param {string} [route] - The optional route value.
   * @param {string} [authcid] - The optional alternative authentication identity
   *     (username) if intending to impersonate another user.
   *     When using the SASL-EXTERNAL authentication mechanism, for example
   *     with client certificates, then the authcid value is used to
   *     determine whether an authorization JID (authzid) should be sent to
   *     the server. The authzid should NOT be sent to the server if the
   *     authzid and authcid are the same. So to prevent it from being sent
   *     (for example when the JID is already contained in the client
   *     certificate), set authcid to that same JID. See XEP-178 for more
   *     details.
   *  @param {number} [disconnection_timeout=3000] - The optional disconnection timeout
   *     in milliseconds before _doDisconnect will be called.
   */
  connect(jid, pass, callback, wait, hold, route, authcid, disconnection_timeout = 3e3) {
    this.jid = jid;
    this.authzid = getBareJidFromJid(this.jid);
    this.authcid = authcid || getNodeFromJid(this.jid);
    this.pass = pass;
    this.scram_keys = null;
    this.connect_callback = callback;
    this.disconnecting = false;
    this.connected = false;
    this.authenticated = false;
    this.restored = false;
    this.disconnection_timeout = disconnection_timeout;
    this.domain = getDomainFromJid(this.jid);
    this._changeConnectStatus(Status.CONNECTING, null);
    this._proto._connect(wait, hold, route);
  }
  /**
   * Attach to an already created and authenticated BOSH session.
   *
   * This function is provided to allow Strophe to attach to BOSH
   * sessions which have been created externally, perhaps by a Web
   * application.  This is often used to support auto-login type features
   * without putting user credentials into the page.
   *
   * @param {string|Function} jid - The full JID that is bound by the session.
   * @param {string} [sid] - The SID of the BOSH session.
   * @param {number} [rid] - The current RID of the BOSH session.  This RID
   *     will be used by the next request.
   * @param {Function} [callback] - The connect callback function.
   * @param {number} [wait] - The optional HTTPBIND wait value.  This is the
   *     time the server will wait before returning an empty result for
   *     a request.  The default setting of 60 seconds is recommended.
   *     Other settings will require tweaks to the Strophe.TIMEOUT value.
   * @param {number} [hold] - The optional HTTPBIND hold value.  This is the
   *     number of connections the server will hold at one time.  This
   *     should almost always be set to 1 (the default).
   * @param {number} [wind] - The optional HTTBIND window value.  This is the
   *     allowed range of request ids that are valid.  The default is 5.
   */
  attach(jid, sid, rid, callback, wait, hold, wind) {
    if (this._proto instanceof Bosh && typeof jid === "string") {
      return this._proto._attach(jid, sid, rid, callback, wait, hold, wind);
    } else if (this._proto instanceof WorkerWebsocket && typeof jid === "function") {
      const callback2 = jid;
      return this._proto._attach(callback2);
    } else {
      throw new SessionError('The "attach" method is not available for your connection protocol');
    }
  }
  /**
   * Attempt to restore a cached BOSH session.
   *
   * This function is only useful in conjunction with providing the
   * "keepalive":true option when instantiating a new {@link Connection}.
   *
   * When "keepalive" is set to true, Strophe will cache the BOSH tokens
   * RID (Request ID) and SID (Session ID) and then when this function is
   * called, it will attempt to restore the session from those cached
   * tokens.
   *
   * This function must therefore be called instead of connect or attach.
   *
   * For an example on how to use it, please see examples/restore.js
   *
   * @param {string} jid - The user's JID.  This may be a bare JID or a full JID.
   * @param {Function} callback - The connect callback function.
   * @param {number} [wait] - The optional HTTPBIND wait value.  This is the
   *     time the server will wait before returning an empty result for
   *     a request.  The default setting of 60 seconds is recommended.
   * @param {number} [hold] - The optional HTTPBIND hold value.  This is the
   *     number of connections the server will hold at one time.  This
   *     should almost always be set to 1 (the default).
   * @param {number} [wind] - The optional HTTBIND window value.  This is the
   *     allowed range of request ids that are valid.  The default is 5.
   */
  restore(jid, callback, wait, hold, wind) {
    if (!(this._proto instanceof Bosh) || !this._sessionCachingSupported()) {
      throw new SessionError('The "restore" method can only be used with a BOSH connection.');
    }
    if (this._sessionCachingSupported()) {
      this._proto._restore(jid, callback, wait, hold, wind);
    }
  }
  /**
   * Checks whether sessionStorage and JSON are supported and whether we're
   * using BOSH.
   */
  _sessionCachingSupported() {
    if (this._proto instanceof Bosh) {
      if (!JSON) {
        return false;
      }
      try {
        sessionStorage.setItem("_strophe_", "_strophe_");
        sessionStorage.removeItem("_strophe_");
      } catch (e) {
        return false;
      }
      return true;
    }
    return false;
  }
  /**
   * User overrideable function that receives XML data coming into the
   * connection.
   *
   * The default function does nothing.  User code can override this with
   * > Connection.xmlInput = function (elem) {
   * >   (user code)
   * > };
   *
   * Due to limitations of current Browsers' XML-Parsers the opening and closing
   * <stream> tag for WebSocket-Connoctions will be passed as selfclosing here.
   *
   * BOSH-Connections will have all stanzas wrapped in a <body> tag. See
   * <Bosh.strip> if you want to strip this tag.
   *
   * @param {Node|MessageEvent} elem - The XML data received by the connection.
   */
  // eslint-disable-next-line no-unused-vars, class-methods-use-this
  xmlInput(elem) {
    return;
  }
  /**
   * User overrideable function that receives XML data sent to the
   * connection.
   *
   * The default function does nothing.  User code can override this with
   * > Connection.xmlOutput = function (elem) {
   * >   (user code)
   * > };
   *
   * Due to limitations of current Browsers' XML-Parsers the opening and closing
   * <stream> tag for WebSocket-Connoctions will be passed as selfclosing here.
   *
   * BOSH-Connections will have all stanzas wrapped in a <body> tag. See
   * <Bosh.strip> if you want to strip this tag.
   *
   * @param {Element} elem - The XMLdata sent by the connection.
   */
  // eslint-disable-next-line no-unused-vars, class-methods-use-this
  xmlOutput(elem) {
    return;
  }
  /**
   * User overrideable function that receives raw data coming into the
   * connection.
   *
   * The default function does nothing.  User code can override this with
   * > Connection.rawInput = function (data) {
   * >   (user code)
   * > };
   *
   * @param {string} data - The data received by the connection.
   */
  // eslint-disable-next-line no-unused-vars, class-methods-use-this
  rawInput(data) {
    return;
  }
  /**
   * User overrideable function that receives raw data sent to the
   * connection.
   *
   * The default function does nothing.  User code can override this with
   * > Connection.rawOutput = function (data) {
   * >   (user code)
   * > };
   *
   * @param {string} data - The data sent by the connection.
   */
  // eslint-disable-next-line no-unused-vars, class-methods-use-this
  rawOutput(data) {
    return;
  }
  /**
   * User overrideable function that receives the new valid rid.
   *
   * The default function does nothing. User code can override this with
   * > Connection.nextValidRid = function (rid) {
   * >    (user code)
   * > };
   *
   * @param {number} rid - The next valid rid
   */
  // eslint-disable-next-line no-unused-vars, class-methods-use-this
  nextValidRid(rid) {
    return;
  }
  /**
   * Send a stanza.
   *
   * This function is called to push data onto the send queue to
   * go out over the wire.  Whenever a request is sent to the BOSH
   * server, all pending data is sent and the queue is flushed.
   *
   * @param {Element|Builder|Element[]|Builder[]} stanza - The stanza to send
   */
  send(stanza) {
    if (stanza === null) return;
    if (Array.isArray(stanza)) {
      stanza.forEach((s) => this._queueData(s instanceof Builder ? s.tree() : s));
    } else {
      const el = stanza instanceof Builder ? stanza.tree() : stanza;
      this._queueData(el);
    }
    this._proto._send();
  }
  /**
   * Immediately send any pending outgoing data.
   *
   * Normally send() queues outgoing data until the next idle period
   * (100ms), which optimizes network use in the common cases when
   * several send()s are called in succession. flush() can be used to
   * immediately send all pending data.
   */
  flush() {
    clearTimeout(this._idleTimeout);
    this._onIdle();
  }
  /**
   * Helper function to send presence stanzas. The main benefit is for
   * sending presence stanzas for which you expect a responding presence
   * stanza with the same id (for example when leaving a chat room).
   *
   * @param {Element} stanza - The stanza to send.
   * @param {Function} [callback] - The callback function for a successful request.
   * @param {Function} [errback] - The callback function for a failed or timed
   *    out request.  On timeout, the stanza will be null.
   * @param {number} [timeout] - The time specified in milliseconds for a
   *    timeout to occur.
   * @return {string} The id used to send the presence.
   */
  sendPresence(stanza, callback, errback, timeout) {
    let timeoutHandler = null;
    const el = stanza instanceof Builder ? stanza.tree() : stanza;
    let id = el.getAttribute("id");
    if (!id) {
      id = this.getUniqueId("sendPresence");
      el.setAttribute("id", id);
    }
    if (typeof callback === "function" || typeof errback === "function") {
      const handler = this.addHandler(
        /** @param {Element} stanza */
        (stanza2) => {
          if (timeoutHandler) this.deleteTimedHandler(timeoutHandler);
          if (stanza2.getAttribute("type") === "error") {
            errback == null ? void 0 : errback(stanza2);
          } else if (callback) {
            callback(stanza2);
          }
        },
        null,
        "presence",
        null,
        id
      );
      if (timeout) {
        timeoutHandler = this.addTimedHandler(timeout, () => {
          this.deleteHandler(handler);
          errback == null ? void 0 : errback(null);
          return false;
        });
      }
    }
    this.send(el);
    return id;
  }
  /**
   * Helper function to send IQ stanzas.
   *
   * @param {Element|Builder} stanza - The stanza to send.
   * @param {Function} [callback] - The callback function for a successful request.
   * @param {Function} [errback] - The callback function for a failed or timed
   *     out request.  On timeout, the stanza will be null.
   * @param {number} [timeout] - The time specified in milliseconds for a
   *     timeout to occur.
   * @return {string} The id used to send the IQ.
   */
  sendIQ(stanza, callback, errback, timeout) {
    let timeoutHandler = null;
    const el = stanza instanceof Builder ? stanza.tree() : stanza;
    let id = el.getAttribute("id");
    if (!id) {
      id = this.getUniqueId("sendIQ");
      el.setAttribute("id", id);
    }
    if (typeof callback === "function" || typeof errback === "function") {
      const handler = this.addHandler(
        /** @param {Element} stanza */
        (stanza2) => {
          if (timeoutHandler) this.deleteTimedHandler(timeoutHandler);
          const iqtype = stanza2.getAttribute("type");
          if (iqtype === "result") {
            callback == null ? void 0 : callback(stanza2);
          } else if (iqtype === "error") {
            errback == null ? void 0 : errback(stanza2);
          } else {
            const error2 = new Error(`Got bad IQ type of ${iqtype}`);
            error2.name = "StropheError";
            throw error2;
          }
        },
        null,
        "iq",
        ["error", "result"],
        id
      );
      if (timeout) {
        timeoutHandler = this.addTimedHandler(timeout, () => {
          this.deleteHandler(handler);
          errback == null ? void 0 : errback(null);
          return false;
        });
      }
    }
    this.send(el);
    return id;
  }
  /**
   * Queue outgoing data for later sending.  Also ensures that the data
   * is a DOMElement.
   * @private
   * @param {Element} element
   */
  _queueData(element) {
    if (element === null || !element.tagName || !element.childNodes) {
      const error2 = new Error("Cannot queue non-DOMElement.");
      error2.name = "StropheError";
      throw error2;
    }
    this._data.push(element);
  }
  /**
   * Send an xmpp:restart stanza.
   * @private
   */
  _sendRestart() {
    this._data.push("restart");
    this._proto._sendRestart();
    this._idleTimeout = setTimeout(() => this._onIdle(), 100);
  }
  /**
   * Add a timed handler to the connection.
   *
   * This function adds a timed handler.  The provided handler will
   * be called every period milliseconds until it returns false,
   * the connection is terminated, or the handler is removed.  Handlers
   * that wish to continue being invoked should return true.
   *
   * Because of method binding it is necessary to save the result of
   * this function if you wish to remove a handler with
   * deleteTimedHandler().
   *
   * Note that user handlers are not active until authentication is
   * successful.
   *
   * @param {number} period - The period of the handler.
   * @param {Function} handler - The callback function.
   * @return {TimedHandler} A reference to the handler that can be used to remove it.
   */
  addTimedHandler(period, handler) {
    const thand = new TimedHandler(period, handler);
    this.addTimeds.push(thand);
    return thand;
  }
  /**
   * Delete a timed handler for a connection.
   *
   * This function removes a timed handler from the connection.  The
   * handRef parameter is *not* the function passed to addTimedHandler(),
   * but is the reference returned from addTimedHandler().
   * @param {TimedHandler} handRef - The handler reference.
   */
  deleteTimedHandler(handRef) {
    this.removeTimeds.push(handRef);
  }
  /**
   * @typedef {Object} HandlerOptions
   * @property {boolean} [HandlerOptions.matchBareFromJid]
   * @property {boolean} [HandlerOptions.ignoreNamespaceFragment]
   */
  /**
   * Add a stanza handler for the connection.
   *
   * This function adds a stanza handler to the connection.  The
   * handler callback will be called for any stanza that matches
   * the parameters.  Note that if multiple parameters are supplied,
   * they must all match for the handler to be invoked.
   *
   * The handler will receive the stanza that triggered it as its argument.
   * *The handler should return true if it is to be invoked again;
   * returning false will remove the handler after it returns.*
   *
   * As a convenience, the ns parameters applies to the top level element
   * and also any of its immediate children.  This is primarily to make
   * matching /iq/query elements easy.
   *
   * ### Options
   *
   * With the options argument, you can specify boolean flags that affect how
   * matches are being done.
   *
   * Currently two flags exist:
   *
   * * *matchBareFromJid*:
   *     When set to true, the from parameter and the
   *     from attribute on the stanza will be matched as bare JIDs instead
   *     of full JIDs. To use this, pass {matchBareFromJid: true} as the
   *     value of options. The default value for matchBareFromJid is false.
   *
   * * *ignoreNamespaceFragment*:
   *     When set to true, a fragment specified on the stanza's namespace
   *     URL will be ignored when it's matched with the one configured for
   *     the handler.
   *
   *     This means that if you register like this:
   *
   *     >   connection.addHandler(
   *     >       handler,
   *     >       'http://jabber.org/protocol/muc',
   *     >       null, null, null, null,
   *     >       {'ignoreNamespaceFragment': true}
   *     >   );
   *
   *     Then a stanza with XML namespace of
   *     'http://jabber.org/protocol/muc#user' will also be matched. If
   *     'ignoreNamespaceFragment' is false, then only stanzas with
   *     'http://jabber.org/protocol/muc' will be matched.
   *
   * ### Deleting the handler
   *
   * The return value should be saved if you wish to remove the handler
   * with `deleteHandler()`.
   *
   * @param {Function} handler - The user callback.
   * @param {string} ns - The namespace to match.
   * @param {string} name - The stanza name to match.
   * @param {string|string[]} type - The stanza type (or types if an array) to match.
   * @param {string} [id] - The stanza id attribute to match.
   * @param {string} [from] - The stanza from attribute to match.
   * @param {HandlerOptions} [options] - The handler options
   * @return {Handler} A reference to the handler that can be used to remove it.
   */
  addHandler(handler, ns, name, type, id, from2, options) {
    const hand = new Handler(handler, ns, name, type, id, from2, options);
    this.addHandlers.push(hand);
    return hand;
  }
  /**
   * Delete a stanza handler for a connection.
   *
   * This function removes a stanza handler from the connection.  The
   * handRef parameter is *not* the function passed to addHandler(),
   * but is the reference returned from addHandler().
   *
   * @param {Handler} handRef - The handler reference.
   */
  deleteHandler(handRef) {
    this.removeHandlers.push(handRef);
    const i = this.addHandlers.indexOf(handRef);
    if (i >= 0) {
      this.addHandlers.splice(i, 1);
    }
  }
  /**
   * Register the SASL mechanisms which will be supported by this instance of
   * Connection (i.e. which this XMPP client will support).
   * @param {SASLMechanism[]} mechanisms - Array of objects with SASLMechanism prototypes
   */
  registerSASLMechanisms(mechanisms) {
    this.mechanisms = {};
    (mechanisms || [
      SASLAnonymous,
      SASLExternal,
      SASLOAuthBearer,
      SASLXOAuth2,
      SASLPlain,
      SASLSHA1,
      SASLSHA256,
      SASLSHA384,
      SASLSHA512
    ]).forEach((m2) => this.registerSASLMechanism(m2));
  }
  /**
   * Register a single SASL mechanism, to be supported by this client.
   * @param {any} Mechanism - Object with a Strophe.SASLMechanism prototype
   */
  registerSASLMechanism(Mechanism) {
    const mechanism = new Mechanism();
    this.mechanisms[mechanism.mechname] = mechanism;
  }
  /**
   * Start the graceful disconnection process.
   *
   * This function starts the disconnection process.  This process starts
   * by sending unavailable presence and sending BOSH body of type
   * terminate.  A timeout handler makes sure that disconnection happens
   * even if the BOSH server does not respond.
   * If the Connection object isn't connected, at least tries to abort all pending requests
   * so the connection object won't generate successful requests (which were already opened).
   *
   * The user supplied connection callback will be notified of the
   * progress as this process happens.
   *
   * @param {string} [reason] - The reason the disconnect is occuring.
   */
  disconnect(reason) {
    this._changeConnectStatus(Status.DISCONNECTING, reason);
    if (reason) {
      log.info("Disconnect was called because: " + reason);
    } else {
      log.debug("Disconnect was called");
    }
    if (this.connected) {
      let pres = null;
      this.disconnecting = true;
      if (this.authenticated) {
        pres = $pres({
          "xmlns": NS.CLIENT,
          "type": "unavailable"
        });
      }
      this._disconnectTimeout = this._addSysTimedHandler(
        this.disconnection_timeout,
        this._onDisconnectTimeout.bind(this)
      );
      this._proto._disconnect(pres);
    } else {
      log.debug("Disconnect was called before Strophe connected to the server");
      this._proto._abortAllRequests();
      this._doDisconnect();
    }
  }
  /**
   * _Private_ helper function that makes sure plugins and the user's
   * callback are notified of connection status changes.
   * @param {number} status - the new connection status, one of the values
   *     in Strophe.Status
   * @param {string|null} [condition] - the error condition
   * @param {Element} [elem] - The triggering stanza.
   */
  _changeConnectStatus(status, condition, elem) {
    for (const k2 in connectionPlugins) {
      if (Object.prototype.hasOwnProperty.call(connectionPlugins, k2)) {
        const plugin = this[k2];
        if (plugin.statusChanged) {
          try {
            plugin.statusChanged(status, condition);
          } catch (err) {
            log.error(`${k2} plugin caused an exception changing status: ${err}`);
          }
        }
      }
    }
    if (this.connect_callback) {
      try {
        this.connect_callback(status, condition, elem);
      } catch (e) {
        handleError(e);
        log.error(`User connection callback caused an exception: ${e}`);
      }
    }
  }
  /**
   * _Private_ function to disconnect.
   *
   * This is the last piece of the disconnection logic.  This resets the
   * connection and alerts the user's connection callback.
   * @param {string|null} [condition] - the error condition
   */
  _doDisconnect(condition) {
    if (typeof this._idleTimeout === "number") {
      clearTimeout(this._idleTimeout);
    }
    if (this._disconnectTimeout !== null) {
      this.deleteTimedHandler(this._disconnectTimeout);
      this._disconnectTimeout = null;
    }
    log.debug("_doDisconnect was called");
    this._proto._doDisconnect();
    this.authenticated = false;
    this.disconnecting = false;
    this.restored = false;
    this.handlers = [];
    this.timedHandlers = [];
    this.removeTimeds = [];
    this.removeHandlers = [];
    this.addTimeds = [];
    this.addHandlers = [];
    this._changeConnectStatus(Status.DISCONNECTED, condition);
    this.connected = false;
  }
  /**
   * _Private_ handler to processes incoming data from the the connection.
   *
   * Except for _connect_cb handling the initial connection request,
   * this function handles the incoming data for all requests.  This
   * function also fires stanza handlers that match each incoming
   * stanza.
   * @param {Element | Request} req - The request that has data ready.
   * @param {string} [raw] - The stanza as raw string.
   */
  _dataRecv(req, raw) {
    const elem = (
      /** @type {Element} */
      "_reqToData" in this._proto ? this._proto._reqToData(
        /** @type {Request} */
        req
      ) : req
    );
    if (elem === null) {
      return;
    }
    if (this.xmlInput !== Connection.prototype.xmlInput) {
      if (elem.nodeName === this._proto.strip && elem.childNodes.length) {
        this.xmlInput(elem.childNodes[0]);
      } else {
        this.xmlInput(elem);
      }
    }
    if (this.rawInput !== Connection.prototype.rawInput) {
      if (raw) {
        this.rawInput(raw);
      } else {
        this.rawInput(Builder.serialize(elem));
      }
    }
    while (this.removeHandlers.length > 0) {
      const hand = this.removeHandlers.pop();
      const i = this.handlers.indexOf(hand);
      if (i >= 0) {
        this.handlers.splice(i, 1);
      }
    }
    while (this.addHandlers.length > 0) {
      this.handlers.push(this.addHandlers.pop());
    }
    if (this.disconnecting && this._proto._emptyQueue()) {
      this._doDisconnect();
      return;
    }
    const type = elem.getAttribute("type");
    if (type !== null && type === "terminate") {
      if (this.disconnecting) {
        return;
      }
      let cond = elem.getAttribute("condition");
      const conflict = elem.getElementsByTagName("conflict");
      if (cond !== null) {
        if (cond === "remote-stream-error" && conflict.length > 0) {
          cond = "conflict";
        }
        this._changeConnectStatus(Status.CONNFAIL, cond);
      } else {
        this._changeConnectStatus(Status.CONNFAIL, ErrorCondition.UNKNOWN_REASON);
      }
      this._doDisconnect(cond);
      return;
    }
    forEachChild(
      elem,
      null,
      /** @param {Element} child */
      (child) => {
        const matches = [];
        this.handlers = this.handlers.reduce((handlers, handler) => {
          try {
            if (handler.isMatch(child) && (this.authenticated || !handler.user)) {
              if (handler.run(child)) {
                handlers.push(handler);
              }
              matches.push(handler);
            } else {
              handlers.push(handler);
            }
          } catch (e) {
            log.warn("Removing Strophe handlers due to uncaught exception: " + e.message);
          }
          return handlers;
        }, []);
        if (!matches.length && this.iqFallbackHandler.isMatch(child)) {
          this.iqFallbackHandler.run(child);
        }
      }
    );
  }
  /**
   * @callback connectionCallback
   * @param {Connection} connection
   */
  /**
   * _Private_ handler for initial connection request.
   *
   * This handler is used to process the initial connection request
   * response from the BOSH server. It is used to set up authentication
   * handlers and start the authentication process.
   *
   * SASL authentication will be attempted if available, otherwise
   * the code will fall back to legacy authentication.
   *
   * @param {Element | Request} req - The current request.
   * @param {connectionCallback} _callback - low level (xmpp) connect callback function.
   *     Useful for plugins with their own xmpp connect callback (when they
   *     want to do something special).
   * @param {string} [raw] - The stanza as raw string.
   */
  _connect_cb(req, _callback, raw) {
    log.debug("_connect_cb was called");
    this.connected = true;
    let bodyWrap;
    try {
      bodyWrap = /** @type {Element} */
      "_reqToData" in this._proto ? this._proto._reqToData(
        /** @type {Request} */
        req
      ) : req;
    } catch (e) {
      if (e.name !== ErrorCondition.BAD_FORMAT) {
        throw e;
      }
      this._changeConnectStatus(Status.CONNFAIL, ErrorCondition.BAD_FORMAT);
      this._doDisconnect(ErrorCondition.BAD_FORMAT);
    }
    if (!bodyWrap) {
      return;
    }
    if (this.xmlInput !== Connection.prototype.xmlInput) {
      if (bodyWrap.nodeName === this._proto.strip && bodyWrap.childNodes.length) {
        this.xmlInput(bodyWrap.childNodes[0]);
      } else {
        this.xmlInput(bodyWrap);
      }
    }
    if (this.rawInput !== Connection.prototype.rawInput) {
      if (raw) {
        this.rawInput(raw);
      } else {
        this.rawInput(Builder.serialize(bodyWrap));
      }
    }
    const conncheck = this._proto._connect_cb(bodyWrap);
    if (conncheck === Status.CONNFAIL) {
      return;
    }
    let hasFeatures;
    if (bodyWrap.getElementsByTagNameNS) {
      hasFeatures = bodyWrap.getElementsByTagNameNS(NS.STREAM, "features").length > 0;
    } else {
      hasFeatures = bodyWrap.getElementsByTagName("stream:features").length > 0 || bodyWrap.getElementsByTagName("features").length > 0;
    }
    if (!hasFeatures) {
      this._proto._no_auth_received(_callback);
      return;
    }
    const matched = Array.from(bodyWrap.getElementsByTagName("mechanism")).map((m2) => this.mechanisms[m2.textContent]).filter((m2) => m2);
    if (matched.length === 0) {
      if (bodyWrap.getElementsByTagName("auth").length === 0) {
        this._proto._no_auth_received(_callback);
        return;
      }
    }
    if (this.do_authentication !== false) {
      this.authenticate(matched);
    }
  }
  /**
   * Sorts an array of objects with prototype SASLMechanism according to
   * their priorities.
   * @param {SASLMechanism[]} mechanisms - Array of SASL mechanisms.
   */
  // eslint-disable-next-line  class-methods-use-this
  sortMechanismsByPriority(mechanisms) {
    for (let i = 0; i < mechanisms.length - 1; ++i) {
      let higher = i;
      for (let j2 = i + 1; j2 < mechanisms.length; ++j2) {
        if (mechanisms[j2].priority > mechanisms[higher].priority) {
          higher = j2;
        }
      }
      if (higher !== i) {
        const swap = mechanisms[i];
        mechanisms[i] = mechanisms[higher];
        mechanisms[higher] = swap;
      }
    }
    return mechanisms;
  }
  /**
   * Set up authentication
   *
   * Continues the initial connection request by setting up authentication
   * handlers and starting the authentication process.
   *
   * SASL authentication will be attempted if available, otherwise
   * the code will fall back to legacy authentication.
   *
   * @param {SASLMechanism[]} matched - Array of SASL mechanisms supported.
   */
  authenticate(matched) {
    if (!this._attemptSASLAuth(matched)) {
      this._attemptLegacyAuth();
    }
  }
  /**
   * Iterate through an array of SASL mechanisms and attempt authentication
   * with the highest priority (enabled) mechanism.
   *
   * @private
   * @param {SASLMechanism[]} mechanisms - Array of SASL mechanisms.
   * @return {Boolean} mechanism_found - true or false, depending on whether a
   *  valid SASL mechanism was found with which authentication could be started.
   */
  _attemptSASLAuth(mechanisms) {
    mechanisms = this.sortMechanismsByPriority(mechanisms || []);
    let mechanism_found = false;
    for (let i = 0; i < mechanisms.length; ++i) {
      if (!mechanisms[i].test(this)) {
        continue;
      }
      this._sasl_success_handler = this._addSysHandler(
        this._sasl_success_cb.bind(this),
        null,
        "success",
        null,
        null
      );
      this._sasl_failure_handler = this._addSysHandler(
        this._sasl_failure_cb.bind(this),
        null,
        "failure",
        null,
        null
      );
      this._sasl_challenge_handler = this._addSysHandler(
        this._sasl_challenge_cb.bind(this),
        null,
        "challenge",
        null,
        null
      );
      this._sasl_mechanism = mechanisms[i];
      this._sasl_mechanism.onStart(this);
      const request_auth_exchange = $build("auth", {
        "xmlns": NS.SASL,
        "mechanism": this._sasl_mechanism.mechname
      });
      if (this._sasl_mechanism.isClientFirst) {
        const response = this._sasl_mechanism.clientChallenge(this);
        request_auth_exchange.t(btoa(
          /** @type {string} */
          response
        ));
      }
      this.send(request_auth_exchange.tree());
      mechanism_found = true;
      break;
    }
    return mechanism_found;
  }
  /**
   * _Private_ handler for the SASL challenge
   * @private
   * @param {Element} elem
   */
  async _sasl_challenge_cb(elem) {
    const challenge = atob(getText(elem));
    const response = await this._sasl_mechanism.onChallenge(this, challenge);
    const stanza = $build("response", { "xmlns": NS.SASL });
    if (response) stanza.t(btoa(response));
    this.send(stanza.tree());
    return true;
  }
  /**
   * Attempt legacy (i.e. non-SASL) authentication.
   * @private
   */
  _attemptLegacyAuth() {
    if (getNodeFromJid(this.jid) === null) {
      this._changeConnectStatus(Status.CONNFAIL, ErrorCondition.MISSING_JID_NODE);
      this.disconnect(ErrorCondition.MISSING_JID_NODE);
    } else {
      this._changeConnectStatus(Status.AUTHENTICATING, null);
      this._addSysHandler(this._onLegacyAuthIQResult.bind(this), null, null, null, "_auth_1");
      this.send(
        $iq({
          "type": "get",
          "to": this.domain,
          "id": "_auth_1"
        }).c("query", { xmlns: NS.AUTH }).c("username", {}).t(getNodeFromJid(this.jid)).tree()
      );
    }
  }
  /**
   * _Private_ handler for legacy authentication.
   *
   * This handler is called in response to the initial <iq type='get'/>
   * for legacy authentication.  It builds an authentication <iq/> and
   * sends it, creating a handler (calling back to _auth2_cb()) to
   * handle the result
   * @private
   * @return {false} `false` to remove the handler.
   */
  _onLegacyAuthIQResult() {
    const pass = typeof this.pass === "string" ? this.pass : "";
    const iq = $iq({ type: "set", id: "_auth_2" }).c("query", { xmlns: NS.AUTH }).c("username", {}).t(getNodeFromJid(this.jid)).up().c("password").t(pass);
    if (!getResourceFromJid(this.jid)) {
      this.jid = getBareJidFromJid(this.jid) + "/strophe";
    }
    iq.up().c("resource", {}).t(getResourceFromJid(this.jid));
    this._addSysHandler(this._auth2_cb.bind(this), null, null, null, "_auth_2");
    this.send(iq.tree());
    return false;
  }
  /**
   * _Private_ handler for succesful SASL authentication.
   * @private
   * @param {Element} elem - The matching stanza.
   * @return {false} `false` to remove the handler.
   */
  _sasl_success_cb(elem) {
    if (this._sasl_data["server-signature"]) {
      let serverSignature;
      const success = atob(getText(elem));
      const attribMatch = /([a-z]+)=([^,]+)(,|$)/;
      const matches = success.match(attribMatch);
      if (matches[1] === "v") {
        serverSignature = matches[2];
      }
      if (serverSignature !== this._sasl_data["server-signature"]) {
        this.deleteHandler(this._sasl_failure_handler);
        this._sasl_failure_handler = null;
        if (this._sasl_challenge_handler) {
          this.deleteHandler(this._sasl_challenge_handler);
          this._sasl_challenge_handler = null;
        }
        this._sasl_data = {};
        return this._sasl_failure_cb(null);
      }
    }
    log.info("SASL authentication succeeded.");
    if (this._sasl_data.keys) {
      this.scram_keys = this._sasl_data.keys;
    }
    if (this._sasl_mechanism) {
      this._sasl_mechanism.onSuccess();
    }
    this.deleteHandler(this._sasl_failure_handler);
    this._sasl_failure_handler = null;
    if (this._sasl_challenge_handler) {
      this.deleteHandler(this._sasl_challenge_handler);
      this._sasl_challenge_handler = null;
    }
    const streamfeature_handlers = [];
    const wrapper2 = (handlers, elem2) => {
      while (handlers.length) {
        this.deleteHandler(handlers.pop());
      }
      this._onStreamFeaturesAfterSASL(elem2);
      return false;
    };
    streamfeature_handlers.push(
      this._addSysHandler(
        /** @param {Element} elem */
        (elem2) => wrapper2(streamfeature_handlers, elem2),
        null,
        "stream:features",
        null,
        null
      )
    );
    streamfeature_handlers.push(
      this._addSysHandler(
        /** @param {Element} elem */
        (elem2) => wrapper2(streamfeature_handlers, elem2),
        NS.STREAM,
        "features",
        null,
        null
      )
    );
    this._sendRestart();
    return false;
  }
  /**
   * @private
   * @param {Element} elem - The matching stanza.
   * @return {false} `false` to remove the handler.
   */
  _onStreamFeaturesAfterSASL(elem) {
    this.features = elem;
    for (let i = 0; i < elem.childNodes.length; i++) {
      const child = elem.childNodes[i];
      if (child.nodeName === "bind") {
        this.do_bind = true;
      }
      if (child.nodeName === "session") {
        this.do_session = true;
      }
    }
    if (!this.do_bind) {
      this._changeConnectStatus(Status.AUTHFAIL, null);
      return false;
    } else if (!this.options.explicitResourceBinding) {
      this.bind();
    } else {
      this._changeConnectStatus(Status.BINDREQUIRED, null);
    }
    return false;
  }
  /**
   * Sends an IQ to the XMPP server to bind a JID resource for this session.
   *
   * https://tools.ietf.org/html/rfc6120#section-7.5
   *
   * If `explicitResourceBinding` was set to a truthy value in the options
   * passed to the Connection constructor, then this function needs
   * to be called explicitly by the client author.
   *
   * Otherwise it'll be called automatically as soon as the XMPP server
   * advertises the "urn:ietf:params:xml:ns:xmpp-bind" stream feature.
   */
  bind() {
    if (!this.do_bind) {
      log.info(`Connection.prototype.bind called but "do_bind" is false`);
      return;
    }
    this._addSysHandler(this._onResourceBindResultIQ.bind(this), null, null, null, "_bind_auth_2");
    const resource = getResourceFromJid(this.jid);
    if (resource) {
      this.send(
        $iq({ type: "set", id: "_bind_auth_2" }).c("bind", { xmlns: NS.BIND }).c("resource", {}).t(resource).tree()
      );
    } else {
      this.send($iq({ type: "set", id: "_bind_auth_2" }).c("bind", { xmlns: NS.BIND }).tree());
    }
  }
  /**
   * _Private_ handler for binding result and session start.
   * @private
   * @param {Element} elem - The matching stanza.
   * @return {false} `false` to remove the handler.
   */
  _onResourceBindResultIQ(elem) {
    if (elem.getAttribute("type") === "error") {
      log.warn("Resource binding failed.");
      const conflict = elem.getElementsByTagName("conflict");
      let condition;
      if (conflict.length > 0) {
        condition = ErrorCondition.CONFLICT;
      }
      this._changeConnectStatus(Status.AUTHFAIL, condition, elem);
      return false;
    }
    const bind = elem.getElementsByTagName("bind");
    if (bind.length > 0) {
      const jidNode = bind[0].getElementsByTagName("jid");
      if (jidNode.length > 0) {
        this.authenticated = true;
        this.jid = getText(jidNode[0]);
        if (this.do_session) {
          this._establishSession();
        } else {
          this._changeConnectStatus(Status.CONNECTED, null);
        }
      }
    } else {
      log.warn("Resource binding failed.");
      this._changeConnectStatus(Status.AUTHFAIL, null, elem);
      return false;
    }
  }
  /**
   * Send IQ request to establish a session with the XMPP server.
   *
   * See https://xmpp.org/rfcs/rfc3921.html#session
   *
   * Note: The protocol for session establishment has been determined as
   * unnecessary and removed in RFC-6121.
   * @private
   */
  _establishSession() {
    if (!this.do_session) {
      throw new Error(
        `Connection.prototype._establishSession called but apparently ${NS.SESSION} wasn't advertised by the server`
      );
    }
    this._addSysHandler(this._onSessionResultIQ.bind(this), null, null, null, "_session_auth_2");
    this.send($iq({ type: "set", id: "_session_auth_2" }).c("session", { xmlns: NS.SESSION }).tree());
  }
  /**
   * _Private_ handler for the server's IQ response to a client's session
   * request.
   *
   * This sets Connection.authenticated to true on success, which
   * starts the processing of user handlers.
   *
   * See https://xmpp.org/rfcs/rfc3921.html#session
   *
   * Note: The protocol for session establishment has been determined as
   * unnecessary and removed in RFC-6121.
   * @private
   * @param {Element} elem - The matching stanza.
   * @return {false} `false` to remove the handler.
   */
  _onSessionResultIQ(elem) {
    if (elem.getAttribute("type") === "result") {
      this.authenticated = true;
      this._changeConnectStatus(Status.CONNECTED, null);
    } else if (elem.getAttribute("type") === "error") {
      this.authenticated = false;
      log.warn("Session creation failed.");
      this._changeConnectStatus(Status.AUTHFAIL, null, elem);
      return false;
    }
    return false;
  }
  /**
   * _Private_ handler for SASL authentication failure.
   * @param {Element} [elem] - The matching stanza.
   * @return {false} `false` to remove the handler.
   */
  _sasl_failure_cb(elem) {
    if (this._sasl_success_handler) {
      this.deleteHandler(this._sasl_success_handler);
      this._sasl_success_handler = null;
    }
    if (this._sasl_challenge_handler) {
      this.deleteHandler(this._sasl_challenge_handler);
      this._sasl_challenge_handler = null;
    }
    if (this._sasl_mechanism) this._sasl_mechanism.onFailure();
    this._changeConnectStatus(Status.AUTHFAIL, null, elem);
    return false;
  }
  /**
   * _Private_ handler to finish legacy authentication.
   *
   * This handler is called when the result from the jabber:iq:auth
   * <iq/> stanza is returned.
   * @private
   * @param {Element} elem - The stanza that triggered the callback.
   * @return {false} `false` to remove the handler.
   */
  _auth2_cb(elem) {
    if (elem.getAttribute("type") === "result") {
      this.authenticated = true;
      this._changeConnectStatus(Status.CONNECTED, null);
    } else if (elem.getAttribute("type") === "error") {
      this._changeConnectStatus(Status.AUTHFAIL, null, elem);
      this.disconnect("authentication failed");
    }
    return false;
  }
  /**
   * _Private_ function to add a system level timed handler.
   *
   * This function is used to add a TimedHandler for the
   * library code.  System timed handlers are allowed to run before
   * authentication is complete.
   * @param {number} period - The period of the handler.
   * @param {Function} handler - The callback function.
   */
  _addSysTimedHandler(period, handler) {
    const thand = new TimedHandler(period, handler);
    thand.user = false;
    this.addTimeds.push(thand);
    return thand;
  }
  /**
   * _Private_ function to add a system level stanza handler.
   *
   * This function is used to add a Handler for the
   * library code.  System stanza handlers are allowed to run before
   * authentication is complete.
   * @param {Function} handler - The callback function.
   * @param {string} ns - The namespace to match.
   * @param {string} name - The stanza name to match.
   * @param {string} type - The stanza type attribute to match.
   * @param {string} id - The stanza id attribute to match.
   */
  _addSysHandler(handler, ns, name, type, id) {
    const hand = new Handler(handler, ns, name, type, id);
    hand.user = false;
    this.addHandlers.push(hand);
    return hand;
  }
  /**
   * _Private_ timeout handler for handling non-graceful disconnection.
   *
   * If the graceful disconnect process does not complete within the
   * time allotted, this handler finishes the disconnect anyway.
   * @return {false} `false` to remove the handler.
   */
  _onDisconnectTimeout() {
    log.debug("_onDisconnectTimeout was called");
    this._changeConnectStatus(Status.CONNTIMEOUT, null);
    this._proto._onDisconnectTimeout();
    this._doDisconnect();
    return false;
  }
  /**
   * _Private_ handler to process events during idle cycle.
   *
   * This handler is called every 100ms to fire timed handlers that
   * are ready and keep poll requests going.
   */
  _onIdle() {
    while (this.addTimeds.length > 0) {
      this.timedHandlers.push(this.addTimeds.pop());
    }
    while (this.removeTimeds.length > 0) {
      const thand = this.removeTimeds.pop();
      const i = this.timedHandlers.indexOf(thand);
      if (i >= 0) {
        this.timedHandlers.splice(i, 1);
      }
    }
    const now = (/* @__PURE__ */ new Date()).getTime();
    const newList = [];
    for (let i = 0; i < this.timedHandlers.length; i++) {
      const thand = this.timedHandlers[i];
      if (this.authenticated || !thand.user) {
        const since = thand.lastCalled + thand.period;
        if (since - now <= 0) {
          if (thand.run()) {
            newList.push(thand);
          }
        } else {
          newList.push(thand);
        }
      }
    }
    this.timedHandlers = newList;
    clearTimeout(this._idleTimeout);
    this._proto._onIdle();
    if (this.connected) {
      this._idleTimeout = setTimeout(() => this._onIdle(), 100);
    }
  }
}
const _Stanza = class _Stanza extends Builder {
  /**
   * @param {string[]} strings
   * @param {any[]} values
   */
  constructor(strings, values2) {
    super("stanza");
    /** @type {string} */
    __privateAdd(this, _string);
    /** @type {Array<string>} */
    __privateAdd(this, _strings);
    /**
     * @typedef {Array<string|Stanza|Builder>} StanzaValue
     * @type {StanzaValue|Array<StanzaValue>}
     */
    __privateAdd(this, _values);
    __privateSet(this, _strings, strings);
    __privateSet(this, _values, values2);
  }
  /**
   * A directive which can be used to pass a string of XML as a value to the
   * stx tagged template literal.
   *
   * It's considered "unsafe" because it can pose a security risk if used with
   * untrusted input.
   *
   * @param {string} string
   * @returns {Builder}
   * @example
   *    const status = '<status>I am busy!</status>';
   *    const pres = stx`
   *       <presence from='juliet@example.com/chamber' id='pres1'>
   *           <show>dnd</show>
   *           ${unsafeXML(status)}
   *       </presence>`;
   *    connection.send(pres);
   */
  static unsafeXML(string) {
    return Builder.fromString(string);
  }
  /**
   * Turns the passed-in string into an XML Element.
   * @param {string} string
   * @param {boolean} [throwErrorIfInvalidNS]
   * @returns {Element}
   */
  static toElement(string, throwErrorIfInvalidNS) {
    const doc = xmlHtmlNode(string);
    const parserError = getParserError(doc);
    if (parserError) {
      throw new Error(`Parser Error: ${parserError}`);
    }
    const node2 = getFirstElementChild(doc);
    if (["message", "iq", "presence"].includes(node2.nodeName.toLowerCase()) && node2.namespaceURI !== "jabber:client" && node2.namespaceURI !== "jabber:server") {
      const err_msg = `Invalid namespaceURI ${node2.namespaceURI}`;
      if (throwErrorIfInvalidNS) {
        throw new Error(err_msg);
      } else {
        log.error(err_msg);
      }
    }
    return node2;
  }
  buildTree() {
    return _Stanza.toElement(this.toString(), true);
  }
  /**
   * @return {string}
   */
  toString() {
    __privateSet(this, _string, __privateGet(this, _string) || __privateGet(this, _strings).reduce((acc, str) => {
      const idx = __privateGet(this, _strings).indexOf(str);
      const value = __privateGet(this, _values).length > idx ? __privateGet(this, _values)[idx] : "";
      return acc + str + (Array.isArray(value) ? value.map(
        (v2) => v2 instanceof _Stanza || v2 instanceof Builder ? v2 : xmlescape(v2.toString())
      ).join("") : value instanceof _Stanza || value instanceof Builder ? value : xmlescape(value.toString()));
    }, "").trim());
    return __privateGet(this, _string);
  }
};
_string = new WeakMap();
_strings = new WeakMap();
_values = new WeakMap();
let Stanza = _Stanza;
function stx(strings, ...values2) {
  return new Stanza(strings, values2);
}
const Strophe = {
  /** @constant: VERSION */
  VERSION: "3.0.0",
  /**
   * @returns {number}
   */
  get TIMEOUT() {
    return Bosh.getTimeoutMultplier();
  },
  /**
   * @param {number} n
   */
  set TIMEOUT(n) {
    Bosh.setTimeoutMultiplier(n);
  },
  /**
   * @returns {number}
   */
  get SECONDARY_TIMEOUT() {
    return Bosh.getSecondaryTimeoutMultplier();
  },
  /**
   * @param {number} n
   */
  set SECONDARY_TIMEOUT(n) {
    Bosh.setSecondaryTimeoutMultiplier(n);
  },
  ...utils$1,
  ...log,
  shims,
  Request,
  // Transports
  Bosh,
  Websocket,
  WorkerWebsocket,
  Connection,
  Handler,
  // Available authentication mechanisms
  SASLAnonymous,
  SASLPlain,
  SASLSHA1,
  SASLSHA256,
  SASLSHA384,
  SASLSHA512,
  SASLOAuthBearer,
  SASLExternal,
  SASLXOAuth2,
  Stanza,
  Builder,
  ElementType,
  ErrorCondition,
  LogLevel: LOG_LEVELS,
  /** @type {Object.<string, string>} */
  NS,
  SASLMechanism,
  /** @type {Status} */
  Status,
  TimedHandler,
  XHTML: {
    ...XHTML,
    validTag,
    validCSS,
    validAttribute
  },
  /**
   * Render a DOM element and all descendants to a String.
   * @method Strophe.serialize
   * @param {Element|Builder} elem - A DOM element.
   * @return {string} - The serialized element tree as a String.
   */
  serialize(elem) {
    return Builder.serialize(elem);
  },
  /**
   * @typedef {import('./constants').LogLevel} LogLevel
   *
   * Library consumers can use this function to set the log level of Strophe.
   * The default log level is Strophe.LogLevel.INFO.
   * @param {LogLevel} level
   * @example Strophe.setLogLevel(Strophe.LogLevel.DEBUG);
   */
  setLogLevel(level) {
    log.setLogLevel(level);
  },
  /**
   * This function is used to extend the current namespaces in
   * Strophe.NS. It takes a key and a value with the key being the
   * name of the new namespace, with its actual value.
   * @example: Strophe.addNamespace('PUBSUB', "http://jabber.org/protocol/pubsub");
   *
   * @param {string} name - The name under which the namespace will be
   *     referenced under Strophe.NS
   * @param {string} value - The actual namespace.
   */
  addNamespace(name, value) {
    Strophe.NS[name] = value;
  },
  /**
   * Extends the Strophe.Connection object with the given plugin.
   * @param {string} name - The name of the extension.
   * @param {Object} ptype - The plugin's prototype.
   */
  addConnectionPlugin(name, ptype) {
    Connection.addConnectionPlugin(name, ptype);
  }
};
globalThis.$build = $build;
globalThis.$iq = $iq;
globalThis.$msg = $msg;
globalThis.$pres = $pres;
globalThis.Strophe = Strophe;
globalThis.stx = stx;
Stanza.toElement;
globalThis.toStanza = Stanza.toElement;
function addUserToRoom(connection, roomJid, nickname) {
  if (!nickname || nickname.trim() === "") {
    return;
  }
  const uniqueResource = Math.random().toString(36).substring(2, 8);
  const fullRoomJid = `${roomJid}/${nickname}-${uniqueResource}`;
  const presenceStanza = $build("presence", { to: fullRoomJid }).c("x", { xmlns: "http://jabber.org/protocol/muc" });
  connection.send(presenceStanza);
}
function addUsersToRoomV1(connection, roomJID, userNick, apiUrl, botNick) {
  return new Promise((resolve, reject) => {
    addUserToRoom(connection, roomJID, userNick);
    connection.addHandler(
      (stanza) => {
        const from2 = stanza.getAttribute("from");
        if (from2 && from2.startsWith(roomJID)) {
          addBotToRoom(apiUrl, roomJID, botNick).then(() => {
          });
          resolve();
        }
        return false;
      },
      "",
      "presence",
      "",
      "",
      ""
    );
    setTimeout(() => reject(new Error("Presence confirmation timeout")), 5e3);
  });
}
function addBotToRoom(apiUrl, roomJID, nickName) {
  const finalUrl = `${apiUrl}?jid=${encodeURIComponent(roomJID)}&nickname=${encodeURIComponent(nickName)}`;
  return fetch(finalUrl, {
    method: "GET",
    mode: "no-cors"
    // Use no-cors mode for bypassing CORS
  }).then((response) => {
  }).catch((error2) => {
  });
}
function decodeHtmlEntities(str) {
  return str.replace(/&quot;/g, '"');
}
const truncateText = (text2, maxLength) => {
  return text2.length > maxLength ? text2.slice(0, maxLength) + "..." : text2;
};
function isSelfUserJid(fromJid, prefix2 = "customer") {
  const resource = fromJid == null ? void 0 : fromJid.split("/")[1];
  return resource ? new RegExp(`^${prefix2}.*`).test(resource) : false;
}
function sendMessage(connection, message2, roomJid) {
  if (connection) {
    const messageStanza = $build("message", {
      type: "groupchat",
      // Use 'groupchat' for MUC rooms
      to: roomJid
      // Room JID
    }).c("body").t(message2);
    connection.send(messageStanza);
  }
}
function initializeWebSocket(userJID, roomJID, wsUrl, botAPIUrl, userType) {
  const connection = new Strophe.Connection(wsUrl);
  connection.connect(userJID, "", function(status) {
    onConnect(status, connection, roomJID, botAPIUrl, userType);
  });
  return connection;
}
function onConnect(status, connection, roomJID, botAPIUrl, userType) {
  switch (status) {
    case Strophe.Status.CONNECTING:
      toggleInputDisabled();
      break;
    case Strophe.Status.CONNFAIL:
      toggleInputDisabled();
      break;
    case Strophe.Status.DISCONNECTING:
      toggleInputDisabled();
      break;
    case Strophe.Status.CONNECTED:
      toggleInputDisabled();
      startProcessingMsg(connection, roomJID, botAPIUrl, userType);
      break;
    case Strophe.Status.DISCONNECTED:
      toggleInputDisabled();
      break;
    case Strophe.Status.AUTHFAIL:
      toggleInputDisabled();
      break;
  }
}
function startProcessingMsg(connection, roomJID, botUrl, userType) {
  if (userType == USER_TYPE.GUEST) {
    addUsersToRoomV1(connection, roomJID, USER_TYPE.GUEST, botUrl, USER_TYPE.BOT).then(() => void 0);
  }
  connection.addHandler((msg) => onMessage(msg, connection, userType, roomJID), "", "message", "");
}
function onMessage(message2, connection, userType, roomJID) {
  const fromJid = message2.getAttribute("from");
  const msgType = message2.getAttribute("type");
  const body = Strophe.getText(message2.getElementsByTagName("body")[0]);
  message2.getAttribute("to");
  if (body && body.length > 0) {
    try {
      const parsedObj = JSON.parse(decodeHtmlEntities(body));
      if (isSelfUserJid(fromJid, userType)) {
        toggleMsgLoader();
        setTimeout(() => setMessageStatus(parsedObj.id, "sent", {}), 100);
        setTimeout(() => setMessageStatus(parsedObj.id, "read"), 150);
        addUserMessage(parsedObj.msg.toString(), { id: parsedObj.id, status: "sent" });
        return true;
      }
      const isMsgFromAgent = fromJid.split("/")[1].startsWith("agent");
      switch (parsedObj.type) {
        case "received":
          if (userType == USER_TYPE.GUEST) {
            handleChatMessage(connection, msgType, parsedObj.msg, roomJID);
          } else {
            handleChatMessageForAgent(connection, msgType, parsedObj.msg, roomJID);
          }
          break;
        case "sent":
          if (userType == USER_TYPE.GUEST && isMsgFromAgent) {
            addResponseMessage(parsedObj.msg.toString());
          } else if (userType == USER_TYPE.GUEST && !isMsgFromAgent) {
            addUserMessage(parsedObj.msg.toString());
          } else {
            addResponseMessage(parsedObj.msg.toString());
          }
          break;
      }
    } catch (err) {
      return true;
    }
  }
  return true;
}
function handleChatMessage(connection, msgType, body, roomJID) {
  var _a2, _b, _c, _d, _e;
  if (msgType == CHAT_TYPES.CHAT && body) {
    if (body.type == CHAT_TYPES.CONNECT_TO_AGENT) {
      const receivedRoomJID = trimResourceSuffix(body.data.custom_props.roomJID, USER_TYPE.GUEST);
      roomJID.current = receivedRoomJID;
      localStorage.setItem(ROOM_STORAGE_KEY, receivedRoomJID);
      addUserToRoom(connection, receivedRoomJID, USER_TYPE.AGENT);
      showNotification("Customer Joined", { severity: "info" });
      setTimeout(() => closeNotification(""), 2e3);
    }
    return true;
  } else if (msgType == CHAT_TYPES.GROUPCHAT) {
    toggleMsgLoader();
    if (body.type == MESSAGES_TYPES.TEXT) {
      addResponseMessage((_a2 = body.data) == null ? void 0 : _a2.summary);
    } else if (body.type == MESSAGES_TYPES.CAROUSEL) {
      const productArray = (_c = (_b = body.data) == null ? void 0 : _b.products) == null ? void 0 : _c.map((product) => ({
        link: product.url,
        image: product.image_url,
        title: truncateText(product.title, 30),
        price: product["Variant Price"],
        category: product.category,
        color: product.Color,
        description: truncateText(product.description, 30)
      }));
      addResponseMessage((_d = body.data) == null ? void 0 : _d.summary);
      addCarouselMessage(productArray, (_e = body.data) == null ? void 0 : _e.summary);
      return;
    }
  } else if (msgType == CHAT_TYPES.ERROR) {
    return;
  } else {
    return;
  }
}
function handleChatMessageForAgent(connection, msgType, body, roomJID) {
  var _a2, _b, _c, _d, _e;
  if (msgType == CHAT_TYPES.CHAT && body) {
    if (body.type == CHAT_TYPES.CONNECT_TO_AGENT) {
      const receivedRoomJID = trimResourceSuffix(body.data.custom_props.roomJID, USER_TYPE.GUEST);
      roomJID.current = receivedRoomJID;
      localStorage.setItem(ROOM_STORAGE_KEY, receivedRoomJID);
      addUserToRoom(connection, receivedRoomJID, USER_TYPE.AGENT);
      showNotification("Customer Joined", { severity: "info" });
      setTimeout(() => closeNotification(""), 2e3);
    }
    return true;
  } else if (msgType == CHAT_TYPES.GROUPCHAT) {
    toggleMsgLoader();
    if (body.type == MESSAGES_TYPES.TEXT) {
      addUserMessage((_a2 = body.data) == null ? void 0 : _a2.summary);
    } else if (body.type == MESSAGES_TYPES.CAROUSEL) {
      const productArray = (_c = (_b = body.data) == null ? void 0 : _b.products) == null ? void 0 : _c.map((product) => ({
        link: product.url,
        image: product.image_url,
        title: truncateText(product.title, 30),
        price: product["Variant Price"],
        category: product.category,
        color: product.Color,
        description: truncateText(product.description, 30)
      }));
      addUserMessage((_d = body.data) == null ? void 0 : _d.summary);
      addCarouselMessageForAgent(productArray, (_e = body.data) == null ? void 0 : _e.summary);
      return;
    }
  } else if (msgType == CHAT_TYPES.ERROR) {
    return;
  } else {
    return;
  }
}
function onResize(w2, h) {
}
function handleToggle(isPopup) {
  if (!isPopup) return void 0;
  return async (isOpened) => {
    if (isOpened) {
      await new Promise((done) => setTimeout(done, 0));
    }
    return true;
  };
}
function generateRandomString() {
  return Math.random().toString(36).substring(2, 15);
}
function generateRandomJid(host, type = "guest") {
  const randomString = `${type}-` + generateRandomString();
  return `${randomString}@${host}`;
}
function generateRandomRoomJid(conference) {
  const randomString = "room-" + generateRandomString();
  return `${randomString}@${conference}`;
}
function showSamples(connection, roomJID) {
  addCarouselMessageForAgent([
    {
      "image": "https://commerce.nearform.com/open-source/nuka-carousel/img/product-1.jpg",
      "link": "https://beatsmate.in/products/wired-headphones-3-5mm-sport-earbuds-with-bass-phone-earphones-stereo-headset-with-mic-volume-control-music-earphones",
      "text": "Audio-Technica ATH-M50x Professional Studio Monitor Headphones"
    },
    {
      "image": "https://commerce.nearform.com/open-source/nuka-carousel/img/product-3.jpg",
      "link": "https://beatsmate.in/products/wired-earphones-with-microphone-3-5mm-earphones-plug-in-ear-headphones-music-earplugs-ergonomic-headphones-for-smartphones",
      "text": "Vintage cameras and accessories for the modern photographer"
    },
    {
      "image": "https://commerce.nearform.com/open-source/nuka-carousel/img/product-3.jpg",
      "link": "https://beatsmate.in/products/wired-earphones-with-microphone-3-5mm-earphones-plug-in-ear-headphones-music-earplugs-ergonomic-headphones-for-smartphones",
      "text": "Vintage cameras and accessories for the modern photographer"
    },
    {
      "image": "https://commerce.nearform.com/open-source/nuka-carousel/img/product-3.jpg",
      "link": "https://beatsmate.in/products/wired-earphones-with-microphone-3-5mm-earphones-plug-in-ear-headphones-music-earplugs-ergonomic-headphones-for-smartphones",
      "text": "Vintage cameras and accessories for the modern photographer"
    },
    {
      "image": "https://commerce.nearform.com/open-source/nuka-carousel/img/product-3.jpg",
      "link": "https://beatsmate.in/products/wired-earphones-with-microphone-3-5mm-earphones-plug-in-ear-headphones-music-earplugs-ergonomic-headphones-for-smartphones",
      "text": "Vintage cameras and accessories for the modern photographer"
    }
  ], "We have a range of orange and black earbuds available. These models come with features like Environmental Noise Cancellation (ENC) and low-latency modes, perfect for both casual listening and gaming experiences. Please check our website for specific models and their details!");
  setQuickButtons([{ label: "Connect To Agent", value: "connect to agent" }, {
    label: "Quote Of the Day",
    value: "Quote Of the Day"
  }]);
  const bottom = {
    "T&C": () => {
      toggleMsgLoader();
      addResponseMessage("T&C");
      sendMessage(connection, "T&C", roomJID);
    },
    "About SysMog": () => addResponseMessage("About SysMog")
  };
  showSuggestions({}, bottom);
  addLinkSnippet({ link: "https://sysmog.com", title: "SysMog Link Snippet" });
  addResponseMessage("![SysMog Image Snippet](https://reactnative.dev/img/header_logo.svg)");
}
function trimResourceSuffix(fromJid, prefix2) {
  const re = new RegExp("/" + prefix2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&") + ".*$");
  return fromJid.replace(re, "");
}
function Overlay({ zIndex: zIndex2 = 1e3, backgroundColor: backgroundColor2, opacity, onClick }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      style: {
        position: "fixed",
        inset: 0,
        zIndex: zIndex2,
        backgroundColor: backgroundColor2 ?? "#000",
        opacity: opacity ?? 0.15
      },
      onClick
    }
  );
}
const menu = "data:image/svg+xml,%3csvg%20version='1.2'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20overflow='visible'%20preserveAspectRatio='none'%20viewBox='0%200%2024%2024'%20width='24'%20height='24'%3e%3cg%3e%3cpath%20xmlns:default='http://www.w3.org/2000/svg'%20id='ellipsis-v'%20d='M13.71,15.62c-0.19-0.19-0.44-0.29-0.71-0.29h-2c-0.55,0-1,0.45-1,1v2c0,0.55,0.45,1,1,1h2%20c0.55,0,1-0.45,1-1v-2C14,16.06,13.9,15.81,13.71,15.62z%20M13.71,10.29C13.52,10.1,13.27,10,13,10h-2c-0.55,0-1,0.45-1,1v2%20c0,0.55,0.45,1,1,1h2c0.55,0,1-0.45,1-1v-2C14,10.73,13.9,10.48,13.71,10.29z%20M13.71,4.96C13.52,4.77,13.27,4.67,13,4.67h-2%20c-0.55,0-1,0.45-1,1v2c0,0.55,0.45,1,1,1h2c0.55,0,1-0.45,1-1v-2C13.99,5.42,13.89,5.18,13.71,5V4.96z'%20style='fill:%20rgb(255,%20255,%20255);'%20vector-effect='non-scaling-stroke'/%3e%3c/g%3e%3c/svg%3e";
const close$1 = "data:image/svg+xml,%3csvg%20version='1.2'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20overflow='visible'%20preserveAspectRatio='none'%20viewBox='0%200%2024%2024'%20width='24'%20height='24'%3e%3cg%3e%3cpath%20xmlns:default='http://www.w3.org/2000/svg'%20id='minus'%20d='M19,10.29c-0.18-0.18-0.42-0.28-0.67-0.29H5.67c-0.55,0-1,0.45-1,1v2c0,0.55,0.45,1,1,1h12.66c0.55,0,1-0.45,1-1%20v-2C19.32,10.73,19.2,10.47,19,10.29z'%20style='fill:%20rgb(255,%20255,%20255);'%20vector-effect='non-scaling-stroke'/%3e%3c/g%3e%3c/svg%3e";
function Header({ title, subtitle, showMenuButton = true, showCloseButton = true, titleAvatar, menus }) {
  const user = useSelector(({ messages }) => messages.responseUser);
  const [showMenu, setShowMenu] = useState(false);
  const { isShowPopup, popupStyles, PopupComponent } = useSelector(({ popup }) => ({
    isShowPopup: popup.showPopup,
    popupStyles: popup.styles,
    PopupComponent: popup.component
  }));
  const clickMenuHandler = (f) => {
    return () => {
      setShowMenu(false);
      return f();
    };
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rcw-header", children: [
    (showMenuButton || showCloseButton) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
      showMenuButton && menus && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "rcw-menu-button", onClick: () => setShowMenu(!showMenu), children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: menu, className: "rcw-menu", alt: "menu" }) }),
        showMenu && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Overlay, { onClick: () => setShowMenu(false) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: "menu-popup", children: menus.map(({ icon, title: title2, onClick, selects }, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: cn("menu-item", { "has-submenu": selects }), onClick: onClick && clickMenuHandler(onClick), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: icon }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: title2 }),
            selects && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "right-anchor", dangerouslySetInnerHTML: { __html: "&blacktriangleright;" } }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: "menu-submenu", children: selects.map(({ icon: icon2, title: title3, onClick: onClick2 }, j2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { onClick: onClick2, children: [
                icon2 && /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: icon2 }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: title3 })
              ] }, j2)) })
            ] })
          ] }, i)) })
        ] })
      ] }),
      showCloseButton && /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "rcw-close-button", onClick: toggleChat, children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: close$1, className: "rcw-close", alt: "close" }) })
    ] }),
    user ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rcw-user", children: [
      typeof user.avatar === "string" ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "avatar", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: user.avatar, alt: "profile" }),
        typeof user.online == "boolean" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `status status-${user.online ? "online" : "offline"}` })
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "avatars", children: user.avatar.map((src, index) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "avatar in-avatars", style: { zIndex: user.avatar.length - index }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src, alt: "profile" }, index) }, index)) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "name", children: user.name ?? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: " " }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "message", children: user.message })
      ] })
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "rcw-title", children: [
        titleAvatar && /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: titleAvatar, className: "avatar", alt: "profile" }),
        title ?? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: " " })
      ] }),
      subtitle && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "rcw-subtitle", children: subtitle })
    ] }),
    isShowPopup && /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "popup-container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Overlay, { onClick: () => hidePopup() }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "popup", style: popupStyles, children: PopupComponent && /* @__PURE__ */ jsxRuntimeExports.jsx(PopupComponent, {}) })
    ] }) })
  ] });
}
function Loader({ typing }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cn("rcw-loader", { active: typing }), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rcw-loader-container", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "rcw-loader-dots" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "rcw-loader-dots" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "rcw-loader-dots" })
  ] }) });
}
function Item({ align, text: text2, onClick }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `rcw-suggestion align-${align}`, dangerouslySetInnerHTML: { __html: text2 }, onClick });
}
function Suggestions({ onClick }) {
  const { right, bottom } = useSelector(({ suggestions }) => ({
    right: suggestions.right,
    bottom: suggestions.bottom
  }));
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rcw-suggestions", children: [
    Object.entries(right).map(([text2, next2], i) => /* @__PURE__ */ jsxRuntimeExports.jsx(Item, { align: "right", text: text2, onClick: onClick ? () => onClick(text2, next2) : next2 }, i)),
    Object.entries(bottom).map(([text2, next2], i) => /* @__PURE__ */ jsxRuntimeExports.jsx(Item, { align: "bottom", text: text2, onClick: onClick ? () => onClick(text2, next2) : next2 }, i))
  ] });
}
const getComponentToRender = (message2, opts) => {
  const ComponentToRender = message2.component;
  if (message2.type === "component") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ComponentToRender, { ...message2.props });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ComponentToRender, { message: message2, ...opts });
};
function Messages({ profileAvatar, profileClientAvatar, showTimeStamp = true, reply, reaction, suggestionsProps }) {
  const { messages, typing, showChat, badgeCount, showSuggestion } = useSelector(({ behavior, messages: messages2, suggestions }) => ({
    messages: messages2.messages,
    badgeCount: messages2.badgeCount,
    typing: behavior.messageLoader,
    showChat: behavior.showChat,
    showSuggestion: suggestions.showSuggestion
  }));
  const messageRef = useRef(null);
  useEffect(() => {
    scrollToBottom(messageRef.current);
    if (showChat && badgeCount) markAllMessagesRead();
    else setBadgeCount(messages.filter((message2) => message2.unread).length);
  }, [messages, badgeCount, showChat]);
  const isClient = (sender) => sender === MESSAGE_SENDER.CLIENT;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { id: "rcw-messages", className: "rcw-messages-container", ref: messageRef, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(ContextMenu, { reply, reaction }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ContextReaction, {}),
    messages == null ? void 0 : messages.map(
      (message2, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: `rcw-message ${isClient(message2.sender) ? "rcw-message-client" : ""}`,
          children: [
            (profileAvatar && !isClient(message2.sender) || profileClientAvatar && isClient(message2.sender)) && message2.showAvatar && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                src: message2.profileAvatar ?? (isClient(message2.sender) ? profileClientAvatar : profileAvatar),
                className: `rcw-avatar ${isClient(message2.sender) ? "rcw-avatar-client" : ""}`,
                alt: "profile"
              }
            ),
            getComponentToRender(message2, { reply, reaction, showTimeStamp })
          ]
        },
        `${index}-${format(message2.timestamp, "hh:mm")}`
      )
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Loader, { typing }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { flexGrow: 1 } }),
    showSuggestion && /* @__PURE__ */ jsxRuntimeExports.jsx(Suggestions, { ...suggestionsProps })
  ] });
}
const getCaretIndex = (el) => {
  let position2 = 0;
  const selection = window.getSelection();
  if (selection.rangeCount !== 0) {
    const range = window.getSelection().getRangeAt(0);
    const preCaretRange = range.cloneRange();
    preCaretRange.selectNodeContents(el);
    preCaretRange.setEnd(range.endContainer, range.endOffset);
    position2 = preCaretRange.toString().length;
  }
  return position2;
};
const getSelection = (el) => {
  const range = window.getSelection().getRangeAt(0);
  const preSelectionRange = range.cloneRange();
  preSelectionRange.selectNodeContents(el);
  preSelectionRange.setEnd(range.startContainer, range.startOffset);
  const start = preSelectionRange.toString().length;
  return {
    start,
    end: start + range.toString().length
  };
};
const isFirefox = () => navigator.userAgent.search("Firefox") > 0;
const updateCaret = (el, caret2, offset) => {
  const range = document.createRange();
  const selection = window.getSelection();
  range.setStart(el.childNodes[0], caret2 + offset);
  range.collapse(true);
  selection.removeAllRanges();
  selection.addRange(range);
  el.focus();
};
const insertNodeAtCaret = (el) => {
  const position2 = getCaretIndex(el);
  let characterToEnter = "\n\n";
  let prevChar, char2 = "";
  if (position2 > 0) {
    prevChar = el.innerHTML.charAt(position2 - 1);
    char2 = el.innerHTML.charAt(position2);
    const newLines = el.innerHTML.match(/\n/g);
    if (prevChar === char2 || prevChar === "\n" && char2 === "" || isFirefox() && (newLines == null ? void 0 : newLines.length) > 0) {
      characterToEnter = "\n";
    }
  }
  const selection = window.getSelection();
  const node2 = document.createTextNode(characterToEnter);
  const range = selection.getRangeAt(0);
  range.collapse(false);
  range.insertNode(node2);
  const cloneRange = range.cloneRange();
  cloneRange.selectNodeContents(node2);
  cloneRange.collapse(false);
  selection.removeAllRanges();
  selection.addRange(cloneRange);
  el.innerHTML = el.innerHTML.replace(/<br>/g, "");
  updateCaret(el, position2, 1);
};
const microphone = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='utf-8'?%3e%3c!DOCTYPE%20svg%20PUBLIC%20'-//W3C//DTD%20SVG%201.1//EN'%20'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'%3e%3csvg%20fill='%23000000'%20height='800px'%20width='800px'%20version='1.1'%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20512%20512'%20enable-background='new%200%200%20512%20512'%3e%3cg%3e%3cg%3e%3cpath%20d='m439.5,236c0-11.3-9.1-20.4-20.4-20.4s-20.4,9.1-20.4,20.4c0,70-64,126.9-142.7,126.9-78.7,0-142.7-56.9-142.7-126.9%200-11.3-9.1-20.4-20.4-20.4s-20.4,9.1-20.4,20.4c0,86.2%2071.5,157.4%20163.1,166.7v57.5h-23.6c-11.3,0-20.4,9.1-20.4,20.4%200,11.3%209.1,20.4%2020.4,20.4h88c11.3,0%2020.4-9.1%2020.4-20.4%200-11.3-9.1-20.4-20.4-20.4h-23.6v-57.5c91.6-9.3%20163.1-80.5%20163.1-166.7z'/%3e%3cpath%20d='m256,323.5c51,0%2092.3-41.3%2092.3-92.3v-127.9c0-51-41.3-92.3-92.3-92.3s-92.3,41.3-92.3,92.3v127.9c0,51%2041.3,92.3%2092.3,92.3zm-52.3-220.2c0-28.8%2023.5-52.3%2052.3-52.3s52.3,23.5%2052.3,52.3v127.9c0,28.8-23.5,52.3-52.3,52.3s-52.3-23.5-52.3-52.3v-127.9z'/%3e%3c/g%3e%3c/g%3e%3c/svg%3e";
const microphoneActive = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='utf-8'?%3e%3c!DOCTYPE%20svg%20PUBLIC%20'-//W3C//DTD%20SVG%201.1//EN'%20'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'%3e%3csvg%20fill='%230080ff'%20height='800px'%20width='800px'%20version='1.1'%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20512%20512'%20enable-background='new%200%200%20512%20512'%3e%3cg%3e%3cg%3e%3cpath%20d='m439.5,236c0-11.3-9.1-20.4-20.4-20.4s-20.4,9.1-20.4,20.4c0,70-64,126.9-142.7,126.9-78.7,0-142.7-56.9-142.7-126.9%200-11.3-9.1-20.4-20.4-20.4s-20.4,9.1-20.4,20.4c0,86.2%2071.5,157.4%20163.1,166.7v57.5h-23.6c-11.3,0-20.4,9.1-20.4,20.4%200,11.3%209.1,20.4%2020.4,20.4h88c11.3,0%2020.4-9.1%2020.4-20.4%200-11.3-9.1-20.4-20.4-20.4h-23.6v-57.5c91.6-9.3%20163.1-80.5%20163.1-166.7z'/%3e%3cpath%20d='m256,323.5c51,0%2092.3-41.3%2092.3-92.3v-127.9c0-51-41.3-92.3-92.3-92.3s-92.3,41.3-92.3,92.3v127.9c0,51%2041.3,92.3%2092.3,92.3zm-52.3-220.2c0-28.8%2023.5-52.3%2052.3-52.3s52.3,23.5%2052.3,52.3v127.9c0,28.8-23.5,52.3-52.3,52.3s-52.3-23.5-52.3-52.3v-127.9z'/%3e%3c/g%3e%3c/g%3e%3c/svg%3e";
const useVoiceToText = () => {
  const locale = useSelector(({ messages }) => messages == null ? void 0 : messages.voiceLocale);
  const [listening, setListening] = useState(false);
  const [text2, setText] = useState("");
  const [isSupported, setIsSupported] = useState(false);
  const [isFinal, setIsFinal] = useState(false);
  const recognition = useRef(null);
  useEffect(() => {
    try {
      if (locale && window.webkitSpeechRecognition) {
        const r2 = new window.webkitSpeechRecognition();
        r2.continuous = true;
        r2.interimResults = true;
        r2.lang = locale;
        r2.addEventListener("start", () => {
          setListening(true);
        });
        r2.addEventListener("result", (event) => {
          let interimTranscript = "";
          let finalTranscript = "";
          for (let i = event.resultIndex; i < event.results.length; i++) {
            const transcript = event.results[i][0].transcript;
            if (event.results[i].isFinal) {
              finalTranscript += transcript + " ";
            } else {
              interimTranscript += transcript;
            }
          }
          setText(finalTranscript || interimTranscript);
          if (finalTranscript) setIsFinal(true);
        });
        r2.addEventListener("end", () => {
          setListening(false);
        });
        r2.addEventListener("error", (error2) => {
          setListening(false);
        });
        recognition.current = r2;
        setIsSupported(true);
      } else {
      }
    } catch (e) {
    }
    return () => {
      const r2 = recognition.current;
      if (r2) {
        r2.stop();
      }
    };
  }, [locale]);
  const start = () => {
    const r2 = recognition.current;
    if (r2) {
      r2.start();
      setIsFinal(false);
    }
  };
  const stop = () => {
    const r2 = recognition.current;
    if (r2) {
      r2.stop();
    }
  };
  const resetText = () => {
    setText("");
  };
  return { isSupported, listening, start, stop, text: text2, resetText, isFinal };
};
const useClickAndHold = (callback = null, duration2 = 500) => {
  const [isHolding, setIsHolding] = useState(false);
  const holdTimer = useRef(setTimeout(() => {
  }, 0));
  const onMouseDown = () => {
    holdTimer.current = setTimeout(() => {
      setIsHolding(true);
      if (callback) {
        callback();
      }
    }, duration2);
  };
  const onMouseUp = () => {
    clearTimeout(holdTimer.current);
    if (isHolding) {
      setIsHolding(false);
    }
  };
  const onMouseLeave = () => {
    clearTimeout(holdTimer.current);
    if (isHolding) {
      setIsHolding(false);
    }
  };
  useEffect(() => {
    return () => {
      clearTimeout(holdTimer.current);
    };
  }, [isHolding, callback, duration2]);
  return { isHolding, onMouseDown, onMouseUp, onMouseLeave };
};
const VoiceButton = ({ onChange }) => {
  const {
    text: text2,
    isSupported,
    start: startListening,
    stop: stopListening,
    isFinal
  } = useVoiceToText();
  useEffect(() => {
    if (!text2) {
      return;
    }
    onChange(text2, isFinal);
  }, [text2, isFinal, onChange]);
  useEffect(() => {
    return () => {
      stopListening();
    };
  }, [stopListening]);
  const { isHolding, ...mouseProps } = useClickAndHold();
  useEffect(() => {
    if (isHolding) {
      startListening();
    } else {
      stopListening();
    }
  }, [isHolding, startListening, stopListening]);
  if (!isSupported) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "submit", className: cn("rcw-micro", { active: isHolding }), ...mouseProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: isHolding ? microphoneActive : microphone, className: "rcw-micro-icon" }) });
};
const send = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='iso-8859-1'?%3e%3c!--%20Generator:%20Adobe%20Illustrator%2016.0.0,%20SVG%20Export%20Plug-In%20.%20SVG%20Version:%206.00%20Build%200)%20--%3e%3c!DOCTYPE%20svg%20PUBLIC%20'-//W3C//DTD%20SVG%201.1//EN'%20'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'%3e%3csvg%20xmlns='http://www.w3.org/2000/svg'%20version='1.1'%20id='Capa_1'%20x='0px'%20y='0px'%20width='24px'%20height='24px'%20viewBox='0%200%2024%2024'%20fill='%23000000a0'%3e%3cpath%20d='M16.6915026,12.4744748%20L3.50612381,13.2599618%20C3.19218622,13.2599618%203.03521743,13.4170592%203.03521743,13.5741566%20L1.15159189,20.0151496%20C0.8376543,20.8006365%200.99,21.89%201.77946707,22.52%20C2.41,22.99%203.50612381,23.1%204.13399899,22.8429026%20L21.714504,14.0454487%20C22.6563168,13.5741566%2023.1272231,12.6315722%2022.9702544,11.6889879%20C22.8132856,11.0605983%2022.3423792,10.4322088%2021.714504,10.118014%20L4.13399899,1.16346272%20C3.34915502,0.9%202.40734225,1.00636533%201.77946707,1.4776575%20C0.994623095,2.10604706%200.8376543,3.0486314%201.15159189,3.99121575%20L3.03521743,10.4322088%20C3.03521743,10.5893061%203.34915502,10.7464035%203.50612381,10.7464035%20L16.6915026,11.5318905%20C16.6915026,11.5318905%2017.1624089,11.5318905%2017.1624089,12.0031827%20C17.1624089,12.4744748%2016.6915026,12.4744748%2016.6915026,12.4744748%20Z'%3e%3c/path%3e%3c/svg%3e";
const sendActive = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='iso-8859-1'?%3e%3c!--%20Generator:%20Adobe%20Illustrator%2016.0.0,%20SVG%20Export%20Plug-In%20.%20SVG%20Version:%206.00%20Build%200)%20--%3e%3c!DOCTYPE%20svg%20PUBLIC%20'-//W3C//DTD%20SVG%201.1//EN'%20'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'%3e%3csvg%20xmlns='http://www.w3.org/2000/svg'%20version='1.1'%20id='Capa_1'%20x='0px'%20y='0px'%20width='24px'%20height='24px'%20viewBox='0%200%2024%2024'%20fill='%230080ff'%3e%3cpath%20d='M16.6915026,12.4744748%20L3.50612381,13.2599618%20C3.19218622,13.2599618%203.03521743,13.4170592%203.03521743,13.5741566%20L1.15159189,20.0151496%20C0.8376543,20.8006365%200.99,21.89%201.77946707,22.52%20C2.41,22.99%203.50612381,23.1%204.13399899,22.8429026%20L21.714504,14.0454487%20C22.6563168,13.5741566%2023.1272231,12.6315722%2022.9702544,11.6889879%20C22.8132856,11.0605983%2022.3423792,10.4322088%2021.714504,10.118014%20L4.13399899,1.16346272%20C3.34915502,0.9%202.40734225,1.00636533%201.77946707,1.4776575%20C0.994623095,2.10604706%200.8376543,3.0486314%201.15159189,3.99121575%20L3.03521743,10.4322088%20C3.03521743,10.5893061%203.34915502,10.7464035%203.50612381,10.7464035%20L16.6915026,11.5318905%20C16.6915026,11.5318905%2017.1624089,11.5318905%2017.1624089,12.0031827%20C17.1624089,12.4744748%2016.6915026,12.4744748%2016.6915026,12.4744748%20Z'%3e%3c/path%3e%3c/svg%3e";
const smiley = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20512%20512'%3e%3cpath%20d='M464%20256A208%20208%200%201%200%2048%20256a208%20208%200%201%200%20416%200zM0%20256a256%20256%200%201%201%20512%200A256%20256%200%201%201%200%20256zm177.6%2062.1C192.8%20334.5%20218.8%20352%20256%20352s63.2-17.5%2078.4-33.9c9-9.7%2024.2-10.4%2033.9-1.4s10.4%2024.2%201.4%2033.9c-22%2023.8-60%2049.4-113.6%2049.4s-91.7-25.5-113.6-49.4c-9-9.7-8.4-24.9%201.4-33.9s24.9-8.4%2033.9%201.4zM144.4%20208a32%2032%200%201%201%2064%200%2032%2032%200%201%201%20-64%200zm192-32a32%2032%200%201%201%200%2064%2032%2032%200%201%201%200-64z'/%3e%3c/svg%3e";
const file = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20512%20512'%3e%3cpath%20d='M448%2080c8.8%200%2016%207.2%2016%2016V415.8l-5-6.5-136-176c-4.5-5.9-11.6-9.3-19-9.3s-14.4%203.4-19%209.3L202%20340.7l-30.5-42.7C167%20291.7%20159.8%20288%20152%20288s-15%203.7-19.5%2010.1l-80%20112L48%20416.3l0-.3V96c0-8.8%207.2-16%2016-16H448zM64%2032C28.7%2032%200%2060.7%200%2096V416c0%2035.3%2028.7%2064%2064%2064H448c35.3%200%2064-28.7%2064-64V96c0-35.3-28.7-64-64-64H64zm80%20192a48%2048%200%201%200%200-96%2048%2048%200%201%200%200%2096z'/%3e%3c/svg%3e";
const brRegex = /<br>/g;
function Sender({
  senderRef,
  sendMessage: sendMessage2,
  placeholder = "Type a message...",
  disabledInput = false,
  autofocus = true,
  onTextInputChange,
  onVoiceInputChange,
  buttonAlt = "Send",
  onPressEmoji,
  onPressFile,
  allowSend = false
}) {
  const showChat = useSelector(({ behavior }) => behavior.showChat);
  const inputRef = useRef(null);
  const refContainer = useRef(null);
  const [enter, setEnter] = useState(true);
  const [firefox, setFirefox] = useState(false);
  const [isTextReady, setIsTextReady] = useState(false);
  useEffect(() => {
    var _a2;
    if (showChat && autofocus) (_a2 = inputRef.current) == null ? void 0 : _a2.focus();
  }, [showChat, autofocus]);
  useEffect(() => {
    setFirefox(isFirefox());
  }, []);
  useEffect(() => {
    if (!disabledInput && inputRef.current) {
      inputRef.current.focus();
    }
  }, [disabledInput]);
  useImperativeHandle(senderRef, () => {
    return {
      onSelectEmoji: handlerOnSelectEmoji
    };
  });
  const handlerOnChange = (event) => {
    var _a2;
    setIsTextReady(((_a2 = inputRef.current) == null ? void 0 : _a2.innerHTML.length) > 0);
    onTextInputChange && onTextInputChange(event);
  };
  const handlerOnSpeech = (text2, isFinal) => {
    if (!inputRef.current) {
      return;
    }
    inputRef.current.innerHTML = text2;
    setIsTextReady(text2.length > 0);
    onVoiceInputChange && onVoiceInputChange(text2, isFinal);
  };
  const handlerSendMessage = () => {
    const el = inputRef.current;
    if (el.innerHTML || allowSend) {
      sendMessage2(el.innerText);
      el.innerHTML = "";
      setIsTextReady(false);
    }
  };
  const handlerOnSelectEmoji = (emoji2) => {
    const el = inputRef.current;
    const { start, end } = getSelection(el);
    if (el.innerHTML) {
      const firstPart = el.innerHTML.substring(0, start);
      const secondPart = el.innerHTML.substring(end);
      el.innerHTML = `${firstPart}${emoji2.emoji}${secondPart}`;
    } else {
      el.innerHTML = emoji2.emoji;
    }
    updateCaret(el, start, emoji2.emoji.length);
  };
  const handlerOnKeyPress = (event) => {
    const el = inputRef.current;
    if (event.charCode == 13 && !event.shiftKey) {
      event.preventDefault();
      handlerSendMessage();
    }
    if (event.charCode === 13 && event.shiftKey) {
      event.preventDefault();
      insertNodeAtCaret(el);
      setEnter(true);
    }
  };
  const handlerOnKeyUp = (event) => {
    const el = inputRef.current;
    if (!el) return true;
    if (firefox && event.key === "Backspace") {
      if (el.innerHTML.length === 1 && enter) {
        el.innerHTML = "";
        setEnter(false);
      } else if (brRegex.test(el.innerHTML)) {
        el.innerHTML = el.innerHTML.replace(brRegex, "");
      }
    }
  };
  const handlerOnKeyDown = (event) => {
    const el = inputRef.current;
    if (event.key === "Backspace" && el) {
      const caretPosition = getCaretIndex(inputRef.current);
      const character2 = el.innerHTML.charAt(caretPosition - 1);
      if (character2 === "\n") {
        event.preventDefault();
        event.stopPropagation();
        el.innerHTML = el.innerHTML.substring(0, caretPosition - 1) + el.innerHTML.substring(caretPosition);
        updateCaret(el, caretPosition, -1);
      }
    }
  };
  const handlerPressEmoji = () => {
    onPressEmoji == null ? void 0 : onPressEmoji();
  };
  const handlerPressFile = () => {
    onPressFile == null ? void 0 : onPressFile();
  };
  const isSendActive = !disabledInput && isTextReady || allowSend;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ref: refContainer, className: "rcw-sender", children: [
    onPressFile && /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "rcw-picker-btn file-picker-btn", type: "submit", onClick: handlerPressFile, children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: file, className: "rcw-picker-icon", alt: "" }) }),
    onPressEmoji && /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "rcw-picker-btn emoji-picker-btn", type: "submit", onClick: handlerPressEmoji, children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: smiley, className: "rcw-picker-icon", alt: "" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cn("rcw-new-message", {
      "rcw-message-disable": disabledInput
    }), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          spellCheck: true,
          contentEditable: true,
          className: "rcw-input",
          role: "textbox",
          ref: inputRef,
          "data-placeholder": "Type a message...",
          onInput: handlerOnChange,
          onKeyPress: handlerOnKeyPress,
          onKeyUp: handlerOnKeyUp,
          onKeyDown: handlerOnKeyDown
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rcw-input-fake", role: "textbox", children: " " })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(VoiceButton, { onChange: handlerOnSpeech }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "submit", className: cn("rcw-send", { active: isSendActive }), onClick: handlerSendMessage, disabled: !enter && !allowSend, children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: isSendActive ? sendActive : send, className: "rcw-send-icon", alt: buttonAlt }) })
  ] });
}
function QuickButtons({ onQuickButtonClicked }) {
  const buttons = useSelector(({ quickButtons }) => quickButtons.quickButtons);
  const getComponentToRender2 = (button) => {
    const ComponentToRender = button.component;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      ComponentToRender,
      {
        onQuickButtonClicked,
        button
      }
    );
  };
  if (!buttons.length) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "quick-buttons-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: "quick-buttons", children: buttons.map(
    (button, index) => /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "quick-list-button", children: getComponentToRender2(button) }, `${button.label}-${index}`)
  ) }) });
}
function SenderContext({ replyMessage }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rcw-sender-context", children: replyMessage && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rcw-sender-context-reply", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "rcw-sender-context-reply-bar" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "rcw-sender-context-reply-close", onClick: () => setReplyMessage(null), children: "×" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rcw-sender-context-reply-content", children: getComponentToRender(replyMessage, { isReplyContext: true }) })
  ] }) });
}
const plus = "data:image/svg+xml,%3csvg%20t='1588073211014'%20class='icon'%20viewBox='0%200%201024%201024'%20version='1.1'%20xmlns='http://www.w3.org/2000/svg'%20p-id='4426'%20width='32'%20height='32'%3e%3cpath%20d='M693.179733%20520.8064c0%2016.9984-13.7216%2030.72-30.72%2030.72h-122.88v116.053333c0%2016.9984-13.7216%2030.72-30.72%2030.72s-30.72-13.7216-30.72-30.72v-116.053333h-116.053333c-16.9984%200-30.72-13.7216-30.72-30.72s13.7216-30.72%2030.72-30.72h116.053333v-122.88c0-16.9984%2013.7216-30.72%2030.72-30.72s30.72%2013.7216%2030.72%2030.72v122.88h122.88a30.72%2030.72%200%200%201%2030.72%2030.72z'%20p-id='4427'%20fill='%23433938'%3e%3c/path%3e%3c/svg%3e";
function FileRemove({ onClick }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "rcw-file-remove", onClick, children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: close$1, alt: "" }) });
}
function FileImage({ item, onRemove }) {
  const [url, setUrl] = useState(null);
  useEffect(() => {
    setUrl(URL.createObjectURL(item));
  }, [item]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rcw-file rcw-file-type-image", children: [
    onRemove && /* @__PURE__ */ jsxRuntimeExports.jsx(FileRemove, { onClick: onRemove }),
    url && /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: url, alt: "" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rcw-file-name", children: " " })
  ] });
}
function FileVideo({ item, onRemove }) {
  const [url, setUrl] = useState(null);
  useEffect(() => {
    setUrl(URL.createObjectURL(item));
  }, [item]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rcw-file rcw-file-type-image", children: [
    onRemove && /* @__PURE__ */ jsxRuntimeExports.jsx(FileRemove, { onClick: onRemove }),
    url && /* @__PURE__ */ jsxRuntimeExports.jsx("video", { src: url }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rcw-file-name", children: " " })
  ] });
}
function FileUnknown({ item, onRemove }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rcw-file rcw-file-type-unknown", children: [
    onRemove && /* @__PURE__ */ jsxRuntimeExports.jsx(FileRemove, { onClick: onRemove }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: file, className: "rcw-file-icon", alt: "" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rcw-file-name", title: item.name, children: item.name })
  ] });
}
function FileAddButton({ onSelect, addFileRef, showButton, multiple, allowImage, allowVideo, allowAny }) {
  const inputRef = useRef(null);
  const handleClick = () => {
    var _a2;
    return (_a2 = inputRef.current) == null ? void 0 : _a2.click();
  };
  const handleFile = () => {
    var _a2;
    const files = (_a2 = inputRef.current) == null ? void 0 : _a2.files;
    files && (onSelect == null ? void 0 : onSelect(files));
  };
  useEffect(() => {
    addFileRef && (addFileRef.current = handleClick);
  }, [addFileRef]);
  const accepts = [];
  if (allowAny) {
    accepts.push("*");
  } else {
    if (allowImage) {
      accepts.push("image/*");
    }
    if (allowVideo) {
      accepts.push("video/*");
    }
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rcw-file rcw-file-add", children: [
    showButton && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: handleClick, children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: plus, className: "rcw-file-icon", alt: "" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rcw-file-name", children: " " })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("input", { type: "file", className: "rcw-file-input", accept: accepts.join(","), multiple, ref: inputRef, onChange: handleFile })
  ] });
}
const isImage = (file2) => file2.type.startsWith("image/");
const isVideo = (file2) => file2.type.startsWith("video/");
function FilePicker$1({ items, height: height2, maxItem = 3, showButton = true, onSelectFile, addFileRef, allowImage, allowVideo, allowAny }) {
  const removeIndex = (item) => {
    const newItems = items.filter((x2) => x2 !== item);
    onSelectFile == null ? void 0 : onSelectFile(newItems.slice(-maxItem));
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("aside", { className: cn("rcw-file-picker", { show: showButton || items.length }), style: { height: height2, width: "100%" }, children: [
    items.map((item, i) => {
      if (isImage(item)) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(FileImage, { item, onRemove: () => removeIndex(item) }, i);
      }
      if (isVideo(item)) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(FileVideo, { item, onRemove: () => removeIndex(item) }, i);
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(FileUnknown, { item, onRemove: () => removeIndex(item) }, i);
    }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      FileAddButton,
      {
        showButton: items.length ? items.length < maxItem : showButton,
        addFileRef,
        multiple: maxItem > 1,
        allowImage,
        allowVideo,
        allowAny,
        onSelect: (files) => {
          let newItems = [...items, ...files];
          if (!allowAny && (allowImage || allowVideo)) {
            newItems = newItems.filter((item) => allowImage && isImage(item) || allowVideo && isVideo(item));
          }
          if (newItems.length > 0) {
            onSelectFile == null ? void 0 : onSelectFile(newItems.slice(-maxItem));
          }
        }
      }
    )
  ] });
}
function FilePicker({ onEmojiClick, height: height2, bottom }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rcw-emoji-picker", style: { bottom: `${bottom}px` }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    EmojiPicker$1,
    {
      onEmojiClick,
      emojiStyle: EmojiStyle.NATIVE,
      searchDisabled: true,
      width: "100%",
      height: height2,
      previewConfig: {
        showPreview: false
      }
    }
  ) });
}
function useSnackbar(parameters = {}) {
  const {
    autoHideDuration = null,
    disableWindowBlurListener = false,
    onClose,
    open,
    resumeHideDuration
  } = parameters;
  const timerAutoHide = useTimeout();
  React.useEffect(() => {
    if (!open) {
      return void 0;
    }
    function handleKeyDown(nativeEvent) {
      if (!nativeEvent.defaultPrevented) {
        if (nativeEvent.key === "Escape") {
          onClose == null ? void 0 : onClose(nativeEvent, "escapeKeyDown");
        }
      }
    }
    document.addEventListener("keydown", handleKeyDown);
    return () => {
      document.removeEventListener("keydown", handleKeyDown);
    };
  }, [open, onClose]);
  const handleClose = useEventCallback((event, reason) => {
    onClose == null ? void 0 : onClose(event, reason);
  });
  const setAutoHideTimer = useEventCallback((autoHideDurationParam) => {
    if (!onClose || autoHideDurationParam == null) {
      return;
    }
    timerAutoHide.start(autoHideDurationParam, () => {
      handleClose(null, "timeout");
    });
  });
  React.useEffect(() => {
    if (open) {
      setAutoHideTimer(autoHideDuration);
    }
    return timerAutoHide.clear;
  }, [open, autoHideDuration, setAutoHideTimer, timerAutoHide]);
  const handleClickAway = (event) => {
    onClose == null ? void 0 : onClose(event, "clickaway");
  };
  const handlePause = timerAutoHide.clear;
  const handleResume = React.useCallback(() => {
    if (autoHideDuration != null) {
      setAutoHideTimer(resumeHideDuration != null ? resumeHideDuration : autoHideDuration * 0.5);
    }
  }, [autoHideDuration, resumeHideDuration, setAutoHideTimer]);
  const createHandleBlur = (otherHandlers) => (event) => {
    const onBlurCallback = otherHandlers.onBlur;
    onBlurCallback == null ? void 0 : onBlurCallback(event);
    handleResume();
  };
  const createHandleFocus = (otherHandlers) => (event) => {
    const onFocusCallback = otherHandlers.onFocus;
    onFocusCallback == null ? void 0 : onFocusCallback(event);
    handlePause();
  };
  const createMouseEnter = (otherHandlers) => (event) => {
    const onMouseEnterCallback = otherHandlers.onMouseEnter;
    onMouseEnterCallback == null ? void 0 : onMouseEnterCallback(event);
    handlePause();
  };
  const createMouseLeave = (otherHandlers) => (event) => {
    const onMouseLeaveCallback = otherHandlers.onMouseLeave;
    onMouseLeaveCallback == null ? void 0 : onMouseLeaveCallback(event);
    handleResume();
  };
  React.useEffect(() => {
    if (!disableWindowBlurListener && open) {
      window.addEventListener("focus", handleResume);
      window.addEventListener("blur", handlePause);
      return () => {
        window.removeEventListener("focus", handleResume);
        window.removeEventListener("blur", handlePause);
      };
    }
    return void 0;
  }, [disableWindowBlurListener, open, handleResume, handlePause]);
  const getRootProps = (externalProps = {}) => {
    const externalEventHandlers = {
      ...extractEventHandlers$1(parameters),
      ...extractEventHandlers$1(externalProps)
    };
    return {
      // ClickAwayListener adds an `onClick` prop which results in the alert not being announced.
      // See https://github.com/mui/material-ui/issues/29080
      role: "presentation",
      ...externalProps,
      ...externalEventHandlers,
      onBlur: createHandleBlur(externalEventHandlers),
      onFocus: createHandleFocus(externalEventHandlers),
      onMouseEnter: createMouseEnter(externalEventHandlers),
      onMouseLeave: createMouseLeave(externalEventHandlers)
    };
  };
  return {
    getRootProps,
    onClickAway: handleClickAway
  };
}
function mapEventPropToEvent(eventProp) {
  return eventProp.substring(2).toLowerCase();
}
function clickedRootScrollbar(event, doc) {
  return doc.documentElement.clientWidth < event.clientX || doc.documentElement.clientHeight < event.clientY;
}
function ClickAwayListener(props) {
  const {
    children,
    disableReactTree = false,
    mouseEvent = "onClick",
    onClickAway,
    touchEvent = "onTouchEnd"
  } = props;
  const movedRef = React.useRef(false);
  const nodeRef = React.useRef(null);
  const activatedRef = React.useRef(false);
  const syntheticEventRef = React.useRef(false);
  React.useEffect(() => {
    setTimeout(() => {
      activatedRef.current = true;
    }, 0);
    return () => {
      activatedRef.current = false;
    };
  }, []);
  const handleRef = useForkRef$1(getReactElementRef(children), nodeRef);
  const handleClickAway = useEventCallback((event) => {
    const insideReactTree = syntheticEventRef.current;
    syntheticEventRef.current = false;
    const doc = ownerDocument(nodeRef.current);
    if (!activatedRef.current || !nodeRef.current || "clientX" in event && clickedRootScrollbar(event, doc)) {
      return;
    }
    if (movedRef.current) {
      movedRef.current = false;
      return;
    }
    let insideDOM;
    if (event.composedPath) {
      insideDOM = event.composedPath().includes(nodeRef.current);
    } else {
      insideDOM = !doc.documentElement.contains(
        // @ts-expect-error returns `false` as intended when not dispatched from a Node
        event.target
      ) || nodeRef.current.contains(
        // @ts-expect-error returns `false` as intended when not dispatched from a Node
        event.target
      );
    }
    if (!insideDOM && (disableReactTree || !insideReactTree)) {
      onClickAway(event);
    }
  });
  const createHandleSynthetic = (handlerName) => (event) => {
    syntheticEventRef.current = true;
    const childrenPropsHandler = children.props[handlerName];
    if (childrenPropsHandler) {
      childrenPropsHandler(event);
    }
  };
  const childrenProps = {
    ref: handleRef
  };
  if (touchEvent !== false) {
    childrenProps[touchEvent] = createHandleSynthetic(touchEvent);
  }
  React.useEffect(() => {
    if (touchEvent !== false) {
      const mappedTouchEvent = mapEventPropToEvent(touchEvent);
      const doc = ownerDocument(nodeRef.current);
      const handleTouchMove = () => {
        movedRef.current = true;
      };
      doc.addEventListener(mappedTouchEvent, handleClickAway);
      doc.addEventListener("touchmove", handleTouchMove);
      return () => {
        doc.removeEventListener(mappedTouchEvent, handleClickAway);
        doc.removeEventListener("touchmove", handleTouchMove);
      };
    }
    return void 0;
  }, [handleClickAway, touchEvent]);
  if (mouseEvent !== false) {
    childrenProps[mouseEvent] = createHandleSynthetic(mouseEvent);
  }
  React.useEffect(() => {
    if (mouseEvent !== false) {
      const mappedMouseEvent = mapEventPropToEvent(mouseEvent);
      const doc = ownerDocument(nodeRef.current);
      doc.addEventListener(mappedMouseEvent, handleClickAway);
      return () => {
        doc.removeEventListener(mappedMouseEvent, handleClickAway);
      };
    }
    return void 0;
  }, [handleClickAway, mouseEvent]);
  return /* @__PURE__ */ React.cloneElement(children, childrenProps);
}
function getSnackbarContentUtilityClass(slot) {
  return generateUtilityClass("MuiSnackbarContent", slot);
}
generateUtilityClasses("MuiSnackbarContent", ["root", "message", "action"]);
const useUtilityClasses$6 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots2 = {
    root: ["root"],
    action: ["action"],
    message: ["message"]
  };
  return composeClasses(slots2, getSnackbarContentUtilityClass, classes);
};
const SnackbarContentRoot = styled(Paper, {
  name: "MuiSnackbarContent",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})(memoTheme(({
  theme
}) => {
  const emphasis = theme.palette.mode === "light" ? 0.8 : 0.98;
  const backgroundColor2 = emphasize(theme.palette.background.default, emphasis);
  return {
    ...theme.typography.body2,
    color: theme.vars ? theme.vars.palette.SnackbarContent.color : theme.palette.getContrastText(backgroundColor2),
    backgroundColor: theme.vars ? theme.vars.palette.SnackbarContent.bg : backgroundColor2,
    display: "flex",
    alignItems: "center",
    flexWrap: "wrap",
    padding: "6px 16px",
    borderRadius: (theme.vars || theme).shape.borderRadius,
    flexGrow: 1,
    [theme.breakpoints.up("sm")]: {
      flexGrow: "initial",
      minWidth: 288
    }
  };
}));
const SnackbarContentMessage = styled("div", {
  name: "MuiSnackbarContent",
  slot: "Message",
  overridesResolver: (props, styles2) => styles2.message
})({
  padding: "8px 0"
});
const SnackbarContentAction = styled("div", {
  name: "MuiSnackbarContent",
  slot: "Action",
  overridesResolver: (props, styles2) => styles2.action
})({
  display: "flex",
  alignItems: "center",
  marginLeft: "auto",
  paddingLeft: 16,
  marginRight: -8
});
const SnackbarContent = /* @__PURE__ */ React.forwardRef(function SnackbarContent2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiSnackbarContent"
  });
  const {
    action,
    className,
    message: message2,
    role = "alert",
    ...other
  } = props;
  const ownerState = props;
  const classes = useUtilityClasses$6(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(SnackbarContentRoot, {
    role,
    square: true,
    elevation: 6,
    className: clsx(classes.root, className),
    ownerState,
    ref: ref2,
    ...other,
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(SnackbarContentMessage, {
      className: classes.message,
      ownerState,
      children: message2
    }), action ? /* @__PURE__ */ jsxRuntimeExports.jsx(SnackbarContentAction, {
      className: classes.action,
      ownerState,
      children: action
    }) : null]
  });
});
function getSnackbarUtilityClass(slot) {
  return generateUtilityClass("MuiSnackbar", slot);
}
generateUtilityClasses("MuiSnackbar", ["root", "anchorOriginTopCenter", "anchorOriginBottomCenter", "anchorOriginTopRight", "anchorOriginBottomRight", "anchorOriginTopLeft", "anchorOriginBottomLeft"]);
const useUtilityClasses$5 = (ownerState) => {
  const {
    classes,
    anchorOrigin
  } = ownerState;
  const slots2 = {
    root: ["root", `anchorOrigin${capitalize(anchorOrigin.vertical)}${capitalize(anchorOrigin.horizontal)}`]
  };
  return composeClasses(slots2, getSnackbarUtilityClass, classes);
};
const SnackbarRoot = styled("div", {
  name: "MuiSnackbar",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[`anchorOrigin${capitalize(ownerState.anchorOrigin.vertical)}${capitalize(ownerState.anchorOrigin.horizontal)}`]];
  }
})(memoTheme(({
  theme
}) => ({
  zIndex: (theme.vars || theme).zIndex.snackbar,
  position: "fixed",
  display: "flex",
  left: 8,
  right: 8,
  justifyContent: "center",
  alignItems: "center",
  variants: [{
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.vertical === "top",
    style: {
      top: 8,
      [theme.breakpoints.up("sm")]: {
        top: 24
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.vertical !== "top",
    style: {
      bottom: 8,
      [theme.breakpoints.up("sm")]: {
        bottom: 24
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.horizontal === "left",
    style: {
      justifyContent: "flex-start",
      [theme.breakpoints.up("sm")]: {
        left: 24,
        right: "auto"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.horizontal === "right",
    style: {
      justifyContent: "flex-end",
      [theme.breakpoints.up("sm")]: {
        right: 24,
        left: "auto"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.horizontal === "center",
    style: {
      [theme.breakpoints.up("sm")]: {
        left: "50%",
        right: "auto",
        transform: "translateX(-50%)"
      }
    }
  }]
})));
const Snackbar = /* @__PURE__ */ React.forwardRef(function Snackbar2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiSnackbar"
  });
  const theme = useTheme();
  const defaultTransitionDuration = {
    enter: theme.transitions.duration.enteringScreen,
    exit: theme.transitions.duration.leavingScreen
  };
  const {
    action,
    anchorOrigin: {
      vertical,
      horizontal
    } = {
      vertical: "bottom",
      horizontal: "left"
    },
    autoHideDuration = null,
    children,
    className,
    ClickAwayListenerProps,
    ContentProps,
    disableWindowBlurListener = false,
    message: message2,
    onBlur,
    onClose,
    onFocus,
    onMouseEnter,
    onMouseLeave,
    open,
    resumeHideDuration,
    TransitionComponent = Grow,
    transitionDuration = defaultTransitionDuration,
    TransitionProps: {
      onEnter,
      onExited,
      ...TransitionProps
    } = {},
    ...other
  } = props;
  const ownerState = {
    ...props,
    anchorOrigin: {
      vertical,
      horizontal
    },
    autoHideDuration,
    disableWindowBlurListener,
    TransitionComponent,
    transitionDuration
  };
  const classes = useUtilityClasses$5(ownerState);
  const {
    getRootProps,
    onClickAway
  } = useSnackbar({
    ...ownerState
  });
  const [exited, setExited] = React.useState(true);
  const rootProps = useSlotProps$1({
    elementType: SnackbarRoot,
    getSlotProps: getRootProps,
    externalForwardedProps: other,
    ownerState,
    additionalProps: {
      ref: ref2
    },
    className: [classes.root, className]
  });
  const handleExited = (node2) => {
    setExited(true);
    if (onExited) {
      onExited(node2);
    }
  };
  const handleEnter = (node2, isAppearing) => {
    setExited(false);
    if (onEnter) {
      onEnter(node2, isAppearing);
    }
  };
  if (!open && exited) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ClickAwayListener, {
    onClickAway,
    ...ClickAwayListenerProps,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(SnackbarRoot, {
      ...rootProps,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, {
        appear: true,
        in: open,
        timeout: transitionDuration,
        direction: vertical === "top" ? "down" : "up",
        onEnter: handleEnter,
        onExited: handleExited,
        ...TransitionProps,
        children: children || /* @__PURE__ */ jsxRuntimeExports.jsx(SnackbarContent, {
          message: message2,
          action,
          ...ContentProps
        })
      })
    })
  });
});
const NotificationsContext = /* @__PURE__ */ React.createContext(null);
const serverNotifications = {
  show: () => {
    throw new Error("Not supported on server side");
  },
  close: () => {
    throw new Error("Not supported on server side");
  }
};
function useNotifications() {
  const context = React.useContext(NotificationsContext);
  if (context) {
    return context;
  }
  return serverNotifications;
}
function getAlertUtilityClass(slot) {
  return generateUtilityClass("MuiAlert", slot);
}
const alertClasses = generateUtilityClasses("MuiAlert", ["root", "action", "icon", "message", "filled", "colorSuccess", "colorInfo", "colorWarning", "colorError", "filledSuccess", "filledInfo", "filledWarning", "filledError", "outlined", "outlinedSuccess", "outlinedInfo", "outlinedWarning", "outlinedError", "standard", "standardSuccess", "standardInfo", "standardWarning", "standardError"]);
function getCircularProgressUtilityClass(slot) {
  return generateUtilityClass("MuiCircularProgress", slot);
}
generateUtilityClasses("MuiCircularProgress", ["root", "determinate", "indeterminate", "colorPrimary", "colorSecondary", "svg", "circle", "circleDeterminate", "circleIndeterminate", "circleDisableShrink"]);
const SIZE = 44;
const circularRotateKeyframe = keyframes`
  0% {
    transform: rotate(0deg);
  }

  100% {
    transform: rotate(360deg);
  }
`;
const circularDashKeyframe = keyframes`
  0% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: 0;
  }

  50% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -15px;
  }

  100% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: -126px;
  }
`;
const rotateAnimation = typeof circularRotateKeyframe !== "string" ? css`
        animation: ${circularRotateKeyframe} 1.4s linear infinite;
      ` : null;
const dashAnimation = typeof circularDashKeyframe !== "string" ? css`
        animation: ${circularDashKeyframe} 1.4s ease-in-out infinite;
      ` : null;
const useUtilityClasses$4 = (ownerState) => {
  const {
    classes,
    variant,
    color: color2,
    disableShrink
  } = ownerState;
  const slots2 = {
    root: ["root", variant, `color${capitalize(color2)}`],
    svg: ["svg"],
    circle: ["circle", `circle${capitalize(variant)}`, disableShrink && "circleDisableShrink"]
  };
  return composeClasses(slots2, getCircularProgressUtilityClass, classes);
};
const CircularProgressRoot = styled("span", {
  name: "MuiCircularProgress",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], styles2[`color${capitalize(ownerState.color)}`]];
  }
})(memoTheme(({
  theme
}) => ({
  display: "inline-block",
  variants: [{
    props: {
      variant: "determinate"
    },
    style: {
      transition: theme.transitions.create("transform")
    }
  }, {
    props: {
      variant: "indeterminate"
    },
    style: rotateAnimation || {
      animation: `${circularRotateKeyframe} 1.4s linear infinite`
    }
  }, ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      color: (theme.vars || theme).palette[color2].main
    }
  }))]
})));
const CircularProgressSVG = styled("svg", {
  name: "MuiCircularProgress",
  slot: "Svg",
  overridesResolver: (props, styles2) => styles2.svg
})({
  display: "block"
  // Keeps the progress centered
});
const CircularProgressCircle = styled("circle", {
  name: "MuiCircularProgress",
  slot: "Circle",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.circle, styles2[`circle${capitalize(ownerState.variant)}`], ownerState.disableShrink && styles2.circleDisableShrink];
  }
})(memoTheme(({
  theme
}) => ({
  stroke: "currentColor",
  variants: [{
    props: {
      variant: "determinate"
    },
    style: {
      transition: theme.transitions.create("stroke-dashoffset")
    }
  }, {
    props: {
      variant: "indeterminate"
    },
    style: {
      // Some default value that looks fine waiting for the animation to kicks in.
      strokeDasharray: "80px, 200px",
      strokeDashoffset: 0
      // Add the unit to fix a Edge 16 and below bug.
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.variant === "indeterminate" && !ownerState.disableShrink,
    style: dashAnimation || {
      // At runtime for Pigment CSS, `bufferAnimation` will be null and the generated keyframe will be used.
      animation: `${circularDashKeyframe} 1.4s ease-in-out infinite`
    }
  }]
})));
const CircularProgress = /* @__PURE__ */ React.forwardRef(function CircularProgress2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiCircularProgress"
  });
  const {
    className,
    color: color2 = "primary",
    disableShrink = false,
    size = 40,
    style: style2,
    thickness = 3.6,
    value = 0,
    variant = "indeterminate",
    ...other
  } = props;
  const ownerState = {
    ...props,
    color: color2,
    disableShrink,
    size,
    thickness,
    value,
    variant
  };
  const classes = useUtilityClasses$4(ownerState);
  const circleStyle = {};
  const rootStyle = {};
  const rootProps = {};
  if (variant === "determinate") {
    const circumference = 2 * Math.PI * ((SIZE - thickness) / 2);
    circleStyle.strokeDasharray = circumference.toFixed(3);
    rootProps["aria-valuenow"] = Math.round(value);
    circleStyle.strokeDashoffset = `${((100 - value) / 100 * circumference).toFixed(3)}px`;
    rootStyle.transform = "rotate(-90deg)";
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressRoot, {
    className: clsx(classes.root, className),
    style: {
      width: size,
      height: size,
      ...rootStyle,
      ...style2
    },
    ownerState,
    ref: ref2,
    role: "progressbar",
    ...rootProps,
    ...other,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressSVG, {
      className: classes.svg,
      ownerState,
      viewBox: `${SIZE / 2} ${SIZE / 2} ${SIZE} ${SIZE}`,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressCircle, {
        className: classes.circle,
        style: circleStyle,
        ownerState,
        cx: SIZE,
        cy: SIZE,
        r: (SIZE - thickness) / 2,
        fill: "none",
        strokeWidth: thickness
      })
    })
  });
});
function getIconButtonUtilityClass(slot) {
  return generateUtilityClass("MuiIconButton", slot);
}
const iconButtonClasses = generateUtilityClasses("MuiIconButton", ["root", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "edgeStart", "edgeEnd", "sizeSmall", "sizeMedium", "sizeLarge", "loading", "loadingIndicator", "loadingWrapper"]);
const useUtilityClasses$3 = (ownerState) => {
  const {
    classes,
    disabled,
    color: color2,
    edge,
    size,
    loading: loading2
  } = ownerState;
  const slots2 = {
    root: ["root", loading2 && "loading", disabled && "disabled", color2 !== "default" && `color${capitalize(color2)}`, edge && `edge${capitalize(edge)}`, `size${capitalize(size)}`],
    loadingIndicator: ["loadingIndicator"],
    loadingWrapper: ["loadingWrapper"]
  };
  return composeClasses(slots2, getIconButtonUtilityClass, classes);
};
const IconButtonRoot = styled(ButtonBase, {
  name: "MuiIconButton",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.loading && styles2.loading, ownerState.color !== "default" && styles2[`color${capitalize(ownerState.color)}`], ownerState.edge && styles2[`edge${capitalize(ownerState.edge)}`], styles2[`size${capitalize(ownerState.size)}`]];
  }
})(memoTheme(({
  theme
}) => ({
  textAlign: "center",
  flex: "0 0 auto",
  fontSize: theme.typography.pxToRem(24),
  padding: 8,
  borderRadius: "50%",
  color: (theme.vars || theme).palette.action.active,
  transition: theme.transitions.create("background-color", {
    duration: theme.transitions.duration.shortest
  }),
  variants: [{
    props: (props) => !props.disableRipple,
    style: {
      "--IconButton-hoverBg": theme.vars ? `rgba(${theme.vars.palette.action.activeChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.action.active, theme.palette.action.hoverOpacity),
      "&:hover": {
        backgroundColor: "var(--IconButton-hoverBg)",
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }
    }
  }, {
    props: {
      edge: "start"
    },
    style: {
      marginLeft: -12
    }
  }, {
    props: {
      edge: "start",
      size: "small"
    },
    style: {
      marginLeft: -3
    }
  }, {
    props: {
      edge: "end"
    },
    style: {
      marginRight: -12
    }
  }, {
    props: {
      edge: "end",
      size: "small"
    },
    style: {
      marginRight: -3
    }
  }]
})), memoTheme(({
  theme
}) => ({
  variants: [{
    props: {
      color: "inherit"
    },
    style: {
      color: "inherit"
    }
  }, ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      color: (theme.vars || theme).palette[color2].main
    }
  })), ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      "--IconButton-hoverBg": theme.vars ? `rgba(${(theme.vars || theme).palette[color2].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha((theme.vars || theme).palette[color2].main, theme.palette.action.hoverOpacity)
    }
  })), {
    props: {
      size: "small"
    },
    style: {
      padding: 5,
      fontSize: theme.typography.pxToRem(18)
    }
  }, {
    props: {
      size: "large"
    },
    style: {
      padding: 12,
      fontSize: theme.typography.pxToRem(28)
    }
  }],
  [`&.${iconButtonClasses.disabled}`]: {
    backgroundColor: "transparent",
    color: (theme.vars || theme).palette.action.disabled
  },
  [`&.${iconButtonClasses.loading}`]: {
    color: "transparent"
  }
})));
const IconButtonLoadingIndicator = styled("span", {
  name: "MuiIconButton",
  slot: "LoadingIndicator",
  overridesResolver: (props, styles2) => styles2.loadingIndicator
})(({
  theme
}) => ({
  display: "none",
  position: "absolute",
  visibility: "visible",
  top: "50%",
  left: "50%",
  transform: "translate(-50%, -50%)",
  color: (theme.vars || theme).palette.action.disabled,
  variants: [{
    props: {
      loading: true
    },
    style: {
      display: "flex"
    }
  }]
}));
const IconButton = /* @__PURE__ */ React.forwardRef(function IconButton2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiIconButton"
  });
  const {
    edge = false,
    children,
    className,
    color: color2 = "default",
    disabled = false,
    disableFocusRipple = false,
    size = "medium",
    id: idProp,
    loading: loading2 = null,
    loadingIndicator: loadingIndicatorProp,
    ...other
  } = props;
  const id = useId(idProp);
  const loadingIndicator = loadingIndicatorProp ?? /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, {
    "aria-labelledby": id,
    color: "inherit",
    size: 16
  });
  const ownerState = {
    ...props,
    edge,
    color: color2,
    disabled,
    disableFocusRipple,
    loading: loading2,
    loadingIndicator,
    size
  };
  const classes = useUtilityClasses$3(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IconButtonRoot, {
    id,
    className: clsx(classes.root, className),
    centerRipple: true,
    focusRipple: !disableFocusRipple,
    disabled: disabled || loading2,
    ref: ref2,
    ...other,
    ownerState,
    children: [typeof loading2 === "boolean" && // use plain HTML span to minimize the runtime overhead
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
      className: classes.loadingWrapper,
      style: {
        display: "contents"
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButtonLoadingIndicator, {
        className: classes.loadingIndicator,
        ownerState,
        children: loading2 && loadingIndicator
      })
    }), children]
  });
});
const SuccessOutlinedIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M20,12A8,8 0 0,1 12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4C12.76,4 13.5,4.11 14.2, 4.31L15.77,2.74C14.61,2.26 13.34,2 12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0, 0 22,12M7.91,10.08L6.5,11.5L11,16L21,6L19.59,4.58L11,13.17L7.91,10.08Z"
}), "SuccessOutlined");
const ReportProblemOutlinedIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 5.99L19.53 19H4.47L12 5.99M12 2L1 21h22L12 2zm1 14h-2v2h2v-2zm0-6h-2v4h2v-4z"
}), "ReportProblemOutlined");
const ErrorOutlineIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M11 15h2v2h-2zm0-8h2v6h-2zm.99-5C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
}), "ErrorOutline");
const InfoOutlinedIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M11,9H13V7H11M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20, 12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10, 10 0 0,0 12,2M11,17H13V11H11V17Z"
}), "InfoOutlined");
const ClearIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
}), "Close");
const useUtilityClasses$2 = (ownerState) => {
  const {
    variant,
    color: color2,
    severity,
    classes
  } = ownerState;
  const slots2 = {
    root: ["root", `color${capitalize(color2 || severity)}`, `${variant}${capitalize(color2 || severity)}`, `${variant}`],
    icon: ["icon"],
    message: ["message"],
    action: ["action"]
  };
  return composeClasses(slots2, getAlertUtilityClass, classes);
};
const AlertRoot = styled(Paper, {
  name: "MuiAlert",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], styles2[`${ownerState.variant}${capitalize(ownerState.color || ownerState.severity)}`]];
  }
})(memoTheme(({
  theme
}) => {
  const getColor = theme.palette.mode === "light" ? darken : lighten;
  const getBackgroundColor = theme.palette.mode === "light" ? lighten : darken;
  return {
    ...theme.typography.body2,
    backgroundColor: "transparent",
    display: "flex",
    padding: "6px 16px",
    variants: [...Object.entries(theme.palette).filter(createSimplePaletteValueFilter(["light"])).map(([color2]) => ({
      props: {
        colorSeverity: color2,
        variant: "standard"
      },
      style: {
        color: theme.vars ? theme.vars.palette.Alert[`${color2}Color`] : getColor(theme.palette[color2].light, 0.6),
        backgroundColor: theme.vars ? theme.vars.palette.Alert[`${color2}StandardBg`] : getBackgroundColor(theme.palette[color2].light, 0.9),
        [`& .${alertClasses.icon}`]: theme.vars ? {
          color: theme.vars.palette.Alert[`${color2}IconColor`]
        } : {
          color: theme.palette[color2].main
        }
      }
    })), ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter(["light"])).map(([color2]) => ({
      props: {
        colorSeverity: color2,
        variant: "outlined"
      },
      style: {
        color: theme.vars ? theme.vars.palette.Alert[`${color2}Color`] : getColor(theme.palette[color2].light, 0.6),
        border: `1px solid ${(theme.vars || theme).palette[color2].light}`,
        [`& .${alertClasses.icon}`]: theme.vars ? {
          color: theme.vars.palette.Alert[`${color2}IconColor`]
        } : {
          color: theme.palette[color2].main
        }
      }
    })), ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter(["dark"])).map(([color2]) => ({
      props: {
        colorSeverity: color2,
        variant: "filled"
      },
      style: {
        fontWeight: theme.typography.fontWeightMedium,
        ...theme.vars ? {
          color: theme.vars.palette.Alert[`${color2}FilledColor`],
          backgroundColor: theme.vars.palette.Alert[`${color2}FilledBg`]
        } : {
          backgroundColor: theme.palette.mode === "dark" ? theme.palette[color2].dark : theme.palette[color2].main,
          color: theme.palette.getContrastText(theme.palette[color2].main)
        }
      }
    }))]
  };
}));
const AlertIcon = styled("div", {
  name: "MuiAlert",
  slot: "Icon",
  overridesResolver: (props, styles2) => styles2.icon
})({
  marginRight: 12,
  padding: "7px 0",
  display: "flex",
  fontSize: 22,
  opacity: 0.9
});
const AlertMessage = styled("div", {
  name: "MuiAlert",
  slot: "Message",
  overridesResolver: (props, styles2) => styles2.message
})({
  padding: "8px 0",
  minWidth: 0,
  overflow: "auto"
});
const AlertAction = styled("div", {
  name: "MuiAlert",
  slot: "Action",
  overridesResolver: (props, styles2) => styles2.action
})({
  display: "flex",
  alignItems: "flex-start",
  padding: "4px 0 0 16px",
  marginLeft: "auto",
  marginRight: -8
});
const defaultIconMapping = {
  success: /* @__PURE__ */ jsxRuntimeExports.jsx(SuccessOutlinedIcon, {
    fontSize: "inherit"
  }),
  warning: /* @__PURE__ */ jsxRuntimeExports.jsx(ReportProblemOutlinedIcon, {
    fontSize: "inherit"
  }),
  error: /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorOutlineIcon, {
    fontSize: "inherit"
  }),
  info: /* @__PURE__ */ jsxRuntimeExports.jsx(InfoOutlinedIcon, {
    fontSize: "inherit"
  })
};
const Alert = /* @__PURE__ */ React.forwardRef(function Alert2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiAlert"
  });
  const {
    action,
    children,
    className,
    closeText: closeText2 = "Close",
    color: color2,
    components = {},
    componentsProps = {},
    icon,
    iconMapping = defaultIconMapping,
    onClose,
    role = "alert",
    severity = "success",
    slotProps = {},
    slots: slots2 = {},
    variant = "standard",
    ...other
  } = props;
  const ownerState = {
    ...props,
    color: color2,
    severity,
    variant,
    colorSeverity: color2 || severity
  };
  const classes = useUtilityClasses$2(ownerState);
  const externalForwardedProps = {
    slots: {
      closeButton: components.CloseButton,
      closeIcon: components.CloseIcon,
      ...slots2
    },
    slotProps: {
      ...componentsProps,
      ...slotProps
    }
  };
  const [RootSlot, rootSlotProps] = useSlot("root", {
    ref: ref2,
    shouldForwardComponentProp: true,
    className: clsx(classes.root, className),
    elementType: AlertRoot,
    externalForwardedProps: {
      ...externalForwardedProps,
      ...other
    },
    ownerState,
    additionalProps: {
      role,
      elevation: 0
    }
  });
  const [IconSlot, iconSlotProps] = useSlot("icon", {
    className: classes.icon,
    elementType: AlertIcon,
    externalForwardedProps,
    ownerState
  });
  const [MessageSlot, messageSlotProps] = useSlot("message", {
    className: classes.message,
    elementType: AlertMessage,
    externalForwardedProps,
    ownerState
  });
  const [ActionSlot, actionSlotProps] = useSlot("action", {
    className: classes.action,
    elementType: AlertAction,
    externalForwardedProps,
    ownerState
  });
  const [CloseButtonSlot, closeButtonProps] = useSlot("closeButton", {
    elementType: IconButton,
    externalForwardedProps,
    ownerState
  });
  const [CloseIconSlot, closeIconProps] = useSlot("closeIcon", {
    elementType: ClearIcon,
    externalForwardedProps,
    ownerState
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, {
    ...rootSlotProps,
    children: [icon !== false ? /* @__PURE__ */ jsxRuntimeExports.jsx(IconSlot, {
      ...iconSlotProps,
      children: icon || iconMapping[severity] || defaultIconMapping[severity]
    }) : null, /* @__PURE__ */ jsxRuntimeExports.jsx(MessageSlot, {
      ...messageSlotProps,
      children
    }), action != null ? /* @__PURE__ */ jsxRuntimeExports.jsx(ActionSlot, {
      ...actionSlotProps,
      children: action
    }) : null, action == null && onClose ? /* @__PURE__ */ jsxRuntimeExports.jsx(ActionSlot, {
      ...actionSlotProps,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseButtonSlot, {
        size: "small",
        "aria-label": closeText2,
        title: closeText2,
        color: "inherit",
        onClick: onClose,
        ...closeButtonProps,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIconSlot, {
          fontSize: "small",
          ...closeIconProps
        })
      })
    }) : null]
  });
});
function useBadge(parameters) {
  const {
    badgeContent: badgeContentProp,
    invisible: invisibleProp = false,
    max: maxProp = 99,
    showZero = false
  } = parameters;
  const prevProps = usePreviousProps({
    badgeContent: badgeContentProp,
    max: maxProp
  });
  let invisible = invisibleProp;
  if (invisibleProp === false && badgeContentProp === 0 && !showZero) {
    invisible = true;
  }
  const {
    badgeContent,
    max = maxProp
  } = invisible ? prevProps : parameters;
  const displayValue = badgeContent && Number(badgeContent) > max ? `${max}+` : badgeContent;
  return {
    badgeContent,
    invisible,
    max,
    displayValue
  };
}
function getBadgeUtilityClass(slot) {
  return generateUtilityClass("MuiBadge", slot);
}
const badgeClasses = generateUtilityClasses("MuiBadge", [
  "root",
  "badge",
  "dot",
  "standard",
  "anchorOriginTopRight",
  "anchorOriginBottomRight",
  "anchorOriginTopLeft",
  "anchorOriginBottomLeft",
  "invisible",
  "colorError",
  "colorInfo",
  "colorPrimary",
  "colorSecondary",
  "colorSuccess",
  "colorWarning",
  "overlapRectangular",
  "overlapCircular",
  // TODO: v6 remove the overlap value from these class keys
  "anchorOriginTopLeftCircular",
  "anchorOriginTopLeftRectangular",
  "anchorOriginTopRightCircular",
  "anchorOriginTopRightRectangular",
  "anchorOriginBottomLeftCircular",
  "anchorOriginBottomLeftRectangular",
  "anchorOriginBottomRightCircular",
  "anchorOriginBottomRightRectangular"
]);
const RADIUS_STANDARD = 10;
const RADIUS_DOT = 4;
const useUtilityClasses$1 = (ownerState) => {
  const {
    color: color2,
    anchorOrigin,
    invisible,
    overlap,
    variant,
    classes = {}
  } = ownerState;
  const slots2 = {
    root: ["root"],
    badge: ["badge", variant, invisible && "invisible", `anchorOrigin${capitalize(anchorOrigin.vertical)}${capitalize(anchorOrigin.horizontal)}`, `anchorOrigin${capitalize(anchorOrigin.vertical)}${capitalize(anchorOrigin.horizontal)}${capitalize(overlap)}`, `overlap${capitalize(overlap)}`, color2 !== "default" && `color${capitalize(color2)}`]
  };
  return composeClasses(slots2, getBadgeUtilityClass, classes);
};
const BadgeRoot = styled("span", {
  name: "MuiBadge",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  position: "relative",
  display: "inline-flex",
  // For correct alignment with the text.
  verticalAlign: "middle",
  flexShrink: 0
});
const BadgeBadge = styled("span", {
  name: "MuiBadge",
  slot: "Badge",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.badge, styles2[ownerState.variant], styles2[`anchorOrigin${capitalize(ownerState.anchorOrigin.vertical)}${capitalize(ownerState.anchorOrigin.horizontal)}${capitalize(ownerState.overlap)}`], ownerState.color !== "default" && styles2[`color${capitalize(ownerState.color)}`], ownerState.invisible && styles2.invisible];
  }
})(memoTheme(({
  theme
}) => ({
  display: "flex",
  flexDirection: "row",
  flexWrap: "wrap",
  justifyContent: "center",
  alignContent: "center",
  alignItems: "center",
  position: "absolute",
  boxSizing: "border-box",
  fontFamily: theme.typography.fontFamily,
  fontWeight: theme.typography.fontWeightMedium,
  fontSize: theme.typography.pxToRem(12),
  minWidth: RADIUS_STANDARD * 2,
  lineHeight: 1,
  padding: "0 6px",
  height: RADIUS_STANDARD * 2,
  borderRadius: RADIUS_STANDARD,
  zIndex: 1,
  // Render the badge on top of potential ripples.
  transition: theme.transitions.create("transform", {
    easing: theme.transitions.easing.easeInOut,
    duration: theme.transitions.duration.enteringScreen
  }),
  variants: [...Object.entries(theme.palette).filter(createSimplePaletteValueFilter(["contrastText"])).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      backgroundColor: (theme.vars || theme).palette[color2].main,
      color: (theme.vars || theme).palette[color2].contrastText
    }
  })), {
    props: {
      variant: "dot"
    },
    style: {
      borderRadius: RADIUS_DOT,
      height: RADIUS_DOT * 2,
      minWidth: RADIUS_DOT * 2,
      padding: 0
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.vertical === "top" && ownerState.anchorOrigin.horizontal === "right" && ownerState.overlap === "rectangular",
    style: {
      top: 0,
      right: 0,
      transform: "scale(1) translate(50%, -50%)",
      transformOrigin: "100% 0%",
      [`&.${badgeClasses.invisible}`]: {
        transform: "scale(0) translate(50%, -50%)"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.vertical === "bottom" && ownerState.anchorOrigin.horizontal === "right" && ownerState.overlap === "rectangular",
    style: {
      bottom: 0,
      right: 0,
      transform: "scale(1) translate(50%, 50%)",
      transformOrigin: "100% 100%",
      [`&.${badgeClasses.invisible}`]: {
        transform: "scale(0) translate(50%, 50%)"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.vertical === "top" && ownerState.anchorOrigin.horizontal === "left" && ownerState.overlap === "rectangular",
    style: {
      top: 0,
      left: 0,
      transform: "scale(1) translate(-50%, -50%)",
      transformOrigin: "0% 0%",
      [`&.${badgeClasses.invisible}`]: {
        transform: "scale(0) translate(-50%, -50%)"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.vertical === "bottom" && ownerState.anchorOrigin.horizontal === "left" && ownerState.overlap === "rectangular",
    style: {
      bottom: 0,
      left: 0,
      transform: "scale(1) translate(-50%, 50%)",
      transformOrigin: "0% 100%",
      [`&.${badgeClasses.invisible}`]: {
        transform: "scale(0) translate(-50%, 50%)"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.vertical === "top" && ownerState.anchorOrigin.horizontal === "right" && ownerState.overlap === "circular",
    style: {
      top: "14%",
      right: "14%",
      transform: "scale(1) translate(50%, -50%)",
      transformOrigin: "100% 0%",
      [`&.${badgeClasses.invisible}`]: {
        transform: "scale(0) translate(50%, -50%)"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.vertical === "bottom" && ownerState.anchorOrigin.horizontal === "right" && ownerState.overlap === "circular",
    style: {
      bottom: "14%",
      right: "14%",
      transform: "scale(1) translate(50%, 50%)",
      transformOrigin: "100% 100%",
      [`&.${badgeClasses.invisible}`]: {
        transform: "scale(0) translate(50%, 50%)"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.vertical === "top" && ownerState.anchorOrigin.horizontal === "left" && ownerState.overlap === "circular",
    style: {
      top: "14%",
      left: "14%",
      transform: "scale(1) translate(-50%, -50%)",
      transformOrigin: "0% 0%",
      [`&.${badgeClasses.invisible}`]: {
        transform: "scale(0) translate(-50%, -50%)"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.vertical === "bottom" && ownerState.anchorOrigin.horizontal === "left" && ownerState.overlap === "circular",
    style: {
      bottom: "14%",
      left: "14%",
      transform: "scale(1) translate(-50%, 50%)",
      transformOrigin: "0% 100%",
      [`&.${badgeClasses.invisible}`]: {
        transform: "scale(0) translate(-50%, 50%)"
      }
    }
  }, {
    props: {
      invisible: true
    },
    style: {
      transition: theme.transitions.create("transform", {
        easing: theme.transitions.easing.easeInOut,
        duration: theme.transitions.duration.leavingScreen
      })
    }
  }]
})));
function getAnchorOrigin(anchorOrigin) {
  return {
    vertical: (anchorOrigin == null ? void 0 : anchorOrigin.vertical) ?? "top",
    horizontal: (anchorOrigin == null ? void 0 : anchorOrigin.horizontal) ?? "right"
  };
}
const Badge$1 = /* @__PURE__ */ React.forwardRef(function Badge2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiBadge"
  });
  const {
    anchorOrigin: anchorOriginProp,
    className,
    classes: classesProp,
    component,
    components = {},
    componentsProps = {},
    children,
    overlap: overlapProp = "rectangular",
    color: colorProp = "default",
    invisible: invisibleProp = false,
    max: maxProp = 99,
    badgeContent: badgeContentProp,
    slots: slots2,
    slotProps,
    showZero = false,
    variant: variantProp = "standard",
    ...other
  } = props;
  const {
    badgeContent,
    invisible: invisibleFromHook,
    max,
    displayValue: displayValueFromHook
  } = useBadge({
    max: maxProp,
    invisible: invisibleProp,
    badgeContent: badgeContentProp,
    showZero
  });
  const prevProps = usePreviousProps({
    anchorOrigin: getAnchorOrigin(anchorOriginProp),
    color: colorProp,
    overlap: overlapProp,
    variant: variantProp,
    badgeContent: badgeContentProp
  });
  const invisible = invisibleFromHook || badgeContent == null && variantProp !== "dot";
  const {
    color: color2 = colorProp,
    overlap = overlapProp,
    anchorOrigin: anchorOriginPropProp,
    variant = variantProp
  } = invisible ? prevProps : props;
  const anchorOrigin = getAnchorOrigin(anchorOriginPropProp);
  const displayValue = variant !== "dot" ? displayValueFromHook : void 0;
  const ownerState = {
    ...props,
    badgeContent,
    invisible,
    max,
    displayValue,
    showZero,
    anchorOrigin,
    color: color2,
    overlap,
    variant
  };
  const classes = useUtilityClasses$1(ownerState);
  const RootSlot = (slots2 == null ? void 0 : slots2.root) ?? components.Root ?? BadgeRoot;
  const BadgeSlot = (slots2 == null ? void 0 : slots2.badge) ?? components.Badge ?? BadgeBadge;
  const rootSlotProps = (slotProps == null ? void 0 : slotProps.root) ?? componentsProps.root;
  const badgeSlotProps = (slotProps == null ? void 0 : slotProps.badge) ?? componentsProps.badge;
  const rootProps = useSlotProps$1({
    elementType: RootSlot,
    externalSlotProps: rootSlotProps,
    externalForwardedProps: other,
    additionalProps: {
      ref: ref2,
      as: component
    },
    ownerState,
    className: clsx(rootSlotProps == null ? void 0 : rootSlotProps.className, classes.root, className)
  });
  const badgeProps = useSlotProps$1({
    elementType: BadgeSlot,
    externalSlotProps: badgeSlotProps,
    ownerState,
    className: clsx(classes.badge, badgeSlotProps == null ? void 0 : badgeSlotProps.className)
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, {
    ...rootProps,
    children: [children, /* @__PURE__ */ jsxRuntimeExports.jsx(BadgeSlot, {
      ...badgeProps,
      children: displayValue
    })]
  });
});
function getButtonUtilityClass(slot) {
  return generateUtilityClass("MuiButton", slot);
}
const buttonClasses = generateUtilityClasses("MuiButton", ["root", "text", "textInherit", "textPrimary", "textSecondary", "textSuccess", "textError", "textInfo", "textWarning", "outlined", "outlinedInherit", "outlinedPrimary", "outlinedSecondary", "outlinedSuccess", "outlinedError", "outlinedInfo", "outlinedWarning", "contained", "containedInherit", "containedPrimary", "containedSecondary", "containedSuccess", "containedError", "containedInfo", "containedWarning", "disableElevation", "focusVisible", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorSuccess", "colorError", "colorInfo", "colorWarning", "textSizeSmall", "textSizeMedium", "textSizeLarge", "outlinedSizeSmall", "outlinedSizeMedium", "outlinedSizeLarge", "containedSizeSmall", "containedSizeMedium", "containedSizeLarge", "sizeMedium", "sizeSmall", "sizeLarge", "fullWidth", "startIcon", "endIcon", "icon", "iconSizeSmall", "iconSizeMedium", "iconSizeLarge", "loading", "loadingWrapper", "loadingIconPlaceholder", "loadingIndicator", "loadingPositionCenter", "loadingPositionStart", "loadingPositionEnd"]);
const ButtonGroupContext = /* @__PURE__ */ React.createContext({});
const ButtonGroupButtonContext = /* @__PURE__ */ React.createContext(void 0);
const useUtilityClasses = (ownerState) => {
  const {
    color: color2,
    disableElevation,
    fullWidth,
    size,
    variant,
    loading: loading2,
    loadingPosition,
    classes
  } = ownerState;
  const slots2 = {
    root: ["root", loading2 && "loading", variant, `${variant}${capitalize(color2)}`, `size${capitalize(size)}`, `${variant}Size${capitalize(size)}`, `color${capitalize(color2)}`, disableElevation && "disableElevation", fullWidth && "fullWidth", loading2 && `loadingPosition${capitalize(loadingPosition)}`],
    startIcon: ["icon", "startIcon", `iconSize${capitalize(size)}`],
    endIcon: ["icon", "endIcon", `iconSize${capitalize(size)}`],
    loadingIndicator: ["loadingIndicator"],
    loadingWrapper: ["loadingWrapper"]
  };
  const composedClasses = composeClasses(slots2, getButtonUtilityClass, classes);
  return {
    ...classes,
    // forward the focused, disabled, etc. classes to the ButtonBase
    ...composedClasses
  };
};
const commonIconStyles = [{
  props: {
    size: "small"
  },
  style: {
    "& > *:nth-of-type(1)": {
      fontSize: 18
    }
  }
}, {
  props: {
    size: "medium"
  },
  style: {
    "& > *:nth-of-type(1)": {
      fontSize: 20
    }
  }
}, {
  props: {
    size: "large"
  },
  style: {
    "& > *:nth-of-type(1)": {
      fontSize: 22
    }
  }
}];
const ButtonRoot = styled(ButtonBase, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiButton",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], styles2[`${ownerState.variant}${capitalize(ownerState.color)}`], styles2[`size${capitalize(ownerState.size)}`], styles2[`${ownerState.variant}Size${capitalize(ownerState.size)}`], ownerState.color === "inherit" && styles2.colorInherit, ownerState.disableElevation && styles2.disableElevation, ownerState.fullWidth && styles2.fullWidth, ownerState.loading && styles2.loading];
  }
})(memoTheme(({
  theme
}) => {
  const inheritContainedBackgroundColor = theme.palette.mode === "light" ? theme.palette.grey[300] : theme.palette.grey[800];
  const inheritContainedHoverBackgroundColor = theme.palette.mode === "light" ? theme.palette.grey.A100 : theme.palette.grey[700];
  return {
    ...theme.typography.button,
    minWidth: 64,
    padding: "6px 16px",
    border: 0,
    borderRadius: (theme.vars || theme).shape.borderRadius,
    transition: theme.transitions.create(["background-color", "box-shadow", "border-color", "color"], {
      duration: theme.transitions.duration.short
    }),
    "&:hover": {
      textDecoration: "none"
    },
    [`&.${buttonClasses.disabled}`]: {
      color: (theme.vars || theme).palette.action.disabled
    },
    variants: [{
      props: {
        variant: "contained"
      },
      style: {
        color: `var(--variant-containedColor)`,
        backgroundColor: `var(--variant-containedBg)`,
        boxShadow: (theme.vars || theme).shadows[2],
        "&:hover": {
          boxShadow: (theme.vars || theme).shadows[4],
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            boxShadow: (theme.vars || theme).shadows[2]
          }
        },
        "&:active": {
          boxShadow: (theme.vars || theme).shadows[8]
        },
        [`&.${buttonClasses.focusVisible}`]: {
          boxShadow: (theme.vars || theme).shadows[6]
        },
        [`&.${buttonClasses.disabled}`]: {
          color: (theme.vars || theme).palette.action.disabled,
          boxShadow: (theme.vars || theme).shadows[0],
          backgroundColor: (theme.vars || theme).palette.action.disabledBackground
        }
      }
    }, {
      props: {
        variant: "outlined"
      },
      style: {
        padding: "5px 15px",
        border: "1px solid currentColor",
        borderColor: `var(--variant-outlinedBorder, currentColor)`,
        backgroundColor: `var(--variant-outlinedBg)`,
        color: `var(--variant-outlinedColor)`,
        [`&.${buttonClasses.disabled}`]: {
          border: `1px solid ${(theme.vars || theme).palette.action.disabledBackground}`
        }
      }
    }, {
      props: {
        variant: "text"
      },
      style: {
        padding: "6px 8px",
        color: `var(--variant-textColor)`,
        backgroundColor: `var(--variant-textBg)`
      }
    }, ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
      props: {
        color: color2
      },
      style: {
        "--variant-textColor": (theme.vars || theme).palette[color2].main,
        "--variant-outlinedColor": (theme.vars || theme).palette[color2].main,
        "--variant-outlinedBorder": theme.vars ? `rgba(${theme.vars.palette[color2].mainChannel} / 0.5)` : alpha(theme.palette[color2].main, 0.5),
        "--variant-containedColor": (theme.vars || theme).palette[color2].contrastText,
        "--variant-containedBg": (theme.vars || theme).palette[color2].main,
        "@media (hover: hover)": {
          "&:hover": {
            "--variant-containedBg": (theme.vars || theme).palette[color2].dark,
            "--variant-textBg": theme.vars ? `rgba(${theme.vars.palette[color2].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette[color2].main, theme.palette.action.hoverOpacity),
            "--variant-outlinedBorder": (theme.vars || theme).palette[color2].main,
            "--variant-outlinedBg": theme.vars ? `rgba(${theme.vars.palette[color2].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette[color2].main, theme.palette.action.hoverOpacity)
          }
        }
      }
    })), {
      props: {
        color: "inherit"
      },
      style: {
        color: "inherit",
        borderColor: "currentColor",
        "--variant-containedBg": theme.vars ? theme.vars.palette.Button.inheritContainedBg : inheritContainedBackgroundColor,
        "@media (hover: hover)": {
          "&:hover": {
            "--variant-containedBg": theme.vars ? theme.vars.palette.Button.inheritContainedHoverBg : inheritContainedHoverBackgroundColor,
            "--variant-textBg": theme.vars ? `rgba(${theme.vars.palette.text.primaryChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.text.primary, theme.palette.action.hoverOpacity),
            "--variant-outlinedBg": theme.vars ? `rgba(${theme.vars.palette.text.primaryChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.text.primary, theme.palette.action.hoverOpacity)
          }
        }
      }
    }, {
      props: {
        size: "small",
        variant: "text"
      },
      style: {
        padding: "4px 5px",
        fontSize: theme.typography.pxToRem(13)
      }
    }, {
      props: {
        size: "large",
        variant: "text"
      },
      style: {
        padding: "8px 11px",
        fontSize: theme.typography.pxToRem(15)
      }
    }, {
      props: {
        size: "small",
        variant: "outlined"
      },
      style: {
        padding: "3px 9px",
        fontSize: theme.typography.pxToRem(13)
      }
    }, {
      props: {
        size: "large",
        variant: "outlined"
      },
      style: {
        padding: "7px 21px",
        fontSize: theme.typography.pxToRem(15)
      }
    }, {
      props: {
        size: "small",
        variant: "contained"
      },
      style: {
        padding: "4px 10px",
        fontSize: theme.typography.pxToRem(13)
      }
    }, {
      props: {
        size: "large",
        variant: "contained"
      },
      style: {
        padding: "8px 22px",
        fontSize: theme.typography.pxToRem(15)
      }
    }, {
      props: {
        disableElevation: true
      },
      style: {
        boxShadow: "none",
        "&:hover": {
          boxShadow: "none"
        },
        [`&.${buttonClasses.focusVisible}`]: {
          boxShadow: "none"
        },
        "&:active": {
          boxShadow: "none"
        },
        [`&.${buttonClasses.disabled}`]: {
          boxShadow: "none"
        }
      }
    }, {
      props: {
        fullWidth: true
      },
      style: {
        width: "100%"
      }
    }, {
      props: {
        loadingPosition: "center"
      },
      style: {
        transition: theme.transitions.create(["background-color", "box-shadow", "border-color"], {
          duration: theme.transitions.duration.short
        }),
        [`&.${buttonClasses.loading}`]: {
          color: "transparent"
        }
      }
    }]
  };
}));
const ButtonStartIcon = styled("span", {
  name: "MuiButton",
  slot: "StartIcon",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.startIcon, ownerState.loading && styles2.startIconLoadingStart, styles2[`iconSize${capitalize(ownerState.size)}`]];
  }
})(({
  theme
}) => ({
  display: "inherit",
  marginRight: 8,
  marginLeft: -4,
  variants: [{
    props: {
      size: "small"
    },
    style: {
      marginLeft: -2
    }
  }, {
    props: {
      loadingPosition: "start",
      loading: true
    },
    style: {
      transition: theme.transitions.create(["opacity"], {
        duration: theme.transitions.duration.short
      }),
      opacity: 0
    }
  }, {
    props: {
      loadingPosition: "start",
      loading: true,
      fullWidth: true
    },
    style: {
      marginRight: -8
    }
  }, ...commonIconStyles]
}));
const ButtonEndIcon = styled("span", {
  name: "MuiButton",
  slot: "EndIcon",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.endIcon, ownerState.loading && styles2.endIconLoadingEnd, styles2[`iconSize${capitalize(ownerState.size)}`]];
  }
})(({
  theme
}) => ({
  display: "inherit",
  marginRight: -4,
  marginLeft: 8,
  variants: [{
    props: {
      size: "small"
    },
    style: {
      marginRight: -2
    }
  }, {
    props: {
      loadingPosition: "end",
      loading: true
    },
    style: {
      transition: theme.transitions.create(["opacity"], {
        duration: theme.transitions.duration.short
      }),
      opacity: 0
    }
  }, {
    props: {
      loadingPosition: "end",
      loading: true,
      fullWidth: true
    },
    style: {
      marginLeft: -8
    }
  }, ...commonIconStyles]
}));
const ButtonLoadingIndicator = styled("span", {
  name: "MuiButton",
  slot: "LoadingIndicator",
  overridesResolver: (props, styles2) => styles2.loadingIndicator
})(({
  theme
}) => ({
  display: "none",
  position: "absolute",
  visibility: "visible",
  variants: [{
    props: {
      loading: true
    },
    style: {
      display: "flex"
    }
  }, {
    props: {
      loadingPosition: "start"
    },
    style: {
      left: 14
    }
  }, {
    props: {
      loadingPosition: "start",
      size: "small"
    },
    style: {
      left: 10
    }
  }, {
    props: {
      variant: "text",
      loadingPosition: "start"
    },
    style: {
      left: 6
    }
  }, {
    props: {
      loadingPosition: "center"
    },
    style: {
      left: "50%",
      transform: "translate(-50%)",
      color: (theme.vars || theme).palette.action.disabled
    }
  }, {
    props: {
      loadingPosition: "end"
    },
    style: {
      right: 14
    }
  }, {
    props: {
      loadingPosition: "end",
      size: "small"
    },
    style: {
      right: 10
    }
  }, {
    props: {
      variant: "text",
      loadingPosition: "end"
    },
    style: {
      right: 6
    }
  }, {
    props: {
      loadingPosition: "start",
      fullWidth: true
    },
    style: {
      position: "relative",
      left: -10
    }
  }, {
    props: {
      loadingPosition: "end",
      fullWidth: true
    },
    style: {
      position: "relative",
      right: -10
    }
  }]
}));
const ButtonLoadingIconPlaceholder = styled("span", {
  name: "MuiButton",
  slot: "LoadingIconPlaceholder",
  overridesResolver: (props, styles2) => styles2.loadingIconPlaceholder
})({
  display: "inline-block",
  width: "1em",
  height: "1em"
});
const Button = /* @__PURE__ */ React.forwardRef(function Button2(inProps, ref2) {
  const contextProps = React.useContext(ButtonGroupContext);
  const buttonGroupButtonContextPositionClassName = React.useContext(ButtonGroupButtonContext);
  const resolvedProps = resolveProps(contextProps, inProps);
  const props = useDefaultProps({
    props: resolvedProps,
    name: "MuiButton"
  });
  const {
    children,
    color: color2 = "primary",
    component = "button",
    className,
    disabled = false,
    disableElevation = false,
    disableFocusRipple = false,
    endIcon: endIconProp,
    focusVisibleClassName,
    fullWidth = false,
    id: idProp,
    loading: loading2 = null,
    loadingIndicator: loadingIndicatorProp,
    loadingPosition = "center",
    size = "medium",
    startIcon: startIconProp,
    type,
    variant = "text",
    ...other
  } = props;
  const id = useId(idProp);
  const loadingIndicator = loadingIndicatorProp ?? /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, {
    "aria-labelledby": id,
    color: "inherit",
    size: 16
  });
  const ownerState = {
    ...props,
    color: color2,
    component,
    disabled,
    disableElevation,
    disableFocusRipple,
    fullWidth,
    loading: loading2,
    loadingIndicator,
    loadingPosition,
    size,
    type,
    variant
  };
  const classes = useUtilityClasses(ownerState);
  const startIcon = (startIconProp || loading2 && loadingPosition === "start") && /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonStartIcon, {
    className: classes.startIcon,
    ownerState,
    children: startIconProp || /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonLoadingIconPlaceholder, {
      className: classes.loadingIconPlaceholder,
      ownerState
    })
  });
  const endIcon = (endIconProp || loading2 && loadingPosition === "end") && /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonEndIcon, {
    className: classes.endIcon,
    ownerState,
    children: endIconProp || /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonLoadingIconPlaceholder, {
      className: classes.loadingIconPlaceholder,
      ownerState
    })
  });
  const positionClassName = buttonGroupButtonContextPositionClassName || "";
  const loader = typeof loading2 === "boolean" ? (
    // use plain HTML span to minimize the runtime overhead
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
      className: classes.loadingWrapper,
      style: {
        display: "contents"
      },
      children: loading2 && /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonLoadingIndicator, {
        className: classes.loadingIndicator,
        ownerState,
        children: loadingIndicator
      })
    })
  ) : null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ButtonRoot, {
    ownerState,
    className: clsx(contextProps.className, classes.root, className, positionClassName),
    component,
    disabled: disabled || loading2,
    focusRipple: !disableFocusRipple,
    focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),
    ref: ref2,
    type,
    id,
    ...other,
    classes,
    children: [startIcon, loadingPosition !== "end" && loader, children, loadingPosition === "end" && loader, endIcon]
  });
});
const CloseIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
}), "Close");
function useNonNullableContext(context, name) {
  const maybeContext = React.useContext(context);
  if (maybeContext === null || maybeContext === void 0) {
    throw new Error(`context "${name}" was used without a Provider`);
  }
  return maybeContext;
}
function setRef(ref2, value) {
  if (typeof ref2 === "function") {
    ref2(value);
  } else if (ref2) {
    ref2.current = value;
  }
}
function useForkRef(...refs) {
  return React.useMemo(() => {
    if (refs.every((ref2) => ref2 == null)) {
      return null;
    }
    return (instance) => {
      refs.forEach((ref2) => {
        setRef(ref2, instance);
      });
    };
  }, refs);
}
function isHostComponent(element) {
  return typeof element === "string";
}
function appendOwnerState(elementType, otherProps, ownerState) {
  if (elementType === void 0 || isHostComponent(elementType)) {
    return otherProps;
  }
  return {
    ...otherProps,
    ownerState: {
      ...otherProps.ownerState,
      ...ownerState
    }
  };
}
function extractEventHandlers(object, excludeKeys = []) {
  if (object === void 0) {
    return {};
  }
  const result = {};
  Object.keys(object).filter((prop) => prop.match(/^on[A-Z]/) && typeof object[prop] === "function" && !excludeKeys.includes(prop)).forEach((prop) => {
    result[prop] = object[prop];
  });
  return result;
}
function omitEventHandlers(object) {
  if (object === void 0) {
    return {};
  }
  const result = {};
  Object.keys(object).filter((prop) => !(prop.match(/^on[A-Z]/) && typeof object[prop] === "function")).forEach((prop) => {
    result[prop] = object[prop];
  });
  return result;
}
function mergeSlotProps(parameters) {
  const {
    getSlotProps,
    additionalProps,
    externalSlotProps,
    externalForwardedProps,
    className
  } = parameters;
  if (!getSlotProps) {
    const joinedClasses2 = clsx(additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
    const mergedStyle2 = {
      ...additionalProps == null ? void 0 : additionalProps.style,
      ...externalForwardedProps == null ? void 0 : externalForwardedProps.style,
      ...externalSlotProps == null ? void 0 : externalSlotProps.style
    };
    const props2 = {
      ...additionalProps,
      ...externalForwardedProps,
      ...externalSlotProps
    };
    if (joinedClasses2.length > 0) {
      props2.className = joinedClasses2;
    }
    if (Object.keys(mergedStyle2).length > 0) {
      props2.style = mergedStyle2;
    }
    return {
      props: props2,
      internalRef: void 0
    };
  }
  const eventHandlers = extractEventHandlers({
    ...externalForwardedProps,
    ...externalSlotProps
  });
  const componentsPropsWithoutEventHandlers = omitEventHandlers(externalSlotProps);
  const otherPropsWithoutEventHandlers = omitEventHandlers(externalForwardedProps);
  const internalSlotProps = getSlotProps(eventHandlers);
  const joinedClasses = clsx(internalSlotProps == null ? void 0 : internalSlotProps.className, additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
  const mergedStyle = {
    ...internalSlotProps == null ? void 0 : internalSlotProps.style,
    ...additionalProps == null ? void 0 : additionalProps.style,
    ...externalForwardedProps == null ? void 0 : externalForwardedProps.style,
    ...externalSlotProps == null ? void 0 : externalSlotProps.style
  };
  const props = {
    ...internalSlotProps,
    ...additionalProps,
    ...otherPropsWithoutEventHandlers,
    ...componentsPropsWithoutEventHandlers
  };
  if (joinedClasses.length > 0) {
    props.className = joinedClasses;
  }
  if (Object.keys(mergedStyle).length > 0) {
    props.style = mergedStyle;
  }
  return {
    props,
    internalRef: internalSlotProps.ref
  };
}
function resolveComponentProps(componentProps, ownerState, slotState) {
  if (typeof componentProps === "function") {
    return componentProps(ownerState, slotState);
  }
  return componentProps;
}
function useSlotProps(parameters) {
  var _a2;
  const {
    elementType,
    externalSlotProps,
    ownerState,
    skipResolvingSlotProps = false,
    ...other
  } = parameters;
  const resolvedComponentsProps = skipResolvingSlotProps ? {} : resolveComponentProps(externalSlotProps, ownerState);
  const {
    props: mergedProps,
    internalRef
  } = mergeSlotProps({
    ...other,
    externalSlotProps: resolvedComponentsProps
  });
  const ref2 = useForkRef(internalRef, resolvedComponentsProps == null ? void 0 : resolvedComponentsProps.ref, (_a2 = parameters.additionalProps) == null ? void 0 : _a2.ref);
  const props = appendOwnerState(elementType, {
    ...mergedProps,
    ref: ref2
  }, ownerState);
  return props;
}
var _CloseIcon;
const closeText = "Close";
const RootPropsContext = /* @__PURE__ */ React.createContext(null);
function Notification({
  notificationKey,
  open,
  message: message2,
  options,
  badge
}) {
  var _a2, _b;
  const {
    close: close2
  } = useNonNullableContext(NotificationsContext);
  const {
    severity,
    actionText,
    onAction,
    autoHideDuration
  } = options;
  const handleClose = React.useCallback((event, reason) => {
    if (reason === "clickaway") {
      return;
    }
    close2(notificationKey);
  }, [notificationKey, close2]);
  const action = /* @__PURE__ */ jsxRuntimeExports.jsxs(React.Fragment, {
    children: [onAction ? /* @__PURE__ */ jsxRuntimeExports.jsx(Button, {
      color: "inherit",
      size: "small",
      onClick: onAction,
      children: actionText ?? "Action"
    }) : null, /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, {
      size: "small",
      "aria-label": closeText,
      title: closeText,
      color: "inherit",
      onClick: handleClose,
      children: _CloseIcon || (_CloseIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIcon, {
        fontSize: "small"
      }))
    })]
  });
  const props = React.useContext(RootPropsContext);
  const SnackbarComponent = ((_a2 = props == null ? void 0 : props.slots) == null ? void 0 : _a2.snackbar) ?? Snackbar;
  const snackbarSlotProps = useSlotProps({
    elementType: SnackbarComponent,
    ownerState: props,
    externalSlotProps: (_b = props == null ? void 0 : props.slotProps) == null ? void 0 : _b.snackbar,
    additionalProps: {
      open,
      autoHideDuration,
      onClose: handleClose,
      action
    }
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SnackbarComponent, {
    ...snackbarSlotProps,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Badge$1, {
      badgeContent: badge,
      color: "primary",
      sx: {
        width: "100%"
      },
      children: severity ? /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, {
        severity,
        sx: {
          width: "100%"
        },
        action,
        children: message2
      }) : /* @__PURE__ */ jsxRuntimeExports.jsx(SnackbarContent, {
        message: message2,
        action
      })
    })
  }, notificationKey);
}
function Notifications({
  state: state2
}) {
  const currentNotification = state2.queue[0] ?? null;
  return currentNotification ? /* @__PURE__ */ jsxRuntimeExports.jsx(Notification, {
    ...currentNotification,
    badge: state2.queue.length > 1 ? String(state2.queue.length) : null
  }) : null;
}
let nextId = 0;
const generateId = () => {
  const id = nextId;
  nextId += 1;
  return id;
};
function NotificationsProvider(props) {
  const {
    children
  } = props;
  const [state2, setState] = React.useState({
    queue: []
  });
  const show = React.useCallback((message2, options = {}) => {
    const notificationKey = options.key ?? `::toolpad-internal::notification::${generateId()}`;
    setState((prev2) => {
      if (prev2.queue.some((n) => n.notificationKey === notificationKey)) {
        return prev2;
      }
      return {
        ...prev2,
        queue: [...prev2.queue, {
          message: message2,
          options,
          notificationKey,
          open: true
        }]
      };
    });
    return notificationKey;
  }, []);
  const close2 = React.useCallback((key) => {
    setState((prev2) => ({
      ...prev2,
      queue: prev2.queue.filter((n) => n.notificationKey !== key)
    }));
  }, []);
  const contextValue = React.useMemo(() => ({
    show,
    close: close2
  }), [show, close2]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RootPropsContext.Provider, {
    value: props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(NotificationsContext.Provider, {
      value: contextValue,
      children: [children, /* @__PURE__ */ jsxRuntimeExports.jsx(Notifications, {
        state: state2
      })]
    })
  });
}
const NotificationContext = ({ children }) => {
  const notifications = useNotifications();
  useEffect(() => {
    setNotification(notifications);
    return () => {
      setNotification({ show: null, close: null });
    };
  }, [notifications]);
  return children;
};
const slots = {
  snackbar: styled(Snackbar)({
    position: "absolute"
  })
};
const NotificationProvider = ({ children }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(NotificationsProvider, { slots, slotProps: {
    snackbar: {
      anchorOrigin: {
        vertical: "top",
        horizontal: "right"
      }
    }
  }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(NotificationContext, { children }) });
};
const minSize = {
  width: 400,
  height: 300
};
function Conversation({
  headerProps,
  messagesProps,
  senderProps,
  quickButtonsProps,
  filePickerProps,
  className,
  sendMessage: sendMessage2,
  resizable,
  resizableProps = {
    heightOffset: 105,
    widthOffset: 35
  },
  defaultSize = minSize,
  onResize: onResize2,
  emojis: emojis2,
  files,
  reply,
  reaction,
  disabledInput: propDisabledInput,
  copyright
}) {
  const containerDivRef = useRef(null);
  const boundResizeRef = useRef(() => {
  });
  const startXRef = useRef(0);
  const startYRef = useRef(0);
  const startWidthRef = useRef(0);
  const startHeightRef = useRef(0);
  const [fileItems, setFileItems] = useState([]);
  const addFileRef = useRef(() => void 0);
  const disableInput = useSelector(({ behavior }) => behavior.disabledInput);
  const { replyMessage } = useSelector(({ messages }) => ({
    replyMessage: messages.replyMessage
  }));
  useEffect(() => {
    containerDivRef.current = document.getElementById("rcw-conversation-container");
  }, []);
  const setSize = useCallback(
    (newWidth, newHeight) => {
      if (containerDivRef.current) {
        const width2 = Math.min(
          Math.max(newWidth, minSize.width),
          Math.round((resizableProps == null ? void 0 : resizableProps.widthOffset) ? window.innerWidth - resizableProps.widthOffset : window.innerWidth - 35)
        );
        const height2 = Math.min(
          Math.max(newHeight, minSize.height),
          Math.round((resizableProps == null ? void 0 : resizableProps.heightOffset) ? window.innerHeight - resizableProps.heightOffset : window.innerHeight - 105)
        );
        onResize2 == null ? void 0 : onResize2(width2, height2);
        containerDivRef.current.style.width = width2 + "px";
        containerDivRef.current.style.height = height2 + "px";
      }
    },
    [containerDivRef, resizableProps, onResize2]
    // Dependencies
  );
  useEffect(() => {
    resizable && setSize(defaultSize.width, defaultSize.height);
  }, [defaultSize, resizable, setSize]);
  const initResize = (e) => {
    if (resizable) {
      const resizerType = e.currentTarget.getAttribute("data-resizer");
      startXRef.current = e.clientX;
      startYRef.current = e.clientY;
      if (document.defaultView && containerDivRef.current) {
        startWidthRef.current = parseInt(document.defaultView.getComputedStyle(containerDivRef.current).width);
        startHeightRef.current = parseInt(document.defaultView.getComputedStyle(containerDivRef.current).height);
        boundResizeRef.current = (event) => resize(event, resizerType);
        window.addEventListener("mousemove", boundResizeRef.current, false);
        window.addEventListener("mouseup", stopResize, false);
      }
    }
  };
  const resize = (e, resizerType) => {
    if (containerDivRef.current) {
      let newWidth = startWidthRef.current;
      let newHeight = startHeightRef.current;
      switch (resizerType) {
        case "top-left":
          newWidth = startWidthRef.current - e.clientX + startXRef.current;
          newHeight = startHeightRef.current - e.clientY + startYRef.current;
          break;
        case "left":
          newWidth = startWidthRef.current - e.clientX + startXRef.current;
          break;
        case "top":
          newHeight = startHeightRef.current - e.clientY + startYRef.current;
          break;
      }
      setSize(newWidth, newHeight);
    }
  };
  const stopResize = (e) => {
    window.removeEventListener("mousemove", boundResizeRef.current, false);
    window.removeEventListener("mouseup", stopResize, false);
  };
  const senderRef = useRef(null);
  const [pickerStatus, setPickerStatus] = useState(false);
  const onSelectEmoji = (emoji) => {
    var _a2;
    (_a2 = senderRef.current) == null ? void 0 : _a2.onSelectEmoji(emoji);
  };
  const onSelectFile = (files2) => {
    sendMessage2 == null ? void 0 : sendMessage2({ files: files2, replyMessage });
  };
  const togglePicker = () => {
    setPickerStatus((prevPickerStatus) => !prevPickerStatus);
  };
  const selectFile = () => {
    var _a2;
    return (_a2 = addFileRef.current) == null ? void 0 : _a2.call(addFileRef);
  };
  const handlerSendMsn = (text2) => {
    sendMessage2 == null ? void 0 : sendMessage2({ text: text2, replyMessage });
    if (pickerStatus) {
      setPickerStatus(false);
    }
    if (replyMessage) {
      setReplyMessage(null);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(NotificationProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      id: "rcw-conversation-container",
      className: cn("rcw-conversation-container", className),
      "aria-live": "polite",
      children: [
        resizable && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { "data-resizer": "top-left", className: "rcw-conversation-xy-resizer", onMouseDown: initResize }),
        resizable && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { "data-resizer": "left", className: "rcw-conversation-x-resizer", onMouseDown: initResize }),
        resizable && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { "data-resizer": "top", className: "rcw-conversation-y-resizer", onMouseDown: initResize }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { ...headerProps }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Messages, { reply, reaction, ...messagesProps }),
        copyright && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "copyright", dangerouslySetInnerHTML: { __html: copyright } }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(QuickButtons, { ...quickButtonsProps }),
        emojis2 && pickerStatus && /* @__PURE__ */ jsxRuntimeExports.jsx(
          FilePicker,
          {
            onEmojiClick: onSelectEmoji,
            height: 300,
            bottom: 70
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(SenderContext, { replyMessage }),
        files && /* @__PURE__ */ jsxRuntimeExports.jsx(
          FilePicker$1,
          {
            items: fileItems,
            onSelectFile,
            addFileRef,
            height: 100,
            maxItem: 1,
            showButton: false,
            allowImage: true,
            ...filePickerProps
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Sender,
          {
            ...senderProps,
            senderRef,
            sendMessage: handlerSendMsn,
            onPressEmoji: emojis2 ? togglePicker : null,
            onPressFile: files ? selectFile : null,
            disabledInput: !!propDisabledInput || disableInput || !!files && fileItems.length > 0,
            allowSend: !!files && fileItems.length > 0
          }
        )
      ]
    }
  ) });
}
function Badge({ badge }) {
  return badge > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "rcw-badge", children: badge }) : null;
}
function Popup({ text: text2, onResize: onResize2 }) {
  const [isClosed, setIsClosed] = useState(false);
  useEffect(() => {
    const el = document.querySelector(".rcw-popup");
    onResize2 == null ? void 0 : onResize2((el == null ? void 0 : el.clientWidth) ?? 0, (el == null ? void 0 : el.clientHeight) ?? 0);
  }, [text2, isClosed, onResize2]);
  if (isClosed) {
    return null;
  }
  const texts = Array.isArray(text2) ? text2 : [text2];
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rcw-popup", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "close-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "close-btn", onClick: () => setIsClosed(true), children: "×" }) }),
    texts.map((text22, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: text22.length > 100 ? text22.slice(0, 100) + " ..." : text22 }, i))
  ] });
}
const logo_light = "data:image/svg+xml,%3csvg%20width='90'%20height='57'%20viewBox='0%200%2090%2057'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M89.3974%2035.3045C89.7815%2033.8117%2089.9898%2032.2517%2089.9999%2030.6462C89.9999%2030.524%2090.0005%2030.3587%2089.9989%2030.288C89.8682%2019.497%2080.7815%2010.7883%2069.5913%2010.7883C62.2449%2010.7883%2055.8051%2014.5417%2052.2108%2020.1736C48.8758%208.49552%2038.7087%200%2026.6838%200C11.9468%200%200%2012.76%200%2028.5003C0%2043.9995%2011.5836%2056.609%2026.0087%2056.9916C26.058%2056.9916%2026.1023%2056.994%2026.1555%2056.9951C26.2762%2056.9976%2026.397%2056.9992%2026.5181%2057L26.7813%2056.9916C27.6728%2056.7735%2028.0691%2055.9432%2028.0691%2055.0174C28.0691%2054.0915%2027.8113%2053.1587%2026.5181%2053.0347C14.5197%2052.9383%204.12018%2042.3855%204.12018%2028.5003C4.12018%2014.5512%2014.6156%203.96521%2026.6838%203.96521C38.7521%203.96521%2049.2475%2014.5512%2049.2475%2028.5003C49.2475%2028.5593%2049.2473%2028.6183%2049.2469%2028.6773C49.2429%2029.301%2049.1823%2029.9012%2049.1823%2030.5239C49.1823%2041.3826%2058.2512%2050.1931%2069.4645%2050.2591C70.6022%2050.2591%2071.5248%2049.393%2071.5248%2048.298C71.5248%2047.203%2070.6023%2046.2938%2069.4645%2046.2938C60.5451%2046.2279%2053.3025%2039.2104%2053.3025%2030.5239L53.3025%2030.5078C53.331%2030.0704%2053.3503%2029.6302%2053.3601%2029.1876C54.0611%2021.0884%2061.0768%2014.7535%2069.5913%2014.7535C78.5688%2014.7535%2085.8801%2021.7962%2085.8801%2030.5239C85.8801%2030.8046%2085.8725%2031.0836%2085.8576%2031.3606H70.2251C69.0873%2031.3606%2068.165%2032.2483%2068.165%2033.3432C68.165%2034.4382%2069.0873%2035.3258%2070.2251%2035.3258H88.2256L89.3974%2035.3045Z'%20fill='white'/%3e%3cpath%20d='M71.2021%2022.8587C72.2687%2022.8587%2075.8373%2022.9591%2075.8373%2021.9326C75.8373%2020.9061%2072.2687%2019.1413%2071.2021%2019.1413C70.1354%2019.1413%2069.2707%2019.9735%2069.2707%2021C69.2707%2022.0265%2070.1354%2022.8587%2071.2021%2022.8587Z'%20fill='white'/%3e%3c/svg%3e";
const loading = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20200%20200'%3e%3clinearGradient%20id='a11'%3e%3cstop%20offset='0'%20stop-color='%23fff'%20stop-opacity='0'%3e%3c/stop%3e%3cstop%20offset='1'%20stop-color='%23fff'%3e%3c/stop%3e%3c/linearGradient%3e%3ccircle%20fill='none'%20stroke='url(%23a11)'%20stroke-width='15'%20stroke-linecap='round'%20stroke-dasharray='0%2044%200%2044%200%2044%200%2044%200%20360'%20cx='100'%20cy='100'%20r='70'%20transform-origin='center'%3e%3canimateTransform%20type='rotate'%20attributeName='transform'%20calcMode='discrete'%20dur='2'%20values='360;324;288;252;216;180;144;108;72;36'%20repeatCount='indefinite'%3e%3c/animateTransform%3e%3c/circle%3e%3c/svg%3e";
const close = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='iso-8859-1'?%3e%3c!--%20Generator:%20Adobe%20Illustrator%2016.0.0,%20SVG%20Export%20Plug-In%20.%20SVG%20Version:%206.00%20Build%200)%20--%3e%3c!DOCTYPE%20svg%20PUBLIC%20'-//W3C//DTD%20SVG%201.1//EN'%20'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'%3e%3csvg%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20version='1.1'%20id='Capa_1'%20x='0px'%20y='0px'%20width='512px'%20height='512px'%20viewBox='0%200%20357%20357'%20style='enable-background:new%200%200%20357%20357;'%20xml:space='preserve'%3e%3cg%3e%3cg%20id='clear'%3e%3cpolygon%20points='357,35.7%20321.3,0%20178.5,142.8%2035.7,0%200,35.7%20142.8,178.5%200,321.3%2035.7,357%20178.5,214.2%20321.3,357%20357,321.3%20214.2,178.5%20'%20fill='%23FFFFFF'/%3e%3c/g%3e%3c/g%3e%3cg%3e%3c/g%3e%3cg%3e%3c/g%3e%3cg%3e%3c/g%3e%3cg%3e%3c/g%3e%3cg%3e%3c/g%3e%3cg%3e%3c/g%3e%3cg%3e%3c/g%3e%3cg%3e%3c/g%3e%3cg%3e%3c/g%3e%3cg%3e%3c/g%3e%3cg%3e%3c/g%3e%3cg%3e%3c/g%3e%3cg%3e%3c/g%3e%3cg%3e%3c/g%3e%3cg%3e%3c/g%3e%3c/svg%3e";
function Launcher({
  toggle,
  chatId = "rcw-chat-container",
  openImg,
  closeImg,
  openLabel = "Open chat",
  closeLabel = "Close chat",
  showBadge = true,
  showPopup: showPopup2 = true,
  isLoading = false,
  popupProps = {}
}) {
  const { showChat, badgeCount, popupMessage } = useSelector(({ behavior, messages }) => ({
    showChat: behavior.showChat,
    badgeCount: messages.badgeCount,
    popupMessage: messages.popupMessage
  }));
  const toggleChat2 = () => {
    toggle();
    if (!showChat) setBadgeCount(0);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    !showChat && showPopup2 && popupMessage && /* @__PURE__ */ jsxRuntimeExports.jsx(Popup, { text: popupMessage, ...popupProps }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { type: "button", className: cn("rcw-launcher", { "rcw-hide-sm": showChat, "default-launcher": !openImg }), onClick: toggleChat2, "aria-controls": chatId, children: [
      !showChat && showBadge && /* @__PURE__ */ jsxRuntimeExports.jsx(Badge, { badge: badgeCount }),
      showChat ? /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: closeImg || close, className: "rcw-close-launcher", alt: openLabel }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cn("rcw-open-launcher", { "default-launcher": !openImg && !isLoading, "loading": isLoading }), children: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: loading, alt: closeLabel }) : openImg ? /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: openImg, alt: closeLabel }) : /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: logo_light, alt: closeLabel }) })
    ] })
  ] });
}
const initState = {
  layout: { width: 800 },
  zoom: false,
  direction: "vertical"
};
const usePreview = (zoomStep) => {
  const [windowSize, setWindowSize] = useState({ width: 0, height: 0 });
  const [fileSize, setFileSize] = useState({ width: 0, height: 0 });
  const reducer = (state22, action) => {
    switch (action.type) {
      case "initLayout":
        return {
          ...state22,
          layout: action.payload.layout,
          direction: action.payload.direction,
          zoom: false
        };
      case "zoomIn":
        return {
          ...state22,
          layout: action.layout,
          zoom: true
        };
      case "zoomOut":
        return {
          ...state22,
          layout: action.layout,
          zoom: true
        };
      case "resetZoom":
        return { ...state22, layout: action.layout, direction: action.direction };
      default:
        throw new Error("Unexpected action");
    }
  };
  const [state2, dispatch] = useReducer(reducer, { ...initState });
  const initFileSize = (width2, height2) => {
    const { innerWidth, innerHeight } = window;
    setWindowSize({ width: innerWidth, height: innerHeight });
    setFileSize({ width: width2, height: height2 });
    const payload = { layout: {}, direction: "horizontal" };
    if (innerWidth / innerHeight <= width2 / height2) {
      payload.layout.width = innerWidth * 0.8;
      payload.direction = "horizontal";
    } else {
      payload.layout.height = innerHeight * 0.8;
      payload.direction = "vertical";
    }
    dispatch({
      type: "initLayout",
      payload
    });
  };
  const getLayout = (step) => {
    let layout;
    if (state2.direction === "vertical") {
      layout = {
        height: state2.layout.height + step
      };
    } else {
      layout = {
        width: state2.layout.width + step
      };
    }
    return layout;
  };
  const isMinSize = () => {
    if (state2.direction === "vertical") {
      return state2.layout.height > windowSize.height / 3;
    }
    return state2.layout.width > windowSize.width / 3;
  };
  const onZoomIn = () => {
    dispatch({
      type: "zoomIn",
      layout: getLayout(zoomStep)
    });
  };
  const onZoomOut = () => {
    if (isMinSize()) {
      dispatch({
        type: "zoomOut",
        layout: getLayout(-zoomStep)
      });
    }
  };
  const onResizePageZoom = () => {
    if (state2.zoom) {
      initFileSize(fileSize.width, fileSize.height);
    }
  };
  return {
    state: state2,
    initFileSize,
    onZoomIn,
    onZoomOut,
    onResizePageZoom
  };
};
function createRootElement(id) {
  const rootContainer = document.createElement("div");
  rootContainer.setAttribute("id", id);
  return rootContainer;
}
function addRootElement(rootElem) {
  document.body.appendChild(rootElem);
}
function usePortal() {
  const rootElemRef = useRef(null);
  useEffect(() => {
    const existingParent = document.querySelector("#rcw-image-preview");
    const parentElem = existingParent || createRootElement("rcw-image-preview");
    if (!existingParent) {
      addRootElement(parentElem);
    }
    if (rootElemRef.current) {
      parentElem.appendChild(rootElemRef.current);
    }
    return function removeElement() {
      if (rootElemRef.current) {
        rootElemRef.current.remove();
      }
      if (parentElem.childNodes.length === -1) {
        parentElem.remove();
      }
    };
  }, []);
  function getRootElem() {
    if (!rootElemRef.current) {
      rootElemRef.current = document.createElement("div");
    }
    return rootElemRef.current;
  }
  return getRootElem();
}
const minus = "data:image/svg+xml,%3csvg%20t='1588073243557'%20class='icon'%20viewBox='0%200%201024%201024'%20version='1.1'%20xmlns='http://www.w3.org/2000/svg'%20p-id='4672'%20width='14'%20height='14'%3e%3cpath%20d='M662.459733%20548.113067h-300.373333c-16.9984%200-30.72-13.7216-30.72-30.72s13.7216-30.72%2030.72-30.72h300.373333a30.72%2030.72%200%200%201%200%2061.44z'%20p-id='4673'%3e%3c/path%3e%3c/svg%3e";
const zoomIn = "data:image/svg+xml,%3csvg%20t='1588074195343'%20class='icon'%20viewBox='0%200%201024%201024'%20version='1.1'%20xmlns='http://www.w3.org/2000/svg'%20p-id='5726'%20width='32'%20height='32'%3e%3cpath%20d='M815.786667%20241.732267v136.533333c0%2015.086933-12.219733%2027.306667-27.306667%2027.306667s-27.306667-12.219733-27.306667-27.306667V307.677867L602.5216%20466.466133c-5.3248%205.3248-12.356267%207.9872-19.319467%207.9872a27.293013%2027.293013%200%200%201-19.319466-46.626133l158.72-158.856533H652.014933c-15.086933%200-27.306667-12.219733-27.306666-27.306667s12.219733-27.306667%2027.306666-27.306667h136.465067c7.236267%200%2014.199467%202.8672%2019.319467%207.9872%205.12%205.188267%207.9872%2012.151467%207.9872%2019.387734z%20m-27.306667%20382.225066c-15.086933%200-27.306667%2012.219733-27.306667%2027.306667v70.587733L605.184%20567.227733c-10.6496-10.6496-28.672-10.6496-39.3216%200-10.6496%2010.6496-11.0592%2027.921067-0.4096%2038.638934l154.4192%20154.692266H649.216h-0.068267c-15.086933%200-27.306667%2012.219733-27.306666%2027.306667s12.219733%2027.306667%2027.306666%2027.306667h136.3968c7.236267%200%2015.633067-2.8672%2020.753067-7.9872s9.489067-12.0832%209.489067-19.319467v-136.533333c0-15.1552-12.219733-27.374933-27.306667-27.374934z%20m-362.837333-57.9584L269.653333%20721.851733V651.264c0-15.086933-12.014933-27.306667-27.0336-27.306667h0.136534a27.2384%2027.2384%200%200%200-27.2384%2027.306667v136.533333c0%207.236267%202.8672%2014.199467%207.9872%2019.319467s12.0832%207.9872%2019.319466%207.9872h136.465067c15.086933%200%2027.306667-12.219733%2027.306667-27.306667s-12.219733-27.306667-27.306667-27.306666H308.701867l155.784533-155.921067c10.6496-10.6496%2010.513067-27.989333-0.136533-38.638933a27.50464%2027.50464%200%200%200-38.7072%200.068266z%20m-117.418667-294.5024h70.519467c15.086933%200%2027.306667-12.219733%2027.306666-27.306666s-12.219733-27.306667-27.306666-27.306667H242.2784c-7.236267%200-14.199467%202.8672-19.319467%207.9872s-7.9872%2012.0832-7.9872%2019.319467v136.533333c0%2015.086933%2012.219733%2027.306667%2027.306667%2027.306667s27.306667-12.219733%2027.306667-27.306667V310.135467L427.076267%20467.626667c5.3248%205.3248%2012.356267%207.9872%2019.319466%207.9872a27.293013%2027.293013%200%200%200%2019.319467-46.626134L308.224%20271.496533z'%20p-id='5727'%20fill='%23433938'%3e%3c/path%3e%3c/svg%3e";
const zoomOut = "data:image/svg+xml,%3csvg%20t='1588074213573'%20class='icon'%20viewBox='0%200%201024%201024'%20version='1.1'%20xmlns='http://www.w3.org/2000/svg'%20p-id='6032'%20width='32'%20height='32'%3e%3cpath%20d='M801.655467%20771.072c10.6496%2010.6496%2010.581333%2027.921067-0.068267%2038.638933-5.3248%205.3248-12.424533%207.9872-19.387733%207.9872-6.9632%200-14.199467-2.6624-19.524267-7.9872l-148.138667-147.729066v70.587733c0%2015.086933-12.219733%2027.306667-27.306666%2027.306667s-27.306667-12.219733-27.306667-27.306667v-136.533333c0-7.236267%203.2768-14.199467%208.3968-19.319467s12.4928-7.9872%2019.729067-7.9872h136.465066c15.086933%200%2027.306667%2012.219733%2027.306667%2027.306667s-12.219733%2027.306667-27.306667%2027.306666H653.9264l147.729067%20147.729067zM586.888533%20469.6064h136.465067c15.086933%200%2027.306667-12.219733%2027.306667-27.306667s-12.219733-27.306667-27.306667-27.306666H652.765867l151.825066-151.620267a27.108693%2027.108693%200%200%200%200-38.434133%2027.108693%2027.108693%200%200%200-38.434133%200.068266L614.536533%20376.900267V306.312533c0-15.086933-12.424533-27.921067-27.4432-27.921066h-0.068266c-15.086933%200-27.374933%2012.4928-27.374934%2027.579733v136.669867c0%207.236267%202.8672%2013.994667%207.9872%2019.114666%205.051733%205.188267%2012.014933%207.850667%2019.2512%207.850667zM436.6336%20280.234667c-15.086933%200-26.897067%2012.219733-26.897067%2027.306666v70.587734L258.798933%20227.5328c-10.6496-10.6496-28.194133-10.6496-38.843733%200-10.6496%2010.6496-10.786133%2027.0336-0.136533%2037.751467L370.2784%20415.061333H300.509867v0.887467c-13.653333%200-27.716267%2012.629333-27.716267%2027.716267%200%2015.086933%2012.4928%2027.511467%2027.511467%2027.511466l136.669866%200.136534v0.068266c6.826667%200%2013.789867-2.8672%2018.909867-7.9872s7.7824-12.0832%207.7824-19.319466l0.068267-136.533334c0.136533-15.086933-12.014933-27.306667-27.101867-27.306666z%20m-1.6384%20284.945066H298.530133c-15.086933%200-27.306667%2012.219733-27.306666%2027.306667s12.219733%2027.306667%2027.306666%2027.306667h70.587734l-148.8896%20150.1184c-10.6496%2010.6496-10.6496%2028.535467%200%2039.185066%205.3248%205.3248%2012.288%208.260267%2019.319466%208.260267%206.9632%200%2015.018667-2.525867%2020.343467-7.850667l149.9136-148.821333v70.587733c0%2015.086933%2011.195733%2024.9856%2026.282667%2024.9856h-0.546134c15.086933%200%2027.0336-11.0592%2027.0336-26.146133l-0.136533-135.918933c0-7.236267-2.935467-15.086933-8.055467-20.206934-5.12-5.051733-12.151467-8.8064-19.387733-8.8064z'%20p-id='6033'%20fill='%23433938'%3e%3c/path%3e%3c/svg%3e";
function FullScreenPreview({ fullScreenMode, zoomStep }) {
  const {
    state: state2,
    initFileSize,
    onZoomIn,
    onZoomOut,
    onResizePageZoom
  } = usePreview(zoomStep);
  const { src, alt, width: width2, height: height2, visible } = useSelector(({ preview }) => preview);
  useEffect(() => {
    if (src) {
      initFileSize(width2, height2);
    }
  }, [src, width2, height2, initFileSize]);
  const pDom = usePortal();
  const onClosePreview = () => {
    closeFullscreenPreview();
  };
  const childNode = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rcw-previewer-container", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rcw-previewer-veil", children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { ...state2.layout, src, className: "rcw-previewer-image", alt }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        className: "rcw-previewer-button rcw-previewer-close-button",
        onClick: onClosePreview,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: close$1, className: "rcw-previewer-icon" })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rcw-previewer-tools", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: "rcw-previewer-button",
          onClick: onResizePageZoom,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "img",
            {
              src: state2.zoom ? zoomOut : zoomIn,
              className: "rcw-previewer-icon",
              alt: "reset zoom"
            }
          )
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: "rcw-previewer-button",
          onClick: onZoomIn,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: plus, className: "rcw-previewer-icon", alt: "zoom in" })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: "rcw-previewer-button",
          onClick: onZoomOut,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: minus, className: "rcw-previewer-icon", alt: "zoom out" })
        }
      )
    ] })
  ] });
  return visible ? ReactDOM__default.createPortal(childNode, pDom) : null;
}
function WidgetLayout({ rootRef, conversationProps, launcherProps, onToggleConversation, fullScreenMode = false, customLauncher, imagePreview = false, zoomStep = 80 }) {
  const [isLoading, setIsLoading] = useState(false);
  const { showChat, visible } = useSelector(({ behavior, preview }) => ({
    showChat: behavior.showChat,
    visible: preview.visible
  }));
  const messageRef = useRef(null);
  useEffect(() => {
    if (showChat) {
      messageRef.current = document.getElementById("rcw-messages");
    }
    return () => {
      messageRef.current = null;
    };
  }, [showChat]);
  const eventHandle = (evt) => {
    if (evt.target && evt.target.className === "rcw-message-img") {
      const { src, alt, naturalWidth, naturalHeight } = evt.target;
      const obj = {
        src,
        width: naturalWidth,
        height: naturalHeight
      };
      openFullscreenPreview(obj);
    }
  };
  useEffect(() => {
    const target = messageRef == null ? void 0 : messageRef.current;
    if (imagePreview && showChat) {
      target == null ? void 0 : target.addEventListener("click", eventHandle, false);
    }
    return () => {
      target == null ? void 0 : target.removeEventListener("click", eventHandle);
    };
  }, [imagePreview, showChat]);
  useEffect(() => {
    document.body.setAttribute("style", `overflow: ${visible || fullScreenMode ? "hidden" : "auto"}`);
  }, [fullScreenMode, visible]);
  const toggleHandler = async () => {
    setIsLoading(true);
    await onToggleConversation();
    setIsLoading(false);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      ref: rootRef,
      className: cn("rcw-widget-container", {
        "rcw-full-screen": fullScreenMode,
        "rcw-previewer": imagePreview,
        "rcw-close-widget-container ": !showChat
      }),
      children: [
        (showChat || fullScreenMode) && /* @__PURE__ */ jsxRuntimeExports.jsx(Conversation, { ...conversationProps, className: showChat || fullScreenMode ? "active" : "hidden" }),
        customLauncher ? customLauncher(toggleHandler) : !fullScreenMode && /* @__PURE__ */ jsxRuntimeExports.jsx(Launcher, { ...launcherProps, toggle: toggleHandler, isLoading }),
        imagePreview && /* @__PURE__ */ jsxRuntimeExports.jsx(FullScreenPreview, { fullScreenMode, zoomStep })
      ]
    }
  );
}
const mergeProps = (...items) => {
  const w2 = {};
  for (const item of items) {
    for (const key of Object.keys(item)) {
      const v2 = Reflect.get(item, key);
      if (typeof v2 === "object") {
        let y;
        if (Reflect.has(w2, key)) {
          const wv = Reflect.get(w2, key);
          if (typeof wv === "object") {
            y = mergeProps(wv, v2);
          } else {
            throw new Error("Invalid types !");
          }
        } else {
          y = lodashExports.cloneDeep(v2);
        }
        Reflect.set(w2, key, y);
      } else {
        Reflect.set(w2, key, v2);
      }
    }
  }
  return w2;
};
const byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    if (typeof crypto === "undefined" || !crypto.getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
    getRandomValues = crypto.getRandomValues.bind(crypto);
  }
  return getRandomValues(rnds8);
}
const randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const native = { randomUUID };
function v4(options, buf, offset) {
  var _a2;
  if (native.randomUUID && true && !options) {
    return native.randomUUID();
  }
  options = options || {};
  const rnds = options.random ?? ((_a2 = options.rng) == null ? void 0 : _a2.call(options)) ?? rng();
  if (rnds.length < 16) {
    throw new Error("Random bytes length must be >= 16");
  }
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  return unsafeStringify(rnds);
}
function Widget({
  layoutProps,
  handleNewUserMessage,
  handleQuickButtonClicked,
  handleTextInputChange,
  disableRichTextInput,
  handleToggle: handleToggle2,
  handleSubmit,
  onResize: onResize2
  // connectionRef,
}) {
  const rootRef = useRef(null);
  useEffect(() => {
    if (!rootRef.current || !onResize2) {
      return;
    }
    const el = rootRef.current;
    const s = new ResizeObserver(() => {
      let width2 = el.clientWidth;
      let height2 = el.clientHeight;
      if (width2 === 0 && height2 === 0) {
        const launcher = el.querySelector(".rcw-launcher");
        if (launcher) {
          width2 = launcher.clientWidth;
          height2 = launcher.clientHeight;
        }
      }
      onResize2(width2, height2);
    });
    s.observe(el);
  }, [rootRef, onResize2]);
  const toggleConversation = async () => {
    if (handleToggle2) {
      if (!await handleToggle2(!isWidgetOpened())) {
        return;
      }
    }
    toggleChat();
  };
  const handleMessageSubmit = async ({ text: text2, files, replyMessage }) => {
    if (!(text2 == null ? void 0 : text2.trim()) && !files) {
      return;
    }
    const msgText = text2 ? text2.trim() : "";
    const id = v4();
    if (handleSubmit) {
      const error2 = await handleSubmit({ text: text2, files });
      if (error2) {
        addUserMessage(msgText, { id, status: "error", props: { files, error: error2, replyMessage } });
        return;
      }
    }
    return handleNewUserMessage == null ? void 0 : handleNewUserMessage({ id, text: text2, files, replyMessage });
  };
  const onQuickButtonClicked = (event, value) => {
    event.preventDefault();
    handleQuickButtonClicked == null ? void 0 : handleQuickButtonClicked(value);
  };
  function defaultTextInputHandler(event) {
    const target = event.target;
    if (target && target.textContent) ;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    WidgetLayout,
    {
      rootRef,
      ...mergeProps({
        conversationProps: {
          sendMessage: handleMessageSubmit,
          senderProps: {
            onTextInputChange: disableRichTextInput ? defaultTextInputHandler : handleTextInputChange
          },
          quickButtonsProps: {
            onQuickButtonClicked
          }
        }
      }, layoutProps ?? {}),
      onToggleConversation: toggleConversation
    }
  );
}
const hacker = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='512'%20height='512'%20viewBox='0%200%20512%20512'%3e%3cimage%20href='data:image/png;base64,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'%20height='512'%20width='512'%20/%3e%3c/svg%3e";
const programmer = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='512'%20height='512'%20viewBox='0%200%20512%20512'%3e%3cimage%20href='data:image/png;base64,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'%20height='512'%20width='512'%20/%3e%3c/svg%3e";
function Root({
  wsUrl,
  botAPIUrl,
  isPopup,
  host,
  title,
  subtitle,
  startMsg,
  userType = "customer",
  // widgetProps,
  primaryColor = "#201657",
  messageClientColor = "#007FFF",
  messageClientTextColor = "#ffffff",
  messageResponseColor = "#ffffff",
  messageResponseTextColor = "#555555",
  anchorBottom = "20px",
  anchorRight = "20px",
  headerPaddingTop,
  headerPaddingBottom
}) {
  const connectionRef = useRef(null);
  const roomJIDRef = useRef("");
  const {
    saveGuestJID,
    saveRoomJID,
    getGuestJID,
    getRoomJID,
    saveTimestamp,
    getTimestamp,
    clearStorage,
    saveUserType
  } = useChatStorage();
  useEffect(() => {
    const r2 = document.querySelector(":root");
    primaryColor && r2.style.setProperty("--primary-color", primaryColor);
    messageClientColor && r2.style.setProperty("--message-client-color", messageClientColor);
    messageClientTextColor && r2.style.setProperty("--message-client-text-color", messageClientTextColor);
    messageResponseColor && r2.style.setProperty("--message-response-color", messageResponseColor);
    messageResponseTextColor && r2.style.setProperty("--message-response-text-color", messageResponseTextColor);
    headerPaddingTop && r2.style.setProperty("--header-padding-top", headerPaddingTop);
    headerPaddingBottom && r2.style.setProperty("--header-padding-bottom", headerPaddingBottom);
    anchorBottom && r2.style.setProperty("--anchor-bottom", typeof anchorBottom === "number" ? `${anchorBottom}px` : anchorBottom);
    anchorRight && r2.style.setProperty("--anchor-right", typeof anchorRight === "number" ? `${anchorRight}px` : anchorRight);
  }, [primaryColor, messageClientColor, messageClientTextColor, messageResponseColor, messageResponseTextColor, headerPaddingTop, headerPaddingBottom, anchorBottom, anchorRight]);
  useEffect(() => {
    setStatusLocale("en");
    setVoiceLocale("en");
    addResponseMessage(startMsg);
    saveUserType(userType);
    const storedTimestamp = getTimestamp();
    if (storedTimestamp) {
      const previousTime = Number(storedTimestamp);
      const currentTime = Date.now();
      const differenceMs = currentTime - previousTime;
      const differenceMinutes = differenceMs / 6e4;
      if (differenceMinutes > 20) {
        clearStorage();
      }
    }
    if (getGuestJID() != null && getGuestJID() != null) {
      const roomJID = getRoomJID();
      const guestJID = getGuestJID();
      if (roomJID && guestJID) {
        roomJIDRef.current = roomJID;
        connectionRef.current = initializeWebSocket(guestJID, roomJID, wsUrl, botAPIUrl, userType);
      }
    } else {
      if (isPopup) {
        addToggleChatListener((state2) => void 0);
        setPopupMessage(["Hey".repeat(1), "Looks like You are Lost".repeat(1), "Can I help ?".repeat(1)]);
      }
      if (userType == USER_TYPE.AGENT) {
        const guestJID = generateRandomJid(host, USER_TYPE.AGENT);
        connectionRef.current = initializeWebSocket(guestJID, roomJIDRef, wsUrl, botAPIUrl, userType);
      } else {
        const guestJID = generateRandomJid(host, USER_TYPE.GUEST);
        const roomJID = generateRandomRoomJid(`conference.${host}`);
        saveGuestJID(guestJID);
        saveRoomJID(roomJID);
        saveTimestamp();
        roomJIDRef.current = roomJID;
        connectionRef.current = initializeWebSocket(guestJID, roomJID, wsUrl, botAPIUrl, userType);
        if (userType == USER_TYPE.GUEST) {
          setQuickButtons([{ label: "Connect To Agent", value: JSON.stringify({ "type": "sent", msg: "Connect To Agent", id: "1234" }) }]);
        }
      }
    }
  }, []);
  const handleNewUserMessage = ({ id, text: text2, files, replyMessage }) => {
    const connection = connectionRef.current;
    const roomJID = roomJIDRef.current;
    if (replyMessage) {
      addResponseMessage(text2, { props: { files, replyMessage } });
      return;
    }
    if (files && files.length > 0) ;
    if (text2 == "agent") {
      return;
    }
    if (text2 == "sample") {
      showSamples(connection, roomJID);
    } else {
      const formattedText = JSON.stringify({ "type": "sent", msg: text2, "id": id });
      setTimeout(() => sendMessage(connection, formattedText, roomJID ?? ""), 10);
      return;
    }
  };
  async function handleSubmit({ text: text2, files }) {
    connectionRef.current;
    roomJIDRef.current;
    if (text2 == "" && (!files || files.length <= 0)) {
      return new Error("Uh oh, please write a bit more.");
    }
    if (text2 == "agent") {
      showNotification("You are now being connected to agent", { severity: "info" });
      setResponseUser({
        avatar: [
          hacker,
          programmer
        ],
        name: "Escalate",
        message: "2 people are online"
      });
      setResponseUser({
        avatar: hacker,
        name: "Support/HelpDesk",
        message: "Online",
        online: true
      });
      return;
    }
  }
  function handleQuickButtonClicked(e) {
    const connection = connectionRef.current;
    const roomJID = roomJIDRef.current;
    const notificationKey = showNotification("You are now being connected to agent", { severity: "info" });
    setTimeout(() => closeNotification(notificationKey), 5e3);
    setQuickButtons([]);
    sendMessage(connection, e, roomJID);
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Widget,
    {
      layoutProps: {
        conversationProps: {
          headerProps: {
            title,
            subtitle,
            showCloseButton: isPopup,
            showMenuButton: false,
            menus: [
              {
                title: "Language",
                icon: smiley,
                selects: [
                  {
                    title: "English",
                    onClick: () => showPopup(() => /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: "You have selected English" }), { top: 20 })
                  },
                  {
                    title: "Hindi",
                    onClick: () => showPopup(() => /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: "You have selected English" }), { top: 20 })
                  }
                ]
              }
            ]
          },
          messagesProps: {
            profileAvatar: hacker,
            profileClientAvatar: programmer
          },
          senderProps: {
            placeholder: "Write Here ..."
          },
          filePickerProps: {
            allowImage: true,
            allowVideo: true,
            allowAny: true
          },
          resizable: true,
          resizableProps: { heightOffset: 105, widthOffset: 35 },
          defaultSize: { width: 1e3, height: 700 },
          emojis: true,
          files: true,
          reply: true,
          reaction: false
        },
        launcherProps: {
          openImg: logo_light,
          popupProps: {
            onResize: (w2, h) => {
            }
          }
        },
        imagePreview: false,
        fullScreenMode: !isPopup
        //change widget to fullscreen
      },
      handleNewUserMessage,
      handleQuickButtonClicked,
      handleSubmit,
      onResize,
      handleToggle: handleToggle(isPopup),
      disableRichTextInput: true
    }
  );
}
export {
  CHAT_TYPES,
  Component,
  GUEST_STORAGE_KEY,
  LOCAL_STORAGE,
  MESSAGES_TYPES,
  MESSAGE_BOX_SCROLL_DURATION,
  MESSAGE_SENDER,
  ROOM_STORAGE_KEY,
  TIMESTAMP_STORAGE_KEY,
  USER_TYPE,
  USER_TYPE_KEY,
  addCarouselMessage,
  addLinkSnippet,
  addResponseMessage,
  addSystemMessage,
  addToggleChatListener,
  addUserMessage,
  closeFullscreenPreview,
  closeNotification,
  createCarouselMessage,
  createCarouselMessageForAgent,
  createComponentMessage,
  createLinkSnippet,
  createNewMessage,
  createQuickButton,
  Root as default,
  deleteMessages,
  dropMessages,
  hideAvatar,
  hidePopup,
  hideSuggestions,
  isWidgetOpened,
  markAllMessagesRead,
  openFullscreenPreview,
  ref,
  renderCustomComponent,
  scrollToBottom,
  setBadgeCount,
  setContextMenu,
  setMessageStatus,
  setMessages,
  setNotification,
  setPopupMessage,
  setQuickButtons,
  setReplyMessage,
  setResponseUser,
  setStatusLocale,
  setVoiceLocale,
  showNotification,
  showPopup,
  showSuggestions,
  toggleChat,
  toggleInputDisabled,
  toggleMsgLoader,
  useSelector
};
